<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Sas\V20181203;

use AlibabaCloud\Endpoint\Endpoint;
use AlibabaCloud\OpenApiUtil\OpenApiUtilClient;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddAssetSelectionCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddAssetSelectionCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddBaselineCheckWhiteRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddBaselineCheckWhiteRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckInstanceResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckInstanceResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCloudVendorAccountAKRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCloudVendorAccountAKResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerDefenseRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddIdcProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddIdcProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageVulWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageVulWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddInstallCodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPrivateRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPrivateRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPublishBatchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPublishBatchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasModuleTrialRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasModuleTrialResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddTagWithUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddTagWithUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddUninstallClientsByUuidsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddUninstallClientsByUuidsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddVpcHoneyPotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddVpcHoneyPotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AdvanceSecurityEventOperationsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AdvanceSecurityEventOperationsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchCreateMaliciousNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchCreateMaliciousNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchDeleteMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchDeleteMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchOperateCommonOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchOperateCommonOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchUpdateMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchUpdateMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindAuthToMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindAuthToMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CancelOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CancelOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeAssetRefreshTaskConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeAssetRefreshTaskConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckConfigShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckCustomConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckCustomConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeSecurityScoreRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeSecurityScoreRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeUserLangRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeUserLangResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckQuaraFileIdRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckQuaraFileIdResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckSecurityEventIdRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckSecurityEventIdResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckStsTokenAuthResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckTrialFixCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckTrialFixCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckUserHasEcsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckUserHasEcsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ConfirmVirusEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ConfirmVirusEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CopyCustomizeReportConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CopyCustomizeReportConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAgentlessScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAgentlessScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAssetSelectionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAssetSelectionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAttestorRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAttestorResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBinarySecurityPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBinarySecurityPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskByAppNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskByAppNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomizedDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomizedDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCycleTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCycleTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateDynamicDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateDynamicDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectUploadUrlRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectUploadUrlResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileUploadLimitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileUploadLimitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeBindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeBindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHybridProxyClusterRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHybridProxyClusterResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMonitorAccountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMonitorAccountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaClusterPluginRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaClusterPluginResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaStrategyNewShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAssetGroupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAssetGroupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAutoTagRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAutoTagRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateDingTalkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateDingTalkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssBucketScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssBucketScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRdDefaultSyncListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRdDefaultSyncListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRestoreJobRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRestoreJobResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSasTrialRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSasTrialResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSasTrialShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceLinkedRoleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceLinkedRoleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceTrailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceTrailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSimilarSecurityEventsQueryTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSimilarSecurityEventsQueryTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSoarStrategyTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSoarStrategyTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSuspEventNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSuspEventNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniRestorePlanRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniRestorePlanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVirusScanOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVirusScanOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVulAutoRepairConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVulAutoRepairConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAttestorRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAttestorResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAutoTagRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAutoTagRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupSnapshotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupSnapshotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBaselineCheckWhiteRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBaselineCheckWhiteRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBinarySecurityPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBinarySecurityPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCloudVendorAccountAKRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCloudVendorAccountAKResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomizedDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomizedDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomizeReportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomizeReportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCycleTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCycleTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteDingTalkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteDingTalkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteGroupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteGroupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeBindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeBindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHybridProxyClusterRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHybridProxyClusterResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteIdcProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteIdcProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInstallCodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteK8sAccessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteK8sAccessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteLoginBaseConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteLoginBaseConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMonitorAccountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMonitorAccountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOpaStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOpaStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeletePrivateRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeletePrivateRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSearchConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSearchConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSecurityEventMarkMissListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSecurityEventMarkMissListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteServiceTrailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteServiceTrailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSoarStrategyTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSoarStrategyTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSuspEventNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSuspEventNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteTagWithUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteTagWithUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteUniBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteUniBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVpcHoneyPotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVpcHoneyPotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulAutoRepairConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulAutoRepairConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccessKeyLeakDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccessKeyLeakDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccesskeyLeakListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccesskeyLeakListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedMaliciousFileImagesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedMaliciousFileImagesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentInstallStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentInstallStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentlessSensitiveFileByKeyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentlessSensitiveFileByKeyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentlessSensitiveFileByKeyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventStackInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventStackInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllEntityResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllGroupsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllGroupsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllImageBaselineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllImageBaselineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllRegionsStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllRegionsStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAntiBruteForceRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAntiBruteForceRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAppVulScanCycleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsScaProcessNumRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsScaProcessNumResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsSecurityEventSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsSecurityEventSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttachRecordsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttachRecordsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttackAnalysisDataRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttackAnalysisDataResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttestorsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttestorsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAutoDelConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupClientsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupClientsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackUpExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackUpExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupMachineStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupMachineStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPoliciesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPoliciesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupRestoreCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBinarySecurityPoliciesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBinarySecurityPoliciesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceRecordsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceRecordsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCanFixVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCanFixVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCanTrySasResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeChartDataRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeChartDataResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeChartListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeChartListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckEcsWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckEcsWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckFixDetailsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckFixDetailsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfSetupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfSetupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientProblemTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudCenterInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudCenterInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudProductFieldStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudVendorAccountAKListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudVendorAccountAKListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterBasicInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterBasicInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterHostSecuritySummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterHostSecuritySummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterImageSecuritySummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterImageSecuritySummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterInfoListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterInfoListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterNetworkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterNetworkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterVulStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterVulStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetResultListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetResultListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeConcernNecessityRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeConcernNecessityResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerAppsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerAppsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerFieldStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerGroupedFieldDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerGroupedFieldDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClusterKritisStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClusterKritisStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClusterNamespacesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClusterNamespacesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClustersRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerServiceK8sClustersResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerTagsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerTagsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCountNotScannedImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCountScannedImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockRecordsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockRecordsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedDictUploadInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedDictUploadInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedStrategyTargetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizedStrategyTargetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizeReportConfigDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizeReportConfigDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizeReportListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomizeReportListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCycleTaskListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCycleTaskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDataSourceRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDataSourceResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDefaultKeyInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDefaultKeyInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDefaultProxyInstallVersionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDingTalkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDingTalkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureAlarmListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureAlarmListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureRiskListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureRiskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureScoreRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureScoreResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainSecureVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDynamicDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDynamicDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDynamicDictUploadInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDynamicDictUploadInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEmgUserAgreementResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEmgVulItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEmgVulItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventLevelCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventLevelCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventOnStageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventOnStageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExcludeSystemPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExcludeSystemPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedCheckWarningRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedCheckWarningResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedStatisticsDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedStatisticsDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFieldStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFieldStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFixUsedCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFrontVulPatchListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFrontVulPatchListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedContainerInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedContainerInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedMaliciousFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedMaliciousFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedTagsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedTagsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupStructRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupStructResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHcExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHcExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotAuthRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotAuthResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotSuspStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotSuspStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyClusterListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyClusterListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyLinkedClientListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyLinkedClientListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHybridProxyPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcAssetCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcAssetCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcProbeScanResultListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIdcProbeScanResultListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineItemListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineItemListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBuildRiskByKeyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBuildRiskByKeyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBuildRiskListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBuildRiskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageFixCycleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageFixTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageFixTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageGroupedVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageGroupedVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInfoListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInfoListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageLatestScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageLatestScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListByBuildRiskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListByBuildRiskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListBySensitiveFileRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListBySensitiveFileResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListBySensitiveFileShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListWithBaselineNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListWithBaselineNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoDetailListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoDetailListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageScanAuthCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageScanAuthorizationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileByKeyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileByKeyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileByKeyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileListShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCaptchaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCaptchaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCodesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceAntiBruteForceRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceAntiBruteForceRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceRebootStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceRebootStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceVulStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceVulStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLatestScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLoginBaseConfigsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLoginBaseConfigsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLoginSwitchConfigsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogMetaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogMetaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogShipperStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogShipperStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogstoreStorageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogstoreStorageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMachineCanRebootRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMachineCanRebootResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMatchedMaliciousNamesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMatchedMaliciousNamesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeModuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMonitorAccountsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNeedAsyncQueryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNeedAsyncQueryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNoticeConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNoticeConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNsasSuspEventTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNsasSuspEventTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOfflineMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOfflineMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskLeafRecordPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskLeafRecordPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaProcessDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaProcessDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyTypeScaItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyTypeScaItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUsageNewestRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUsageNewestResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUsageTopRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUsageTopResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeQuaraFileDownloadInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeQuaraFileDownloadInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeReportExportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeReportExportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeReportRecipientStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeReportRecipientStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestoreJobsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestoreJobsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestorePlansRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestorePlansResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckItemResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckItemResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskItemTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskItemTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskListCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskListCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRisksRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRisksResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSasPmAgentListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSasPmAgentListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskProgressRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskProgressResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScreenScoreThreadRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScreenScoreThreadResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSearchConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSearchConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecureSuggestionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecureSuggestionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityCheckScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityCheckScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventMarkMissListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventMarkMissListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityStatInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityStatInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeServiceLinkedRoleStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeServiceLinkedRoleStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarEventScenariosRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarEventScenariosResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarSecurityEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarSecurityEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSnapshotsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSnapshotsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategiesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategiesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyParamRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyParamResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTaskDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTaskDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTasksRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarStrategyTasksResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarSubscribedStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSoarSubscribedStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyExecDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyExecDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSummaryInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSummaryInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSupervisonInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSupportRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventQuaraFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventQuaraFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventsShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousUUIDConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousUUIDConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSyncAssetTaskListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSyncAssetTaskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSyncAssetTaskLogDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSyncAssetTaskLogDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTaskErrorLogRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTaskErrorLogResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTotalStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTotalStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPoliciesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPoliciesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPolicyDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPolicyDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniRecoverableListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniRecoverableListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniSupportRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserBackupMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserBaselineAuthorizationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserBaselineAuthorizationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserLayoutAuthorizationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserLayoutAuthorizationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUuidsByVulNamesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUuidsByVulNamesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVendorListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVersionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVersionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVolDingdingMessageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVolDingdingMessageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulCheckTaskStatusDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulCheckTaskStatusDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDefendCountStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDefendCountStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDetailsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDetailsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulFixStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulMetaCountStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulNumStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulNumStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockBindListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockBindListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockConfigListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockConfigListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockExclusiveFileTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileChangeStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileChangeStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileTypeSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockInclusiveFileTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessBlockStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessBlockStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockTotalFileChangeCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListAssetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListAssetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListAuthorizeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListAuthorizeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListEffectiveAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListEffectiveAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListProcessRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListProcessResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyUuidCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWhiteListStrategyUuidCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DingTalkOnlineTestRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DingTalkOnlineTestResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableBruteForceRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableBruteForceRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableBruteForceRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableBruteForceRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomInstanceBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomInstanceBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableServiceAccessResourceDirectoryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExecStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExecStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportCustomizeReportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportCustomizeReportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportSuspEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportSuspEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportWarningRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportWarningResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\FindContainerNetworkConnectRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FindContainerNetworkConnectResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\FindContainerNetworkConnectShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FinishGuidTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FinishGuidTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\FixCheckWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FixCheckWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateDynamicDictRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateDynamicDictResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateK8sAccessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateK8sAccessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAccountLabelRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAccountLabelResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAgentlessTaskCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAgentlessTaskCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAlarmMachineCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAlarmMachineCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAppNetworkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAppNetworkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetDetailByUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetDetailByUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetSelectionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetSelectionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAttackTypeListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAuthSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAuthVersionStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetBackupAutoConfigStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetBackupStorageCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetBuildRiskDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetBuildRiskDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCanTrySasRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCanTrySasResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckProcessRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckProcessResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckRiskStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckRiskStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSaleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSaleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckStructureRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckStructureResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientInstallationStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientInstallationStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientRatioStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientRatioStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterCheckItemWarningStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterCheckItemWarningStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterRuleSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterRuleSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterStrategyCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterSuspEventStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterSuspEventStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCommonSwitchConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCommonSwitchConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetContainerDefenseRuleDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetContainerDefenseRuleDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCurrentVersionPublishResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDataTrendRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDataTrendResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetDefenceCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectApiInvokeInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectReportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectReportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectDashboardResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileUploadLimitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotAttackStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotAttackStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotEventTrendRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotEventTrendResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeMetricListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeMetricListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneyPotUploadPolicyInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneyPotUploadPolicyInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageScanNumInPeriodRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageScanNumInPeriodResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionRuleDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionRuleDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionTargetDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionTargetDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLastOnceTaskInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLastOnceTaskInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLocalDefaultRegionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLocalDefaultRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLogMetaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLogMetaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigStatusShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleTrialAuthInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleTrialAuthInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetObjectScanEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetObjectScanEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOnceTaskResultInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOnceTaskResultInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterBaseLineListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterImageListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterImageListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterLabelListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterLabelListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterNamespaceListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterNamespaceListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaPluginStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaPluginStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaStrategyDetailNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaStrategyDetailNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaStrategyTemplateSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssBucketScanStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssBucketScanStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetPropertyScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetPropertyScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetRdTreeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetRulesCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleApplicationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleApplicationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSecurityScoreRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSecurityScoreRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSensitiveDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSensitiveDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServiceTrailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServiceTrailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetStrategyTemplateDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetStrategyTemplateDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSupportedModulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSupportedModulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSuspiciousStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSuspiciousStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSwitchRegionDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSwitchRegionDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetUserLangResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVirusScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVirusScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVirusScanLatestTaskStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSecurityEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSecurityEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSimilarSecurityEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSimilarSecurityEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreCheckItemsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreCheckItemsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreHcCheckWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreHcCheckWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreIdcProbeScanResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreIdcProbeScanResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallBackupClientRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallBackupClientResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallCloudMonitorRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallCloudMonitorResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallPmAgentRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallPmAgentResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallRaspAttachRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallRaspAttachResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallUniBackupAgentRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallUniBackupAgentResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\JoinWebLockProcessWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\JoinWebLockProcessWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAccountsInResourceDirectoryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAegisContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAegisContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessMaliciousFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessMaliciousFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRelateMaliciousRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRelateMaliciousResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRiskUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRiskUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetCleanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetInfoPublishRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetInfoPublishResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetRefreshTaskConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetRefreshTaskConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionSelectedTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionSelectedTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAutoTagRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAutoTagRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAvailableHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAvailableHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBackupRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBackupRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBaselineCheckWhiteRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBaselineCheckWhiteRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBaselineCheckWhiteRecordShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckInstanceResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckInstanceResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckStandardRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckStandardResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckTypesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientAlertModeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientAlertModeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientUserDefineRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientUserDefineRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientUserDefineRuleTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudVendorRegionsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudVendorRegionsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterCnnfStatusDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterCnnfStatusDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterInterceptionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterInterceptionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterPluginInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterPluginInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCompressFileDetectResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCompressFileDetectResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListContainerDefenseRuleClustersResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCriteriaStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCriteriaStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectPluginStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectPluginStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListGroupsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListGroupsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAlarmEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAlarmEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerPortraitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerPortraitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerSourceRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerSourceResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventFlowsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventFlowsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageBuildRiskItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageBuildRiskItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRegistryRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRiskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRiskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceCatalogRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceCatalogResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskLevelsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskLevelsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskNumRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskNumResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionHistoryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionHistoryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionRulePageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionRulePageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionTargetPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionTargetPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListK8sAccessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListK8sAccessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListLogShipperRegionsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMaliciousFileWhitelistConfigsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMaliciousFileWhitelistConfigsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListObjectScanEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListObjectScanEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOpaClusterStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOpaClusterStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketScanInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketScanInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPluginForUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPluginForUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPluginForUuidShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPodRiskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPodRiskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateK8sResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPublishBatchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPublishBatchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListQueryRaspAppInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListQueryRaspAppInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListRdDefaultSyncListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListRuleTargetAllRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListRuleTargetAllResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSupportObjectSuffixResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemAggregationRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemAggregationRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemClientRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemClientRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemClientRuleTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemRuleAggregationTypesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemRuleAggregationTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUnfinishedOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUnfinishedOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUninstallAegisMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUninstallAegisMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUuidsByWebPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUuidsByWebPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulAutoRepairConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulAutoRepairConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulGlobalConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulGlobalConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\MarkMonitorAccountsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\MarkMonitorAccountsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAccessKeyLeakDealRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAccessKeyLeakDealResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAppVulScanCycleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAppVulScanCycleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetCleanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetCleanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetGroupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetGroupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetImportantRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetImportantResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAttestorRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAttestorResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAutoDelConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAutoDelConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClearLogstoreStorageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClearLogstoreStorageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfSetupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfSetupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCloudVendorAccountAKRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCloudVendorAccountAKResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClusterCnnfStatusUserConfirmRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClusterCnnfStatusUserConfirmResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyConcernNecessityRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyConcernNecessityResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleSwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleSwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCreateVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCreateVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCycleTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCycleTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyDingTalkStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyDingTalkStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyEmgVulSubmitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyEmgVulSubmitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyGroupPropertyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyGroupPropertyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyIdcProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyIdcProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageFixCycleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageFixCycleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInstanceAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInstanceAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleSwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleSwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginBaseConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginBaseConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginSwitchConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginSwitchConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLogMetaStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLogMetaStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyNoticeConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyNoticeConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOpenLogShipperRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOpenLogShipperResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOperateVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOperateVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPostPayModuleSwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPostPayModuleSwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyProcessWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyProcessWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPropertyScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPropertyScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPushAllTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPushAllTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRefreshProcessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRefreshProcessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySearchConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySearchConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityCheckScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityCheckScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityEventMarkMissIndividuallyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityEventMarkMissIndividuallyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySoarStrategySubscribeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySoarStrategySubscribeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStartVulScanRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStartVulScanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyTagWithUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyTagWithUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyUniBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyUniBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyUniBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVpcHoneyPotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVpcHoneyPotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulWhitelistTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulWhitelistTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockCreateConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockCreateConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockDeleteConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockDeleteConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockProcessStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockProcessStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockRefreshRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockRefreshResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStartRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStartResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUnbindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUnbindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUpdateConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUpdateConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenBackupAutoConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenBackupAutoConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenPartialBuyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenPartialBuyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenSensitiveFileScanRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenSensitiveFileScanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateAgentClientInstallRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateAgentClientInstallResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateApplicationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateApplicationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateBucketScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateBucketScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageBaselineWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageBaselineWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSwitchStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSwitchStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVirusEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVirusEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVulsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVulsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateWebLockFileEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateWebLockFileEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCancelIgnoreSuspEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCancelIgnoreSuspEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCustomizeReportChartRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCustomizeReportChartResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationSuspEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationSuspEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PageImageRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PageImageRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PauseClientRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PauseClientResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicCreateImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicCreateImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicPreCheckImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicPreCheckImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicSyncAndCreateImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicSyncAndCreateImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryAssetDetailByUUIDRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryAssetDetailByUUIDResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryAttackCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryAttackCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryDiscoverDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryDiscoverDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupedSecurityEventMarkMissListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupedSecurityEventMarkMissListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupIdByGroupNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupIdByGroupNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGuidTaskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentIconListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentSubNodesCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentSubNodesCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentTracingDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentTracingDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentTracingJudgeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentTracingJudgeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexExtendInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexExtendInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexNodesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexNodesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexNodesShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryJenkinsImageRegistryPersistenceDayRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryJenkinsImageRegistryPersistenceDayResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryPreCheckDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryPreCheckDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RebootMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RebootMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReceiveFunctionTrialRewardByAliUidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReceiveFunctionTrialRewardByAliUidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshContainerAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshContainerAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshOssBucketScanInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshRegistryTokenRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshRegistryTokenResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReleaseSasInstanceRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReleaseSasInstanceResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckInstanceResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckInstanceResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetLogShipperRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetLogShipperResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryAgentlessTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryAgentlessTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryInstallProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryInstallProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RollbackSuspEventQuaraFileRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RollbackSuspEventQuaraFileResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SasInstallCodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SasInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveCustomizeReportConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveCustomizeReportConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveImageBaselineStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveImageBaselineStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveSuspEventUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveSuspEventUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveWhiteListStrategyAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveWhiteListStrategyAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveWhiteListStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveWhiteListStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SendCustomizeReportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SendCustomizeReportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetBuildRiskDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetBuildRiskDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetClusterInterceptionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetClusterInterceptionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageBuildRiskStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageBuildRiskStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageSensitiveFileStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageSensitiveFileStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetRegistryScanDayNumRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetRegistryScanDayNumResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSensitiveDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSensitiveDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSyncRefreshRegionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSyncRefreshRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartBaselineSecurityCheckRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartBaselineSecurityCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartDiscoverDatabaseTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartIdcProbeScanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartPreCheckDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartPreCheckDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartVirusScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartVirusScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StopHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StopHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitCheckRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitOperationTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitOperationTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\TriggerCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnbindAegisRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnbindAegisResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnBindHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnBindHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallBackupClientRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallBackupClientResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallRaspAttachRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallRaspAttachResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallUniBackupAgentRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallUniBackupAgentResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnMarkMonitorAccountsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnMarkMonitorAccountsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAlarmEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAlarmEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateBaselineCheckWhiteRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateBaselineCheckWhiteRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateClientAlertModeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateClientAlertModeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCommonSwitchConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCommonSwitchConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCustomizeReportStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCustomizeReportStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectEventStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectEventStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRemarkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRemarkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileUploadLimitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileUploadLimitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeBindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeBindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageVulWhitelistTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageVulWhitelistTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryPersistenceDayRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryPersistenceDayResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOpaStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOpaStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOpaStrategyNewShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishAutoUpgradeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishAutoUpgradeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishBatchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishBatchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishCronRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishCronResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishGraySwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdatePublishGraySwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateSelectionKeyByTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateSelectionKeyByTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateTargetListByBatchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateTargetListByBatchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateWhiteListStrategyStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateWhiteListStrategyStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeBackupPolicyVersionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeBackupPolicyVersionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeVersionByUuidsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeVersionByUuidsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UploadedHoneyPotFileRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UploadedHoneyPotFileResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ValidateHcWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ValidateHcWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckInstanceResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckInstanceResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckResultResponse;
use AlibabaCloud\Tea\Utils\Utils;
use AlibabaCloud\Tea\Utils\Utils\RuntimeOptions;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;

class Sas extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap  = [
            'cn-qingdao'            => 'tds.aliyuncs.com',
            'cn-beijing'            => 'tds.aliyuncs.com',
            'cn-zhangjiakou'        => 'tds.aliyuncs.com',
            'cn-huhehaote'          => 'tds.aliyuncs.com',
            'cn-wulanchabu'         => 'tds.aliyuncs.com',
            'cn-hangzhou'           => 'tds.aliyuncs.com',
            'cn-shanghai'           => 'tds.aliyuncs.com',
            'cn-nanjing'            => 'tds.aliyuncs.com',
            'cn-fuzhou'             => 'tds.aliyuncs.com',
            'cn-shenzhen'           => 'tds.aliyuncs.com',
            'cn-heyuan'             => 'tds.aliyuncs.com',
            'cn-guangzhou'          => 'tds.aliyuncs.com',
            'ap-southeast-2'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-6'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-northeast-2'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-3'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-northeast-1'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-7'        => 'tds.ap-southeast-1.aliyuncs.com',
            'cn-chengdu'            => 'tds.aliyuncs.com',
            'ap-southeast-1'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-5'        => 'tds.ap-southeast-1.aliyuncs.com',
            'cn-hongkong'           => 'tds.aliyuncs.com',
            'eu-central-1'          => 'tds.ap-southeast-1.aliyuncs.com',
            'us-east-1'             => 'tds.ap-southeast-1.aliyuncs.com',
            'us-west-1'             => 'tds.ap-southeast-1.aliyuncs.com',
            'eu-west-1'             => 'tds.ap-southeast-1.aliyuncs.com',
            'me-east-1'             => 'tds.ap-southeast-1.aliyuncs.com',
            'me-central-1'          => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-south-1'            => 'tds.ap-southeast-1.aliyuncs.com',
            'cn-beijing-finance-1'  => 'tds.aliyuncs.com',
            'cn-hangzhou-finance'   => 'tds.aliyuncs.com',
            'cn-shanghai-finance-1' => 'tds.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'tds.aliyuncs.com',
            'cn-heyuan-acdr-1'      => 'tds.aliyuncs.com',
            'cn-north-2-gov-1'      => 'tds.aliyuncs.com',
            'cn-qingdao-acdr-ut-1'  => 'tds.aliyuncs.com',
            'cn-shanghai-mybk'      => 'tds.aliyuncs.com',
            'cn-wuhan-lr'           => 'tds.aliyuncs.com',
            'cn-zhengzhou-jva'      => 'tds.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('sas', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (!Utils::empty_($endpoint)) {
            return $endpoint;
        }
        if (!Utils::isUnset($endpointMap) && !Utils::empty_(@$endpointMap[$regionId])) {
            return @$endpointMap[$regionId];
        }

        return Endpoint::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * @summary Select an operation for assets.
     *  *
     * @param AddAssetSelectionCriteriaRequest $request AddAssetSelectionCriteriaRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return AddAssetSelectionCriteriaResponse AddAssetSelectionCriteriaResponse
     */
    public function addAssetSelectionCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaOperation)) {
            $query['CriteriaOperation'] = $request->criteriaOperation;
        }
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        if (!Utils::isUnset($request->targetOperationList)) {
            $query['TargetOperationList'] = $request->targetOperationList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddAssetSelectionCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddAssetSelectionCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Select an operation for assets.
     *  *
     * @param AddAssetSelectionCriteriaRequest $request AddAssetSelectionCriteriaRequest
     *
     * @return AddAssetSelectionCriteriaResponse AddAssetSelectionCriteriaResponse
     */
    public function addAssetSelectionCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addAssetSelectionCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a whitelist rule for a baseline check item.
     *  *
     * @param AddBaselineCheckWhiteRecordRequest $request AddBaselineCheckWhiteRecordRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return AddBaselineCheckWhiteRecordResponse AddBaselineCheckWhiteRecordResponse
     */
    public function addBaselineCheckWhiteRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddBaselineCheckWhiteRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddBaselineCheckWhiteRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a whitelist rule for a baseline check item.
     *  *
     * @param AddBaselineCheckWhiteRecordRequest $request AddBaselineCheckWhiteRecordRequest
     *
     * @return AddBaselineCheckWhiteRecordResponse AddBaselineCheckWhiteRecordResponse
     */
    public function addBaselineCheckWhiteRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addBaselineCheckWhiteRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Adds check items to the whitelist for instances.
     *  *
     * @param AddCheckInstanceResultWhiteListRequest $request AddCheckInstanceResultWhiteListRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCheckInstanceResultWhiteListResponse AddCheckInstanceResultWhiteListResponse
     */
    public function addCheckInstanceResultWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkGroupId)) {
            $query['CheckGroupId'] = $request->checkGroupId;
        }
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->instanceList)) {
            $query['InstanceList'] = $request->instanceList;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddCheckInstanceResultWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddCheckInstanceResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds check items to the whitelist for instances.
     *  *
     * @param AddCheckInstanceResultWhiteListRequest $request AddCheckInstanceResultWhiteListRequest
     *
     * @return AddCheckInstanceResultWhiteListResponse AddCheckInstanceResultWhiteListResponse
     */
    public function addCheckInstanceResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCheckInstanceResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Adds check items to the whitelist.
     *  *
     * @param AddCheckResultWhiteListRequest $request AddCheckResultWhiteListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCheckResultWhiteListResponse AddCheckResultWhiteListResponse
     */
    public function addCheckResultWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddCheckResultWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddCheckResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds check items to the whitelist.
     *  *
     * @param AddCheckResultWhiteListRequest $request AddCheckResultWhiteListRequest
     *
     * @return AddCheckResultWhiteListResponse AddCheckResultWhiteListResponse
     */
    public function addCheckResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCheckResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a custom defense rule.
     *  *
     * @param AddClientUserDefineRuleRequest $request AddClientUserDefineRuleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddClientUserDefineRuleResponse AddClientUserDefineRuleResponse
     */
    public function addClientUserDefineRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->actionType)) {
            $query['ActionType'] = $request->actionType;
        }
        if (!Utils::isUnset($request->cmdline)) {
            $query['Cmdline'] = $request->cmdline;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->filePath)) {
            $query['FilePath'] = $request->filePath;
        }
        if (!Utils::isUnset($request->IP)) {
            $query['IP'] = $request->IP;
        }
        if (!Utils::isUnset($request->md5List)) {
            $query['Md5List'] = $request->md5List;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->newFilePath)) {
            $query['NewFilePath'] = $request->newFilePath;
        }
        if (!Utils::isUnset($request->parentCmdline)) {
            $query['ParentCmdline'] = $request->parentCmdline;
        }
        if (!Utils::isUnset($request->parentProcPath)) {
            $query['ParentProcPath'] = $request->parentProcPath;
        }
        if (!Utils::isUnset($request->platform)) {
            $query['Platform'] = $request->platform;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->portStr)) {
            $query['PortStr'] = $request->portStr;
        }
        if (!Utils::isUnset($request->procPath)) {
            $query['ProcPath'] = $request->procPath;
        }
        if (!Utils::isUnset($request->registryContent)) {
            $query['RegistryContent'] = $request->registryContent;
        }
        if (!Utils::isUnset($request->registryKey)) {
            $query['RegistryKey'] = $request->registryKey;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddClientUserDefineRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a custom defense rule.
     *  *
     * @param AddClientUserDefineRuleRequest $request AddClientUserDefineRuleRequest
     *
     * @return AddClientUserDefineRuleResponse AddClientUserDefineRuleResponse
     */
    public function addClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Adds the configuration information of multi-cloud assets.
     *  *
     * @param AddCloudVendorAccountAKRequest $request AddCloudVendorAccountAKRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCloudVendorAccountAKResponse AddCloudVendorAccountAKResponse
     */
    public function addCloudVendorAccountAKWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->akType)) {
            $query['AkType'] = $request->akType;
        }
        if (!Utils::isUnset($request->authModules)) {
            $query['AuthModules'] = $request->authModules;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->regions)) {
            $query['Regions'] = $request->regions;
        }
        if (!Utils::isUnset($request->secretId)) {
            $query['SecretId'] = $request->secretId;
        }
        if (!Utils::isUnset($request->secretKey)) {
            $query['SecretKey'] = $request->secretKey;
        }
        if (!Utils::isUnset($request->subscriptionIds)) {
            $query['SubscriptionIds'] = $request->subscriptionIds;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $query['TenantId'] = $request->tenantId;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddCloudVendorAccountAK',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddCloudVendorAccountAKResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds the configuration information of multi-cloud assets.
     *  *
     * @param AddCloudVendorAccountAKRequest $request AddCloudVendorAccountAKRequest
     *
     * @return AddCloudVendorAccountAKResponse AddCloudVendorAccountAKResponse
     */
    public function addCloudVendorAccountAK($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCloudVendorAccountAKWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a rule for non-image program defense.
     *  *
     * @param AddContainerDefenseRuleRequest $tmpReq  AddContainerDefenseRuleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddContainerDefenseRuleResponse AddContainerDefenseRuleResponse
     */
    public function addContainerDefenseRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new AddContainerDefenseRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->whitelist)) {
            $request->whitelistShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->whitelist, 'Whitelist', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->scope)) {
            $query['Scope'] = $request->scope;
        }
        if (!Utils::isUnset($request->whitelistShrink)) {
            $query['Whitelist'] = $request->whitelistShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddContainerDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a rule for non-image program defense.
     *  *
     * @param AddContainerDefenseRuleRequest $request AddContainerDefenseRuleRequest
     *
     * @return AddContainerDefenseRuleResponse AddContainerDefenseRuleResponse
     */
    public function addContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a defense rule against container escapes.
     *  *
     * @param AddContainerPluginRuleRequest $request AddContainerPluginRuleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddContainerPluginRuleResponse AddContainerPluginRuleResponse
     */
    public function addContainerPluginRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleTemplateId)) {
            $query['RuleTemplateId'] = $request->ruleTemplateId;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->selectedPolicy)) {
            $query['SelectedPolicy'] = $request->selectedPolicy;
        }
        if (!Utils::isUnset($request->whiteImages)) {
            $query['WhiteImages'] = $request->whiteImages;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddContainerPluginRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a defense rule against container escapes.
     *  *
     * @param AddContainerPluginRuleRequest $request AddContainerPluginRuleRequest
     *
     * @return AddContainerPluginRuleResponse AddContainerPluginRuleResponse
     */
    public function addContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an IDC probe to add assets in a data center to Security Center and manage the assets by using the Security Center console.
     *  *
     * @description Security Center allows you to create an IDC probe only on servers on which the Security Center agent is installed.
     *  *
     * @param AddIdcProbeRequest $request AddIdcProbeRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return AddIdcProbeResponse AddIdcProbeResponse
     */
    public function addIdcProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->idcName)) {
            $query['IdcName'] = $request->idcName;
        }
        if (!Utils::isUnset($request->idcRegion)) {
            $query['IdcRegion'] = $request->idcRegion;
        }
        if (!Utils::isUnset($request->intervalPeriod)) {
            $query['IntervalPeriod'] = $request->intervalPeriod;
        }
        if (!Utils::isUnset($request->ipSegments)) {
            $query['IpSegments'] = $request->ipSegments;
        }
        if (!Utils::isUnset($request->linuxPort)) {
            $query['LinuxPort'] = $request->linuxPort;
        }
        if (!Utils::isUnset($request->periodUnit)) {
            $query['PeriodUnit'] = $request->periodUnit;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->winPort)) {
            $query['WinPort'] = $request->winPort;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddIdcProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddIdcProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an IDC probe to add assets in a data center to Security Center and manage the assets by using the Security Center console.
     *  *
     * @description Security Center allows you to create an IDC probe only on servers on which the Security Center agent is installed.
     *  *
     * @param AddIdcProbeRequest $request AddIdcProbeRequest
     *
     * @return AddIdcProbeResponse AddIdcProbeResponse
     */
    public function addIdcProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addIdcProbeWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an alert handling rule.
     *  *
     * @param AddImageEventOperationRequest $request AddImageEventOperationRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddImageEventOperationResponse AddImageEventOperationResponse
     */
    public function addImageEventOperationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->conditions)) {
            $query['Conditions'] = $request->conditions;
        }
        if (!Utils::isUnset($request->eventKey)) {
            $query['EventKey'] = $request->eventKey;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->eventType)) {
            $query['EventType'] = $request->eventType;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->scenarios)) {
            $query['Scenarios'] = $request->scenarios;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddImageEventOperation',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an alert handling rule.
     *  *
     * @param AddImageEventOperationRequest $request AddImageEventOperationRequest
     *
     * @return AddImageEventOperationResponse AddImageEventOperationResponse
     */
    public function addImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * @summary Adds image vulnerabilities to the whitelist.
     *  *
     * @param AddImageVulWhiteListRequest $request AddImageVulWhiteListRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return AddImageVulWhiteListResponse AddImageVulWhiteListResponse
     */
    public function addImageVulWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->whitelist)) {
            $query['Whitelist'] = $request->whitelist;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddImageVulWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddImageVulWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds image vulnerabilities to the whitelist.
     *  *
     * @param AddImageVulWhiteListRequest $request AddImageVulWhiteListRequest
     *
     * @return AddImageVulWhiteListResponse AddImageVulWhiteListResponse
     */
    public function addImageVulWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addImageVulWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a command that is used to install the Security Center agent.
     *  *
     * @param AddInstallCodeRequest $request AddInstallCodeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return AddInstallCodeResponse AddInstallCodeResponse
     */
    public function addInstallCodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->expiredDate)) {
            $query['ExpiredDate'] = $request->expiredDate;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->onlyImage)) {
            $query['OnlyImage'] = $request->onlyImage;
        }
        if (!Utils::isUnset($request->os)) {
            $query['Os'] = $request->os;
        }
        if (!Utils::isUnset($request->proxyCluster)) {
            $query['ProxyCluster'] = $request->proxyCluster;
        }
        if (!Utils::isUnset($request->vendorName)) {
            $query['VendorName'] = $request->vendorName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddInstallCode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a command that is used to install the Security Center agent.
     *  *
     * @param AddInstallCodeRequest $request AddInstallCodeRequest
     *
     * @return AddInstallCodeResponse AddInstallCodeResponse
     */
    public function addInstallCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addInstallCodeWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a self-managed image repository.
     *  *
     * @param AddPrivateRegistryRequest $request AddPrivateRegistryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return AddPrivateRegistryResponse AddPrivateRegistryResponse
     */
    public function addPrivateRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->extraParam)) {
            $query['ExtraParam'] = $request->extraParam;
        }
        if (!Utils::isUnset($request->netType)) {
            $query['NetType'] = $request->netType;
        }
        if (!Utils::isUnset($request->password)) {
            $query['Password'] = $request->password;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->protocolType)) {
            $query['ProtocolType'] = $request->protocolType;
        }
        if (!Utils::isUnset($request->registryHostIp)) {
            $query['RegistryHostIp'] = $request->registryHostIp;
        }
        if (!Utils::isUnset($request->registryRegionId)) {
            $query['RegistryRegionId'] = $request->registryRegionId;
        }
        if (!Utils::isUnset($request->registryType)) {
            $query['RegistryType'] = $request->registryType;
        }
        if (!Utils::isUnset($request->registryVersion)) {
            $query['RegistryVersion'] = $request->registryVersion;
        }
        if (!Utils::isUnset($request->transPerHour)) {
            $query['TransPerHour'] = $request->transPerHour;
        }
        if (!Utils::isUnset($request->userName)) {
            $query['UserName'] = $request->userName;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddPrivateRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddPrivateRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a self-managed image repository.
     *  *
     * @param AddPrivateRegistryRequest $request AddPrivateRegistryRequest
     *
     * @return AddPrivateRegistryResponse AddPrivateRegistryResponse
     */
    public function addPrivateRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addPrivateRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary 新增发布批次
     *  *
     * @param AddPublishBatchRequest $request AddPublishBatchRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return AddPublishBatchResponse AddPublishBatchResponse
     */
    public function addPublishBatchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->batchName)) {
            $query['BatchName'] = $request->batchName;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->operationBase)) {
            $query['OperationBase'] = $request->operationBase;
        }
        if (!Utils::isUnset($request->upgradeVersion)) {
            $query['UpgradeVersion'] = $request->upgradeVersion;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddPublishBatch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddPublishBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 新增发布批次
     *  *
     * @param AddPublishBatchRequest $request AddPublishBatchRequest
     *
     * @return AddPublishBatchResponse AddPublishBatchResponse
     */
    public function addPublishBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addPublishBatchWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a rule for container tamper-proofing.
     *  *
     * @param AddSasContainerWebDefenseRuleRequest $request AddSasContainerWebDefenseRuleRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return AddSasContainerWebDefenseRuleResponse AddSasContainerWebDefenseRuleResponse
     */
    public function addSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pathConfDTOList)) {
            $query['PathConfDTOList'] = $request->pathConfDTOList;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddSasContainerWebDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a rule for container tamper-proofing.
     *  *
     * @param AddSasContainerWebDefenseRuleRequest $request AddSasContainerWebDefenseRuleRequest
     *
     * @return AddSasContainerWebDefenseRuleResponse AddSasContainerWebDefenseRuleResponse
     */
    public function addSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
     *  *
     * @param AddSasModuleTrialRequest $request AddSasModuleTrialRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return AddSasModuleTrialResponse AddSasModuleTrialResponse
     */
    public function addSasModuleTrialWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->moduleCode)) {
            $query['ModuleCode'] = $request->moduleCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddSasModuleTrial',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddSasModuleTrialResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
     *  *
     * @param AddSasModuleTrialRequest $request AddSasModuleTrialRequest
     *
     * @return AddSasModuleTrialResponse AddSasModuleTrialResponse
     */
    public function addSasModuleTrial($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addSasModuleTrialWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a tag to assets.
     *  *
     * @description Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
     *  *
     * @param AddTagWithUuidRequest $request AddTagWithUuidRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return AddTagWithUuidResponse AddTagWithUuidResponse
     */
    public function addTagWithUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tagName)) {
            $query['TagName'] = $request->tagName;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddTagWithUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddTagWithUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a tag to assets.
     *  *
     * @description Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
     *  *
     * @param AddTagWithUuidRequest $request AddTagWithUuidRequest
     *
     * @return AddTagWithUuidResponse AddTagWithUuidResponse
     */
    public function addTagWithUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addTagWithUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Adds servers from which you want to uninstall the Security Center agent.
     *  *
     * @param AddUninstallClientsByUuidsRequest $request AddUninstallClientsByUuidsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return AddUninstallClientsByUuidsResponse AddUninstallClientsByUuidsResponse
     */
    public function addUninstallClientsByUuidsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->callMethod)) {
            $query['CallMethod'] = $request->callMethod;
        }
        if (!Utils::isUnset($request->feedback)) {
            $query['Feedback'] = $request->feedback;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddUninstallClientsByUuids',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddUninstallClientsByUuidsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds servers from which you want to uninstall the Security Center agent.
     *  *
     * @param AddUninstallClientsByUuidsRequest $request AddUninstallClientsByUuidsRequest
     *
     * @return AddUninstallClientsByUuidsResponse AddUninstallClientsByUuidsResponse
     */
    public function addUninstallClientsByUuids($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addUninstallClientsByUuidsWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a honeypot.
     *  *
     * @param AddVpcHoneyPotRequest $request AddVpcHoneyPotRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return AddVpcHoneyPotResponse AddVpcHoneyPotResponse
     */
    public function addVpcHoneyPotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddVpcHoneyPot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddVpcHoneyPotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a honeypot.
     *  *
     * @param AddVpcHoneyPotRequest $request AddVpcHoneyPotRequest
     *
     * @return AddVpcHoneyPotResponse AddVpcHoneyPotResponse
     */
    public function addVpcHoneyPot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addVpcHoneyPotWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of an advanced whitelist rule.
     *  *
     * @param AdvanceSecurityEventOperationsRequest $request AdvanceSecurityEventOperationsRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return AdvanceSecurityEventOperationsResponse AdvanceSecurityEventOperationsResponse
     */
    public function advanceSecurityEventOperationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->eventType)) {
            $query['EventType'] = $request->eventType;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AdvanceSecurityEventOperations',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AdvanceSecurityEventOperationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of an advanced whitelist rule.
     *  *
     * @param AdvanceSecurityEventOperationsRequest $request AdvanceSecurityEventOperationsRequest
     *
     * @return AdvanceSecurityEventOperationsResponse AdvanceSecurityEventOperationsResponse
     */
    public function advanceSecurityEventOperations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->advanceSecurityEventOperationsWithOptions($request, $runtime);
    }

    /**
     * @summary 批量创建恶意文件告警备注
     *  *
     * @param BatchCreateMaliciousNoteRequest $request BatchCreateMaliciousNoteRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchCreateMaliciousNoteResponse BatchCreateMaliciousNoteResponse
     */
    public function batchCreateMaliciousNoteWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->imageMaliciousFileList)) {
            $query['ImageMaliciousFileList'] = $request->imageMaliciousFileList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BatchCreateMaliciousNote',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BatchCreateMaliciousNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 批量创建恶意文件告警备注
     *  *
     * @param BatchCreateMaliciousNoteRequest $request BatchCreateMaliciousNoteRequest
     *
     * @return BatchCreateMaliciousNoteResponse BatchCreateMaliciousNoteResponse
     */
    public function batchCreateMaliciousNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchCreateMaliciousNoteWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
     *  *
     * @param BatchDeleteMaliciousFileWhitelistConfigRequest $request BatchDeleteMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchDeleteMaliciousFileWhitelistConfigResponse BatchDeleteMaliciousFileWhitelistConfigResponse
     */
    public function batchDeleteMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configIdList)) {
            $query['ConfigIdList'] = $request->configIdList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BatchDeleteMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BatchDeleteMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
     *  *
     * @param BatchDeleteMaliciousFileWhitelistConfigRequest $request BatchDeleteMaliciousFileWhitelistConfigRequest
     *
     * @return BatchDeleteMaliciousFileWhitelistConfigResponse BatchDeleteMaliciousFileWhitelistConfigResponse
     */
    public function batchDeleteMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchDeleteMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables multiple features in proactive defense at a time.
     *  *
     * @param BatchOperateCommonOverallConfigRequest $request BatchOperateCommonOverallConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchOperateCommonOverallConfigResponse BatchOperateCommonOverallConfigResponse
     */
    public function batchOperateCommonOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->typeList)) {
            $query['TypeList'] = $request->typeList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BatchOperateCommonOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BatchOperateCommonOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables multiple features in proactive defense at a time.
     *  *
     * @param BatchOperateCommonOverallConfigRequest $request BatchOperateCommonOverallConfigRequest
     *
     * @return BatchOperateCommonOverallConfigResponse BatchOperateCommonOverallConfigResponse
     */
    public function batchOperateCommonOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchOperateCommonOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
     *  *
     * @param BatchUpdateMaliciousFileWhitelistConfigRequest $request BatchUpdateMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchUpdateMaliciousFileWhitelistConfigResponse BatchUpdateMaliciousFileWhitelistConfigResponse
     */
    public function batchUpdateMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configList)) {
            $query['ConfigList'] = $request->configList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BatchUpdateMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BatchUpdateMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
     *  *
     * @param BatchUpdateMaliciousFileWhitelistConfigRequest $request BatchUpdateMaliciousFileWhitelistConfigRequest
     *
     * @return BatchUpdateMaliciousFileWhitelistConfigResponse BatchUpdateMaliciousFileWhitelistConfigResponse
     */
    public function batchUpdateMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchUpdateMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Binds servers to Security Center or unbinds servers from Security Center.
     *  *
     * @param BindAuthToMachineRequest $request BindAuthToMachineRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return BindAuthToMachineResponse BindAuthToMachineResponse
     */
    public function bindAuthToMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->authVersion)) {
            $query['AuthVersion'] = $request->authVersion;
        }
        if (!Utils::isUnset($request->autoBind)) {
            $query['AutoBind'] = $request->autoBind;
        }
        if (!Utils::isUnset($request->bind)) {
            $query['Bind'] = $request->bind;
        }
        if (!Utils::isUnset($request->bindAll)) {
            $query['BindAll'] = $request->bindAll;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->isPreBind)) {
            $query['IsPreBind'] = $request->isPreBind;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->ntmVersion)) {
            $query['NtmVersion'] = $request->ntmVersion;
        }
        if (!Utils::isUnset($request->preBindOrderId)) {
            $query['PreBindOrderId'] = $request->preBindOrderId;
        }
        if (!Utils::isUnset($request->unBind)) {
            $query['UnBind'] = $request->unBind;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BindAuthToMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BindAuthToMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Binds servers to Security Center or unbinds servers from Security Center.
     *  *
     * @param BindAuthToMachineRequest $request BindAuthToMachineRequest
     *
     * @return BindAuthToMachineResponse BindAuthToMachineResponse
     */
    public function bindAuthToMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->bindAuthToMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
     *  *
     * @param BindHybridProxyRequest $request BindHybridProxyRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return BindHybridProxyResponse BindHybridProxyResponse
     */
    public function bindHybridProxyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->yundunUuids)) {
            $query['YundunUuids'] = $request->yundunUuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BindHybridProxy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BindHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
     *  *
     * @param BindHybridProxyRequest $request BindHybridProxyRequest
     *
     * @return BindHybridProxyResponse BindHybridProxyResponse
     */
    public function bindHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->bindHybridProxyWithOptions($request, $runtime);
    }

    /**
     * @summary Cancels the main task.
     *  *
     * @param CancelOnceTaskRequest $request CancelOnceTaskRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CancelOnceTaskResponse CancelOnceTaskResponse
     */
    public function cancelOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CancelOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CancelOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Cancels the main task.
     *  *
     * @param CancelOnceTaskRequest $request CancelOnceTaskRequest
     *
     * @return CancelOnceTaskResponse CancelOnceTaskResponse
     */
    public function cancelOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the interval of asset synchronization configurations.
     *  *
     * @param ChangeAssetRefreshTaskConfigRequest $request ChangeAssetRefreshTaskConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeAssetRefreshTaskConfigResponse ChangeAssetRefreshTaskConfigResponse
     */
    public function changeAssetRefreshTaskConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetRefreshConfigs)) {
            $query['AssetRefreshConfigs'] = $request->assetRefreshConfigs;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeAssetRefreshTaskConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeAssetRefreshTaskConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the interval of asset synchronization configurations.
     *  *
     * @param ChangeAssetRefreshTaskConfigRequest $request ChangeAssetRefreshTaskConfigRequest
     *
     * @return ChangeAssetRefreshTaskConfigResponse ChangeAssetRefreshTaskConfigResponse
     */
    public function changeAssetRefreshTaskConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeAssetRefreshTaskConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration items of the configuration assessment feature.
     *  *
     * @param ChangeCheckConfigRequest $tmpReq  ChangeCheckConfigRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeCheckConfigResponse ChangeCheckConfigResponse
     */
    public function changeCheckConfigWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ChangeCheckConfigShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->configRequirementIds)) {
            $request->configRequirementIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->configRequirementIds, 'ConfigRequirementIds', 'json');
        }
        if (!Utils::isUnset($tmpReq->configStandardIds)) {
            $request->configStandardIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->configStandardIds, 'ConfigStandardIds', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->addedCheck)) {
            $query['AddedCheck'] = $request->addedCheck;
        }
        if (!Utils::isUnset($request->configRequirementIdsShrink)) {
            $query['ConfigRequirementIds'] = $request->configRequirementIdsShrink;
        }
        if (!Utils::isUnset($request->configStandardIdsShrink)) {
            $query['ConfigStandardIds'] = $request->configStandardIdsShrink;
        }
        if (!Utils::isUnset($request->configure)) {
            $query['Configure'] = $request->configure;
        }
        if (!Utils::isUnset($request->cycleDays)) {
            $query['CycleDays'] = $request->cycleDays;
        }
        if (!Utils::isUnset($request->enableAddCheck)) {
            $query['EnableAddCheck'] = $request->enableAddCheck;
        }
        if (!Utils::isUnset($request->enableAutoCheck)) {
            $query['EnableAutoCheck'] = $request->enableAutoCheck;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->removedCheck)) {
            $query['RemovedCheck'] = $request->removedCheck;
        }
        if (!Utils::isUnset($request->standardIds)) {
            $query['StandardIds'] = $request->standardIds;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->systemConfig)) {
            $query['SystemConfig'] = $request->systemConfig;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeCheckConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeCheckConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration items of the configuration assessment feature.
     *  *
     * @param ChangeCheckConfigRequest $request ChangeCheckConfigRequest
     *
     * @return ChangeCheckConfigResponse ChangeCheckConfigResponse
     */
    public function changeCheckConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeCheckConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the custom configuration items of a check item.
     *  *
     * @param ChangeCheckCustomConfigRequest $request ChangeCheckCustomConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeCheckCustomConfigResponse ChangeCheckCustomConfigResponse
     */
    public function changeCheckCustomConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->customConfigs)) {
            $query['CustomConfigs'] = $request->customConfigs;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repairConfigs)) {
            $query['RepairConfigs'] = $request->repairConfigs;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeCheckCustomConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeCheckCustomConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the custom configuration items of a check item.
     *  *
     * @param ChangeCheckCustomConfigRequest $request ChangeCheckCustomConfigRequest
     *
     * @return ChangeCheckCustomConfigResponse ChangeCheckCustomConfigResponse
     */
    public function changeCheckCustomConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeCheckCustomConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the details of the deduction modules of the security score feature, including custom settings.
     *  *
     * @param ChangeSecurityScoreRuleRequest $request ChangeSecurityScoreRuleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeSecurityScoreRuleResponse ChangeSecurityScoreRuleResponse
     */
    public function changeSecurityScoreRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resetSecurityScoreRule)) {
            $query['ResetSecurityScoreRule'] = $request->resetSecurityScoreRule;
        }
        if (!Utils::isUnset($request->securityScoreRuleList)) {
            $query['SecurityScoreRuleList'] = $request->securityScoreRuleList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeSecurityScoreRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeSecurityScoreRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the details of the deduction modules of the security score feature, including custom settings.
     *  *
     * @param ChangeSecurityScoreRuleRequest $request ChangeSecurityScoreRuleRequest
     *
     * @return ChangeSecurityScoreRuleResponse ChangeSecurityScoreRuleResponse
     */
    public function changeSecurityScoreRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeSecurityScoreRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
     *  *
     * @param ChangeUserLangRequest $request ChangeUserLangRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeUserLangResponse ChangeUserLangResponse
     */
    public function changeUserLangWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->userLang)) {
            $query['UserLang'] = $request->userLang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeUserLang',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeUserLangResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
     *  *
     * @param ChangeUserLangRequest $request ChangeUserLangRequest
     *
     * @return ChangeUserLangResponse ChangeUserLangResponse
     */
    public function changeUserLang($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeUserLangWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CheckQuaraFileId is deprecated
     *  *
     * @summary Checks whether the IDs of quarantined files are valid.
     *  *
     * Deprecated
     *
     * @param CheckQuaraFileIdRequest $request CheckQuaraFileIdRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckQuaraFileIdResponse CheckQuaraFileIdResponse
     */
    public function checkQuaraFileIdWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->quaraFileIds)) {
            $query['QuaraFileIds'] = $request->quaraFileIds;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckQuaraFileId',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckQuaraFileIdResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CheckQuaraFileId is deprecated
     *  *
     * @summary Checks whether the IDs of quarantined files are valid.
     *  *
     * Deprecated
     *
     * @param CheckQuaraFileIdRequest $request CheckQuaraFileIdRequest
     *
     * @return CheckQuaraFileIdResponse CheckQuaraFileIdResponse
     */
    public function checkQuaraFileId($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkQuaraFileIdWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
     *  *
     * @param CheckSecurityEventIdRequest $request CheckSecurityEventIdRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckSecurityEventIdResponse CheckSecurityEventIdResponse
     */
    public function checkSecurityEventIdWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->securityEventIds)) {
            $query['SecurityEventIds'] = $request->securityEventIds;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckSecurityEventId',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckSecurityEventIdResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
     *  *
     * @param CheckSecurityEventIdRequest $request CheckSecurityEventIdRequest
     *
     * @return CheckSecurityEventIdResponse CheckSecurityEventIdResponse
     */
    public function checkSecurityEventId($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkSecurityEventIdWithOptions($request, $runtime);
    }

    /**
     * @summary Checks a Security Token Service (STS) token and returns the ID of the Alibaba Cloud account.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckStsTokenAuthResponse CheckStsTokenAuthResponse
     */
    public function checkStsTokenAuthWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'CheckStsTokenAuth',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckStsTokenAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks a Security Token Service (STS) token and returns the ID of the Alibaba Cloud account.
     *  *
     * @return CheckStsTokenAuthResponse CheckStsTokenAuthResponse
     */
    public function checkStsTokenAuth()
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkStsTokenAuthWithOptions($runtime);
    }

    /**
     * @summary 检查试用修复数量
     *  *
     * @param CheckTrialFixCountRequest $request CheckTrialFixCountRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckTrialFixCountResponse CheckTrialFixCountResponse
     */
    public function checkTrialFixCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->info)) {
            $query['Info'] = $request->info;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->vulNames)) {
            $query['VulNames'] = $request->vulNames;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckTrialFixCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckTrialFixCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 检查试用修复数量
     *  *
     * @param CheckTrialFixCountRequest $request CheckTrialFixCountRequest
     *
     * @return CheckTrialFixCountResponse CheckTrialFixCountResponse
     */
    public function checkTrialFixCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkTrialFixCountWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether Elastic Compute Service (ECS) instances exist.
     *  *
     * @param CheckUserHasEcsRequest $request CheckUserHasEcsRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckUserHasEcsResponse CheckUserHasEcsResponse
     */
    public function checkUserHasEcsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckUserHasEcs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckUserHasEcsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether Elastic Compute Service (ECS) instances exist.
     *  *
     * @param CheckUserHasEcsRequest $request CheckUserHasEcsRequest
     *
     * @return CheckUserHasEcsResponse CheckUserHasEcsResponse
     */
    public function checkUserHasEcs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkUserHasEcsWithOptions($request, $runtime);
    }

    /**
     * @summary Confirms the alert events that you want to handle.
     *  *
     * @param ConfirmVirusEventsRequest $request ConfirmVirusEventsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ConfirmVirusEventsResponse ConfirmVirusEventsResponse
     */
    public function confirmVirusEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->operationAll)) {
            $query['OperationAll'] = $request->operationAll;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->operationRange)) {
            $query['OperationRange'] = $request->operationRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ConfirmVirusEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ConfirmVirusEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Confirms the alert events that you want to handle.
     *  *
     * @param ConfirmVirusEventsRequest $request ConfirmVirusEventsRequest
     *
     * @return ConfirmVirusEventsResponse ConfirmVirusEventsResponse
     */
    public function confirmVirusEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->confirmVirusEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Clones an existing security report. The new security report has the same configuration as the existing security report.
     *  *
     * @param CopyCustomizeReportConfigRequest $request CopyCustomizeReportConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CopyCustomizeReportConfigResponse CopyCustomizeReportConfigResponse
     */
    public function copyCustomizeReportConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CopyCustomizeReportConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CopyCustomizeReportConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Clones an existing security report. The new security report has the same configuration as the existing security report.
     *  *
     * @param CopyCustomizeReportConfigRequest $request CopyCustomizeReportConfigRequest
     *
     * @return CopyCustomizeReportConfigResponse CopyCustomizeReportConfigResponse
     */
    public function copyCustomizeReportConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyCustomizeReportConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an agentless detection task.
     *  *
     * @param CreateAgentlessScanTaskRequest $request CreateAgentlessScanTaskRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateAgentlessScanTaskResponse CreateAgentlessScanTaskResponse
     */
    public function createAgentlessScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetSelectionType)) {
            $query['AssetSelectionType'] = $request->assetSelectionType;
        }
        if (!Utils::isUnset($request->autoDeleteDays)) {
            $query['AutoDeleteDays'] = $request->autoDeleteDays;
        }
        if (!Utils::isUnset($request->releaseAfterScan)) {
            $query['ReleaseAfterScan'] = $request->releaseAfterScan;
        }
        if (!Utils::isUnset($request->scanDataDisk)) {
            $query['ScanDataDisk'] = $request->scanDataDisk;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateAgentlessScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateAgentlessScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an agentless detection task.
     *  *
     * @param CreateAgentlessScanTaskRequest $request CreateAgentlessScanTaskRequest
     *
     * @return CreateAgentlessScanTaskResponse CreateAgentlessScanTaskResponse
     */
    public function createAgentlessScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAgentlessScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a defense rule against brute-force attacks.
     *  *
     * @param CreateAntiBruteForceRuleRequest $request CreateAntiBruteForceRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateAntiBruteForceRuleResponse CreateAntiBruteForceRuleResponse
     */
    public function createAntiBruteForceRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defaultRule)) {
            $query['DefaultRule'] = $request->defaultRule;
        }
        if (!Utils::isUnset($request->failCount)) {
            $query['FailCount'] = $request->failCount;
        }
        if (!Utils::isUnset($request->forbiddenTime)) {
            $query['ForbiddenTime'] = $request->forbiddenTime;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->span)) {
            $query['Span'] = $request->span;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateAntiBruteForceRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a defense rule against brute-force attacks.
     *  *
     * @param CreateAntiBruteForceRuleRequest $request CreateAntiBruteForceRuleRequest
     *
     * @return CreateAntiBruteForceRuleResponse CreateAntiBruteForceRuleResponse
     */
    public function createAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Create asset selection configurations.
     *  *
     * @param CreateAssetSelectionConfigRequest $request CreateAssetSelectionConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateAssetSelectionConfigResponse CreateAssetSelectionConfigResponse
     */
    public function createAssetSelectionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->businessType)) {
            $query['BusinessType'] = $request->businessType;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateAssetSelectionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateAssetSelectionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Create asset selection configurations.
     *  *
     * @param CreateAssetSelectionConfigRequest $request CreateAssetSelectionConfigRequest
     *
     * @return CreateAssetSelectionConfigResponse CreateAssetSelectionConfigResponse
     */
    public function createAssetSelectionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAssetSelectionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a witness.
     *  *
     * @param CreateAttestorRequest $request CreateAttestorRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateAttestorResponse CreateAttestorResponse
     */
    public function createAttestorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->keyId)) {
            $query['KeyId'] = $request->keyId;
        }
        if (!Utils::isUnset($request->keyRegionId)) {
            $query['KeyRegionId'] = $request->keyRegionId;
        }
        if (!Utils::isUnset($request->keyVersionId)) {
            $query['KeyVersionId'] = $request->keyVersionId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateAttestor',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateAttestorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a witness.
     *  *
     * @param CreateAttestorRequest $request CreateAttestorRequest
     *
     * @return CreateAttestorResponse CreateAttestorResponse
     */
    public function createAttestor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAttestorWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an anti-ransomware policy for servers.
     *  *
     * @param CreateBackupPolicyRequest $tmpReq  CreateBackupPolicyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateBackupPolicyResponse CreateBackupPolicyResponse
     */
    public function createBackupPolicyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateBackupPolicyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->policy)) {
            $request->policyShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->policy, 'Policy', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->policyShrink)) {
            $query['Policy'] = $request->policyShrink;
        }
        if (!Utils::isUnset($request->policyRegionId)) {
            $query['PolicyRegionId'] = $request->policyRegionId;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an anti-ransomware policy for servers.
     *  *
     * @param CreateBackupPolicyRequest $request CreateBackupPolicyRequest
     *
     * @return CreateBackupPolicyResponse CreateBackupPolicyResponse
     */
    public function createBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a binary security policy.
     *  *
     * @param CreateBinarySecurityPolicyRequest $request CreateBinarySecurityPolicyRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateBinarySecurityPolicyResponse CreateBinarySecurityPolicyResponse
     */
    public function createBinarySecurityPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusters)) {
            $query['Clusters'] = $request->clusters;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->policy)) {
            $query['Policy'] = $request->policy;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateBinarySecurityPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateBinarySecurityPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a binary security policy.
     *  *
     * @param CreateBinarySecurityPolicyRequest $request CreateBinarySecurityPolicyRequest
     *
     * @return CreateBinarySecurityPolicyResponse CreateBinarySecurityPolicyResponse
     */
    public function createBinarySecurityPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBinarySecurityPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a container scan task.
     *  *
     * @param CreateContainerScanTaskRequest $request CreateContainerScanTaskRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateContainerScanTaskResponse CreateContainerScanTaskResponse
     */
    public function createContainerScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerIds)) {
            $query['ContainerIds'] = $request->containerIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateContainerScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateContainerScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a container scan task.
     *  *
     * @param CreateContainerScanTaskRequest $request CreateContainerScanTaskRequest
     *
     * @return CreateContainerScanTaskResponse CreateContainerScanTaskResponse
     */
    public function createContainerScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createContainerScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a scan task for a running container application based on the application name.
     *  *
     * @param CreateContainerScanTaskByAppNameRequest $request CreateContainerScanTaskByAppNameRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateContainerScanTaskByAppNameResponse CreateContainerScanTaskByAppNameResponse
     */
    public function createContainerScanTaskByAppNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appNames)) {
            $query['AppNames'] = $request->appNames;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateContainerScanTaskByAppName',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateContainerScanTaskByAppNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a scan task for a running container application based on the application name.
     *  *
     * @param CreateContainerScanTaskByAppNameRequest $request CreateContainerScanTaskByAppNameRequest
     *
     * @return CreateContainerScanTaskByAppNameResponse CreateContainerScanTaskByAppNameResponse
     */
    public function createContainerScanTaskByAppName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createContainerScanTaskByAppNameWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an IP address blocking policy for one or more servers.
     *  *
     * @param CreateCustomBlockRecordRequest $request CreateCustomBlockRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateCustomBlockRecordResponse CreateCustomBlockRecordResponse
     */
    public function createCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->expireTime)) {
            $query['ExpireTime'] = $request->expireTime;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an IP address blocking policy for one or more servers.
     *  *
     * @param CreateCustomBlockRecordRequest $request CreateCustomBlockRecordRequest
     *
     * @return CreateCustomBlockRecordResponse CreateCustomBlockRecordResponse
     */
    public function createCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Creates custom weak password rules.
     *  *
     * @param CreateCustomizedDictRequest $request CreateCustomizedDictRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateCustomizedDictResponse CreateCustomizedDictResponse
     */
    public function createCustomizedDictWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateCustomizedDict',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateCustomizedDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates custom weak password rules.
     *  *
     * @param CreateCustomizedDictRequest $request CreateCustomizedDictRequest
     *
     * @return CreateCustomizedDictResponse CreateCustomizedDictResponse
     */
    public function createCustomizedDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomizedDictWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *  *
     * @param CreateCycleTaskRequest $request CreateCycleTaskRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateCycleTaskResponse CreateCycleTaskResponse
     */
    public function createCycleTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->enable)) {
            $query['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->firstDateStr)) {
            $query['FirstDateStr'] = $request->firstDateStr;
        }
        if (!Utils::isUnset($request->intervalPeriod)) {
            $query['IntervalPeriod'] = $request->intervalPeriod;
        }
        if (!Utils::isUnset($request->param)) {
            $query['Param'] = $request->param;
        }
        if (!Utils::isUnset($request->periodUnit)) {
            $query['PeriodUnit'] = $request->periodUnit;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->targetEndTime)) {
            $query['TargetEndTime'] = $request->targetEndTime;
        }
        if (!Utils::isUnset($request->targetStartTime)) {
            $query['TargetStartTime'] = $request->targetStartTime;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateCycleTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateCycleTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *  *
     * @param CreateCycleTaskRequest $request CreateCycleTaskRequest
     *
     * @return CreateCycleTaskResponse CreateCycleTaskResponse
     */
    public function createCycleTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCycleTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a dynamic dictionary of weak passwords.
     *  *
     * @param CreateDynamicDictRequest $request CreateDynamicDictRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDynamicDictResponse CreateDynamicDictResponse
     */
    public function createDynamicDictWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->override)) {
            $query['Override'] = $request->override;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateDynamicDict',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDynamicDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a dynamic dictionary of weak passwords.
     *  *
     * @param CreateDynamicDictRequest $request CreateDynamicDictRequest
     *
     * @return CreateDynamicDictResponse CreateDynamicDictResponse
     */
    public function createDynamicDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDynamicDictWithOptions($request, $runtime);
    }

    /**
     * @summary Pushes a file to the cloud for detection.
     *  *
     * @description You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param CreateFileDetectRequest $request CreateFileDetectRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileDetectResponse CreateFileDetectResponse
     */
    public function createFileDetectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->decompress)) {
            $query['Decompress'] = $request->decompress;
        }
        if (!Utils::isUnset($request->decompressMaxFileCount)) {
            $query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }
        if (!Utils::isUnset($request->decompressMaxLayer)) {
            $query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }
        if (!Utils::isUnset($request->downloadUrl)) {
            $query['DownloadUrl'] = $request->downloadUrl;
        }
        if (!Utils::isUnset($request->hashKey)) {
            $query['HashKey'] = $request->hashKey;
        }
        if (!Utils::isUnset($request->ossKey)) {
            $query['OssKey'] = $request->ossKey;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFileDetect',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileDetectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Pushes a file to the cloud for detection.
     *  *
     * @description You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param CreateFileDetectRequest $request CreateFileDetectRequest
     *
     * @return CreateFileDetectResponse CreateFileDetectResponse
     */
    public function createFileDetect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileDetectWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the parameters that are required to upload a file for detection.
     *  *
     * @description You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
     * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param CreateFileDetectUploadUrlRequest $request CreateFileDetectUploadUrlRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileDetectUploadUrlResponse CreateFileDetectUploadUrlResponse
     */
    public function createFileDetectUploadUrlWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->hashKeyContextList)) {
            $query['HashKeyContextList'] = $request->hashKeyContextList;
        }
        if (!Utils::isUnset($request->hashKeyList)) {
            $query['HashKeyList'] = $request->hashKeyList;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFileDetectUploadUrl',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileDetectUploadUrlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the parameters that are required to upload a file for detection.
     *  *
     * @description You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
     * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param CreateFileDetectUploadUrlRequest $request CreateFileDetectUploadUrlRequest
     *
     * @return CreateFileDetectUploadUrlResponse CreateFileDetectUploadUrlResponse
     */
    public function createFileDetectUploadUrl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileDetectUploadUrlWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a core file monitoring rule.
     *  *
     * @param CreateFileProtectRuleRequest $request CreateFileProtectRuleRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileProtectRuleResponse CreateFileProtectRuleResponse
     */
    public function createFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alertLevel)) {
            $query['AlertLevel'] = $request->alertLevel;
        }
        if (!Utils::isUnset($request->fileOps)) {
            $query['FileOps'] = $request->fileOps;
        }
        if (!Utils::isUnset($request->filePaths)) {
            $query['FilePaths'] = $request->filePaths;
        }
        if (!Utils::isUnset($request->platform)) {
            $query['Platform'] = $request->platform;
        }
        if (!Utils::isUnset($request->procPaths)) {
            $query['ProcPaths'] = $request->procPaths;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->switchId)) {
            $query['SwitchId'] = $request->switchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a core file monitoring rule.
     *  *
     * @param CreateFileProtectRuleRequest $request CreateFileProtectRuleRequest
     *
     * @return CreateFileProtectRuleResponse CreateFileProtectRuleResponse
     */
    public function createFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Specifies the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param CreateFileUploadLimitRequest $request CreateFileUploadLimitRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileUploadLimitResponse CreateFileUploadLimitResponse
     */
    public function createFileUploadLimitWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->limit)) {
            $query['Limit'] = $request->limit;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFileUploadLimit',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileUploadLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Specifies the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param CreateFileUploadLimitRequest $request CreateFileUploadLimitRequest
     *
     * @return CreateFileUploadLimitResponse CreateFileUploadLimitResponse
     */
    public function createFileUploadLimit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileUploadLimitWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a honeypot.
     *  *
     * @param CreateHoneypotRequest $request CreateHoneypotRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotResponse CreateHoneypotResponse
     */
    public function createHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotImageId)) {
            $query['HoneypotImageId'] = $request->honeypotImageId;
        }
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->honeypotName)) {
            $query['HoneypotName'] = $request->honeypotName;
        }
        if (!Utils::isUnset($request->meta)) {
            $query['Meta'] = $request->meta;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a honeypot.
     *  *
     * @param CreateHoneypotRequest $request CreateHoneypotRequest
     *
     * @return CreateHoneypotResponse CreateHoneypotResponse
     */
    public function createHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a management node.
     *  *
     * @param CreateHoneypotNodeRequest $request CreateHoneypotNodeRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotNodeResponse CreateHoneypotNodeResponse
     */
    public function createHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allowHoneypotAccessInternet)) {
            $query['AllowHoneypotAccessInternet'] = $request->allowHoneypotAccessInternet;
        }
        if (!Utils::isUnset($request->availableProbeNum)) {
            $query['AvailableProbeNum'] = $request->availableProbeNum;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->securityGroupProbeIpList)) {
            $query['SecurityGroupProbeIpList'] = $request->securityGroupProbeIpList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a management node.
     *  *
     * @param CreateHoneypotNodeRequest $request CreateHoneypotNodeRequest
     *
     * @return CreateHoneypotNodeResponse CreateHoneypotNodeResponse
     */
    public function createHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a honeypot template.
     *  *
     * @param CreateHoneypotPresetRequest $request CreateHoneypotPresetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotPresetResponse CreateHoneypotPresetResponse
     */
    public function createHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->meta)) {
            $query['Meta'] = $request->meta;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->presetName)) {
            $query['PresetName'] = $request->presetName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a honeypot template.
     *  *
     * @param CreateHoneypotPresetRequest $request CreateHoneypotPresetRequest
     *
     * @return CreateHoneypotPresetResponse CreateHoneypotPresetResponse
     */
    public function createHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a probe.
     *  *
     * @param CreateHoneypotProbeRequest $request CreateHoneypotProbeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotProbeResponse CreateHoneypotProbeResponse
     */
    public function createHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->arp)) {
            $query['Arp'] = $request->arp;
        }
        if (!Utils::isUnset($request->businessGroupId)) {
            $query['BusinessGroupId'] = $request->businessGroupId;
        }
        if (!Utils::isUnset($request->controlNodeId)) {
            $query['ControlNodeId'] = $request->controlNodeId;
        }
        if (!Utils::isUnset($request->displayName)) {
            $query['DisplayName'] = $request->displayName;
        }
        if (!Utils::isUnset($request->honeypotBindList)) {
            $query['HoneypotBindList'] = $request->honeypotBindList;
        }
        if (!Utils::isUnset($request->ping)) {
            $query['Ping'] = $request->ping;
        }
        if (!Utils::isUnset($request->probeType)) {
            $query['ProbeType'] = $request->probeType;
        }
        if (!Utils::isUnset($request->probeVersion)) {
            $query['ProbeVersion'] = $request->probeVersion;
        }
        if (!Utils::isUnset($request->proxyIp)) {
            $query['ProxyIp'] = $request->proxyIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a probe.
     *  *
     * @param CreateHoneypotProbeRequest $request CreateHoneypotProbeRequest
     *
     * @return CreateHoneypotProbeResponse CreateHoneypotProbeResponse
     */
    public function createHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a monitoring or forwarding service for a probe.
     *  *
     * @param CreateHoneypotProbeBindRequest $request CreateHoneypotProbeBindRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotProbeBindResponse CreateHoneypotProbeBindResponse
     */
    public function createHoneypotProbeBindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bindPortList)) {
            $query['BindPortList'] = $request->bindPortList;
        }
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        if (!Utils::isUnset($request->serviceIpList)) {
            $query['ServiceIpList'] = $request->serviceIpList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypotProbeBind',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotProbeBindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a monitoring or forwarding service for a probe.
     *  *
     * @param CreateHoneypotProbeBindRequest $request CreateHoneypotProbeBindRequest
     *
     * @return CreateHoneypotProbeBindResponse CreateHoneypotProbeBindResponse
     */
    public function createHoneypotProbeBind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotProbeBindWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a hybrid-cloud proxy cluster.
     *  *
     * @param CreateHybridProxyClusterRequest $request CreateHybridProxyClusterRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHybridProxyClusterResponse CreateHybridProxyClusterResponse
     */
    public function createHybridProxyClusterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->ip)) {
            $query['Ip'] = $request->ip;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHybridProxyCluster',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHybridProxyClusterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a hybrid-cloud proxy cluster.
     *  *
     * @param CreateHybridProxyClusterRequest $request CreateHybridProxyClusterRequest
     *
     * @return CreateHybridProxyClusterResponse CreateHybridProxyClusterResponse
     */
    public function createHybridProxyCluster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHybridProxyClusterWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a defense rule in the container firewall module.
     *  *
     * @param CreateInterceptionRuleRequest $tmpReq  CreateInterceptionRuleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateInterceptionRuleResponse CreateInterceptionRuleResponse
     */
    public function createInterceptionRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateInterceptionRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->dstTargetList)) {
            $request->dstTargetListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->dstTargetList, 'DstTargetList', 'json');
        }
        if (!Utils::isUnset($tmpReq->srcTarget)) {
            $request->srcTargetShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->srcTarget, 'SrcTarget', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->dstTargetListShrink)) {
            $query['DstTargetList'] = $request->dstTargetListShrink;
        }
        if (!Utils::isUnset($request->interceptType)) {
            $query['InterceptType'] = $request->interceptType;
        }
        if (!Utils::isUnset($request->orderIndex)) {
            $query['OrderIndex'] = $request->orderIndex;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->srcTargetShrink)) {
            $query['SrcTarget'] = $request->srcTargetShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateInterceptionRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateInterceptionRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a defense rule in the container firewall module.
     *  *
     * @param CreateInterceptionRuleRequest $request CreateInterceptionRuleRequest
     *
     * @return CreateInterceptionRuleResponse CreateInterceptionRuleResponse
     */
    public function createInterceptionRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createInterceptionRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a defense object.
     *  *
     * @param CreateInterceptionTargetRequest $request CreateInterceptionTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateInterceptionTargetResponse CreateInterceptionTargetResponse
     */
    public function createInterceptionTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->imageList)) {
            $query['ImageList'] = $request->imageList;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->tagList)) {
            $query['TagList'] = $request->tagList;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateInterceptionTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateInterceptionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a defense object.
     *  *
     * @param CreateInterceptionTargetRequest $request CreateInterceptionTargetRequest
     *
     * @return CreateInterceptionTargetResponse CreateInterceptionTargetResponse
     */
    public function createInterceptionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createInterceptionTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a Jenkins image repository.
     *  *
     * @param CreateJenkinsImageRegistryRequest $request CreateJenkinsImageRegistryRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateJenkinsImageRegistryResponse CreateJenkinsImageRegistryResponse
     */
    public function createJenkinsImageRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->domainName)) {
            $body['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->extraParam)) {
            $body['ExtraParam'] = $request->extraParam;
        }
        if (!Utils::isUnset($request->netType)) {
            $body['NetType'] = $request->netType;
        }
        if (!Utils::isUnset($request->password)) {
            $body['Password'] = $request->password;
        }
        if (!Utils::isUnset($request->persistenceDay)) {
            $body['PersistenceDay'] = $request->persistenceDay;
        }
        if (!Utils::isUnset($request->protocolType)) {
            $body['ProtocolType'] = $request->protocolType;
        }
        if (!Utils::isUnset($request->regionId)) {
            $body['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->registryHostIp)) {
            $body['RegistryHostIp'] = $request->registryHostIp;
        }
        if (!Utils::isUnset($request->registryName)) {
            $body['RegistryName'] = $request->registryName;
        }
        if (!Utils::isUnset($request->registryType)) {
            $body['RegistryType'] = $request->registryType;
        }
        if (!Utils::isUnset($request->registryVersion)) {
            $body['RegistryVersion'] = $request->registryVersion;
        }
        if (!Utils::isUnset($request->transPerHour)) {
            $body['TransPerHour'] = $request->transPerHour;
        }
        if (!Utils::isUnset($request->userName)) {
            $body['UserName'] = $request->userName;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $body['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->whiteList)) {
            $body['WhiteList'] = $request->whiteList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateJenkinsImageRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateJenkinsImageRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a Jenkins image repository.
     *  *
     * @param CreateJenkinsImageRegistryRequest $request CreateJenkinsImageRegistryRequest
     *
     * @return CreateJenkinsImageRegistryResponse CreateJenkinsImageRegistryResponse
     */
    public function createJenkinsImageRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createJenkinsImageRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a Jenkins scan task.
     *  *
     * @param CreateJenkinsImageScanTaskRequest $request CreateJenkinsImageScanTaskRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateJenkinsImageScanTaskResponse CreateJenkinsImageScanTaskResponse
     */
    public function createJenkinsImageScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->jenkinsEnv)) {
            $query['JenkinsEnv'] = $request->jenkinsEnv;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->digest)) {
            $body['Digest'] = $request->digest;
        }
        if (!Utils::isUnset($request->imageCreate)) {
            $body['ImageCreate'] = $request->imageCreate;
        }
        if (!Utils::isUnset($request->imageId)) {
            $body['ImageId'] = $request->imageId;
        }
        if (!Utils::isUnset($request->imageSize)) {
            $body['ImageSize'] = $request->imageSize;
        }
        if (!Utils::isUnset($request->imageUpdate)) {
            $body['ImageUpdate'] = $request->imageUpdate;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $body['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->repoName)) {
            $body['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->tag)) {
            $body['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->token)) {
            $body['Token'] = $request->token;
        }
        if (!Utils::isUnset($request->uuid)) {
            $body['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateJenkinsImageScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateJenkinsImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a Jenkins scan task.
     *  *
     * @param CreateJenkinsImageScanTaskRequest $request CreateJenkinsImageScanTaskRequest
     *
     * @return CreateJenkinsImageScanTaskResponse CreateJenkinsImageScanTaskResponse
     */
    public function createJenkinsImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createJenkinsImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param CreateMaliciousFileWhitelistConfigRequest $request CreateMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMaliciousFileWhitelistConfigResponse CreateMaliciousFileWhitelistConfigResponse
     */
    public function createMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->field)) {
            $query['Field'] = $request->field;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->operator)) {
            $query['Operator'] = $request->operator;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->targetValue)) {
            $query['TargetValue'] = $request->targetValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param CreateMaliciousFileWhitelistConfigRequest $request CreateMaliciousFileWhitelistConfigRequest
     *
     * @return CreateMaliciousFileWhitelistConfigResponse CreateMaliciousFileWhitelistConfigResponse
     */
    public function createMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds remarks to alert events for agentless detection.
     *  *
     * @param CreateMaliciousNoteRequest $request CreateMaliciousNoteRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMaliciousNoteResponse CreateMaliciousNoteResponse
     */
    public function createMaliciousNoteWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->note)) {
            $query['Note'] = $request->note;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateMaliciousNote',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateMaliciousNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds remarks to alert events for agentless detection.
     *  *
     * @param CreateMaliciousNoteRequest $request CreateMaliciousNoteRequest
     *
     * @return CreateMaliciousNoteResponse CreateMaliciousNoteResponse
     */
    public function createMaliciousNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMaliciousNoteWithOptions($request, $runtime);
    }

    /**
     * @summary 创建监视器帐户
     *  *
     * @param CreateMonitorAccountRequest $request CreateMonitorAccountRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMonitorAccountResponse CreateMonitorAccountResponse
     */
    public function createMonitorAccountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accountIds)) {
            $query['AccountIds'] = $request->accountIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateMonitorAccount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateMonitorAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 创建监视器帐户
     *  *
     * @param CreateMonitorAccountRequest $request CreateMonitorAccountRequest
     *
     * @return CreateMonitorAccountResponse CreateMonitorAccountResponse
     */
    public function createMonitorAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMonitorAccountWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
     *  *
     * @param CreateOpaClusterPluginRequest $request CreateOpaClusterPluginRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOpaClusterPluginResponse CreateOpaClusterPluginResponse
     */
    public function createOpaClusterPluginWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOpaClusterPlugin',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOpaClusterPluginResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
     *  *
     * @param CreateOpaClusterPluginRequest $request CreateOpaClusterPluginRequest
     *
     * @return CreateOpaClusterPluginResponse CreateOpaClusterPluginResponse
     */
    public function createOpaClusterPlugin($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOpaClusterPluginWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a rule to block at-risk images.
     *  *
     * @param CreateOpaStrategyNewRequest $tmpReq  CreateOpaStrategyNewRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOpaStrategyNewResponse CreateOpaStrategyNewResponse
     */
    public function createOpaStrategyNewWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateOpaStrategyNewShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->alarmDetail)) {
            $request->alarmDetailShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->alarmDetail, 'AlarmDetail', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->alarmDetailShrink)) {
            $query['AlarmDetail'] = $request->alarmDetailShrink;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->label)) {
            $query['Label'] = $request->label;
        }
        if (!Utils::isUnset($request->maliciousImage)) {
            $query['MaliciousImage'] = $request->maliciousImage;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->scopes)) {
            $query['Scopes'] = $request->scopes;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        if (!Utils::isUnset($request->strategyTemplateId)) {
            $query['StrategyTemplateId'] = $request->strategyTemplateId;
        }
        if (!Utils::isUnset($request->unScanedImage)) {
            $query['UnScanedImage'] = $request->unScanedImage;
        }
        if (!Utils::isUnset($request->whiteList)) {
            $query['WhiteList'] = $request->whiteList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOpaStrategyNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOpaStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a rule to block at-risk images.
     *  *
     * @param CreateOpaStrategyNewRequest $request CreateOpaStrategyNewRequest
     *
     * @return CreateOpaStrategyNewResponse CreateOpaStrategyNewResponse
     */
    public function createOpaStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOpaStrategyNewWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
     *  *
     * @description A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
     *  *
     * @param CreateOrUpdateAssetGroupRequest $request CreateOrUpdateAssetGroupRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOrUpdateAssetGroupResponse CreateOrUpdateAssetGroupResponse
     */
    public function createOrUpdateAssetGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->groupName)) {
            $query['GroupName'] = $request->groupName;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOrUpdateAssetGroup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOrUpdateAssetGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
     *  *
     * @description A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
     *  *
     * @param CreateOrUpdateAssetGroupRequest $request CreateOrUpdateAssetGroupRequest
     *
     * @return CreateOrUpdateAssetGroupResponse CreateOrUpdateAssetGroupResponse
     */
    public function createOrUpdateAssetGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOrUpdateAssetGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an asset auto-tagging rule or modifies an asset auto-tagging rule that is created on the Asset Management Rule tab.
     *  *
     * @param CreateOrUpdateAutoTagRuleRequest $request CreateOrUpdateAutoTagRuleRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOrUpdateAutoTagRuleResponse CreateOrUpdateAutoTagRuleResponse
     */
    public function createOrUpdateAutoTagRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkAll)) {
            $query['CheckAll'] = $request->checkAll;
        }
        if (!Utils::isUnset($request->expression)) {
            $query['Expression'] = $request->expression;
        }
        if (!Utils::isUnset($request->ruleDesc)) {
            $query['RuleDesc'] = $request->ruleDesc;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->tagContext)) {
            $query['TagContext'] = $request->tagContext;
        }
        if (!Utils::isUnset($request->tagType)) {
            $query['TagType'] = $request->tagType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOrUpdateAutoTagRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOrUpdateAutoTagRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an asset auto-tagging rule or modifies an asset auto-tagging rule that is created on the Asset Management Rule tab.
     *  *
     * @param CreateOrUpdateAutoTagRuleRequest $request CreateOrUpdateAutoTagRuleRequest
     *
     * @return CreateOrUpdateAutoTagRuleResponse CreateOrUpdateAutoTagRuleResponse
     */
    public function createOrUpdateAutoTagRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOrUpdateAutoTagRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates or modifies a DingTalk chatbot that sends notifications.
     *  *
     * @param CreateOrUpdateDingTalkRequest $request CreateOrUpdateDingTalkRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOrUpdateDingTalkResponse CreateOrUpdateDingTalkResponse
     */
    public function createOrUpdateDingTalkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configList)) {
            $query['ConfigList'] = $request->configList;
        }
        if (!Utils::isUnset($request->dingTalkLang)) {
            $query['DingTalkLang'] = $request->dingTalkLang;
        }
        if (!Utils::isUnset($request->groupIdList)) {
            $query['GroupIdList'] = $request->groupIdList;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->intervalTime)) {
            $query['IntervalTime'] = $request->intervalTime;
        }
        if (!Utils::isUnset($request->ruleActionName)) {
            $query['RuleActionName'] = $request->ruleActionName;
        }
        if (!Utils::isUnset($request->sendUrl)) {
            $query['SendUrl'] = $request->sendUrl;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOrUpdateDingTalk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOrUpdateDingTalkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates or modifies a DingTalk chatbot that sends notifications.
     *  *
     * @param CreateOrUpdateDingTalkRequest $request CreateOrUpdateDingTalkRequest
     *
     * @return CreateOrUpdateDingTalkResponse CreateOrUpdateDingTalkResponse
     */
    public function createOrUpdateDingTalk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOrUpdateDingTalkWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a bucket check task.
     *  *
     * @param CreateOssBucketScanTaskRequest $request CreateOssBucketScanTaskRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOssBucketScanTaskResponse CreateOssBucketScanTaskResponse
     */
    public function createOssBucketScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allKeyPrefix)) {
            $query['AllKeyPrefix'] = $request->allKeyPrefix;
        }
        if (!Utils::isUnset($request->bucketNameList)) {
            $query['BucketNameList'] = $request->bucketNameList;
        }
        if (!Utils::isUnset($request->decompressMaxFileCount)) {
            $query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }
        if (!Utils::isUnset($request->decompressMaxLayer)) {
            $query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }
        if (!Utils::isUnset($request->decryptionList)) {
            $query['DecryptionList'] = $request->decryptionList;
        }
        if (!Utils::isUnset($request->excludeKeySuffixList)) {
            $query['ExcludeKeySuffixList'] = $request->excludeKeySuffixList;
        }
        if (!Utils::isUnset($request->keyPrefixList)) {
            $query['KeyPrefixList'] = $request->keyPrefixList;
        }
        if (!Utils::isUnset($request->keySuffixList)) {
            $query['KeySuffixList'] = $request->keySuffixList;
        }
        if (!Utils::isUnset($request->lastModifiedStartTime)) {
            $query['LastModifiedStartTime'] = $request->lastModifiedStartTime;
        }
        if (!Utils::isUnset($request->scanMode)) {
            $query['ScanMode'] = $request->scanMode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOssBucketScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOssBucketScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a bucket check task.
     *  *
     * @param CreateOssBucketScanTaskRequest $request CreateOssBucketScanTaskRequest
     *
     * @return CreateOssBucketScanTaskResponse CreateOssBucketScanTaskResponse
     */
    public function createOssBucketScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOssBucketScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a scan policy.
     *  *
     * @param CreateOssScanConfigRequest $request CreateOssScanConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOssScanConfigResponse CreateOssScanConfigResponse
     */
    public function createOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allKeyPrefix)) {
            $query['AllKeyPrefix'] = $request->allKeyPrefix;
        }
        if (!Utils::isUnset($request->bucketNameList)) {
            $query['BucketNameList'] = $request->bucketNameList;
        }
        if (!Utils::isUnset($request->decompressMaxFileCount)) {
            $query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }
        if (!Utils::isUnset($request->decompressMaxLayer)) {
            $query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }
        if (!Utils::isUnset($request->decryptionList)) {
            $query['DecryptionList'] = $request->decryptionList;
        }
        if (!Utils::isUnset($request->enable)) {
            $query['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->keyPrefixList)) {
            $query['KeyPrefixList'] = $request->keyPrefixList;
        }
        if (!Utils::isUnset($request->keySuffixList)) {
            $query['KeySuffixList'] = $request->keySuffixList;
        }
        if (!Utils::isUnset($request->lastModifiedStartTime)) {
            $query['LastModifiedStartTime'] = $request->lastModifiedStartTime;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->scanDayList)) {
            $query['ScanDayList'] = $request->scanDayList;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a scan policy.
     *  *
     * @param CreateOssScanConfigRequest $request CreateOssScanConfigRequest
     *
     * @return CreateOssScanConfigResponse CreateOssScanConfigResponse
     */
    public function createOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary 新增修改目录节点同步开关
     *  *
     * @param CreateRdDefaultSyncListRequest $request CreateRdDefaultSyncListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRdDefaultSyncListResponse CreateRdDefaultSyncListResponse
     */
    public function createRdDefaultSyncListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->folderIds)) {
            $query['FolderIds'] = $request->folderIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateRdDefaultSyncList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateRdDefaultSyncListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 新增修改目录节点同步开关
     *  *
     * @param CreateRdDefaultSyncListRequest $request CreateRdDefaultSyncListRequest
     *
     * @return CreateRdDefaultSyncListResponse CreateRdDefaultSyncListResponse
     */
    public function createRdDefaultSyncList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRdDefaultSyncListWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a restoration task.
     *  *
     * @param CreateRestoreJobRequest $request CreateRestoreJobRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRestoreJobResponse CreateRestoreJobResponse
     */
    public function createRestoreJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->includes)) {
            $query['Includes'] = $request->includes;
        }
        if (!Utils::isUnset($request->snapshotHash)) {
            $query['SnapshotHash'] = $request->snapshotHash;
        }
        if (!Utils::isUnset($request->snapshotId)) {
            $query['SnapshotId'] = $request->snapshotId;
        }
        if (!Utils::isUnset($request->snapshotVersion)) {
            $query['SnapshotVersion'] = $request->snapshotVersion;
        }
        if (!Utils::isUnset($request->sourceType)) {
            $query['SourceType'] = $request->sourceType;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->vaultId)) {
            $query['VaultId'] = $request->vaultId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateRestoreJob',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateRestoreJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a restoration task.
     *  *
     * @param CreateRestoreJobRequest $request CreateRestoreJobRequest
     *
     * @return CreateRestoreJobResponse CreateRestoreJobResponse
     */
    public function createRestoreJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRestoreJobWithOptions($request, $runtime);
    }

    /**
     * @summary Applies for a trial of Security Center.
     *  *
     * @param CreateSasTrialRequest $tmpReq  CreateSasTrialRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateSasTrialResponse CreateSasTrialResponse
     */
    public function createSasTrialWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateSasTrialShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->requestForm)) {
            $request->requestFormShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->requestForm, 'RequestForm', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->fromEcs)) {
            $body['FromEcs'] = $request->fromEcs;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->requestFormShrink)) {
            $body['RequestForm'] = $request->requestFormShrink;
        }
        if (!Utils::isUnset($request->tryType)) {
            $body['TryType'] = $request->tryType;
        }
        if (!Utils::isUnset($request->tryVersion)) {
            $body['TryVersion'] = $request->tryVersion;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateSasTrial',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateSasTrialResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Applies for a trial of Security Center.
     *  *
     * @param CreateSasTrialRequest $request CreateSasTrialRequest
     *
     * @return CreateSasTrialResponse CreateSasTrialResponse
     */
    public function createSasTrial($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSasTrialWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a service-linked role and authorizes Security Center to access cloud resources.
     *  *
     * @description For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
     *  *
     * @param CreateServiceLinkedRoleRequest $request CreateServiceLinkedRoleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateServiceLinkedRoleResponse CreateServiceLinkedRoleResponse
     */
    public function createServiceLinkedRoleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->serviceLinkedRole)) {
            $query['ServiceLinkedRole'] = $request->serviceLinkedRole;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateServiceLinkedRole',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateServiceLinkedRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a service-linked role and authorizes Security Center to access cloud resources.
     *  *
     * @description For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
     *  *
     * @param CreateServiceLinkedRoleRequest $request CreateServiceLinkedRoleRequest
     *
     * @return CreateServiceLinkedRoleResponse CreateServiceLinkedRoleResponse
     */
    public function createServiceLinkedRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createServiceLinkedRoleWithOptions($request, $runtime);
    }

    /**
     * @summary Create a service trail.
     *  *
     * @param CreateServiceTrailRequest $request CreateServiceTrailRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateServiceTrailResponse CreateServiceTrailResponse
     */
    public function createServiceTrailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateServiceTrail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateServiceTrailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Create a service trail.
     *  *
     * @param CreateServiceTrailRequest $request CreateServiceTrailRequest
     *
     * @return CreateServiceTrailResponse CreateServiceTrailResponse
     */
    public function createServiceTrail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createServiceTrailWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a task to query alert events that are triggered by the same rule or of the same alert type.
     *  *
     * @param CreateSimilarSecurityEventsQueryTaskRequest $request CreateSimilarSecurityEventsQueryTaskRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateSimilarSecurityEventsQueryTaskResponse CreateSimilarSecurityEventsQueryTaskResponse
     */
    public function createSimilarSecurityEventsQueryTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityEventId)) {
            $query['SecurityEventId'] = $request->securityEventId;
        }
        if (!Utils::isUnset($request->similarEventScenarioCode)) {
            $query['SimilarEventScenarioCode'] = $request->similarEventScenarioCode;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateSimilarSecurityEventsQueryTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateSimilarSecurityEventsQueryTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a task to query alert events that are triggered by the same rule or of the same alert type.
     *  *
     * @param CreateSimilarSecurityEventsQueryTaskRequest $request CreateSimilarSecurityEventsQueryTaskRequest
     *
     * @return CreateSimilarSecurityEventsQueryTaskResponse CreateSimilarSecurityEventsQueryTaskResponse
     */
    public function createSimilarSecurityEventsQueryTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSimilarSecurityEventsQueryTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a task on the My Policies tab of the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param CreateSoarStrategyTaskRequest $request CreateSoarStrategyTaskRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateSoarStrategyTaskResponse CreateSoarStrategyTaskResponse
     */
    public function createSoarStrategyTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        if (!Utils::isUnset($request->strategyTaskName)) {
            $query['StrategyTaskName'] = $request->strategyTaskName;
        }
        if (!Utils::isUnset($request->strategyTaskParams)) {
            $query['StrategyTaskParams'] = $request->strategyTaskParams;
        }
        if (!Utils::isUnset($request->strategyTaskPlanExeTime)) {
            $query['StrategyTaskPlanExeTime'] = $request->strategyTaskPlanExeTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateSoarStrategyTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateSoarStrategyTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a task on the My Policies tab of the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param CreateSoarStrategyTaskRequest $request CreateSoarStrategyTaskRequest
     *
     * @return CreateSoarStrategyTaskResponse CreateSoarStrategyTaskResponse
     */
    public function createSoarStrategyTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSoarStrategyTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Adds remarks to an alert event.
     *  *
     * @param CreateSuspEventNoteRequest $request CreateSuspEventNoteRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateSuspEventNoteResponse CreateSuspEventNoteResponse
     */
    public function createSuspEventNoteWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->note)) {
            $query['Note'] = $request->note;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateSuspEventNote',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateSuspEventNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds remarks to an alert event.
     *  *
     * @param CreateSuspEventNoteRequest $request CreateSuspEventNoteRequest
     *
     * @return CreateSuspEventNoteResponse CreateSuspEventNoteResponse
     */
    public function createSuspEventNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSuspEventNoteWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an anti-ransomware policy for a database.
     *  *
     * @param CreateUniBackupPolicyRequest $tmpReq  CreateUniBackupPolicyRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateUniBackupPolicyResponse CreateUniBackupPolicyResponse
     */
    public function createUniBackupPolicyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateUniBackupPolicyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->fullPlan)) {
            $request->fullPlanShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->fullPlan, 'FullPlan', 'json');
        }
        if (!Utils::isUnset($tmpReq->incPlan)) {
            $request->incPlanShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->incPlan, 'IncPlan', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->accountName)) {
            $query['AccountName'] = $request->accountName;
        }
        if (!Utils::isUnset($request->accountPassword)) {
            $query['AccountPassword'] = $request->accountPassword;
        }
        if (!Utils::isUnset($request->databaseAddByUser)) {
            $query['DatabaseAddByUser'] = $request->databaseAddByUser;
        }
        if (!Utils::isUnset($request->databaseType)) {
            $query['DatabaseType'] = $request->databaseType;
        }
        if (!Utils::isUnset($request->fullPlanShrink)) {
            $query['FullPlan'] = $request->fullPlanShrink;
        }
        if (!Utils::isUnset($request->incPlanShrink)) {
            $query['IncPlan'] = $request->incPlanShrink;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->policyName)) {
            $query['PolicyName'] = $request->policyName;
        }
        if (!Utils::isUnset($request->retention)) {
            $query['Retention'] = $request->retention;
        }
        if (!Utils::isUnset($request->speedLimiter)) {
            $query['SpeedLimiter'] = $request->speedLimiter;
        }
        if (!Utils::isUnset($request->uniRegionId)) {
            $query['UniRegionId'] = $request->uniRegionId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateUniBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateUniBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an anti-ransomware policy for a database.
     *  *
     * @param CreateUniBackupPolicyRequest $request CreateUniBackupPolicyRequest
     *
     * @return CreateUniBackupPolicyResponse CreateUniBackupPolicyResponse
     */
    public function createUniBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUniBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a restoration task for a database.
     *  *
     * @param CreateUniRestorePlanRequest $request CreateUniRestorePlanRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateUniRestorePlanResponse CreateUniRestorePlanResponse
     */
    public function createUniRestorePlanWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->database)) {
            $query['Database'] = $request->database;
        }
        if (!Utils::isUnset($request->instanceUuid)) {
            $query['InstanceUuid'] = $request->instanceUuid;
        }
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->resetScn)) {
            $query['ResetScn'] = $request->resetScn;
        }
        if (!Utils::isUnset($request->resetTime)) {
            $query['ResetTime'] = $request->resetTime;
        }
        if (!Utils::isUnset($request->restoreInfo)) {
            $query['RestoreInfo'] = $request->restoreInfo;
        }
        if (!Utils::isUnset($request->timePoint)) {
            $query['TimePoint'] = $request->timePoint;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateUniRestorePlan',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateUniRestorePlanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a restoration task for a database.
     *  *
     * @param CreateUniRestorePlanRequest $request CreateUniRestorePlanRequest
     *
     * @return CreateUniRestorePlanResponse CreateUniRestorePlanResponse
     */
    public function createUniRestorePlan($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUniRestorePlanWithOptions($request, $runtime);
    }

    /**
     * @summary Creates the risk level settings for baseline check items.
     *  *
     * @param CreateUserSettingRequest $request CreateUserSettingRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateUserSettingResponse CreateUserSettingResponse
     */
    public function createUserSettingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alertLevels)) {
            $query['AlertLevels'] = $request->alertLevels;
        }
        if (!Utils::isUnset($request->invalidWarningKeepDays)) {
            $query['InvalidWarningKeepDays'] = $request->invalidWarningKeepDays;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateUserSetting',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates the risk level settings for baseline check items.
     *  *
     * @param CreateUserSettingRequest $request CreateUserSettingRequest
     *
     * @return CreateUserSettingResponse CreateUserSettingResponse
     */
    public function createUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUserSettingWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a one-time virus scan task that is immediately executed.
     *  *
     * @param CreateVirusScanOnceTaskRequest $request CreateVirusScanOnceTaskRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVirusScanOnceTaskResponse CreateVirusScanOnceTaskResponse
     */
    public function createVirusScanOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->scanPath)) {
            $query['ScanPath'] = $request->scanPath;
        }
        if (!Utils::isUnset($request->scanType)) {
            $query['ScanType'] = $request->scanType;
        }
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVirusScanOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVirusScanOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a one-time virus scan task that is immediately executed.
     *  *
     * @param CreateVirusScanOnceTaskRequest $request CreateVirusScanOnceTaskRequest
     *
     * @return CreateVirusScanOnceTaskResponse CreateVirusScanOnceTaskResponse
     */
    public function createVirusScanOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVirusScanOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
     *  *
     * @param CreateVulAutoRepairConfigRequest $request CreateVulAutoRepairConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVulAutoRepairConfigResponse CreateVulAutoRepairConfigResponse
     */
    public function createVulAutoRepairConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->vulAutoRepairConfigList)) {
            $query['VulAutoRepairConfigList'] = $request->vulAutoRepairConfigList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVulAutoRepairConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVulAutoRepairConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
     *  *
     * @param CreateVulAutoRepairConfigRequest $request CreateVulAutoRepairConfigRequest
     *
     * @return CreateVulAutoRepairConfigResponse CreateVulAutoRepairConfigResponse
     */
    public function createVulAutoRepairConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVulAutoRepairConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the specified defense rules against brute-force attacks.
     *  *
     * @param DeleteAntiBruteForceRuleRequest $request DeleteAntiBruteForceRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteAntiBruteForceRuleResponse DeleteAntiBruteForceRuleResponse
     */
    public function deleteAntiBruteForceRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteAntiBruteForceRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the specified defense rules against brute-force attacks.
     *  *
     * @param DeleteAntiBruteForceRuleRequest $request DeleteAntiBruteForceRuleRequest
     *
     * @return DeleteAntiBruteForceRuleResponse DeleteAntiBruteForceRuleResponse
     */
    public function deleteAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a witness.
     *  *
     * @param DeleteAttestorRequest $request DeleteAttestorRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteAttestorResponse DeleteAttestorResponse
     */
    public function deleteAttestorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteAttestor',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteAttestorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a witness.
     *  *
     * @param DeleteAttestorRequest $request DeleteAttestorRequest
     *
     * @return DeleteAttestorResponse DeleteAttestorResponse
     */
    public function deleteAttestor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAttestorWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
     *  *
     * @param DeleteAutoTagRulesRequest $request DeleteAutoTagRulesRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteAutoTagRulesResponse DeleteAutoTagRulesResponse
     */
    public function deleteAutoTagRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleIdList)) {
            $query['RuleIdList'] = $request->ruleIdList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteAutoTagRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteAutoTagRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
     *  *
     * @param DeleteAutoTagRulesRequest $request DeleteAutoTagRulesRequest
     *
     * @return DeleteAutoTagRulesResponse DeleteAutoTagRulesResponse
     */
    public function deleteAutoTagRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAutoTagRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an anti-ransomware policy.
     *  *
     * @param DeleteBackupPolicyRequest $request DeleteBackupPolicyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBackupPolicyResponse DeleteBackupPolicyResponse
     */
    public function deleteBackupPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an anti-ransomware policy.
     *  *
     * @param DeleteBackupPolicyRequest $request DeleteBackupPolicyRequest
     *
     * @return DeleteBackupPolicyResponse DeleteBackupPolicyResponse
     */
    public function deleteBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
     *  *
     * @param DeleteBackupPolicyMachineRequest $request DeleteBackupPolicyMachineRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBackupPolicyMachineResponse DeleteBackupPolicyMachineResponse
     */
    public function deleteBackupPolicyMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBackupPolicyMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBackupPolicyMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
     *  *
     * @param DeleteBackupPolicyMachineRequest $request DeleteBackupPolicyMachineRequest
     *
     * @return DeleteBackupPolicyMachineResponse DeleteBackupPolicyMachineResponse
     */
    public function deleteBackupPolicyMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupPolicyMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a backup snapshot that is created for anti-ransomware.
     *  *
     * @param DeleteBackupSnapshotRequest $request DeleteBackupSnapshotRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBackupSnapshotResponse DeleteBackupSnapshotResponse
     */
    public function deleteBackupSnapshotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->backupRegionIdList)) {
            $query['BackupRegionIdList'] = $request->backupRegionIdList;
        }
        if (!Utils::isUnset($request->backupSnapshotList)) {
            $query['BackupSnapshotList'] = $request->backupSnapshotList;
        }
        if (!Utils::isUnset($request->retainLatestSnapshot)) {
            $query['RetainLatestSnapshot'] = $request->retainLatestSnapshot;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBackupSnapshot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBackupSnapshotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a backup snapshot that is created for anti-ransomware.
     *  *
     * @param DeleteBackupSnapshotRequest $request DeleteBackupSnapshotRequest
     *
     * @return DeleteBackupSnapshotResponse DeleteBackupSnapshotResponse
     */
    public function deleteBackupSnapshot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupSnapshotWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the whitelist record for a baseline check item.
     *  *
     * @param DeleteBaselineCheckWhiteRecordRequest $request DeleteBaselineCheckWhiteRecordRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBaselineCheckWhiteRecordResponse DeleteBaselineCheckWhiteRecordResponse
     */
    public function deleteBaselineCheckWhiteRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->recordIds)) {
            $query['RecordIds'] = $request->recordIds;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBaselineCheckWhiteRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBaselineCheckWhiteRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the whitelist record for a baseline check item.
     *  *
     * @param DeleteBaselineCheckWhiteRecordRequest $request DeleteBaselineCheckWhiteRecordRequest
     *
     * @return DeleteBaselineCheckWhiteRecordResponse DeleteBaselineCheckWhiteRecordResponse
     */
    public function deleteBaselineCheckWhiteRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBaselineCheckWhiteRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a binary security policy from the container signature feature.
     *  *
     * @param DeleteBinarySecurityPolicyRequest $request DeleteBinarySecurityPolicyRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBinarySecurityPolicyResponse DeleteBinarySecurityPolicyResponse
     */
    public function deleteBinarySecurityPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBinarySecurityPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBinarySecurityPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a binary security policy from the container signature feature.
     *  *
     * @param DeleteBinarySecurityPolicyRequest $request DeleteBinarySecurityPolicyRequest
     *
     * @return DeleteBinarySecurityPolicyResponse DeleteBinarySecurityPolicyResponse
     */
    public function deleteBinarySecurityPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBinarySecurityPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes specified custom defense rules.
     *  *
     * @param DeleteClientUserDefineRuleRequest $request DeleteClientUserDefineRuleRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteClientUserDefineRuleResponse DeleteClientUserDefineRuleResponse
     */
    public function deleteClientUserDefineRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->idList)) {
            $query['IdList'] = $request->idList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteClientUserDefineRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes specified custom defense rules.
     *  *
     * @param DeleteClientUserDefineRuleRequest $request DeleteClientUserDefineRuleRequest
     *
     * @return DeleteClientUserDefineRuleResponse DeleteClientUserDefineRuleResponse
     */
    public function deleteClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * @summary 删除多云资产同步配置
     *  *
     * @param DeleteCloudVendorAccountAKRequest $request DeleteCloudVendorAccountAKRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCloudVendorAccountAKResponse DeleteCloudVendorAccountAKResponse
     */
    public function deleteCloudVendorAccountAKWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->authId)) {
            $query['AuthId'] = $request->authId;
        }
        if (!Utils::isUnset($request->authModules)) {
            $query['AuthModules'] = $request->authModules;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteCloudVendorAccountAK',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteCloudVendorAccountAKResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 删除多云资产同步配置
     *  *
     * @param DeleteCloudVendorAccountAKRequest $request DeleteCloudVendorAccountAKRequest
     *
     * @return DeleteCloudVendorAccountAKResponse DeleteCloudVendorAccountAKResponse
     */
    public function deleteCloudVendorAccountAK($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCloudVendorAccountAKWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a rule for non-image program defense.
     *  *
     * @param DeleteContainerDefenseRuleRequest $request DeleteContainerDefenseRuleRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteContainerDefenseRuleResponse DeleteContainerDefenseRuleResponse
     */
    public function deleteContainerDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleIds)) {
            $query['RuleIds'] = $request->ruleIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteContainerDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a rule for non-image program defense.
     *  *
     * @param DeleteContainerDefenseRuleRequest $request DeleteContainerDefenseRuleRequest
     *
     * @return DeleteContainerDefenseRuleResponse DeleteContainerDefenseRuleResponse
     */
    public function deleteContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a defense rule against container escapes.
     *  *
     * @param DeleteContainerPluginRuleRequest $request DeleteContainerPluginRuleRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteContainerPluginRuleResponse DeleteContainerPluginRuleResponse
     */
    public function deleteContainerPluginRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteContainerPluginRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a defense rule against container escapes.
     *  *
     * @param DeleteContainerPluginRuleRequest $request DeleteContainerPluginRuleRequest
     *
     * @return DeleteContainerPluginRuleResponse DeleteContainerPluginRuleResponse
     */
    public function deleteContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified IP address blocking policy from one or more servers.
     *  *
     * @param DeleteCustomBlockRecordRequest $request DeleteCustomBlockRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCustomBlockRecordResponse DeleteCustomBlockRecordResponse
     */
    public function deleteCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified IP address blocking policy from one or more servers.
     *  *
     * @param DeleteCustomBlockRecordRequest $request DeleteCustomBlockRecordRequest
     *
     * @return DeleteCustomBlockRecordResponse DeleteCustomBlockRecordResponse
     */
    public function deleteCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a custom security report.
     *  *
     * @param DeleteCustomizeReportRequest $request DeleteCustomizeReportRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCustomizeReportResponse DeleteCustomizeReportResponse
     */
    public function deleteCustomizeReportWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteCustomizeReport',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteCustomizeReportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a custom security report.
     *  *
     * @param DeleteCustomizeReportRequest $request DeleteCustomizeReportRequest
     *
     * @return DeleteCustomizeReportResponse DeleteCustomizeReportResponse
     */
    public function deleteCustomizeReport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomizeReportWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the file that is uploaded to create custom weak password rules.
     *  *
     * @param DeleteCustomizedDictRequest $request DeleteCustomizedDictRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCustomizedDictResponse DeleteCustomizedDictResponse
     */
    public function deleteCustomizedDictWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteCustomizedDict',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteCustomizedDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the file that is uploaded to create custom weak password rules.
     *  *
     * @param DeleteCustomizedDictRequest $request DeleteCustomizedDictRequest
     *
     * @return DeleteCustomizedDictResponse DeleteCustomizedDictResponse
     */
    public function deleteCustomizedDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomizedDictWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *  *
     * @param DeleteCycleTaskRequest $request DeleteCycleTaskRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCycleTaskResponse DeleteCycleTaskResponse
     */
    public function deleteCycleTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteCycleTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteCycleTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *  *
     * @param DeleteCycleTaskRequest $request DeleteCycleTaskRequest
     *
     * @return DeleteCycleTaskResponse DeleteCycleTaskResponse
     */
    public function deleteCycleTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCycleTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a DingTalk chatbot on the DingTalk Chatbot tab of the Notification Settings page.
     *  *
     * @param DeleteDingTalkRequest $request DeleteDingTalkRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDingTalkResponse DeleteDingTalkResponse
     */
    public function deleteDingTalkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteDingTalk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDingTalkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a DingTalk chatbot on the DingTalk Chatbot tab of the Notification Settings page.
     *  *
     * @param DeleteDingTalkRequest $request DeleteDingTalkRequest
     *
     * @return DeleteDingTalkResponse DeleteDingTalkResponse
     */
    public function deleteDingTalk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDingTalkWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes core file monitoring rules.
     *  *
     * @param DeleteFileProtectRuleRequest $request DeleteFileProtectRuleRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFileProtectRuleResponse DeleteFileProtectRuleResponse
     */
    public function deleteFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes core file monitoring rules.
     *  *
     * @param DeleteFileProtectRuleRequest $request DeleteFileProtectRuleRequest
     *
     * @return DeleteFileProtectRuleResponse DeleteFileProtectRuleResponse
     */
    public function deleteFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a server group.
     *  *
     * @description The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
     *  *
     * @param DeleteGroupRequest $request DeleteGroupRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteGroupResponse DeleteGroupResponse
     */
    public function deleteGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteGroup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a server group.
     *  *
     * @description The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
     *  *
     * @param DeleteGroupRequest $request DeleteGroupRequest
     *
     * @return DeleteGroupResponse DeleteGroupResponse
     */
    public function deleteGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified honeypot.
     *  *
     * @param DeleteHoneypotRequest $request DeleteHoneypotRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotResponse DeleteHoneypotResponse
     */
    public function deleteHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified honeypot.
     *  *
     * @param DeleteHoneypotRequest $request DeleteHoneypotRequest
     *
     * @return DeleteHoneypotResponse DeleteHoneypotResponse
     */
    public function deleteHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified management node.
     *  *
     * @param DeleteHoneypotNodeRequest $request DeleteHoneypotNodeRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotNodeResponse DeleteHoneypotNodeResponse
     */
    public function deleteHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified management node.
     *  *
     * @param DeleteHoneypotNodeRequest $request DeleteHoneypotNodeRequest
     *
     * @return DeleteHoneypotNodeResponse DeleteHoneypotNodeResponse
     */
    public function deleteHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified honeypot template.
     *  *
     * @param DeleteHoneypotPresetRequest $request DeleteHoneypotPresetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotPresetResponse DeleteHoneypotPresetResponse
     */
    public function deleteHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotPresetId)) {
            $query['HoneypotPresetId'] = $request->honeypotPresetId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified honeypot template.
     *  *
     * @param DeleteHoneypotPresetRequest $request DeleteHoneypotPresetRequest
     *
     * @return DeleteHoneypotPresetResponse DeleteHoneypotPresetResponse
     */
    public function deleteHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified probe.
     *  *
     * @param DeleteHoneypotProbeRequest $request DeleteHoneypotProbeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotProbeResponse DeleteHoneypotProbeResponse
     */
    public function deleteHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified probe.
     *  *
     * @param DeleteHoneypotProbeRequest $request DeleteHoneypotProbeRequest
     *
     * @return DeleteHoneypotProbeResponse DeleteHoneypotProbeResponse
     */
    public function deleteHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary Delete the probe service.
     *  *
     * @param DeleteHoneypotProbeBindRequest $request DeleteHoneypotProbeBindRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotProbeBindResponse DeleteHoneypotProbeBindResponse
     */
    public function deleteHoneypotProbeBindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bindId)) {
            $query['BindId'] = $request->bindId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypotProbeBind',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotProbeBindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Delete the probe service.
     *  *
     * @param DeleteHoneypotProbeBindRequest $request DeleteHoneypotProbeBindRequest
     *
     * @return DeleteHoneypotProbeBindResponse DeleteHoneypotProbeBindResponse
     */
    public function deleteHoneypotProbeBind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotProbeBindWithOptions($request, $runtime);
    }

    /**
     * @summary 删除代理
     *  *
     * @param DeleteHybridProxyRequest $request DeleteHybridProxyRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHybridProxyResponse DeleteHybridProxyResponse
     */
    public function deleteHybridProxyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHybridProxy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 删除代理
     *  *
     * @param DeleteHybridProxyRequest $request DeleteHybridProxyRequest
     *
     * @return DeleteHybridProxyResponse DeleteHybridProxyResponse
     */
    public function deleteHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHybridProxyWithOptions($request, $runtime);
    }

    /**
     * @summary 删除代理集群
     *  *
     * @param DeleteHybridProxyClusterRequest $request DeleteHybridProxyClusterRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHybridProxyClusterResponse DeleteHybridProxyClusterResponse
     */
    public function deleteHybridProxyClusterWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHybridProxyCluster',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHybridProxyClusterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 删除代理集群
     *  *
     * @param DeleteHybridProxyClusterRequest $request DeleteHybridProxyClusterRequest
     *
     * @return DeleteHybridProxyClusterResponse DeleteHybridProxyClusterResponse
     */
    public function deleteHybridProxyCluster($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHybridProxyClusterWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an IDC probe that is created in Security Center.
     *  *
     * @param DeleteIdcProbeRequest $request DeleteIdcProbeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteIdcProbeResponse DeleteIdcProbeResponse
     */
    public function deleteIdcProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteIdcProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteIdcProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an IDC probe that is created in Security Center.
     *  *
     * @param DeleteIdcProbeRequest $request DeleteIdcProbeRequest
     *
     * @return DeleteIdcProbeResponse DeleteIdcProbeResponse
     */
    public function deleteIdcProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIdcProbeWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an alert handling rule.
     *  *
     * @param DeleteImageEventOperationRequest $request DeleteImageEventOperationRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteImageEventOperationResponse DeleteImageEventOperationResponse
     */
    public function deleteImageEventOperationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteImageEventOperation',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an alert handling rule.
     *  *
     * @param DeleteImageEventOperationRequest $request DeleteImageEventOperationRequest
     *
     * @return DeleteImageEventOperationResponse DeleteImageEventOperationResponse
     */
    public function deleteImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an image vulnerability whitelist.
     *  *
     * @param DeleteImageVulWhitelistRequest $request DeleteImageVulWhitelistRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteImageVulWhitelistResponse DeleteImageVulWhitelistResponse
     */
    public function deleteImageVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteImageVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteImageVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an image vulnerability whitelist.
     *  *
     * @param DeleteImageVulWhitelistRequest $request DeleteImageVulWhitelistRequest
     *
     * @return DeleteImageVulWhitelistResponse DeleteImageVulWhitelistResponse
     */
    public function deleteImageVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteImageVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the command that is used to install the Security Center agent.
     *  *
     * @param DeleteInstallCodeRequest $request DeleteInstallCodeRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteInstallCodeResponse DeleteInstallCodeResponse
     */
    public function deleteInstallCodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->captchaCode)) {
            $query['CaptchaCode'] = $request->captchaCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteInstallCode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the command that is used to install the Security Center agent.
     *  *
     * @param DeleteInstallCodeRequest $request DeleteInstallCodeRequest
     *
     * @return DeleteInstallCodeResponse DeleteInstallCodeResponse
     */
    public function deleteInstallCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteInstallCodeWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a defense rule in the container firewall module.
     *  *
     * @param DeleteInterceptionRuleRequest $request DeleteInterceptionRuleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteInterceptionRuleResponse DeleteInterceptionRuleResponse
     */
    public function deleteInterceptionRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->ruleIds)) {
            $query['RuleIds'] = $request->ruleIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteInterceptionRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteInterceptionRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a defense rule in the container firewall module.
     *  *
     * @param DeleteInterceptionRuleRequest $request DeleteInterceptionRuleRequest
     *
     * @return DeleteInterceptionRuleResponse DeleteInterceptionRuleResponse
     */
    public function deleteInterceptionRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteInterceptionRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Removes the network objects that are in effect in the container firewall.
     *  *
     * @param DeleteInterceptionTargetRequest $request DeleteInterceptionTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteInterceptionTargetResponse DeleteInterceptionTargetResponse
     */
    public function deleteInterceptionTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->targetIds)) {
            $query['TargetIds'] = $request->targetIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteInterceptionTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteInterceptionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes the network objects that are in effect in the container firewall.
     *  *
     * @param DeleteInterceptionTargetRequest $request DeleteInterceptionTargetRequest
     *
     * @return DeleteInterceptionTargetResponse DeleteInterceptionTargetResponse
     */
    public function deleteInterceptionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteInterceptionTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the Kubernetes access information.
     *  *
     * @param DeleteK8sAccessInfoRequest $request DeleteK8sAccessInfoRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteK8sAccessInfoResponse DeleteK8sAccessInfoResponse
     */
    public function deleteK8sAccessInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliyunYundunGatewayApiName)) {
            $query['AliyunYundunGatewayApiName'] = $request->aliyunYundunGatewayApiName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayPopName)) {
            $query['AliyunYundunGatewayPopName'] = $request->aliyunYundunGatewayPopName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayProjectName)) {
            $query['AliyunYundunGatewayProjectName'] = $request->aliyunYundunGatewayProjectName;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteK8sAccessInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteK8sAccessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the Kubernetes access information.
     *  *
     * @param DeleteK8sAccessInfoRequest $request DeleteK8sAccessInfoRequest
     *
     * @return DeleteK8sAccessInfoResponse DeleteK8sAccessInfoResponse
     */
    public function deleteK8sAccessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteK8sAccessInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the basic configuration information from the logon security configurations for a specific asset.
     *  *
     * @param DeleteLoginBaseConfigRequest $request DeleteLoginBaseConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLoginBaseConfigResponse DeleteLoginBaseConfigResponse
     */
    public function deleteLoginBaseConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteLoginBaseConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteLoginBaseConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the basic configuration information from the logon security configurations for a specific asset.
     *  *
     * @param DeleteLoginBaseConfigRequest $request DeleteLoginBaseConfigRequest
     *
     * @return DeleteLoginBaseConfigResponse DeleteLoginBaseConfigResponse
     */
    public function deleteLoginBaseConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLoginBaseConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param DeleteMaliciousFileWhitelistConfigRequest $request DeleteMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMaliciousFileWhitelistConfigResponse DeleteMaliciousFileWhitelistConfigResponse
     */
    public function deleteMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param DeleteMaliciousFileWhitelistConfigRequest $request DeleteMaliciousFileWhitelistConfigRequest
     *
     * @return DeleteMaliciousFileWhitelistConfigResponse DeleteMaliciousFileWhitelistConfigResponse
     */
    public function deleteMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Removes the remarks added to alert events that are generated by the agentless detection feature.
     *  *
     * @param DeleteMaliciousNoteRequest $request DeleteMaliciousNoteRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMaliciousNoteResponse DeleteMaliciousNoteResponse
     */
    public function deleteMaliciousNoteWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->noteId)) {
            $query['NoteId'] = $request->noteId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMaliciousNote',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMaliciousNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes the remarks added to alert events that are generated by the agentless detection feature.
     *  *
     * @param DeleteMaliciousNoteRequest $request DeleteMaliciousNoteRequest
     *
     * @return DeleteMaliciousNoteResponse DeleteMaliciousNoteResponse
     */
    public function deleteMaliciousNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMaliciousNoteWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a member of the account managed by Security Center type of the multi-account management feature.
     *  *
     * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *  *
     * @param DeleteMonitorAccountRequest $request DeleteMonitorAccountRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMonitorAccountResponse DeleteMonitorAccountResponse
     */
    public function deleteMonitorAccountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accountId)) {
            $query['AccountId'] = $request->accountId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMonitorAccount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMonitorAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a member of the account managed by Security Center type of the multi-account management feature.
     *  *
     * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *  *
     * @param DeleteMonitorAccountRequest $request DeleteMonitorAccountRequest
     *
     * @return DeleteMonitorAccountResponse DeleteMonitorAccountResponse
     */
    public function deleteMonitorAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMonitorAccountWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes rules of the at-risk image blocking type.
     *  *
     * @param DeleteOpaStrategyNewRequest $request DeleteOpaStrategyNewRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteOpaStrategyNewResponse DeleteOpaStrategyNewResponse
     */
    public function deleteOpaStrategyNewWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyIds)) {
            $query['StrategyIds'] = $request->strategyIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteOpaStrategyNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteOpaStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes rules of the at-risk image blocking type.
     *  *
     * @param DeleteOpaStrategyNewRequest $request DeleteOpaStrategyNewRequest
     *
     * @return DeleteOpaStrategyNewResponse DeleteOpaStrategyNewResponse
     */
    public function deleteOpaStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteOpaStrategyNewWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configuration of an Object Storage Service (OSS) file detection policy.
     *  *
     * @param DeleteOssScanConfigRequest $request DeleteOssScanConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteOssScanConfigResponse DeleteOssScanConfigResponse
     */
    public function deleteOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configuration of an Object Storage Service (OSS) file detection policy.
     *  *
     * @param DeleteOssScanConfigRequest $request DeleteOssScanConfigRequest
     *
     * @return DeleteOssScanConfigResponse DeleteOssScanConfigResponse
     */
    public function deleteOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a private image repository by using the ID of the image repository.
     *  *
     * @param DeletePrivateRegistryRequest $request DeletePrivateRegistryRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeletePrivateRegistryResponse DeletePrivateRegistryResponse
     */
    public function deletePrivateRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->registryId)) {
            $query['RegistryId'] = $request->registryId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeletePrivateRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeletePrivateRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a private image repository by using the ID of the image repository.
     *  *
     * @param DeletePrivateRegistryRequest $request DeletePrivateRegistryRequest
     *
     * @return DeletePrivateRegistryResponse DeletePrivateRegistryResponse
     */
    public function deletePrivateRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePrivateRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a rule for container tamper-proofing.
     *  *
     * @param DeleteSasContainerWebDefenseRuleRequest $request DeleteSasContainerWebDefenseRuleRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSasContainerWebDefenseRuleResponse DeleteSasContainerWebDefenseRuleResponse
     */
    public function deleteSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSasContainerWebDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a rule for container tamper-proofing.
     *  *
     * @param DeleteSasContainerWebDefenseRuleRequest $request DeleteSasContainerWebDefenseRuleRequest
     *
     * @return DeleteSasContainerWebDefenseRuleResponse DeleteSasContainerWebDefenseRuleResponse
     */
    public function deleteSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a frequently used search condition by using the asset management feature of the Assets module in the Security Center console.
     *  *
     * @param DeleteSearchConditionRequest $request DeleteSearchConditionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSearchConditionResponse DeleteSearchConditionResponse
     */
    public function deleteSearchConditionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSearchCondition',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSearchConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a frequently used search condition by using the asset management feature of the Assets module in the Security Center console.
     *  *
     * @param DeleteSearchConditionRequest $request DeleteSearchConditionRequest
     *
     * @return DeleteSearchConditionResponse DeleteSearchConditionResponse
     */
    public function deleteSearchCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSearchConditionWithOptions($request, $runtime);
    }

    /**
     * @deprecated openAPI DeleteSecurityEventMarkMissList is deprecated, please use Sas::2018-12-03::ModifySecurityEventMarkMissIndividually instead
     *  *
     * @summary Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
     *  *
     * Deprecated
     *
     * @param DeleteSecurityEventMarkMissListRequest $request DeleteSecurityEventMarkMissListRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSecurityEventMarkMissListResponse DeleteSecurityEventMarkMissListResponse
     */
    public function deleteSecurityEventMarkMissListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSecurityEventMarkMissList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSecurityEventMarkMissListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated openAPI DeleteSecurityEventMarkMissList is deprecated, please use Sas::2018-12-03::ModifySecurityEventMarkMissIndividually instead
     *  *
     * @summary Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
     *  *
     * Deprecated
     *
     * @param DeleteSecurityEventMarkMissListRequest $request DeleteSecurityEventMarkMissListRequest
     *
     * @return DeleteSecurityEventMarkMissListResponse DeleteSecurityEventMarkMissListResponse
     */
    public function deleteSecurityEventMarkMissList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSecurityEventMarkMissListWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a service trail.
     *  *
     * @param DeleteServiceTrailRequest $request DeleteServiceTrailRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteServiceTrailResponse DeleteServiceTrailResponse
     */
    public function deleteServiceTrailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteServiceTrail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteServiceTrailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a service trail.
     *  *
     * @param DeleteServiceTrailRequest $request DeleteServiceTrailRequest
     *
     * @return DeleteServiceTrailResponse DeleteServiceTrailResponse
     */
    public function deleteServiceTrail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteServiceTrailWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a policy task that is in the waiting state on the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DeleteSoarStrategyTaskRequest $request DeleteSoarStrategyTaskRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSoarStrategyTaskResponse DeleteSoarStrategyTaskResponse
     */
    public function deleteSoarStrategyTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyTaskId)) {
            $query['StrategyTaskId'] = $request->strategyTaskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSoarStrategyTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSoarStrategyTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a policy task that is in the waiting state on the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DeleteSoarStrategyTaskRequest $request DeleteSoarStrategyTaskRequest
     *
     * @return DeleteSoarStrategyTaskResponse DeleteSoarStrategyTaskResponse
     */
    public function deleteSoarStrategyTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSoarStrategyTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a baseline check policy.
     *  *
     * @param DeleteStrategyRequest $request DeleteStrategyRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteStrategyResponse DeleteStrategyResponse
     */
    public function deleteStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a baseline check policy.
     *  *
     * @param DeleteStrategyRequest $request DeleteStrategyRequest
     *
     * @return DeleteStrategyResponse DeleteStrategyResponse
     */
    public function deleteStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the description of an alert.
     *  *
     * @param DeleteSuspEventNodeRequest $request DeleteSuspEventNodeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSuspEventNodeResponse DeleteSuspEventNodeResponse
     */
    public function deleteSuspEventNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->noteId)) {
            $query['NoteId'] = $request->noteId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSuspEventNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSuspEventNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the description of an alert.
     *  *
     * @param DeleteSuspEventNodeRequest $request DeleteSuspEventNodeRequest
     *
     * @return DeleteSuspEventNodeResponse DeleteSuspEventNodeResponse
     */
    public function deleteSuspEventNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSuspEventNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Removes custom tags from assets.
     *  *
     * @description Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
     *  *
     * @param DeleteTagWithUuidRequest $request DeleteTagWithUuidRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTagWithUuidResponse DeleteTagWithUuidResponse
     */
    public function deleteTagWithUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tagName)) {
            $query['TagName'] = $request->tagName;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTagWithUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTagWithUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes custom tags from assets.
     *  *
     * @description Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
     *  *
     * @param DeleteTagWithUuidRequest $request DeleteTagWithUuidRequest
     *
     * @return DeleteTagWithUuidResponse DeleteTagWithUuidResponse
     */
    public function deleteTagWithUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTagWithUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes anti-ransomware policies that are created for databases.
     *  *
     * @param DeleteUniBackupPolicyRequest $request DeleteUniBackupPolicyRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteUniBackupPolicyResponse DeleteUniBackupPolicyResponse
     */
    public function deleteUniBackupPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->policyIds)) {
            $query['PolicyIds'] = $request->policyIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteUniBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteUniBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes anti-ransomware policies that are created for databases.
     *  *
     * @param DeleteUniBackupPolicyRequest $request DeleteUniBackupPolicyRequest
     *
     * @return DeleteUniBackupPolicyResponse DeleteUniBackupPolicyResponse
     */
    public function deleteUniBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteUniBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a honeypot.
     *  *
     * @param DeleteVpcHoneyPotRequest $request DeleteVpcHoneyPotRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpcHoneyPotResponse DeleteVpcHoneyPotResponse
     */
    public function deleteVpcHoneyPotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpcHoneyPot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpcHoneyPotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a honeypot.
     *  *
     * @param DeleteVpcHoneyPotRequest $request DeleteVpcHoneyPotRequest
     *
     * @return DeleteVpcHoneyPotResponse DeleteVpcHoneyPotResponse
     */
    public function deleteVpcHoneyPot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpcHoneyPotWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes configurations of of an automatic vulnerability fixing task at a time on the Playbook page.
     *  *
     * @param DeleteVulAutoRepairConfigRequest $request DeleteVulAutoRepairConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVulAutoRepairConfigResponse DeleteVulAutoRepairConfigResponse
     */
    public function deleteVulAutoRepairConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->configIdList)) {
            $query['ConfigIdList'] = $request->configIdList;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVulAutoRepairConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVulAutoRepairConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes configurations of of an automatic vulnerability fixing task at a time on the Playbook page.
     *  *
     * @param DeleteVulAutoRepairConfigRequest $request DeleteVulAutoRepairConfigRequest
     *
     * @return DeleteVulAutoRepairConfigResponse DeleteVulAutoRepairConfigResponse
     */
    public function deleteVulAutoRepairConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVulAutoRepairConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified vulnerability whitelist.
     *  *
     * @param DeleteVulWhitelistRequest $request DeleteVulWhitelistRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVulWhitelistResponse DeleteVulWhitelistResponse
     */
    public function deleteVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->whitelist)) {
            $query['Whitelist'] = $request->whitelist;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified vulnerability whitelist.
     *  *
     * @param DeleteVulWhitelistRequest $request DeleteVulWhitelistRequest
     *
     * @return DeleteVulWhitelistResponse DeleteVulWhitelistResponse
     */
    public function deleteVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of AccessKey pair leaks.
     *  *
     * @param DescribeAccessKeyLeakDetailRequest $request DescribeAccessKeyLeakDetailRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAccessKeyLeakDetailResponse DescribeAccessKeyLeakDetailResponse
     */
    public function describeAccessKeyLeakDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAccessKeyLeakDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAccessKeyLeakDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of AccessKey pair leaks.
     *  *
     * @param DescribeAccessKeyLeakDetailRequest $request DescribeAccessKeyLeakDetailRequest
     *
     * @return DescribeAccessKeyLeakDetailResponse DescribeAccessKeyLeakDetailResponse
     */
    public function describeAccessKeyLeakDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccessKeyLeakDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the AccessKey pair leaks that are detected on your assets.
     *  *
     * @param DescribeAccesskeyLeakListRequest $request DescribeAccesskeyLeakListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAccesskeyLeakListResponse DescribeAccesskeyLeakListResponse
     */
    public function describeAccesskeyLeakListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->query)) {
            $query['Query'] = $request->query;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->startTs)) {
            $query['StartTs'] = $request->startTs;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAccesskeyLeakList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAccesskeyLeakListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the AccessKey pair leaks that are detected on your assets.
     *  *
     * @param DescribeAccesskeyLeakListRequest $request DescribeAccesskeyLeakListRequest
     *
     * @return DescribeAccesskeyLeakListResponse DescribeAccesskeyLeakListResponse
     */
    public function describeAccesskeyLeakList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccesskeyLeakListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the affected servers in the result of a virus scan task.
     *  *
     * @param DescribeAffectedAssetsRequest $request DescribeAffectedAssetsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAffectedAssetsResponse DescribeAffectedAssetsResponse
     */
    public function describeAffectedAssetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->current)) {
            $query['Current'] = $request->current;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAffectedAssets',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAffectedAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the affected servers in the result of a virus scan task.
     *  *
     * @param DescribeAffectedAssetsRequest $request DescribeAffectedAssetsRequest
     *
     * @return DescribeAffectedAssetsResponse DescribeAffectedAssetsResponse
     */
    public function describeAffectedAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAffectedAssetsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of malicious image samples.
     *  *
     * @param DescribeAffectedMaliciousFileImagesRequest $request DescribeAffectedMaliciousFileImagesRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAffectedMaliciousFileImagesResponse DescribeAffectedMaliciousFileImagesResponse
     */
    public function describeAffectedMaliciousFileImagesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->containerId)) {
            $query['ContainerId'] = $request->containerId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->image)) {
            $query['Image'] = $request->image;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->imageLayer)) {
            $query['ImageLayer'] = $request->imageLayer;
        }
        if (!Utils::isUnset($request->imageTag)) {
            $query['ImageTag'] = $request->imageTag;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->maliciousMd5)) {
            $query['MaliciousMd5'] = $request->maliciousMd5;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pod)) {
            $query['Pod'] = $request->pod;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAffectedMaliciousFileImages',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAffectedMaliciousFileImagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of malicious image samples.
     *  *
     * @param DescribeAffectedMaliciousFileImagesRequest $request DescribeAffectedMaliciousFileImagesRequest
     *
     * @return DescribeAffectedMaliciousFileImagesResponse DescribeAffectedMaliciousFileImagesResponse
     */
    public function describeAffectedMaliciousFileImages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAffectedMaliciousFileImagesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
     *  *
     * @param DescribeAgentInstallStatusRequest $request DescribeAgentInstallStatusRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAgentInstallStatusResponse DescribeAgentInstallStatusResponse
     */
    public function describeAgentInstallStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAgentInstallStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAgentInstallStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
     *  *
     * @param DescribeAgentInstallStatusRequest $request DescribeAgentInstallStatusRequest
     *
     * @return DescribeAgentInstallStatusResponse DescribeAgentInstallStatusResponse
     */
    public function describeAgentInstallStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAgentInstallStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of assets on which a specific type of sensitive files are detected by using the agentless detection feature.
     *  *
     * @description You can call this operation only when the agentless detection feature is purchased by using the pay-as-you-go billing method within your Alibaba Cloud account.
     *  *
     * @param DescribeAgentlessSensitiveFileByKeyRequest $tmpReq  DescribeAgentlessSensitiveFileByKeyRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAgentlessSensitiveFileByKeyResponse DescribeAgentlessSensitiveFileByKeyResponse
     */
    public function describeAgentlessSensitiveFileByKeyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeAgentlessSensitiveFileByKeyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->scanRange)) {
            $request->scanRangeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAgentlessSensitiveFileByKey',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAgentlessSensitiveFileByKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of assets on which a specific type of sensitive files are detected by using the agentless detection feature.
     *  *
     * @description You can call this operation only when the agentless detection feature is purchased by using the pay-as-you-go billing method within your Alibaba Cloud account.
     *  *
     * @param DescribeAgentlessSensitiveFileByKeyRequest $request DescribeAgentlessSensitiveFileByKeyRequest
     *
     * @return DescribeAgentlessSensitiveFileByKeyResponse DescribeAgentlessSensitiveFileByKeyResponse
     */
    public function describeAgentlessSensitiveFileByKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAgentlessSensitiveFileByKeyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
     *  *
     * @param DescribeAlarmEventDetailRequest $request DescribeAlarmEventDetailRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAlarmEventDetailResponse DescribeAlarmEventDetailResponse
     */
    public function describeAlarmEventDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alarmUniqueInfo)) {
            $query['AlarmUniqueInfo'] = $request->alarmUniqueInfo;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAlarmEventDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAlarmEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
     *  *
     * @param DescribeAlarmEventDetailRequest $request DescribeAlarmEventDetailRequest
     *
     * @return DescribeAlarmEventDetailResponse DescribeAlarmEventDetailResponse
     */
    public function describeAlarmEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAlarmEventDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the stack information about an alert event.
     *  *
     * @param DescribeAlarmEventStackInfoRequest $request DescribeAlarmEventStackInfoRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAlarmEventStackInfoResponse DescribeAlarmEventStackInfoResponse
     */
    public function describeAlarmEventStackInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uniqueInfo)) {
            $query['UniqueInfo'] = $request->uniqueInfo;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAlarmEventStackInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAlarmEventStackInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the stack information about an alert event.
     *  *
     * @param DescribeAlarmEventStackInfoRequest $request DescribeAlarmEventStackInfoRequest
     *
     * @return DescribeAlarmEventStackInfoResponse DescribeAlarmEventStackInfoResponse
     */
    public function describeAlarmEventStackInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAlarmEventStackInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about all server assets, including the asset group IDs and asset names.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAllEntityResponse DescribeAllEntityResponse
     */
    public function describeAllEntityWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeAllEntity',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAllEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about all server assets, including the asset group IDs and asset names.
     *  *
     * @return DescribeAllEntityResponse DescribeAllEntityResponse
     */
    public function describeAllEntity()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllEntityWithOptions($runtime);
    }

    /**
     * @summary Queries the information about all server groups.
     *  *
     * @param DescribeAllGroupsRequest $request DescribeAllGroupsRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAllGroupsResponse DescribeAllGroupsResponse
     */
    public function describeAllGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAllGroups',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAllGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about all server groups.
     *  *
     * @param DescribeAllGroupsRequest $request DescribeAllGroupsRequest
     *
     * @return DescribeAllGroupsResponse DescribeAllGroupsResponse
     */
    public function describeAllGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries baselines that are used in image baseline checks.
     *  *
     * @param DescribeAllImageBaselineRequest $request DescribeAllImageBaselineRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAllImageBaselineResponse DescribeAllImageBaselineResponse
     */
    public function describeAllImageBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAllImageBaseline',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAllImageBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries baselines that are used in image baseline checks.
     *  *
     * @param DescribeAllImageBaselineRequest $request DescribeAllImageBaselineRequest
     *
     * @return DescribeAllImageBaselineResponse DescribeAllImageBaselineResponse
     */
    public function describeAllImageBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllImageBaselineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics on global security events, including the numbers of unfixed vulnerabilities, baseline risks, and alerts.
     *  *
     * @param DescribeAllRegionsStatisticsRequest $request DescribeAllRegionsStatisticsRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAllRegionsStatisticsResponse DescribeAllRegionsStatisticsResponse
     */
    public function describeAllRegionsStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAllRegionsStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAllRegionsStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on global security events, including the numbers of unfixed vulnerabilities, baseline risks, and alerts.
     *  *
     * @param DescribeAllRegionsStatisticsRequest $request DescribeAllRegionsStatisticsRequest
     *
     * @return DescribeAllRegionsStatisticsResponse DescribeAllRegionsStatisticsResponse
     */
    public function describeAllRegionsStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllRegionsStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries created defense rules against brute-force attacks.
     *  *
     * @param DescribeAntiBruteForceRulesRequest $request DescribeAntiBruteForceRulesRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAntiBruteForceRulesResponse DescribeAntiBruteForceRulesResponse
     */
    public function describeAntiBruteForceRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAntiBruteForceRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAntiBruteForceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries created defense rules against brute-force attacks.
     *  *
     * @param DescribeAntiBruteForceRulesRequest $request DescribeAntiBruteForceRulesRequest
     *
     * @return DescribeAntiBruteForceRulesResponse DescribeAntiBruteForceRulesResponse
     */
    public function describeAntiBruteForceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAntiBruteForceRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the scan cycle for application vulnerabilities.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAppVulScanCycleResponse DescribeAppVulScanCycleResponse
     */
    public function describeAppVulScanCycleWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeAppVulScanCycle',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAppVulScanCycleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the scan cycle for application vulnerabilities.
     *  *
     * @return DescribeAppVulScanCycleResponse DescribeAppVulScanCycleResponse
     */
    public function describeAppVulScanCycle()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAppVulScanCycleWithOptions($runtime);
    }

    /**
     * @deprecated openAPI DescribeAssetDetailByUuid is deprecated, please use Sas::2018-12-03::GetAssetDetailByUuid instead
     *  *
     * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
     *  *
     * Deprecated
     *
     * @param DescribeAssetDetailByUuidRequest $request DescribeAssetDetailByUuidRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAssetDetailByUuidResponse DescribeAssetDetailByUuidResponse
     */
    public function describeAssetDetailByUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAssetDetailByUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAssetDetailByUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated openAPI DescribeAssetDetailByUuid is deprecated, please use Sas::2018-12-03::GetAssetDetailByUuid instead
     *  *
     * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
     *  *
     * Deprecated
     *
     * @param DescribeAssetDetailByUuidRequest $request DescribeAssetDetailByUuidRequest
     *
     * @return DescribeAssetDetailByUuidResponse DescribeAssetDetailByUuidResponse
     */
    public function describeAssetDetailByUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetDetailByUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of Elastic Compute Service (ECS) instances.
     *  *
     * @param DescribeAssetDetailByUuidsRequest $request DescribeAssetDetailByUuidsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAssetDetailByUuidsResponse DescribeAssetDetailByUuidsResponse
     */
    public function describeAssetDetailByUuidsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAssetDetailByUuids',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAssetDetailByUuidsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of Elastic Compute Service (ECS) instances.
     *  *
     * @param DescribeAssetDetailByUuidsRequest $request DescribeAssetDetailByUuidsRequest
     *
     * @return DescribeAssetDetailByUuidsResponse DescribeAssetDetailByUuidsResponse
     */
    public function describeAssetDetailByUuids($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetDetailByUuidsWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the request, which is used to locate and troubleshoot issues.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAssetSummaryResponse DescribeAssetSummaryResponse
     */
    public function describeAssetSummaryWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeAssetSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAssetSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the request, which is used to locate and troubleshoot issues.
     *  *
     * @return DescribeAssetSummaryResponse DescribeAssetSummaryResponse
     */
    public function describeAssetSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetSummaryWithOptions($runtime);
    }

    /**
     * @summary Queries the number of Java processes in an asset by using the asset fingerprints feature of Security Center.
     *  *
     * @param DescribeAssetsScaProcessNumRequest $request DescribeAssetsScaProcessNumRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAssetsScaProcessNumResponse DescribeAssetsScaProcessNumResponse
     */
    public function describeAssetsScaProcessNumWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAssetsScaProcessNum',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAssetsScaProcessNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of Java processes in an asset by using the asset fingerprints feature of Security Center.
     *  *
     * @param DescribeAssetsScaProcessNumRequest $request DescribeAssetsScaProcessNumRequest
     *
     * @return DescribeAssetsScaProcessNumResponse DescribeAssetsScaProcessNumResponse
     */
    public function describeAssetsScaProcessNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetsScaProcessNumWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the risk information about containers.
     *  *
     * @param DescribeAssetsSecurityEventSummaryRequest $request DescribeAssetsSecurityEventSummaryRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAssetsSecurityEventSummaryResponse DescribeAssetsSecurityEventSummaryResponse
     */
    public function describeAssetsSecurityEventSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAssetsSecurityEventSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAssetsSecurityEventSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk information about containers.
     *  *
     * @param DescribeAssetsSecurityEventSummaryRequest $request DescribeAssetsSecurityEventSummaryRequest
     *
     * @return DescribeAssetsSecurityEventSummaryResponse DescribeAssetsSecurityEventSummaryResponse
     */
    public function describeAssetsSecurityEventSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetsSecurityEventSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the results of automatically connecting applications on Elastic Compute Service (ECS) instances to the application protection feature after the Runtime Application Self-Protection (RASP) agent is installed on the ECS instances.
     *  *
     * @param DescribeAttachRecordsRequest $request DescribeAttachRecordsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAttachRecordsResponse DescribeAttachRecordsResponse
     */
    public function describeAttachRecordsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->applicationId)) {
            $query['ApplicationId'] = $request->applicationId;
        }
        if (!Utils::isUnset($request->ecsUUIDList)) {
            $query['EcsUUIDList'] = $request->ecsUUIDList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAttachRecords',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAttachRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the results of automatically connecting applications on Elastic Compute Service (ECS) instances to the application protection feature after the Runtime Application Self-Protection (RASP) agent is installed on the ECS instances.
     *  *
     * @param DescribeAttachRecordsRequest $request DescribeAttachRecordsRequest
     *
     * @return DescribeAttachRecordsResponse DescribeAttachRecordsResponse
     */
    public function describeAttachRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAttachRecordsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of attack analysis.
     *  *
     * @param DescribeAttackAnalysisDataRequest $request DescribeAttackAnalysisDataRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAttackAnalysisDataResponse DescribeAttackAnalysisDataResponse
     */
    public function describeAttackAnalysisDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->base64)) {
            $query['Base64'] = $request->base64;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->data)) {
            $query['Data'] = $request->data;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAttackAnalysisData',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAttackAnalysisDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of attack analysis.
     *  *
     * @param DescribeAttackAnalysisDataRequest $request DescribeAttackAnalysisDataRequest
     *
     * @return DescribeAttackAnalysisDataResponse DescribeAttackAnalysisDataResponse
     */
    public function describeAttackAnalysisData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAttackAnalysisDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of witnesses.
     *  *
     * @param DescribeAttestorsRequest $request DescribeAttestorsRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAttestorsResponse DescribeAttestorsResponse
     */
    public function describeAttestorsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAttestors',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAttestorsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of witnesses.
     *  *
     * @param DescribeAttestorsRequest $request DescribeAttestorsRequest
     *
     * @return DescribeAttestorsResponse DescribeAttestorsResponse
     */
    public function describeAttestors($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAttestorsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAutoDelConfigResponse DescribeAutoDelConfigResponse
     */
    public function describeAutoDelConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeAutoDelConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAutoDelConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
     *  *
     * @return DescribeAutoDelConfigResponse DescribeAutoDelConfigResponse
     */
    public function describeAutoDelConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAutoDelConfigWithOptions($runtime);
    }

    /**
     * @summary Queries the information about a file to which archived alert events are exported.
     *  *
     * @param DescribeBackUpExportInfoRequest $request DescribeBackUpExportInfoRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackUpExportInfoResponse DescribeBackUpExportInfoResponse
     */
    public function describeBackUpExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->exportType)) {
            $query['ExportType'] = $request->exportType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackUpExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackUpExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a file to which archived alert events are exported.
     *  *
     * @param DescribeBackUpExportInfoRequest $request DescribeBackUpExportInfoRequest
     *
     * @return DescribeBackUpExportInfoResponse DescribeBackUpExportInfoResponse
     */
    public function describeBackUpExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackUpExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers on which the anti-ransomware agent is installed in a specified region.
     *  *
     * @description You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
     *  *
     * @param DescribeBackupClientsRequest $request DescribeBackupClientsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupClientsResponse DescribeBackupClientsResponse
     */
    public function describeBackupClientsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->supportRegionId)) {
            $query['SupportRegionId'] = $request->supportRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupClients',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupClientsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers on which the anti-ransomware agent is installed in a specified region.
     *  *
     * @description You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
     *  *
     * @param DescribeBackupClientsRequest $request DescribeBackupClientsRequest
     *
     * @return DescribeBackupClientsResponse DescribeBackupClientsResponse
     */
    public function describeBackupClients($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupClientsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries backup files.
     *  *
     * @param DescribeBackupFilesRequest $request DescribeBackupFilesRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupFilesResponse DescribeBackupFilesResponse
     */
    public function describeBackupFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->path)) {
            $query['Path'] = $request->path;
        }
        if (!Utils::isUnset($request->snapshotHash)) {
            $query['SnapshotHash'] = $request->snapshotHash;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupFiles',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries backup files.
     *  *
     * @param DescribeBackupFilesRequest $request DescribeBackupFilesRequest
     *
     * @return DescribeBackupFilesResponse DescribeBackupFilesResponse
     */
    public function describeBackupFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the backup status of a sever to which an anti-ransomware policy is applied.
     *  *
     * @param DescribeBackupMachineStatusRequest $request DescribeBackupMachineStatusRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupMachineStatusResponse DescribeBackupMachineStatusResponse
     */
    public function describeBackupMachineStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupMachineStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupMachineStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the backup status of a sever to which an anti-ransomware policy is applied.
     *  *
     * @param DescribeBackupMachineStatusRequest $request DescribeBackupMachineStatusRequest
     *
     * @return DescribeBackupMachineStatusResponse DescribeBackupMachineStatusResponse
     */
    public function describeBackupMachineStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupMachineStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries anti-ransomware policies.
     *  *
     * @param DescribeBackupPoliciesRequest $request DescribeBackupPoliciesRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupPoliciesResponse DescribeBackupPoliciesResponse
     */
    public function describeBackupPoliciesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->machineRemark)) {
            $query['MachineRemark'] = $request->machineRemark;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupPolicies',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries anti-ransomware policies.
     *  *
     * @param DescribeBackupPoliciesRequest $request DescribeBackupPoliciesRequest
     *
     * @return DescribeBackupPoliciesResponse DescribeBackupPoliciesResponse
     */
    public function describeBackupPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupPoliciesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an anti-ransomware policy for servers.
     *  *
     * @param DescribeBackupPolicyRequest $request DescribeBackupPolicyRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupPolicyResponse DescribeBackupPolicyResponse
     */
    public function describeBackupPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an anti-ransomware policy for servers.
     *  *
     * @param DescribeBackupPolicyRequest $request DescribeBackupPolicyRequest
     *
     * @return DescribeBackupPolicyResponse DescribeBackupPolicyResponse
     */
    public function describeBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of restoration tasks.
     *  *
     * @description If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupRestoreCountResponse DescribeBackupRestoreCountResponse
     */
    public function describeBackupRestoreCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeBackupRestoreCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupRestoreCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of restoration tasks.
     *  *
     * @description If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
     *  *
     * @return DescribeBackupRestoreCountResponse DescribeBackupRestoreCountResponse
     */
    public function describeBackupRestoreCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupRestoreCountWithOptions($runtime);
    }

    /**
     * @summary Queries binary security policies.
     *  *
     * @param DescribeBinarySecurityPoliciesRequest $request DescribeBinarySecurityPoliciesRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBinarySecurityPoliciesResponse DescribeBinarySecurityPoliciesResponse
     */
    public function describeBinarySecurityPoliciesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBinarySecurityPolicies',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBinarySecurityPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries binary security policies.
     *  *
     * @param DescribeBinarySecurityPoliciesRequest $request DescribeBinarySecurityPoliciesRequest
     *
     * @return DescribeBinarySecurityPoliciesResponse DescribeBinarySecurityPoliciesResponse
     */
    public function describeBinarySecurityPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBinarySecurityPoliciesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
     *  *
     * @param DescribeBruteForceRecordsRequest $request DescribeBruteForceRecordsRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBruteForceRecordsResponse DescribeBruteForceRecordsResponse
     */
    public function describeBruteForceRecordsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBruteForceRecords',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBruteForceRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
     *  *
     * @param DescribeBruteForceRecordsRequest $request DescribeBruteForceRecordsRequest
     *
     * @return DescribeBruteForceRecordsResponse DescribeBruteForceRecordsResponse
     */
    public function describeBruteForceRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBruteForceRecordsWithOptions($request, $runtime);
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param DescribeBruteForceSummaryRequest $request DescribeBruteForceSummaryRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBruteForceSummaryResponse DescribeBruteForceSummaryResponse
     */
    public function describeBruteForceSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBruteForceSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBruteForceSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param DescribeBruteForceSummaryRequest $request DescribeBruteForceSummaryRequest
     *
     * @return DescribeBruteForceSummaryResponse DescribeBruteForceSummaryResponse
     */
    public function describeBruteForceSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBruteForceSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of fixable vulnerabilities.
     *  *
     * @param DescribeCanFixVulListRequest $request DescribeCanFixVulListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCanFixVulListResponse DescribeCanFixVulListResponse
     */
    public function describeCanFixVulListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->containerId)) {
            $query['ContainerId'] = $request->containerId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->digest)) {
            $query['Digest'] = $request->digest;
        }
        if (!Utils::isUnset($request->image)) {
            $query['Image'] = $request->image;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pod)) {
            $query['Pod'] = $request->pod;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCanFixVulList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCanFixVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of fixable vulnerabilities.
     *  *
     * @param DescribeCanFixVulListRequest $request DescribeCanFixVulListRequest
     *
     * @return DescribeCanFixVulListResponse DescribeCanFixVulListResponse
     */
    public function describeCanFixVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCanFixVulListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询是否允许试用云安全中心
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCanTrySasResponse DescribeCanTrySasResponse
     */
    public function describeCanTrySasWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeCanTrySas',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCanTrySasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询是否允许试用云安全中心
     *  *
     * @return DescribeCanTrySasResponse DescribeCanTrySasResponse
     */
    public function describeCanTrySas()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCanTrySasWithOptions($runtime);
    }

    /**
     * @summary Queries the chart data of a security report.
     *  *
     * @param DescribeChartDataRequest $request DescribeChartDataRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeChartDataResponse DescribeChartDataResponse
     */
    public function describeChartDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->charId)) {
            $query['CharId'] = $request->charId;
        }
        if (!Utils::isUnset($request->chartId)) {
            $query['ChartId'] = $request->chartId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeChartData',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeChartDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the chart data of a security report.
     *  *
     * @param DescribeChartDataRequest $request DescribeChartDataRequest
     *
     * @return DescribeChartDataResponse DescribeChartDataResponse
     */
    public function describeChartData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeChartDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the charts that are supported by using the security report feature of Security Center.
     *  *
     * @param DescribeChartListRequest $request DescribeChartListRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeChartListResponse DescribeChartListResponse
     */
    public function describeChartListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->projectCode)) {
            $query['ProjectCode'] = $request->projectCode;
        }
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeChartList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeChartListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the charts that are supported by using the security report feature of Security Center.
     *  *
     * @param DescribeChartListRequest $request DescribeChartListRequest
     *
     * @return DescribeChartListResponse DescribeChartListResponse
     */
    public function describeChartList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeChartListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询分类并附带每个分类的未处理异常数量
     *  *
     * @param DescribeCheckEcsWarningsRequest $request DescribeCheckEcsWarningsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckEcsWarningsResponse DescribeCheckEcsWarningsResponse
     */
    public function describeCheckEcsWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckEcsWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckEcsWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询分类并附带每个分类的未处理异常数量
     *  *
     * @param DescribeCheckEcsWarningsRequest $request DescribeCheckEcsWarningsRequest
     *
     * @return DescribeCheckEcsWarningsResponse DescribeCheckEcsWarningsResponse
     */
    public function describeCheckEcsWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckEcsWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the parameters that you can configure to fix specified risk items.
     *  *
     * @param DescribeCheckFixDetailsRequest $request DescribeCheckFixDetailsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckFixDetailsResponse DescribeCheckFixDetailsResponse
     */
    public function describeCheckFixDetailsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckFixDetails',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckFixDetailsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the parameters that you can configure to fix specified risk items.
     *  *
     * @param DescribeCheckFixDetailsRequest $request DescribeCheckFixDetailsRequest
     *
     * @return DescribeCheckFixDetailsResponse DescribeCheckFixDetailsResponse
     */
    public function describeCheckFixDetails($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckFixDetailsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the result of the ISO 27001 compliance check.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckResultResponse DescribeCheckResultResponse
     */
    public function describeCheckResultWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the result of the ISO 27001 compliance check.
     *  *
     * @return DescribeCheckResultResponse DescribeCheckResultResponse
     */
    public function describeCheckResult()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckResultWithOptions($runtime);
    }

    /**
     * @summary 获取基线问题条数
     *  *
     * @param DescribeCheckWarningCountRequest $request DescribeCheckWarningCountRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckWarningCountResponse DescribeCheckWarningCountResponse
     */
    public function describeCheckWarningCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliUid)) {
            $query['AliUid'] = $request->aliUid;
        }
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckWarningCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckWarningCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取基线问题条数
     *  *
     * @param DescribeCheckWarningCountRequest $request DescribeCheckWarningCountRequest
     *
     * @return DescribeCheckWarningCountResponse DescribeCheckWarningCountResponse
     */
    public function describeCheckWarningCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a specified check item.
     *  *
     * @param DescribeCheckWarningDetailRequest $request DescribeCheckWarningDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckWarningDetailResponse DescribeCheckWarningDetailResponse
     */
    public function describeCheckWarningDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->checkWarningId)) {
            $query['CheckWarningId'] = $request->checkWarningId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckWarningDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckWarningDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a specified check item.
     *  *
     * @param DescribeCheckWarningDetailRequest $request DescribeCheckWarningDetailRequest
     *
     * @return DescribeCheckWarningDetailResponse DescribeCheckWarningDetailResponse
     */
    public function describeCheckWarningDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
     *  *
     * @param DescribeCheckWarningMachinesRequest $request DescribeCheckWarningMachinesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckWarningMachinesResponse DescribeCheckWarningMachinesResponse
     */
    public function describeCheckWarningMachinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->filterUuid)) {
            $query['FilterUuid'] = $request->filterUuid;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckWarningMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckWarningMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
     *  *
     * @param DescribeCheckWarningMachinesRequest $request DescribeCheckWarningMachinesRequest
     *
     * @return DescribeCheckWarningMachinesResponse DescribeCheckWarningMachinesResponse
     */
    public function describeCheckWarningMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningMachinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
     *  *
     * @param DescribeCheckWarningSummaryRequest $request DescribeCheckWarningSummaryRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckWarningSummaryResponse DescribeCheckWarningSummaryResponse
     */
    public function describeCheckWarningSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskName)) {
            $query['RiskName'] = $request->riskName;
        }
        if (!Utils::isUnset($request->riskStatus)) {
            $query['RiskStatus'] = $request->riskStatus;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->typeName)) {
            $query['TypeName'] = $request->typeName;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckWarningSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckWarningSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
     *  *
     * @param DescribeCheckWarningSummaryRequest $request DescribeCheckWarningSummaryRequest
     *
     * @return DescribeCheckWarningSummaryResponse DescribeCheckWarningSummaryResponse
     */
    public function describeCheckWarningSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about specified risk items and the check items of a specified server.
     *  *
     * @param DescribeCheckWarningsRequest $request DescribeCheckWarningsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckWarningsResponse DescribeCheckWarningsResponse
     */
    public function describeCheckWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->checkType)) {
            $query['CheckType'] = $request->checkType;
        }
        if (!Utils::isUnset($request->containerName)) {
            $query['ContainerName'] = $request->containerName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->riskStatus)) {
            $query['RiskStatus'] = $request->riskStatus;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about specified risk items and the check items of a specified server.
     *  *
     * @param DescribeCheckWarningsRequest $request DescribeCheckWarningsRequest
     *
     * @return DescribeCheckWarningsResponse DescribeCheckWarningsResponse
     */
    public function describeCheckWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the Security Center agent.
     *  *
     * @param DescribeClientConfSetupRequest $request DescribeClientConfSetupRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClientConfSetupResponse DescribeClientConfSetupResponse
     */
    public function describeClientConfSetupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyTag)) {
            $query['StrategyTag'] = $request->strategyTag;
        }
        if (!Utils::isUnset($request->strategyTagValue)) {
            $query['StrategyTagValue'] = $request->strategyTagValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClientConfSetup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClientConfSetupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the Security Center agent.
     *  *
     * @param DescribeClientConfSetupRequest $request DescribeClientConfSetupRequest
     *
     * @return DescribeClientConfSetupResponse DescribeClientConfSetupResponse
     */
    public function describeClientConfSetup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClientConfSetupWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of servers to which different tags are added.
     *  *
     * @param DescribeClientConfStrategyRequest $request DescribeClientConfStrategyRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClientConfStrategyResponse DescribeClientConfStrategyResponse
     */
    public function describeClientConfStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->tagValue)) {
            $query['TagValue'] = $request->tagValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClientConfStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClientConfStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of servers to which different tags are added.
     *  *
     * @param DescribeClientConfStrategyRequest $request DescribeClientConfStrategyRequest
     *
     * @return DescribeClientConfStrategyResponse DescribeClientConfStrategyResponse
     */
    public function describeClientConfStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClientConfStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary 查询客户端问题列表
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClientProblemTypeResponse DescribeClientProblemTypeResponse
     */
    public function describeClientProblemTypeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeClientProblemType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClientProblemTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询客户端问题列表
     *  *
     * @return DescribeClientProblemTypeResponse DescribeClientProblemTypeResponse
     */
    public function describeClientProblemType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClientProblemTypeWithOptions($runtime);
    }

    /**
     * @summary Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
     *  *
     * @description You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
     *  *
     * @param DescribeCloudCenterInstancesRequest $request DescribeCloudCenterInstancesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCloudCenterInstancesResponse DescribeCloudCenterInstancesResponse
     */
    public function describeCloudCenterInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->flags)) {
            $query['Flags'] = $request->flags;
        }
        if (!Utils::isUnset($request->importance)) {
            $query['Importance'] = $request->importance;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->noGroupTrace)) {
            $query['NoGroupTrace'] = $request->noGroupTrace;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->useNextToken)) {
            $query['UseNextToken'] = $request->useNextToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCloudCenterInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCloudCenterInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
     *  *
     * @description You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
     *  *
     * @param DescribeCloudCenterInstancesRequest $request DescribeCloudCenterInstancesRequest
     *
     * @return DescribeCloudCenterInstancesResponse DescribeCloudCenterInstancesResponse
     */
    public function describeCloudCenterInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudCenterInstancesWithOptions($request, $runtime);
    }

    /**
     * @deprecated openAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead
     *  *
     * @summary Queries the statistics of cloud services.
     *  *
     * Deprecated
     *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCloudProductFieldStatisticsResponse DescribeCloudProductFieldStatisticsResponse
     */
    public function describeCloudProductFieldStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeCloudProductFieldStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCloudProductFieldStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated openAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead
     *  *
     * @summary Queries the statistics of cloud services.
     *  *
     * Deprecated
     *
     * @return DescribeCloudProductFieldStatisticsResponse DescribeCloudProductFieldStatisticsResponse
     */
    public function describeCloudProductFieldStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudProductFieldStatisticsWithOptions($runtime);
    }

    /**
     * @summary 查询多云资产配置列表
     *  *
     * @param DescribeCloudVendorAccountAKListRequest $request DescribeCloudVendorAccountAKListRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCloudVendorAccountAKListResponse DescribeCloudVendorAccountAKListResponse
     */
    public function describeCloudVendorAccountAKListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->authIds)) {
            $query['AuthIds'] = $request->authIds;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->subAccountName)) {
            $query['SubAccountName'] = $request->subAccountName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCloudVendorAccountAKList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCloudVendorAccountAKListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询多云资产配置列表
     *  *
     * @param DescribeCloudVendorAccountAKListRequest $request DescribeCloudVendorAccountAKListRequest
     *
     * @return DescribeCloudVendorAccountAKListResponse DescribeCloudVendorAccountAKListResponse
     */
    public function describeCloudVendorAccountAKList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudVendorAccountAKListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an cluster based on the cluster ID.
     *  *
     * @param DescribeClusterBasicInfoRequest $request DescribeClusterBasicInfoRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterBasicInfoResponse DescribeClusterBasicInfoResponse
     */
    public function describeClusterBasicInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterBasicInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterBasicInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an cluster based on the cluster ID.
     *  *
     * @param DescribeClusterBasicInfoRequest $request DescribeClusterBasicInfoRequest
     *
     * @return DescribeClusterBasicInfoResponse DescribeClusterBasicInfoResponse
     */
    public function describeClusterBasicInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterBasicInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistical information about host security.
     *  *
     * @param DescribeClusterHostSecuritySummaryRequest $request DescribeClusterHostSecuritySummaryRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterHostSecuritySummaryResponse DescribeClusterHostSecuritySummaryResponse
     */
    public function describeClusterHostSecuritySummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterHostSecuritySummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterHostSecuritySummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistical information about host security.
     *  *
     * @param DescribeClusterHostSecuritySummaryRequest $request DescribeClusterHostSecuritySummaryRequest
     *
     * @return DescribeClusterHostSecuritySummaryResponse DescribeClusterHostSecuritySummaryResponse
     */
    public function describeClusterHostSecuritySummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterHostSecuritySummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistical information about image security.
     *  *
     * @param DescribeClusterImageSecuritySummaryRequest $request DescribeClusterImageSecuritySummaryRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterImageSecuritySummaryResponse DescribeClusterImageSecuritySummaryResponse
     */
    public function describeClusterImageSecuritySummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->imageRepoName)) {
            $query['ImageRepoName'] = $request->imageRepoName;
        }
        if (!Utils::isUnset($request->imageRepoNamespace)) {
            $query['ImageRepoNamespace'] = $request->imageRepoNamespace;
        }
        if (!Utils::isUnset($request->imageTag)) {
            $query['ImageTag'] = $request->imageTag;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterImageSecuritySummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterImageSecuritySummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistical information about image security.
     *  *
     * @param DescribeClusterImageSecuritySummaryRequest $request DescribeClusterImageSecuritySummaryRequest
     *
     * @return DescribeClusterImageSecuritySummaryResponse DescribeClusterImageSecuritySummaryResponse
     */
    public function describeClusterImageSecuritySummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterImageSecuritySummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a cluster.
     *  *
     * @param DescribeClusterInfoListRequest $request DescribeClusterInfoListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterInfoListResponse DescribeClusterInfoListResponse
     */
    public function describeClusterInfoListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterInfoList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterInfoListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a cluster.
     *  *
     * @param DescribeClusterInfoListRequest $request DescribeClusterInfoListRequest
     *
     * @return DescribeClusterInfoListResponse DescribeClusterInfoListResponse
     */
    public function describeClusterInfoList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterInfoListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the network topology edge by cluster.
     *  *
     * @param DescribeClusterNetworkRequest $request DescribeClusterNetworkRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterNetworkResponse DescribeClusterNetworkResponse
     */
    public function describeClusterNetworkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterNetwork',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the network topology edge by cluster.
     *  *
     * @param DescribeClusterNetworkRequest $request DescribeClusterNetworkRequest
     *
     * @return DescribeClusterNetworkResponse DescribeClusterNetworkResponse
     */
    public function describeClusterNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterNetworkWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
     *  *
     * @param DescribeClusterVulStatisticsRequest $request DescribeClusterVulStatisticsRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterVulStatisticsResponse DescribeClusterVulStatisticsResponse
     */
    public function describeClusterVulStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterVulStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterVulStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
     *  *
     * @param DescribeClusterVulStatisticsRequest $request DescribeClusterVulStatisticsRequest
     *
     * @return DescribeClusterVulStatisticsResponse DescribeClusterVulStatisticsResponse
     */
    public function describeClusterVulStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterVulStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a specified feature.
     *  *
     * @param DescribeCommonOverallConfigRequest $request DescribeCommonOverallConfigRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCommonOverallConfigResponse DescribeCommonOverallConfigResponse
     */
    public function describeCommonOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCommonOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCommonOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a specified feature.
     *  *
     * @param DescribeCommonOverallConfigRequest $request DescribeCommonOverallConfigRequest
     *
     * @return DescribeCommonOverallConfigResponse DescribeCommonOverallConfigResponse
     */
    public function describeCommonOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of features in proactive defense.
     *  *
     * @param DescribeCommonOverallConfigListRequest $request DescribeCommonOverallConfigListRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCommonOverallConfigListResponse DescribeCommonOverallConfigListResponse
     */
    public function describeCommonOverallConfigListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->typeList)) {
            $query['TypeList'] = $request->typeList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCommonOverallConfigList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCommonOverallConfigListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of features in proactive defense.
     *  *
     * @param DescribeCommonOverallConfigListRequest $request DescribeCommonOverallConfigListRequest
     *
     * @return DescribeCommonOverallConfigListResponse DescribeCommonOverallConfigListResponse
     */
    public function describeCommonOverallConfigList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonOverallConfigListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the proactive defense feature.
     *  *
     * @param DescribeCommonTargetConfigRequest $request DescribeCommonTargetConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCommonTargetConfigResponse DescribeCommonTargetConfigResponse
     */
    public function describeCommonTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCommonTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCommonTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the proactive defense feature.
     *  *
     * @param DescribeCommonTargetConfigRequest $request DescribeCommonTargetConfigRequest
     *
     * @return DescribeCommonTargetConfigResponse DescribeCommonTargetConfigResponse
     */
    public function describeCommonTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers based on the specified configuration item.
     *  *
     * @param DescribeCommonTargetResultListRequest $request DescribeCommonTargetResultListRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCommonTargetResultListResponse DescribeCommonTargetResultListResponse
     */
    public function describeCommonTargetResultListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCommonTargetResultList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCommonTargetResultListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers based on the specified configuration item.
     *  *
     * @param DescribeCommonTargetResultListRequest $request DescribeCommonTargetResultListRequest
     *
     * @return DescribeCommonTargetResultListResponse DescribeCommonTargetResultListResponse
     */
    public function describeCommonTargetResultList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonTargetResultListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the priorities to fix vulnerabilities.
     *  *
     * @param DescribeConcernNecessityRequest $request DescribeConcernNecessityRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeConcernNecessityResponse DescribeConcernNecessityResponse
     */
    public function describeConcernNecessityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeConcernNecessity',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeConcernNecessityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the priorities to fix vulnerabilities.
     *  *
     * @param DescribeConcernNecessityRequest $request DescribeConcernNecessityRequest
     *
     * @return DescribeConcernNecessityResponse DescribeConcernNecessityResponse
     */
    public function describeConcernNecessity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeConcernNecessityWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a containerized application.
     *  *
     * @param DescribeContainerAppsRequest $request DescribeContainerAppsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerAppsResponse DescribeContainerAppsResponse
     */
    public function describeContainerAppsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerApps',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerAppsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a containerized application.
     *  *
     * @param DescribeContainerAppsRequest $request DescribeContainerAppsRequest
     *
     * @return DescribeContainerAppsResponse DescribeContainerAppsResponse
     */
    public function describeContainerApps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerAppsWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the filter conditions that you can use to filter the containers.
     *  *
     * @param DescribeContainerCriteriaRequest $request DescribeContainerCriteriaRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerCriteriaResponse DescribeContainerCriteriaResponse
     */
    public function describeContainerCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupField)) {
            $query['GroupField'] = $request->groupField;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the filter conditions that you can use to filter the containers.
     *  *
     * @param DescribeContainerCriteriaRequest $request DescribeContainerCriteriaRequest
     *
     * @return DescribeContainerCriteriaResponse DescribeContainerCriteriaResponse
     */
    public function describeContainerCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistical information about containers.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerFieldStatisticsResponse DescribeContainerFieldStatisticsResponse
     */
    public function describeContainerFieldStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeContainerFieldStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerFieldStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistical information about containers.
     *  *
     * @return DescribeContainerFieldStatisticsResponse DescribeContainerFieldStatisticsResponse
     */
    public function describeContainerFieldStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerFieldStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries the attribute details of containers.
     *  *
     * @param DescribeContainerGroupedFieldDetailRequest $request DescribeContainerGroupedFieldDetailRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerGroupedFieldDetailResponse DescribeContainerGroupedFieldDetailResponse
     */
    public function describeContainerGroupedFieldDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->groupField)) {
            $query['GroupField'] = $request->groupField;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerGroupedFieldDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerGroupedFieldDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the attribute details of containers.
     *  *
     * @param DescribeContainerGroupedFieldDetailRequest $request DescribeContainerGroupedFieldDetailRequest
     *
     * @return DescribeContainerGroupedFieldDetailResponse DescribeContainerGroupedFieldDetailResponse
     */
    public function describeContainerGroupedFieldDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerGroupedFieldDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about containers.
     *  *
     * @param DescribeContainerInstancesRequest $request DescribeContainerInstancesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerInstancesResponse DescribeContainerInstancesResponse
     */
    public function describeContainerInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about containers.
     *  *
     * @param DescribeContainerInstancesRequest $request DescribeContainerInstancesRequest
     *
     * @return DescribeContainerInstancesResponse DescribeContainerInstancesResponse
     */
    public function describeContainerInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the vulnerability scan of one or more running container applications.
     *  *
     * @param DescribeContainerScanConfigRequest $request DescribeContainerScanConfigRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerScanConfigResponse DescribeContainerScanConfigResponse
     */
    public function describeContainerScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the vulnerability scan of one or more running container applications.
     *  *
     * @param DescribeContainerScanConfigRequest $request DescribeContainerScanConfigRequest
     *
     * @return DescribeContainerScanConfigResponse DescribeContainerScanConfigResponse
     */
    public function describeContainerScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the Kritis status of a Container Service for Kubernetes (ACK) cluster.
     *  *
     * @param DescribeContainerServiceK8sClusterKritisStatusRequest $request DescribeContainerServiceK8sClusterKritisStatusRequest
     * @param RuntimeOptions                                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerServiceK8sClusterKritisStatusResponse DescribeContainerServiceK8sClusterKritisStatusResponse
     */
    public function describeContainerServiceK8sClusterKritisStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerServiceK8sClusterKritisStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerServiceK8sClusterKritisStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the Kritis status of a Container Service for Kubernetes (ACK) cluster.
     *  *
     * @param DescribeContainerServiceK8sClusterKritisStatusRequest $request DescribeContainerServiceK8sClusterKritisStatusRequest
     *
     * @return DescribeContainerServiceK8sClusterKritisStatusResponse DescribeContainerServiceK8sClusterKritisStatusResponse
     */
    public function describeContainerServiceK8sClusterKritisStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerServiceK8sClusterKritisStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the namespace of a Container Service for Kubernetes (ACK) cluster.
     *  *
     * @param DescribeContainerServiceK8sClusterNamespacesRequest $request DescribeContainerServiceK8sClusterNamespacesRequest
     * @param RuntimeOptions                                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerServiceK8sClusterNamespacesResponse DescribeContainerServiceK8sClusterNamespacesResponse
     */
    public function describeContainerServiceK8sClusterNamespacesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerServiceK8sClusterNamespaces',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerServiceK8sClusterNamespacesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the namespace of a Container Service for Kubernetes (ACK) cluster.
     *  *
     * @param DescribeContainerServiceK8sClusterNamespacesRequest $request DescribeContainerServiceK8sClusterNamespacesRequest
     *
     * @return DescribeContainerServiceK8sClusterNamespacesResponse DescribeContainerServiceK8sClusterNamespacesResponse
     */
    public function describeContainerServiceK8sClusterNamespaces($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerServiceK8sClusterNamespacesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of Container Service for Kubernetes (ACK) clusters.
     *  *
     * @param DescribeContainerServiceK8sClustersRequest $request DescribeContainerServiceK8sClustersRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerServiceK8sClustersResponse DescribeContainerServiceK8sClustersResponse
     */
    public function describeContainerServiceK8sClustersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerServiceK8sClusters',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerServiceK8sClustersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of Container Service for Kubernetes (ACK) clusters.
     *  *
     * @param DescribeContainerServiceK8sClustersRequest $request DescribeContainerServiceK8sClustersRequest
     *
     * @return DescribeContainerServiceK8sClustersResponse DescribeContainerServiceK8sClustersResponse
     */
    public function describeContainerServiceK8sClusters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerServiceK8sClustersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alert statistics on container assets.
     *  *
     * @description Only users who created a Container Registry Enterprise Edition instance can call this operation.
     *  *
     * @param DescribeContainerStatisticsRequest $request DescribeContainerStatisticsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerStatisticsResponse DescribeContainerStatisticsResponse
     */
    public function describeContainerStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert statistics on container assets.
     *  *
     * @description Only users who created a Container Registry Enterprise Edition instance can call this operation.
     *  *
     * @param DescribeContainerStatisticsRequest $request DescribeContainerStatisticsRequest
     *
     * @return DescribeContainerStatisticsResponse DescribeContainerStatisticsResponse
     */
    public function describeContainerStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of container assets by using an attribute.
     *  *
     * @param DescribeContainerTagsRequest $request DescribeContainerTagsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerTagsResponse DescribeContainerTagsResponse
     */
    public function describeContainerTagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldName)) {
            $query['FieldName'] = $request->fieldName;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerTags',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of container assets by using an attribute.
     *  *
     * @param DescribeContainerTagsRequest $request DescribeContainerTagsRequest
     *
     * @return DescribeContainerTagsResponse DescribeContainerTagsResponse
     */
    public function describeContainerTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerTagsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of images that are not scanned.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCountNotScannedImageResponse DescribeCountNotScannedImageResponse
     */
    public function describeCountNotScannedImageWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeCountNotScannedImage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCountNotScannedImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of images that are not scanned.
     *  *
     * @return DescribeCountNotScannedImageResponse DescribeCountNotScannedImageResponse
     */
    public function describeCountNotScannedImage()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCountNotScannedImageWithOptions($runtime);
    }

    /**
     * @summary Queries the number of images that are scanned.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCountScannedImageResponse DescribeCountScannedImageResponse
     */
    public function describeCountScannedImageWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeCountScannedImage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCountScannedImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of images that are scanned.
     *  *
     * @return DescribeCountScannedImageResponse DescribeCountScannedImageResponse
     */
    public function describeCountScannedImage()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCountScannedImageWithOptions($runtime);
    }

    /**
     * @summary Queries the filter conditions that are used to search for assets in fuzzy match mode.
     *  *
     * @param DescribeCriteriaRequest $request DescribeCriteriaRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCriteriaResponse DescribeCriteriaResponse
     */
    public function describeCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->supportAutoTag)) {
            $query['SupportAutoTag'] = $request->supportAutoTag;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the filter conditions that are used to search for assets in fuzzy match mode.
     *  *
     * @param DescribeCriteriaRequest $request DescribeCriteriaRequest
     *
     * @return DescribeCriteriaResponse DescribeCriteriaResponse
     */
    public function describeCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
     *  *
     * @param DescribeCustomBlockInstancesRequest $request DescribeCustomBlockInstancesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomBlockInstancesResponse DescribeCustomBlockInstancesResponse
     */
    public function describeCustomBlockInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomBlockInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomBlockInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
     *  *
     * @param DescribeCustomBlockInstancesRequest $request DescribeCustomBlockInstancesRequest
     *
     * @return DescribeCustomBlockInstancesResponse DescribeCustomBlockInstancesResponse
     */
    public function describeCustomBlockInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomBlockInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the defense rules against brute-force attacks that are applied to one or more servers.
     *  *
     * @param DescribeCustomBlockRecordsRequest $request DescribeCustomBlockRecordsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomBlockRecordsResponse DescribeCustomBlockRecordsResponse
     */
    public function describeCustomBlockRecordsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomBlockRecords',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomBlockRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the defense rules against brute-force attacks that are applied to one or more servers.
     *  *
     * @param DescribeCustomBlockRecordsRequest $request DescribeCustomBlockRecordsRequest
     *
     * @return DescribeCustomBlockRecordsResponse DescribeCustomBlockRecordsResponse
     */
    public function describeCustomBlockRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomBlockRecordsWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the configurations of a security report.
     *  *
     * @param DescribeCustomizeReportConfigDetailRequest $request DescribeCustomizeReportConfigDetailRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomizeReportConfigDetailResponse DescribeCustomizeReportConfigDetailResponse
     */
    public function describeCustomizeReportConfigDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomizeReportConfigDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomizeReportConfigDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the configurations of a security report.
     *  *
     * @param DescribeCustomizeReportConfigDetailRequest $request DescribeCustomizeReportConfigDetailRequest
     *
     * @return DescribeCustomizeReportConfigDetailResponse DescribeCustomizeReportConfigDetailResponse
     */
    public function describeCustomizeReportConfigDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomizeReportConfigDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries security reports.
     *  *
     * @param DescribeCustomizeReportListRequest $request DescribeCustomizeReportListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomizeReportListResponse DescribeCustomizeReportListResponse
     */
    public function describeCustomizeReportListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pinned)) {
            $query['Pinned'] = $request->pinned;
        }
        if (!Utils::isUnset($request->reportStatus)) {
            $query['ReportStatus'] = $request->reportStatus;
        }
        if (!Utils::isUnset($request->reportType)) {
            $query['ReportType'] = $request->reportType;
        }
        if (!Utils::isUnset($request->reportVersion)) {
            $query['ReportVersion'] = $request->reportVersion;
        }
        if (!Utils::isUnset($request->title)) {
            $query['Title'] = $request->title;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomizeReportList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomizeReportListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries security reports.
     *  *
     * @param DescribeCustomizeReportListRequest $request DescribeCustomizeReportListRequest
     *
     * @return DescribeCustomizeReportListResponse DescribeCustomizeReportListResponse
     */
    public function describeCustomizeReportList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomizeReportListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the Object Storage Service (OSS) information of the file that is uploaded to create custom weak password rules.
     *  *
     * @param DescribeCustomizedDictUploadInfoRequest $request DescribeCustomizedDictUploadInfoRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomizedDictUploadInfoResponse DescribeCustomizedDictUploadInfoResponse
     */
    public function describeCustomizedDictUploadInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomizedDictUploadInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomizedDictUploadInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the Object Storage Service (OSS) information of the file that is uploaded to create custom weak password rules.
     *  *
     * @param DescribeCustomizedDictUploadInfoRequest $request DescribeCustomizedDictUploadInfoRequest
     *
     * @return DescribeCustomizedDictUploadInfoResponse DescribeCustomizedDictUploadInfoResponse
     */
    public function describeCustomizedDictUploadInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomizedDictUploadInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers to which custom policies are applied.
     *  *
     * @param DescribeCustomizedStrategyTargetsRequest $request DescribeCustomizedStrategyTargetsRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomizedStrategyTargetsResponse DescribeCustomizedStrategyTargetsResponse
     */
    public function describeCustomizedStrategyTargetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomizedStrategyTargets',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomizedStrategyTargetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers to which custom policies are applied.
     *  *
     * @param DescribeCustomizedStrategyTargetsRequest $request DescribeCustomizedStrategyTargetsRequest
     *
     * @return DescribeCustomizedStrategyTargetsResponse DescribeCustomizedStrategyTargetsResponse
     */
    public function describeCustomizedStrategyTargets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomizedStrategyTargetsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
     *  *
     * @param DescribeCycleTaskListRequest $request DescribeCycleTaskListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCycleTaskListResponse DescribeCycleTaskListResponse
     */
    public function describeCycleTaskListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCycleTaskList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCycleTaskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
     *  *
     * @param DescribeCycleTaskListRequest $request DescribeCycleTaskListRequest
     *
     * @return DescribeCycleTaskListResponse DescribeCycleTaskListResponse
     */
    public function describeCycleTaskList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCycleTaskListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询操作审计数据源
     *  *
     * @param DescribeDataSourceRequest $request DescribeDataSourceRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDataSourceResponse DescribeDataSourceResponse
     */
    public function describeDataSourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configType)) {
            $query['ConfigType'] = $request->configType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDataSource',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询操作审计数据源
     *  *
     * @param DescribeDataSourceRequest $request DescribeDataSourceRequest
     *
     * @return DescribeDataSourceResponse DescribeDataSourceResponse
     */
    public function describeDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDataSourceWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the keywords of a custom dictionary that is generated by using weak passwords.
     *  *
     * @param DescribeDefaultKeyInfoRequest $request DescribeDefaultKeyInfoRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDefaultKeyInfoResponse DescribeDefaultKeyInfoResponse
     */
    public function describeDefaultKeyInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDefaultKeyInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDefaultKeyInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the keywords of a custom dictionary that is generated by using weak passwords.
     *  *
     * @param DescribeDefaultKeyInfoRequest $request DescribeDefaultKeyInfoRequest
     *
     * @return DescribeDefaultKeyInfoResponse DescribeDefaultKeyInfoResponse
     */
    public function describeDefaultKeyInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDefaultKeyInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDefaultProxyInstallVersionResponse DescribeDefaultProxyInstallVersionResponse
     */
    public function describeDefaultProxyInstallVersionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeDefaultProxyInstallVersion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDefaultProxyInstallVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
     *  *
     * @return DescribeDefaultProxyInstallVersionResponse DescribeDefaultProxyInstallVersionResponse
     */
    public function describeDefaultProxyInstallVersion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDefaultProxyInstallVersionWithOptions($runtime);
    }

    /**
     * @summary Obtains DingTalk notifications.
     *  *
     * @param DescribeDingTalkRequest $request DescribeDingTalkRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDingTalkResponse DescribeDingTalkResponse
     */
    public function describeDingTalkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleActionName)) {
            $query['RuleActionName'] = $request->ruleActionName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDingTalk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDingTalkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains DingTalk notifications.
     *  *
     * @param DescribeDingTalkRequest $request DescribeDingTalkRequest
     *
     * @return DescribeDingTalkResponse DescribeDingTalkResponse
     */
    public function describeDingTalk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDingTalkWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainCountRequest $request DescribeDomainCountRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainCountResponse DescribeDomainCountResponse
     */
    public function describeDomainCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainCountRequest $request DescribeDomainCountRequest
     *
     * @return DescribeDomainCountResponse DescribeDomainCountResponse
     */
    public function describeDomainCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainDetailRequest $request DescribeDomainDetailRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainDetailResponse DescribeDomainDetailResponse
     */
    public function describeDomainDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainDetailRequest $request DescribeDomainDetailRequest
     *
     * @return DescribeDomainDetailResponse DescribeDomainDetailResponse
     */
    public function describeDomainDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainListRequest $request DescribeDomainListRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainListResponse DescribeDomainListResponse
     */
    public function describeDomainListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->domainType)) {
            $query['DomainType'] = $request->domainType;
        }
        if (!Utils::isUnset($request->fuzzyDomain)) {
            $query['FuzzyDomain'] = $request->fuzzyDomain;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainListRequest $request DescribeDomainListRequest
     *
     * @return DescribeDomainListResponse DescribeDomainListResponse
     */
    public function describeDomainList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询网络安全报告-安全告警
     *  *
     * @param DescribeDomainSecureAlarmListRequest $request DescribeDomainSecureAlarmListRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainSecureAlarmListResponse DescribeDomainSecureAlarmListResponse
     */
    public function describeDomainSecureAlarmListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainSecureAlarmList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainSecureAlarmListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询网络安全报告-安全告警
     *  *
     * @param DescribeDomainSecureAlarmListRequest $request DescribeDomainSecureAlarmListRequest
     *
     * @return DescribeDomainSecureAlarmListResponse DescribeDomainSecureAlarmListResponse
     */
    public function describeDomainSecureAlarmList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureAlarmListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询网络安全报告-存在风险的网站
     *  *
     * @param DescribeDomainSecureRiskListRequest $request DescribeDomainSecureRiskListRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainSecureRiskListResponse DescribeDomainSecureRiskListResponse
     */
    public function describeDomainSecureRiskListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainSecureRiskList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainSecureRiskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询网络安全报告-存在风险的网站
     *  *
     * @param DescribeDomainSecureRiskListRequest $request DescribeDomainSecureRiskListRequest
     *
     * @return DescribeDomainSecureRiskListResponse DescribeDomainSecureRiskListResponse
     */
    public function describeDomainSecureRiskList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureRiskListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询网络安全报告的安全分
     *  *
     * @param DescribeDomainSecureScoreRequest $request DescribeDomainSecureScoreRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainSecureScoreResponse DescribeDomainSecureScoreResponse
     */
    public function describeDomainSecureScoreWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainSecureScore',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainSecureScoreResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询网络安全报告的安全分
     *  *
     * @param DescribeDomainSecureScoreRequest $request DescribeDomainSecureScoreRequest
     *
     * @return DescribeDomainSecureScoreResponse DescribeDomainSecureScoreResponse
     */
    public function describeDomainSecureScore($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureScoreWithOptions($request, $runtime);
    }

    /**
     * @summary 查询网络安全报告- 统计值
     *  *
     * @param DescribeDomainSecureStatisticsRequest $request DescribeDomainSecureStatisticsRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainSecureStatisticsResponse DescribeDomainSecureStatisticsResponse
     */
    public function describeDomainSecureStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainSecureStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainSecureStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询网络安全报告- 统计值
     *  *
     * @param DescribeDomainSecureStatisticsRequest $request DescribeDomainSecureStatisticsRequest
     *
     * @return DescribeDomainSecureStatisticsResponse DescribeDomainSecureStatisticsResponse
     */
    public function describeDomainSecureStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary 查询网络安全报告-漏洞
     *  *
     * @param DescribeDomainSecureVulListRequest $request DescribeDomainSecureVulListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainSecureVulListResponse DescribeDomainSecureVulListResponse
     */
    public function describeDomainSecureVulListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainSecureVulList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainSecureVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询网络安全报告-漏洞
     *  *
     * @param DescribeDomainSecureVulListRequest $request DescribeDomainSecureVulListRequest
     *
     * @return DescribeDomainSecureVulListResponse DescribeDomainSecureVulListResponse
     */
    public function describeDomainSecureVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainSecureVulListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries custom weak password rules for the baseline check feature.
     *  *
     * @param DescribeDynamicDictRequest $request DescribeDynamicDictRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDynamicDictResponse DescribeDynamicDictResponse
     */
    public function describeDynamicDictWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDynamicDict',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDynamicDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries custom weak password rules for the baseline check feature.
     *  *
     * @param DescribeDynamicDictRequest $request DescribeDynamicDictRequest
     *
     * @return DescribeDynamicDictResponse DescribeDynamicDictResponse
     */
    public function describeDynamicDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDynamicDictWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an uploaded Object Storage Service (OSS) object that contains custom weak passwords and is used for baseline checks.
     *  *
     * @param DescribeDynamicDictUploadInfoRequest $request DescribeDynamicDictUploadInfoRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDynamicDictUploadInfoResponse DescribeDynamicDictUploadInfoResponse
     */
    public function describeDynamicDictUploadInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDynamicDictUploadInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDynamicDictUploadInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an uploaded Object Storage Service (OSS) object that contains custom weak passwords and is used for baseline checks.
     *  *
     * @param DescribeDynamicDictUploadInfoRequest $request DescribeDynamicDictUploadInfoRequest
     *
     * @return DescribeDynamicDictUploadInfoResponse DescribeDynamicDictUploadInfoResponse
     */
    public function describeDynamicDictUploadInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDynamicDictUploadInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether Security Center is authorized to scan for urgent vulnerabilities.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEmgUserAgreementResponse DescribeEmgUserAgreementResponse
     */
    public function describeEmgUserAgreementWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeEmgUserAgreement',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEmgUserAgreementResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether Security Center is authorized to scan for urgent vulnerabilities.
     *  *
     * @return DescribeEmgUserAgreementResponse DescribeEmgUserAgreementResponse
     */
    public function describeEmgUserAgreement()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEmgUserAgreementWithOptions($runtime);
    }

    /**
     * @summary Queries the details of urgent vulnerabilities.
     *  *
     * @param DescribeEmgVulItemRequest $request DescribeEmgVulItemRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEmgVulItemResponse DescribeEmgVulItemResponse
     */
    public function describeEmgVulItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkType)) {
            $query['CheckType'] = $request->checkType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskStatus)) {
            $query['RiskStatus'] = $request->riskStatus;
        }
        if (!Utils::isUnset($request->scanType)) {
            $query['ScanType'] = $request->scanType;
        }
        if (!Utils::isUnset($request->vulName)) {
            $query['VulName'] = $request->vulName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEmgVulItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEmgVulItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of urgent vulnerabilities.
     *  *
     * @param DescribeEmgVulItemRequest $request DescribeEmgVulItemRequest
     *
     * @return DescribeEmgVulItemResponse DescribeEmgVulItemResponse
     */
    public function describeEmgVulItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEmgVulItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of alert events by risk level.
     *  *
     * @param DescribeEventLevelCountRequest $request DescribeEventLevelCountRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEventLevelCountResponse DescribeEventLevelCountResponse
     */
    public function describeEventLevelCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->containerIds)) {
            $query['ContainerIds'] = $request->containerIds;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->multiAccountActionType)) {
            $query['MultiAccountActionType'] = $request->multiAccountActionType;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEventLevelCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEventLevelCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of alert events by risk level.
     *  *
     * @param DescribeEventLevelCountRequest $request DescribeEventLevelCountRequest
     *
     * @return DescribeEventLevelCountResponse DescribeEventLevelCountResponse
     */
    public function describeEventLevelCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEventLevelCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the platforms that are supported by the feature of container threat detection.
     *  *
     * @param DescribeEventOnStageRequest $request DescribeEventOnStageRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEventOnStageResponse DescribeEventOnStageResponse
     */
    public function describeEventOnStageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEventOnStage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEventOnStageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the platforms that are supported by the feature of container threat detection.
     *  *
     * @param DescribeEventOnStageRequest $request DescribeEventOnStageRequest
     *
     * @return DescribeEventOnStageResponse DescribeEventOnStageResponse
     */
    public function describeEventOnStage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEventOnStageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the directories that are excluded from anti-ransomware.
     *  *
     * @param DescribeExcludeSystemPathRequest $request DescribeExcludeSystemPathRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExcludeSystemPathResponse DescribeExcludeSystemPathResponse
     */
    public function describeExcludeSystemPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExcludeSystemPath',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExcludeSystemPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the directories that are excluded from anti-ransomware.
     *  *
     * @param DescribeExcludeSystemPathRequest $request DescribeExcludeSystemPathRequest
     *
     * @return DescribeExcludeSystemPathResponse DescribeExcludeSystemPathResponse
     */
    public function describeExcludeSystemPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExcludeSystemPathWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a task that exports your assets to an Excel file.
     *  *
     * @param DescribeExportInfoRequest $request DescribeExportInfoRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExportInfoResponse DescribeExportInfoResponse
     */
    public function describeExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a task that exports your assets to an Excel file.
     *  *
     * @param DescribeExportInfoRequest $request DescribeExportInfoRequest
     *
     * @return DescribeExportInfoResponse DescribeExportInfoResponse
     */
    public function describeExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the weak password-related risks of a specified server that is exposed on the Internet.
     *  *
     * @param DescribeExposedCheckWarningRequest $request DescribeExposedCheckWarningRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedCheckWarningResponse DescribeExposedCheckWarningResponse
     */
    public function describeExposedCheckWarningWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->typeName)) {
            $query['TypeName'] = $request->typeName;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedCheckWarning',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedCheckWarningResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the weak password-related risks of a specified server that is exposed on the Internet.
     *  *
     * @param DescribeExposedCheckWarningRequest $request DescribeExposedCheckWarningRequest
     *
     * @return DescribeExposedCheckWarningResponse DescribeExposedCheckWarningResponse
     */
    public function describeExposedCheckWarning($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedCheckWarningWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the search conditions that are used to search for exposed assets.
     *  *
     * @param DescribeExposedInstanceCriteriaRequest $request DescribeExposedInstanceCriteriaRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedInstanceCriteriaResponse DescribeExposedInstanceCriteriaResponse
     */
    public function describeExposedInstanceCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedInstanceCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedInstanceCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the search conditions that are used to search for exposed assets.
     *  *
     * @param DescribeExposedInstanceCriteriaRequest $request DescribeExposedInstanceCriteriaRequest
     *
     * @return DescribeExposedInstanceCriteriaResponse DescribeExposedInstanceCriteriaResponse
     */
    public function describeExposedInstanceCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedInstanceCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a specified server that is exposed on the Internet.
     *  *
     * @param DescribeExposedInstanceDetailRequest $request DescribeExposedInstanceDetailRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedInstanceDetailResponse DescribeExposedInstanceDetailResponse
     */
    public function describeExposedInstanceDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedInstanceDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedInstanceDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a specified server that is exposed on the Internet.
     *  *
     * @param DescribeExposedInstanceDetailRequest $request DescribeExposedInstanceDetailRequest
     *
     * @return DescribeExposedInstanceDetailResponse DescribeExposedInstanceDetailResponse
     */
    public function describeExposedInstanceDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedInstanceDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers that are exposed on the Internet.
     *  *
     * @param DescribeExposedInstanceListRequest $request DescribeExposedInstanceListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedInstanceListResponse DescribeExposedInstanceListResponse
     */
    public function describeExposedInstanceListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        if (!Utils::isUnset($request->cspmStatus)) {
            $query['CspmStatus'] = $request->cspmStatus;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->exposureComponent)) {
            $query['ExposureComponent'] = $request->exposureComponent;
        }
        if (!Utils::isUnset($request->exposureIp)) {
            $query['ExposureIp'] = $request->exposureIp;
        }
        if (!Utils::isUnset($request->exposurePort)) {
            $query['ExposurePort'] = $request->exposurePort;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->healthStatus)) {
            $query['HealthStatus'] = $request->healthStatus;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceName)) {
            $query['InstanceName'] = $request->instanceName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->vulStatus)) {
            $query['VulStatus'] = $request->vulStatus;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedInstanceList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedInstanceListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers that are exposed on the Internet.
     *  *
     * @param DescribeExposedInstanceListRequest $request DescribeExposedInstanceListRequest
     *
     * @return DescribeExposedInstanceListResponse DescribeExposedInstanceListResponse
     */
    public function describeExposedInstanceList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedInstanceListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the exposure statistics of the assets on the Internet.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedStatisticsResponse DescribeExposedStatisticsResponse
     */
    public function describeExposedStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeExposedStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the exposure statistics of the assets on the Internet.
     *  *
     * @return DescribeExposedStatisticsResponse DescribeExposedStatisticsResponse
     */
    public function describeExposedStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
     *  *
     * @param DescribeExposedStatisticsDetailRequest $request DescribeExposedStatisticsDetailRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedStatisticsDetailResponse DescribeExposedStatisticsDetailResponse
     */
    public function describeExposedStatisticsDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->statisticsType)) {
            $query['StatisticsType'] = $request->statisticsType;
        }
        if (!Utils::isUnset($request->statisticsTypeGatewayType)) {
            $query['StatisticsTypeGatewayType'] = $request->statisticsTypeGatewayType;
        }
        if (!Utils::isUnset($request->statisticsTypeInstanceValue)) {
            $query['StatisticsTypeInstanceValue'] = $request->statisticsTypeInstanceValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedStatisticsDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedStatisticsDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
     *  *
     * @param DescribeExposedStatisticsDetailRequest $request DescribeExposedStatisticsDetailRequest
     *
     * @return DescribeExposedStatisticsDetailResponse DescribeExposedStatisticsDetailResponse
     */
    public function describeExposedStatisticsDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedStatisticsDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of servers.
     *  *
     * @param DescribeFieldStatisticsRequest $request DescribeFieldStatisticsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeFieldStatisticsResponse DescribeFieldStatisticsResponse
     */
    public function describeFieldStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeFieldStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeFieldStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of servers.
     *  *
     * @param DescribeFieldStatisticsRequest $request DescribeFieldStatisticsRequest
     *
     * @return DescribeFieldStatisticsResponse DescribeFieldStatisticsResponse
     */
    public function describeFieldStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFieldStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeFixUsedCountResponse DescribeFixUsedCountResponse
     */
    public function describeFixUsedCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeFixUsedCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeFixUsedCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
     *  *
     * @return DescribeFixUsedCountResponse DescribeFixUsedCountResponse
     */
    public function describeFixUsedCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFixUsedCountWithOptions($runtime);
    }

    /**
     * @summary Queries the pre-patches that are required to fix a specified Windows system vulnerability.
     *  *
     * @param DescribeFrontVulPatchListRequest $request DescribeFrontVulPatchListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeFrontVulPatchListResponse DescribeFrontVulPatchListResponse
     */
    public function describeFrontVulPatchListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->info)) {
            $query['Info'] = $request->info;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeFrontVulPatchList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeFrontVulPatchListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the pre-patches that are required to fix a specified Windows system vulnerability.
     *  *
     * @param DescribeFrontVulPatchListRequest $request DescribeFrontVulPatchListRequest
     *
     * @return DescribeFrontVulPatchListResponse DescribeFrontVulPatchListResponse
     */
    public function describeFrontVulPatchList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFrontVulPatchListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the structure of a group.
     *  *
     * @param DescribeGroupStructRequest $request DescribeGroupStructRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupStructResponse DescribeGroupStructResponse
     */
    public function describeGroupStructWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupStruct',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupStructResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the structure of a group.
     *  *
     * @param DescribeGroupStructRequest $request DescribeGroupStructRequest
     *
     * @return DescribeGroupStructResponse DescribeGroupStructResponse
     */
    public function describeGroupStruct($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupStructWithOptions($request, $runtime);
    }

    /**
     * @summary Queries containers by group type.
     *  *
     * @param DescribeGroupedContainerInstancesRequest $request DescribeGroupedContainerInstancesRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedContainerInstancesResponse DescribeGroupedContainerInstancesResponse
     */
    public function describeGroupedContainerInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->groupField)) {
            $query['GroupField'] = $request->groupField;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedContainerInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedContainerInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries containers by group type.
     *  *
     * @param DescribeGroupedContainerInstancesRequest $request DescribeGroupedContainerInstancesRequest
     *
     * @return DescribeGroupedContainerInstancesResponse DescribeGroupedContainerInstancesResponse
     */
    public function describeGroupedContainerInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedContainerInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistical information about assets based on a specified filter condition.
     *  *
     * @param DescribeGroupedInstancesRequest $request DescribeGroupedInstancesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedInstancesResponse DescribeGroupedInstancesResponse
     */
    public function describeGroupedInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->groupField)) {
            $query['GroupField'] = $request->groupField;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->noPage)) {
            $query['NoPage'] = $request->noPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->saleVersionCheckCode)) {
            $query['SaleVersionCheckCode'] = $request->saleVersionCheckCode;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistical information about assets based on a specified filter condition.
     *  *
     * @param DescribeGroupedInstancesRequest $request DescribeGroupedInstancesRequest
     *
     * @return DescribeGroupedInstancesResponse DescribeGroupedInstancesResponse
     */
    public function describeGroupedInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of malicious image samples.
     *  *
     * @param DescribeGroupedMaliciousFilesRequest $request DescribeGroupedMaliciousFilesRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedMaliciousFilesResponse DescribeGroupedMaliciousFilesResponse
     */
    public function describeGroupedMaliciousFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fuzzyMaliciousName)) {
            $query['FuzzyMaliciousName'] = $request->fuzzyMaliciousName;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->imageLayer)) {
            $query['ImageLayer'] = $request->imageLayer;
        }
        if (!Utils::isUnset($request->imageTag)) {
            $query['ImageTag'] = $request->imageTag;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->maliciousMd5)) {
            $query['MaliciousMd5'] = $request->maliciousMd5;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedMaliciousFiles',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedMaliciousFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of malicious image samples.
     *  *
     * @param DescribeGroupedMaliciousFilesRequest $request DescribeGroupedMaliciousFilesRequest
     *
     * @return DescribeGroupedMaliciousFilesResponse DescribeGroupedMaliciousFilesResponse
     */
    public function describeGroupedMaliciousFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedMaliciousFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of asset tags.
     *  *
     * @param DescribeGroupedTagsRequest $request DescribeGroupedTagsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedTagsResponse DescribeGroupedTagsResponse
     */
    public function describeGroupedTagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedTags',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of asset tags.
     *  *
     * @param DescribeGroupedTagsRequest $request DescribeGroupedTagsRequest
     *
     * @return DescribeGroupedTagsResponse DescribeGroupedTagsResponse
     */
    public function describeGroupedTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedTagsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries vulnerabilities by group.
     *  *
     * @param DescribeGroupedVulRequest $request DescribeGroupedVulRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedVulResponse DescribeGroupedVulResponse
     */
    public function describeGroupedVulWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        if (!Utils::isUnset($request->attachTypes)) {
            $query['AttachTypes'] = $request->attachTypes;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->searchTags)) {
            $query['SearchTags'] = $request->searchTags;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedVul',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries vulnerabilities by group.
     *  *
     * @param DescribeGroupedVulRequest $request DescribeGroupedVulRequest
     *
     * @return DescribeGroupedVulResponse DescribeGroupedVulResponse
     */
    public function describeGroupedVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedVulWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
     *  *
     * @param DescribeHcExportInfoRequest $request DescribeHcExportInfoRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHcExportInfoResponse DescribeHcExportInfoResponse
     */
    public function describeHcExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHcExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHcExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
     *  *
     * @param DescribeHcExportInfoRequest $request DescribeHcExportInfoRequest
     *
     * @return DescribeHcExportInfoResponse DescribeHcExportInfoResponse
     */
    public function describeHcExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHcExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries statistics on the quota of honeypots.
     *  *
     * @param DescribeHoneyPotAuthRequest $request DescribeHoneyPotAuthRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHoneyPotAuthResponse DescribeHoneyPotAuthResponse
     */
    public function describeHoneyPotAuthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHoneyPotAuth',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHoneyPotAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries statistics on the quota of honeypots.
     *  *
     * @param DescribeHoneyPotAuthRequest $request DescribeHoneyPotAuthRequest
     *
     * @return DescribeHoneyPotAuthResponse DescribeHoneyPotAuthResponse
     */
    public function describeHoneyPotAuth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHoneyPotAuthWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
     *  *
     * @param DescribeHoneyPotSuspStatisticsRequest $request DescribeHoneyPotSuspStatisticsRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHoneyPotSuspStatisticsResponse DescribeHoneyPotSuspStatisticsResponse
     */
    public function describeHoneyPotSuspStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->statisticsDays)) {
            $query['StatisticsDays'] = $request->statisticsDays;
        }
        if (!Utils::isUnset($request->statisticsKeyType)) {
            $query['StatisticsKeyType'] = $request->statisticsKeyType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHoneyPotSuspStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHoneyPotSuspStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
     *  *
     * @param DescribeHoneyPotSuspStatisticsRequest $request DescribeHoneyPotSuspStatisticsRequest
     *
     * @return DescribeHoneyPotSuspStatisticsResponse DescribeHoneyPotSuspStatisticsResponse
     */
    public function describeHoneyPotSuspStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHoneyPotSuspStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary 查询代理集群列表
     *  *
     * @param DescribeHybridProxyClusterListRequest $request DescribeHybridProxyClusterListRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHybridProxyClusterListResponse DescribeHybridProxyClusterListResponse
     */
    public function describeHybridProxyClusterListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHybridProxyClusterList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHybridProxyClusterListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询代理集群列表
     *  *
     * @param DescribeHybridProxyClusterListRequest $request DescribeHybridProxyClusterListRequest
     *
     * @return DescribeHybridProxyClusterListResponse DescribeHybridProxyClusterListResponse
     */
    public function describeHybridProxyClusterList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHybridProxyClusterListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询代理连接的客户端
     *  *
     * @param DescribeHybridProxyLinkedClientListRequest $request DescribeHybridProxyLinkedClientListRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHybridProxyLinkedClientListResponse DescribeHybridProxyLinkedClientListResponse
     */
    public function describeHybridProxyLinkedClientListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->proxyUuid)) {
            $query['ProxyUuid'] = $request->proxyUuid;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHybridProxyLinkedClientList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHybridProxyLinkedClientListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询代理连接的客户端
     *  *
     * @param DescribeHybridProxyLinkedClientListRequest $request DescribeHybridProxyLinkedClientListRequest
     *
     * @return DescribeHybridProxyLinkedClientListResponse DescribeHybridProxyLinkedClientListResponse
     */
    public function describeHybridProxyLinkedClientList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHybridProxyLinkedClientListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询代理
     *  *
     * @param DescribeHybridProxyListRequest $request DescribeHybridProxyListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHybridProxyListResponse DescribeHybridProxyListResponse
     */
    public function describeHybridProxyListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHybridProxyList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHybridProxyListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询代理
     *  *
     * @param DescribeHybridProxyListRequest $request DescribeHybridProxyListRequest
     *
     * @return DescribeHybridProxyListResponse DescribeHybridProxyListResponse
     */
    public function describeHybridProxyList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHybridProxyListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询用户代理策略设置
     *  *
     * @param DescribeHybridProxyPolicyRequest $request DescribeHybridProxyPolicyRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHybridProxyPolicyResponse DescribeHybridProxyPolicyResponse
     */
    public function describeHybridProxyPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHybridProxyPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHybridProxyPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询用户代理策略设置
     *  *
     * @param DescribeHybridProxyPolicyRequest $request DescribeHybridProxyPolicyRequest
     *
     * @return DescribeHybridProxyPolicyResponse DescribeHybridProxyPolicyResponse
     */
    public function describeHybridProxyPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHybridProxyPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the search conditions that can be used to query data center assets found after scanning in fuzzy match mode.
     *  *
     * @param DescribeIdcAssetCriteriaRequest $request DescribeIdcAssetCriteriaRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIdcAssetCriteriaResponse DescribeIdcAssetCriteriaResponse
     */
    public function describeIdcAssetCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIdcAssetCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIdcAssetCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the search conditions that can be used to query data center assets found after scanning in fuzzy match mode.
     *  *
     * @param DescribeIdcAssetCriteriaRequest $request DescribeIdcAssetCriteriaRequest
     *
     * @return DescribeIdcAssetCriteriaResponse DescribeIdcAssetCriteriaResponse
     */
    public function describeIdcAssetCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIdcAssetCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries assets that are identified by Internet Data Center (IDC) probes.
     *  *
     * @param DescribeIdcProbeScanResultListRequest $request DescribeIdcProbeScanResultListRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIdcProbeScanResultListResponse DescribeIdcProbeScanResultListResponse
     */
    public function describeIdcProbeScanResultListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->foundEndTime)) {
            $query['FoundEndTime'] = $request->foundEndTime;
        }
        if (!Utils::isUnset($request->foundStartTime)) {
            $query['FoundStartTime'] = $request->foundStartTime;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIdcProbeScanResultList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIdcProbeScanResultListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries assets that are identified by Internet Data Center (IDC) probes.
     *  *
     * @param DescribeIdcProbeScanResultListRequest $request DescribeIdcProbeScanResultListRequest
     *
     * @return DescribeIdcProbeScanResultListResponse DescribeIdcProbeScanResultListResponse
     */
    public function describeIdcProbeScanResultList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIdcProbeScanResultListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries an image digest.
     *  *
     * @param DescribeImageRequest $request DescribeImageRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageResponse DescribeImageResponse
     */
    public function describeImageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->imageInstanceId)) {
            $query['ImageInstanceId'] = $request->imageInstanceId;
        }
        if (!Utils::isUnset($request->imageRegionId)) {
            $query['ImageRegionId'] = $request->imageRegionId;
        }
        if (!Utils::isUnset($request->imageRepoId)) {
            $query['ImageRepoId'] = $request->imageRepoId;
        }
        if (!Utils::isUnset($request->imageTag)) {
            $query['ImageTag'] = $request->imageTag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries an image digest.
     *  *
     * @param DescribeImageRequest $request DescribeImageRequest
     *
     * @return DescribeImageResponse DescribeImageResponse
     */
    public function describeImage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the security scan results of images.
     *  *
     * @param DescribeImageBaselineCheckResultRequest $request DescribeImageBaselineCheckResultRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineCheckResultResponse DescribeImageBaselineCheckResultResponse
     */
    public function describeImageBaselineCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the security scan results of images.
     *  *
     * @param DescribeImageBaselineCheckResultRequest $request DescribeImageBaselineCheckResultRequest
     *
     * @return DescribeImageBaselineCheckResultResponse DescribeImageBaselineCheckResultResponse
     */
    public function describeImageBaselineCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineCheckResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the check results of image baselines that are included in an image scan task.
     *  *
     * @param DescribeImageBaselineCheckSummaryRequest $request DescribeImageBaselineCheckSummaryRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineCheckSummaryResponse DescribeImageBaselineCheckSummaryResponse
     */
    public function describeImageBaselineCheckSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineCheckSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineCheckSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the check results of image baselines that are included in an image scan task.
     *  *
     * @param DescribeImageBaselineCheckSummaryRequest $request DescribeImageBaselineCheckSummaryRequest
     *
     * @return DescribeImageBaselineCheckSummaryResponse DescribeImageBaselineCheckSummaryResponse
     */
    public function describeImageBaselineCheckSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineCheckSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about the baseline check result for an image.
     *  *
     * @param DescribeImageBaselineDetailRequest $request DescribeImageBaselineDetailRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineDetailResponse DescribeImageBaselineDetailResponse
     */
    public function describeImageBaselineDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineItemKey)) {
            $query['BaselineItemKey'] = $request->baselineItemKey;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about the baseline check result for an image.
     *  *
     * @param DescribeImageBaselineDetailRequest $request DescribeImageBaselineDetailRequest
     *
     * @return DescribeImageBaselineDetailResponse DescribeImageBaselineDetailResponse
     */
    public function describeImageBaselineDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries baseline check results based on images.
     *  *
     * @param DescribeImageBaselineItemListRequest $request DescribeImageBaselineItemListRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineItemListResponse DescribeImageBaselineItemListResponse
     */
    public function describeImageBaselineItemListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineClassKey)) {
            $query['BaselineClassKey'] = $request->baselineClassKey;
        }
        if (!Utils::isUnset($request->baselineNameKey)) {
            $query['BaselineNameKey'] = $request->baselineNameKey;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineItemList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineItemListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries baseline check results based on images.
     *  *
     * @param DescribeImageBaselineItemListRequest $request DescribeImageBaselineItemListRequest
     *
     * @return DescribeImageBaselineItemListResponse DescribeImageBaselineItemListResponse
     */
    public function describeImageBaselineItemList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineItemListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a baseline check policy for images.
     *  *
     * @param DescribeImageBaselineStrategyRequest $request DescribeImageBaselineStrategyRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineStrategyResponse DescribeImageBaselineStrategyResponse
     */
    public function describeImageBaselineStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a baseline check policy for images.
     *  *
     * @param DescribeImageBaselineStrategyRequest $request DescribeImageBaselineStrategyRequest
     *
     * @return DescribeImageBaselineStrategyResponse DescribeImageBaselineStrategyResponse
     */
    public function describeImageBaselineStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary 通过风险项关键字查询镜像的构建风险。
     *  *
     * @param DescribeImageBuildRiskByKeyRequest $request DescribeImageBuildRiskByKeyRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBuildRiskByKeyResponse DescribeImageBuildRiskByKeyResponse
     */
    public function describeImageBuildRiskByKeyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskKey)) {
            $query['RiskKey'] = $request->riskKey;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBuildRiskByKey',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBuildRiskByKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 通过风险项关键字查询镜像的构建风险。
     *  *
     * @param DescribeImageBuildRiskByKeyRequest $request DescribeImageBuildRiskByKeyRequest
     *
     * @return DescribeImageBuildRiskByKeyResponse DescribeImageBuildRiskByKeyResponse
     */
    public function describeImageBuildRiskByKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBuildRiskByKeyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of image build command risks by page.
     *  *
     * @param DescribeImageBuildRiskListRequest $request DescribeImageBuildRiskListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBuildRiskListResponse DescribeImageBuildRiskListResponse
     */
    public function describeImageBuildRiskListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBuildRiskList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBuildRiskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of image build command risks by page.
     *  *
     * @param DescribeImageBuildRiskListRequest $request DescribeImageBuildRiskListRequest
     *
     * @return DescribeImageBuildRiskListResponse DescribeImageBuildRiskListResponse
     */
    public function describeImageBuildRiskList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBuildRiskListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the search conditions that are used to query images.
     *  *
     * @param DescribeImageCriteriaRequest $request DescribeImageCriteriaRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageCriteriaResponse DescribeImageCriteriaResponse
     */
    public function describeImageCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the search conditions that are used to query images.
     *  *
     * @param DescribeImageCriteriaRequest $request DescribeImageCriteriaRequest
     *
     * @return DescribeImageCriteriaResponse DescribeImageCriteriaResponse
     */
    public function describeImageCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the conditions for handling alert events in an image.
     *  *
     * @param DescribeImageEventOperationConditionRequest $request DescribeImageEventOperationConditionRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageEventOperationConditionResponse DescribeImageEventOperationConditionResponse
     */
    public function describeImageEventOperationConditionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventType)) {
            $query['EventType'] = $request->eventType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageEventOperationCondition',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageEventOperationConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the conditions for handling alert events in an image.
     *  *
     * @param DescribeImageEventOperationConditionRequest $request DescribeImageEventOperationConditionRequest
     *
     * @return DescribeImageEventOperationConditionResponse DescribeImageEventOperationConditionResponse
     */
    public function describeImageEventOperationCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageEventOperationConditionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries alert handling rules by page.
     *  *
     * @param DescribeImageEventOperationPageRequest $request DescribeImageEventOperationPageRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageEventOperationPageResponse DescribeImageEventOperationPageResponse
     */
    public function describeImageEventOperationPageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventKey)) {
            $query['EventKey'] = $request->eventKey;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->eventType)) {
            $query['EventType'] = $request->eventType;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageEventOperationPage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageEventOperationPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries alert handling rules by page.
     *  *
     * @param DescribeImageEventOperationPageRequest $request DescribeImageEventOperationPageRequest
     *
     * @return DescribeImageEventOperationPageResponse DescribeImageEventOperationPageResponse
     */
    public function describeImageEventOperationPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageEventOperationPageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the scheduled fix of image risks.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageFixCycleConfigResponse DescribeImageFixCycleConfigResponse
     */
    public function describeImageFixCycleConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeImageFixCycleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageFixCycleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the scheduled fix of image risks.
     *  *
     * @return DescribeImageFixCycleConfigResponse DescribeImageFixCycleConfigResponse
     */
    public function describeImageFixCycleConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageFixCycleConfigWithOptions($runtime);
    }

    /**
     * @summary Queries the tasks that you create to fix image risks.
     *  *
     * @param DescribeImageFixTaskRequest $request DescribeImageFixTaskRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageFixTaskResponse DescribeImageFixTaskResponse
     */
    public function describeImageFixTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageFixTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageFixTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the tasks that you create to fix image risks.
     *  *
     * @param DescribeImageFixTaskRequest $request DescribeImageFixTaskRequest
     *
     * @return DescribeImageFixTaskResponse DescribeImageFixTaskResponse
     */
    public function describeImageFixTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageFixTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries image vulnerabilities.
     *  *
     * @param DescribeImageGroupedVulListRequest $request DescribeImageGroupedVulListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageGroupedVulListResponse DescribeImageGroupedVulListResponse
     */
    public function describeImageGroupedVulListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->cveId)) {
            $query['CveId'] = $request->cveId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->imageLayer)) {
            $query['ImageLayer'] = $request->imageLayer;
        }
        if (!Utils::isUnset($request->imageTag)) {
            $query['ImageTag'] = $request->imageTag;
        }
        if (!Utils::isUnset($request->isLatest)) {
            $query['IsLatest'] = $request->isLatest;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->patchId)) {
            $query['PatchId'] = $request->patchId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageGroupedVulList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageGroupedVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries image vulnerabilities.
     *  *
     * @param DescribeImageGroupedVulListRequest $request DescribeImageGroupedVulListRequest
     *
     * @return DescribeImageGroupedVulListResponse DescribeImageGroupedVulListResponse
     */
    public function describeImageGroupedVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageGroupedVulListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries images.
     *  *
     * @param DescribeImageInfoListRequest $request DescribeImageInfoListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageInfoListResponse DescribeImageInfoListResponse
     */
    public function describeImageInfoListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageInfoList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageInfoListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries images.
     *  *
     * @param DescribeImageInfoListRequest $request DescribeImageInfoListRequest
     *
     * @return DescribeImageInfoListResponse DescribeImageInfoListResponse
     */
    public function describeImageInfoList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageInfoListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about images.
     *  *
     * @param DescribeImageInstancesRequest $request DescribeImageInstancesRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageInstancesResponse DescribeImageInstancesResponse
     */
    public function describeImageInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->scanned)) {
            $query['Scanned'] = $request->scanned;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about images.
     *  *
     * @param DescribeImageInstancesRequest $request DescribeImageInstancesRequest
     *
     * @return DescribeImageInstancesResponse DescribeImageInstancesResponse
     */
    public function describeImageInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the most recent scan task that is created for an image.
     *  *
     * @param DescribeImageLatestScanTaskRequest $request DescribeImageLatestScanTaskRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageLatestScanTaskResponse DescribeImageLatestScanTaskResponse
     */
    public function describeImageLatestScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->digest)) {
            $query['Digest'] = $request->digest;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageLatestScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageLatestScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the most recent scan task that is created for an image.
     *  *
     * @param DescribeImageLatestScanTaskRequest $request DescribeImageLatestScanTaskRequest
     *
     * @return DescribeImageLatestScanTaskResponse DescribeImageLatestScanTaskResponse
     */
    public function describeImageLatestScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageLatestScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of images that are affected by image build command risks by page.
     *  *
     * @param DescribeImageListByBuildRiskRequest $request DescribeImageListByBuildRiskRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageListByBuildRiskResponse DescribeImageListByBuildRiskResponse
     */
    public function describeImageListByBuildRiskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskKey)) {
            $query['RiskKey'] = $request->riskKey;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageListByBuildRisk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageListByBuildRiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of images that are affected by image build command risks by page.
     *  *
     * @param DescribeImageListByBuildRiskRequest $request DescribeImageListByBuildRiskRequest
     *
     * @return DescribeImageListByBuildRiskResponse DescribeImageListByBuildRiskResponse
     */
    public function describeImageListByBuildRisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageListByBuildRiskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about images that are affected by sensitive files.
     *  *
     * @param DescribeImageListBySensitiveFileRequest $tmpReq  DescribeImageListBySensitiveFileRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageListBySensitiveFileResponse DescribeImageListBySensitiveFileResponse
     */
    public function describeImageListBySensitiveFileWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeImageListBySensitiveFileShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->scanRange)) {
            $request->scanRangeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->scanRangeShrink)) {
            $query['ScanRange'] = $request->scanRangeShrink;
        }
        if (!Utils::isUnset($request->sensitiveFileKey)) {
            $query['SensitiveFileKey'] = $request->sensitiveFileKey;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageListBySensitiveFile',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageListBySensitiveFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about images that are affected by sensitive files.
     *  *
     * @param DescribeImageListBySensitiveFileRequest $request DescribeImageListBySensitiveFileRequest
     *
     * @return DescribeImageListBySensitiveFileResponse DescribeImageListBySensitiveFileResponse
     */
    public function describeImageListBySensitiveFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageListBySensitiveFileWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about images in the results of image baseline checks.
     *  *
     * @param DescribeImageListWithBaselineNameRequest $request DescribeImageListWithBaselineNameRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageListWithBaselineNameResponse DescribeImageListWithBaselineNameResponse
     */
    public function describeImageListWithBaselineNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineNameKey)) {
            $query['BaselineNameKey'] = $request->baselineNameKey;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->containerId)) {
            $query['ContainerId'] = $request->containerId;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->image)) {
            $query['Image'] = $request->image;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pod)) {
            $query['Pod'] = $request->pod;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageListWithBaselineName',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageListWithBaselineNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about images in the results of image baseline checks.
     *  *
     * @param DescribeImageListWithBaselineNameRequest $request DescribeImageListWithBaselineNameRequest
     *
     * @return DescribeImageListWithBaselineNameResponse DescribeImageListWithBaselineNameResponse
     */
    public function describeImageListWithBaselineName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageListWithBaselineNameWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the filter conditions that are supported by the image repository.
     *  *
     * @param DescribeImageRepoCriteriaRequest $request DescribeImageRepoCriteriaRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageRepoCriteriaResponse DescribeImageRepoCriteriaResponse
     */
    public function describeImageRepoCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageRepoCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageRepoCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the filter conditions that are supported by the image repository.
     *  *
     * @param DescribeImageRepoCriteriaRequest $request DescribeImageRepoCriteriaRequest
     *
     * @return DescribeImageRepoCriteriaResponse DescribeImageRepoCriteriaResponse
     */
    public function describeImageRepoCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRepoCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about image repositories.
     *  *
     * @param DescribeImageRepoDetailListRequest $request DescribeImageRepoDetailListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageRepoDetailListResponse DescribeImageRepoDetailListResponse
     */
    public function describeImageRepoDetailListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageRepoDetailList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageRepoDetailListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about image repositories.
     *  *
     * @param DescribeImageRepoDetailListRequest $request DescribeImageRepoDetailListRequest
     *
     * @return DescribeImageRepoDetailListResponse DescribeImageRepoDetailListResponse
     */
    public function describeImageRepoDetailList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRepoDetailListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics and configurations of the feature that protects images.
     *  *
     * @param DescribeImageRepoListRequest $request DescribeImageRepoListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageRepoListResponse DescribeImageRepoListResponse
     */
    public function describeImageRepoListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldName)) {
            $query['FieldName'] = $request->fieldName;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageRepoList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageRepoListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics and configurations of the feature that protects images.
     *  *
     * @param DescribeImageRepoListRequest $request DescribeImageRepoListRequest
     *
     * @return DescribeImageRepoListResponse DescribeImageRepoListResponse
     */
    public function describeImageRepoList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRepoListWithOptions($request, $runtime);
    }

    /**
     * @summary The quota for container image scan.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageScanAuthCountResponse DescribeImageScanAuthCountResponse
     */
    public function describeImageScanAuthCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeImageScanAuthCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageScanAuthCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The quota for container image scan.
     *  *
     * @return DescribeImageScanAuthCountResponse DescribeImageScanAuthCountResponse
     */
    public function describeImageScanAuthCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageScanAuthCountWithOptions($runtime);
    }

    /**
     * @summary Queries whether Security Center is authorized to scan images.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageScanAuthorizationResponse DescribeImageScanAuthorizationResponse
     */
    public function describeImageScanAuthorizationWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeImageScanAuthorization',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageScanAuthorizationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether Security Center is authorized to scan images.
     *  *
     * @return DescribeImageScanAuthorizationResponse DescribeImageScanAuthorizationResponse
     */
    public function describeImageScanAuthorization()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageScanAuthorizationWithOptions($runtime);
    }

    /**
     * @summary Queries the sensitive files in an image.
     *  *
     * @param DescribeImageSensitiveFileByKeyRequest $tmpReq  DescribeImageSensitiveFileByKeyRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageSensitiveFileByKeyResponse DescribeImageSensitiveFileByKeyResponse
     */
    public function describeImageSensitiveFileByKeyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeImageSensitiveFileByKeyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->scanRange)) {
            $request->scanRangeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->scanRangeShrink)) {
            $query['ScanRange'] = $request->scanRangeShrink;
        }
        if (!Utils::isUnset($request->sensitiveFileKey)) {
            $query['SensitiveFileKey'] = $request->sensitiveFileKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageSensitiveFileByKey',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageSensitiveFileByKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the sensitive files in an image.
     *  *
     * @param DescribeImageSensitiveFileByKeyRequest $request DescribeImageSensitiveFileByKeyRequest
     *
     * @return DescribeImageSensitiveFileByKeyResponse DescribeImageSensitiveFileByKeyResponse
     */
    public function describeImageSensitiveFileByKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageSensitiveFileByKeyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about sensitive files.
     *  *
     * @param DescribeImageSensitiveFileListRequest $tmpReq  DescribeImageSensitiveFileListRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageSensitiveFileListResponse DescribeImageSensitiveFileListResponse
     */
    public function describeImageSensitiveFileListWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeImageSensitiveFileListShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->scanRange)) {
            $request->scanRangeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->scanRangeShrink)) {
            $query['ScanRange'] = $request->scanRangeShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageSensitiveFileList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageSensitiveFileListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about sensitive files.
     *  *
     * @param DescribeImageSensitiveFileListRequest $request DescribeImageSensitiveFileListRequest
     *
     * @return DescribeImageSensitiveFileListResponse DescribeImageSensitiveFileListResponse
     */
    public function describeImageSensitiveFileList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageSensitiveFileListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the risk statistics on container images.
     *  *
     * @description Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
     * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageStatisticsResponse DescribeImageStatisticsResponse
     */
    public function describeImageStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeImageStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk statistics on container images.
     *  *
     * @description Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
     * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
     *  *
     * @return DescribeImageStatisticsResponse DescribeImageStatisticsResponse
     */
    public function describeImageStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries information about the vulnerabilities that are detected by using container image scan and the affected images.
     *  *
     * @description To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](~~PublicCreateImageScanTask~~) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
     *  *
     * @param DescribeImageVulListRequest $request DescribeImageVulListRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageVulListResponse DescribeImageVulListResponse
     */
    public function describeImageVulListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->containerId)) {
            $query['ContainerId'] = $request->containerId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->digest)) {
            $query['Digest'] = $request->digest;
        }
        if (!Utils::isUnset($request->image)) {
            $query['Image'] = $request->image;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pod)) {
            $query['Pod'] = $request->pod;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageVulList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the vulnerabilities that are detected by using container image scan and the affected images.
     *  *
     * @description To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](~~PublicCreateImageScanTask~~) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
     *  *
     * @param DescribeImageVulListRequest $request DescribeImageVulListRequest
     *
     * @return DescribeImageVulListResponse DescribeImageVulListResponse
     */
    public function describeImageVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageVulListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the whitelist of image vulnerabilities.
     *  *
     * @param DescribeImageVulWhiteListRequest $request DescribeImageVulWhiteListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageVulWhiteListResponse DescribeImageVulWhiteListResponse
     */
    public function describeImageVulWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageVulWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageVulWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the whitelist of image vulnerabilities.
     *  *
     * @param DescribeImageVulWhiteListRequest $request DescribeImageVulWhiteListRequest
     *
     * @return DescribeImageVulWhiteListResponse DescribeImageVulWhiteListResponse
     */
    public function describeImageVulWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageVulWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the verification codes that are used to manually install the Security Center agent.
     *  *
     * @param DescribeInstallCaptchaRequest $request DescribeInstallCaptchaRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstallCaptchaResponse DescribeInstallCaptchaResponse
     */
    public function describeInstallCaptchaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->deadline)) {
            $query['Deadline'] = $request->deadline;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeInstallCaptcha',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstallCaptchaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the verification codes that are used to manually install the Security Center agent.
     *  *
     * @param DescribeInstallCaptchaRequest $request DescribeInstallCaptchaRequest
     *
     * @return DescribeInstallCaptchaResponse DescribeInstallCaptchaResponse
     */
    public function describeInstallCaptcha($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstallCaptchaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstallCodeResponse DescribeInstallCodeResponse
     */
    public function describeInstallCodeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeInstallCode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
     *  *
     * @return DescribeInstallCodeResponse DescribeInstallCodeResponse
     */
    public function describeInstallCode()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstallCodeWithOptions($runtime);
    }

    /**
     * @summary Queries the commands that are used to manually install the Security Center Agent.
     *  *
     * @description You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstallCodesResponse DescribeInstallCodesResponse
     */
    public function describeInstallCodesWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeInstallCodes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstallCodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the commands that are used to manually install the Security Center Agent.
     *  *
     * @description You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @return DescribeInstallCodesResponse DescribeInstallCodesResponse
     */
    public function describeInstallCodes()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstallCodesWithOptions($runtime);
    }

    /**
     * @summary Queries the information about servers to which a defense rule against brute-force attacks is applied.
     *  *
     * @param DescribeInstanceAntiBruteForceRulesRequest $request DescribeInstanceAntiBruteForceRulesRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstanceAntiBruteForceRulesResponse DescribeInstanceAntiBruteForceRulesResponse
     */
    public function describeInstanceAntiBruteForceRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeInstanceAntiBruteForceRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstanceAntiBruteForceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about servers to which a defense rule against brute-force attacks is applied.
     *  *
     * @param DescribeInstanceAntiBruteForceRulesRequest $request DescribeInstanceAntiBruteForceRulesRequest
     *
     * @return DescribeInstanceAntiBruteForceRulesResponse DescribeInstanceAntiBruteForceRulesResponse
     */
    public function describeInstanceAntiBruteForceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceAntiBruteForceRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of the instance that you restart.
     *  *
     * @param DescribeInstanceRebootStatusRequest $request DescribeInstanceRebootStatusRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstanceRebootStatusResponse DescribeInstanceRebootStatusResponse
     */
    public function describeInstanceRebootStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeInstanceRebootStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstanceRebootStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of the instance that you restart.
     *  *
     * @param DescribeInstanceRebootStatusRequest $request DescribeInstanceRebootStatusRequest
     *
     * @return DescribeInstanceRebootStatusResponse DescribeInstanceRebootStatusResponse
     */
    public function describeInstanceRebootStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceRebootStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of assets that are protected by Security Center.
     *  *
     * @param DescribeInstanceStatisticsRequest $request DescribeInstanceStatisticsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstanceStatisticsResponse DescribeInstanceStatisticsResponse
     */
    public function describeInstanceStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeInstanceStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstanceStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of assets that are protected by Security Center.
     *  *
     * @param DescribeInstanceStatisticsRequest $request DescribeInstanceStatisticsRequest
     *
     * @return DescribeInstanceStatisticsResponse DescribeInstanceStatisticsResponse
     */
    public function describeInstanceStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary 查询集群漏洞统计
     *  *
     * @param DescribeInstanceVulStatisticsRequest $request DescribeInstanceVulStatisticsRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstanceVulStatisticsResponse DescribeInstanceVulStatisticsResponse
     */
    public function describeInstanceVulStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeInstanceVulStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstanceVulStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询集群漏洞统计
     *  *
     * @param DescribeInstanceVulStatisticsRequest $request DescribeInstanceVulStatisticsRequest
     *
     * @return DescribeInstanceVulStatisticsResponse DescribeInstanceVulStatisticsResponse
     */
    public function describeInstanceVulStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceVulStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary 查询最新病毒扫描
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLatestScanTaskResponse DescribeLatestScanTaskResponse
     */
    public function describeLatestScanTaskWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeLatestScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLatestScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询最新病毒扫描
     *  *
     * @return DescribeLatestScanTaskResponse DescribeLatestScanTaskResponse
     */
    public function describeLatestScanTask()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLatestScanTaskWithOptions($runtime);
    }

    /**
     * @summary Queries the configurations of the log analysis feature provided by Security Center.
     *  *
     * @param DescribeLogMetaRequest $request DescribeLogMetaRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLogMetaResponse DescribeLogMetaResponse
     */
    public function describeLogMetaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeLogMeta',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLogMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the log analysis feature provided by Security Center.
     *  *
     * @param DescribeLogMetaRequest $request DescribeLogMetaRequest
     *
     * @return DescribeLogMetaResponse DescribeLogMetaResponse
     */
    public function describeLogMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogMetaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status information about the log analysis feature.
     *  *
     * @param DescribeLogShipperStatusRequest $request DescribeLogShipperStatusRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLogShipperStatusResponse DescribeLogShipperStatusResponse
     */
    public function describeLogShipperStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeLogShipperStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLogShipperStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status information about the log analysis feature.
     *  *
     * @param DescribeLogShipperStatusRequest $request DescribeLogShipperStatusRequest
     *
     * @return DescribeLogShipperStatusResponse DescribeLogShipperStatusResponse
     */
    public function describeLogShipperStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogShipperStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the configurations that are used to detect unusual logons to your servers.
     *  *
     * @param DescribeLoginBaseConfigsRequest $request DescribeLoginBaseConfigsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLoginBaseConfigsResponse DescribeLoginBaseConfigsResponse
     */
    public function describeLoginBaseConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeLoginBaseConfigs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLoginBaseConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the configurations that are used to detect unusual logons to your servers.
     *  *
     * @param DescribeLoginBaseConfigsRequest $request DescribeLoginBaseConfigsRequest
     *
     * @return DescribeLoginBaseConfigsResponse DescribeLoginBaseConfigsResponse
     */
    public function describeLoginBaseConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLoginBaseConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLoginSwitchConfigsResponse DescribeLoginSwitchConfigsResponse
     */
    public function describeLoginSwitchConfigsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeLoginSwitchConfigs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLoginSwitchConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
     *  *
     * @return DescribeLoginSwitchConfigsResponse DescribeLoginSwitchConfigsResponse
     */
    public function describeLoginSwitchConfigs()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLoginSwitchConfigsWithOptions($runtime);
    }

    /**
     * @summary Queries the purchased log storage capacity.
     *  *
     * @param DescribeLogstoreStorageRequest $request DescribeLogstoreStorageRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLogstoreStorageResponse DescribeLogstoreStorageResponse
     */
    public function describeLogstoreStorageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeLogstoreStorage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLogstoreStorageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the purchased log storage capacity.
     *  *
     * @param DescribeLogstoreStorageRequest $request DescribeLogstoreStorageRequest
     *
     * @return DescribeLogstoreStorageResponse DescribeLogstoreStorageResponse
     */
    public function describeLogstoreStorage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogstoreStorageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
     *  *
     * @param DescribeMachineCanRebootRequest $request DescribeMachineCanRebootRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeMachineCanRebootResponse DescribeMachineCanRebootResponse
     */
    public function describeMachineCanRebootWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeMachineCanReboot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeMachineCanRebootResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
     *  *
     * @param DescribeMachineCanRebootRequest $request DescribeMachineCanRebootRequest
     *
     * @return DescribeMachineCanRebootResponse DescribeMachineCanRebootResponse
     */
    public function describeMachineCanReboot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMachineCanRebootWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of malicious image sample types.
     *  *
     * @param DescribeMatchedMaliciousNamesRequest $request DescribeMatchedMaliciousNamesRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeMatchedMaliciousNamesResponse DescribeMatchedMaliciousNamesResponse
     */
    public function describeMatchedMaliciousNamesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeMatchedMaliciousNames',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeMatchedMaliciousNamesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of malicious image sample types.
     *  *
     * @param DescribeMatchedMaliciousNamesRequest $request DescribeMatchedMaliciousNamesRequest
     *
     * @return DescribeMatchedMaliciousNamesResponse DescribeMatchedMaliciousNamesResponse
     */
    public function describeMatchedMaliciousNames($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMatchedMaliciousNamesWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the server.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeModuleConfigResponse DescribeModuleConfigResponse
     */
    public function describeModuleConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeModuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeModuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the server.
     *  *
     * @return DescribeModuleConfigResponse DescribeModuleConfigResponse
     */
    public function describeModuleConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeModuleConfigWithOptions($runtime);
    }

    /**
     * @summary Queries the list of accounts that are added to the multi-account management feature as members.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeMonitorAccountsResponse DescribeMonitorAccountsResponse
     */
    public function describeMonitorAccountsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeMonitorAccounts',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeMonitorAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of accounts that are added to the multi-account management feature as members.
     *  *
     * @return DescribeMonitorAccountsResponse DescribeMonitorAccountsResponse
     */
    public function describeMonitorAccounts()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMonitorAccountsWithOptions($runtime);
    }

    /**
     * @summary 查询是否需要慢查询优化
     *  *
     * @param DescribeNeedAsyncQueryRequest $request DescribeNeedAsyncQueryRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeNeedAsyncQueryResponse DescribeNeedAsyncQueryResponse
     */
    public function describeNeedAsyncQueryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeNeedAsyncQuery',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeNeedAsyncQueryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询是否需要慢查询优化
     *  *
     * @param DescribeNeedAsyncQueryRequest $request DescribeNeedAsyncQueryRequest
     *
     * @return DescribeNeedAsyncQueryResponse DescribeNeedAsyncQueryResponse
     */
    public function describeNeedAsyncQuery($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNeedAsyncQueryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries notification settings.
     *  *
     * @param DescribeNoticeConfigRequest $request DescribeNoticeConfigRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeNoticeConfigResponse DescribeNoticeConfigResponse
     */
    public function describeNoticeConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeNoticeConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeNoticeConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries notification settings.
     *  *
     * @param DescribeNoticeConfigRequest $request DescribeNoticeConfigRequest
     *
     * @return DescribeNoticeConfigResponse DescribeNoticeConfigResponse
     */
    public function describeNoticeConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNoticeConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an alert type.
     *  *
     * @param DescribeNsasSuspEventTypeRequest $request DescribeNsasSuspEventTypeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeNsasSuspEventTypeResponse DescribeNsasSuspEventTypeResponse
     */
    public function describeNsasSuspEventTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->multiAccountActionType)) {
            $query['MultiAccountActionType'] = $request->multiAccountActionType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeNsasSuspEventType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeNsasSuspEventTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an alert type.
     *  *
     * @param DescribeNsasSuspEventTypeRequest $request DescribeNsasSuspEventTypeRequest
     *
     * @return DescribeNsasSuspEventTypeResponse DescribeNsasSuspEventTypeResponse
     */
    public function describeNsasSuspEventType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNsasSuspEventTypeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers whose Security Center agent status is Offline.
     *  *
     * @param DescribeOfflineMachinesRequest $request DescribeOfflineMachinesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeOfflineMachinesResponse DescribeOfflineMachinesResponse
     */
    public function describeOfflineMachinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->os)) {
            $query['Os'] = $request->os;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionIdStr)) {
            $query['RegionIdStr'] = $request->regionIdStr;
        }
        if (!Utils::isUnset($request->regionNo)) {
            $query['RegionNo'] = $request->regionNo;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeOfflineMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeOfflineMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers whose Security Center agent status is Offline.
     *  *
     * @param DescribeOfflineMachinesRequest $request DescribeOfflineMachinesRequest
     *
     * @return DescribeOfflineMachinesResponse DescribeOfflineMachinesResponse
     */
    public function describeOfflineMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOfflineMachinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries troubleshooting tasks for the Security Center agent.
     *  *
     * @param DescribeOnceTaskRequest $request DescribeOnceTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeOnceTaskResponse DescribeOnceTaskResponse
     */
    public function describeOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTimeQuery)) {
            $query['EndTimeQuery'] = $request->endTimeQuery;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->rootTaskId)) {
            $query['RootTaskId'] = $request->rootTaskId;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->startTimeQuery)) {
            $query['StartTimeQuery'] = $request->startTimeQuery;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries troubleshooting tasks for the Security Center agent.
     *  *
     * @param DescribeOnceTaskRequest $request DescribeOnceTaskRequest
     *
     * @return DescribeOnceTaskResponse DescribeOnceTaskResponse
     */
    public function describeOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
     *  *
     * @param DescribeOnceTaskLeafRecordPageRequest $request DescribeOnceTaskLeafRecordPageRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeOnceTaskLeafRecordPageResponse DescribeOnceTaskLeafRecordPageResponse
     */
    public function describeOnceTaskLeafRecordPageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->relateInfo)) {
            $query['RelateInfo'] = $request->relateInfo;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeOnceTaskLeafRecordPage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeOnceTaskLeafRecordPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
     *  *
     * @param DescribeOnceTaskLeafRecordPageRequest $request DescribeOnceTaskLeafRecordPageRequest
     *
     * @return DescribeOnceTaskLeafRecordPageResponse DescribeOnceTaskLeafRecordPageResponse
     */
    public function describeOnceTaskLeafRecordPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOnceTaskLeafRecordPageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
     *  *
     * @param DescribePropertyCountRequest $request DescribePropertyCountRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyCountResponse DescribePropertyCountResponse
     */
    public function describePropertyCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
     *  *
     * @param DescribePropertyCountRequest $request DescribePropertyCountRequest
     *
     * @return DescribePropertyCountResponse DescribePropertyCountResponse
     */
    public function describePropertyCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of scheduled tasks on the Host page.
     *  *
     * @param DescribePropertyCronDetailRequest $request DescribePropertyCronDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyCronDetailResponse DescribePropertyCronDetailResponse
     */
    public function describePropertyCronDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyCronDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyCronDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of scheduled tasks on the Host page.
     *  *
     * @param DescribePropertyCronDetailRequest $request DescribePropertyCronDetailRequest
     *
     * @return DescribePropertyCronDetailResponse DescribePropertyCronDetailResponse
     */
    public function describePropertyCronDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyCronDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the scheduled tasks of your assets.
     *  *
     * @param DescribePropertyCronItemRequest $request DescribePropertyCronItemRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyCronItemResponse DescribePropertyCronItemResponse
     */
    public function describePropertyCronItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyCronItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyCronItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the scheduled tasks of your assets.
     *  *
     * @param DescribePropertyCronItemRequest $request DescribePropertyCronItemRequest
     *
     * @return DescribePropertyCronItemResponse DescribePropertyCronItemResponse
     */
    public function describePropertyCronItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyCronItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the fingerprints of ports on a specified server.
     *  *
     * @param DescribePropertyPortDetailRequest $request DescribePropertyPortDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyPortDetailResponse DescribePropertyPortDetailResponse
     */
    public function describePropertyPortDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bindIp)) {
            $query['BindIp'] = $request->bindIp;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->procName)) {
            $query['ProcName'] = $request->procName;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyPortDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyPortDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the fingerprints of ports on a specified server.
     *  *
     * @param DescribePropertyPortDetailRequest $request DescribePropertyPortDetailRequest
     *
     * @return DescribePropertyPortDetailResponse DescribePropertyPortDetailResponse
     */
    public function describePropertyPortDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyPortDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about all ports.
     *  *
     * @param DescribePropertyPortItemRequest $request DescribePropertyPortItemRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyPortItemResponse DescribePropertyPortItemResponse
     */
    public function describePropertyPortItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyPortItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyPortItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about all ports.
     *  *
     * @param DescribePropertyPortItemRequest $request DescribePropertyPortItemRequest
     *
     * @return DescribePropertyPortItemResponse DescribePropertyPortItemResponse
     */
    public function describePropertyPortItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyPortItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the fingerprints of processes on a specified server.
     *  *
     * @param DescribePropertyProcDetailRequest $request DescribePropertyProcDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyProcDetailResponse DescribePropertyProcDetailResponse
     */
    public function describePropertyProcDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cmdline)) {
            $query['Cmdline'] = $request->cmdline;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->procTimeEnd)) {
            $query['ProcTimeEnd'] = $request->procTimeEnd;
        }
        if (!Utils::isUnset($request->procTimeStart)) {
            $query['ProcTimeStart'] = $request->procTimeStart;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyProcDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyProcDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the fingerprints of processes on a specified server.
     *  *
     * @param DescribePropertyProcDetailRequest $request DescribePropertyProcDetailRequest
     *
     * @return DescribePropertyProcDetailResponse DescribePropertyProcDetailResponse
     */
    public function describePropertyProcDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyProcDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about all processes.
     *  *
     * @param DescribePropertyProcItemRequest $request DescribePropertyProcItemRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyProcItemResponse DescribePropertyProcItemResponse
     */
    public function describePropertyProcItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyProcItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyProcItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about all processes.
     *  *
     * @param DescribePropertyProcItemRequest $request DescribePropertyProcItemRequest
     *
     * @return DescribePropertyProcItemResponse DescribePropertyProcItemResponse
     */
    public function describePropertyProcItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyProcItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries middleware fingerprints.
     *  *
     * @param DescribePropertyScaDetailRequest $request DescribePropertyScaDetailRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyScaDetailResponse DescribePropertyScaDetailResponse
     */
    public function describePropertyScaDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->biz)) {
            $query['Biz'] = $request->biz;
        }
        if (!Utils::isUnset($request->bizType)) {
            $query['BizType'] = $request->bizType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pid)) {
            $query['Pid'] = $request->pid;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->processStartedEnd)) {
            $query['ProcessStartedEnd'] = $request->processStartedEnd;
        }
        if (!Utils::isUnset($request->processStartedStart)) {
            $query['ProcessStartedStart'] = $request->processStartedStart;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->scaName)) {
            $query['ScaName'] = $request->scaName;
        }
        if (!Utils::isUnset($request->scaNamePattern)) {
            $query['ScaNamePattern'] = $request->scaNamePattern;
        }
        if (!Utils::isUnset($request->scaVersion)) {
            $query['ScaVersion'] = $request->scaVersion;
        }
        if (!Utils::isUnset($request->searchInfo)) {
            $query['SearchInfo'] = $request->searchInfo;
        }
        if (!Utils::isUnset($request->searchInfoSub)) {
            $query['SearchInfoSub'] = $request->searchInfoSub;
        }
        if (!Utils::isUnset($request->searchItem)) {
            $query['SearchItem'] = $request->searchItem;
        }
        if (!Utils::isUnset($request->searchItemSub)) {
            $query['SearchItemSub'] = $request->searchItemSub;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyScaDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyScaDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries middleware fingerprints.
     *  *
     * @param DescribePropertyScaDetailRequest $request DescribePropertyScaDetailRequest
     *
     * @return DescribePropertyScaDetailResponse DescribePropertyScaDetailResponse
     */
    public function describePropertyScaDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScaDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries middleware fingerprints.
     *  *
     * @param DescribePropertyScaItemRequest $request DescribePropertyScaItemRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyScaItemResponse DescribePropertyScaItemResponse
     */
    public function describePropertyScaItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->biz)) {
            $query['Biz'] = $request->biz;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->searchInfo)) {
            $query['SearchInfo'] = $request->searchInfo;
        }
        if (!Utils::isUnset($request->searchItem)) {
            $query['SearchItem'] = $request->searchItem;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyScaItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyScaItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries middleware fingerprints.
     *  *
     * @param DescribePropertyScaItemRequest $request DescribePropertyScaItemRequest
     *
     * @return DescribePropertyScaItemResponse DescribePropertyScaItemResponse
     */
    public function describePropertyScaItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScaItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the Java processes that are collected by the asset fingerprints feature of Security Center in your assets.
     *  *
     * @param DescribePropertyScaProcessDetailRequest $request DescribePropertyScaProcessDetailRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyScaProcessDetailResponse DescribePropertyScaProcessDetailResponse
     */
    public function describePropertyScaProcessDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pid)) {
            $query['Pid'] = $request->pid;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyScaProcessDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyScaProcessDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the Java processes that are collected by the asset fingerprints feature of Security Center in your assets.
     *  *
     * @param DescribePropertyScaProcessDetailRequest $request DescribePropertyScaProcessDetailRequest
     *
     * @return DescribePropertyScaProcessDetailResponse DescribePropertyScaProcessDetailResponse
     */
    public function describePropertyScaProcessDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScaProcessDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of scheduled tasks of asset fingerprint collection.
     *  *
     * @param DescribePropertyScheduleConfigRequest $request DescribePropertyScheduleConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyScheduleConfigResponse DescribePropertyScheduleConfigResponse
     */
    public function describePropertyScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of scheduled tasks of asset fingerprint collection.
     *  *
     * @param DescribePropertyScheduleConfigRequest $request DescribePropertyScheduleConfigRequest
     *
     * @return DescribePropertyScheduleConfigResponse DescribePropertyScheduleConfigResponse
     */
    public function describePropertyScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a software asset.
     *  *
     * @param DescribePropertySoftwareDetailRequest $request DescribePropertySoftwareDetailRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertySoftwareDetailResponse DescribePropertySoftwareDetailResponse
     */
    public function describePropertySoftwareDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->installTimeEnd)) {
            $query['InstallTimeEnd'] = $request->installTimeEnd;
        }
        if (!Utils::isUnset($request->installTimeStart)) {
            $query['InstallTimeStart'] = $request->installTimeStart;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->path)) {
            $query['Path'] = $request->path;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->softwareVersion)) {
            $query['SoftwareVersion'] = $request->softwareVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertySoftwareDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertySoftwareDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a software asset.
     *  *
     * @param DescribePropertySoftwareDetailRequest $request DescribePropertySoftwareDetailRequest
     *
     * @return DescribePropertySoftwareDetailResponse DescribePropertySoftwareDetailResponse
     */
    public function describePropertySoftwareDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertySoftwareDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about all software assets.
     *  *
     * @param DescribePropertySoftwareItemRequest $request DescribePropertySoftwareItemRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertySoftwareItemResponse DescribePropertySoftwareItemResponse
     */
    public function describePropertySoftwareItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertySoftwareItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertySoftwareItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about all software assets.
     *  *
     * @param DescribePropertySoftwareItemRequest $request DescribePropertySoftwareItemRequest
     *
     * @return DescribePropertySoftwareItemResponse DescribePropertySoftwareItemResponse
     */
    public function describePropertySoftwareItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertySoftwareItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries middleware types.
     *  *
     * @param DescribePropertyTypeScaItemRequest $request DescribePropertyTypeScaItemRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyTypeScaItemResponse DescribePropertyTypeScaItemResponse
     */
    public function describePropertyTypeScaItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyTypeScaItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyTypeScaItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries middleware types.
     *  *
     * @param DescribePropertyTypeScaItemRequest $request DescribePropertyTypeScaItemRequest
     *
     * @return DescribePropertyTypeScaItemResponse DescribePropertyTypeScaItemResponse
     */
    public function describePropertyTypeScaItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyTypeScaItemWithOptions($request, $runtime);
    }

    /**
     * @deprecated openAPI DescribePropertyUsageNewest is deprecated, please use Sas::2018-12-03::DescribeOnceTask instead
     *  *
     * @summary 查询资产指纹用户创建时间统计
     *  *
     * Deprecated
     *
     * @param DescribePropertyUsageNewestRequest $request DescribePropertyUsageNewestRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyUsageNewestResponse DescribePropertyUsageNewestResponse
     */
    public function describePropertyUsageNewestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyUsageNewest',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyUsageNewestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated openAPI DescribePropertyUsageNewest is deprecated, please use Sas::2018-12-03::DescribeOnceTask instead
     *  *
     * @summary 查询资产指纹用户创建时间统计
     *  *
     * Deprecated
     *
     * @param DescribePropertyUsageNewestRequest $request DescribePropertyUsageNewestRequest
     *
     * @return DescribePropertyUsageNewestResponse DescribePropertyUsageNewestResponse
     */
    public function describePropertyUsageNewest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUsageNewestWithOptions($request, $runtime);
    }

    /**
     * @summary Uses the asset fingerprints feature to obtain the statistics on top five most frequently detected ports, processes, software, accounts, or middleware.
     *  *
     * @description Only users who purchase the Enterprise or Ultimate edition of Security Center can call this operation.
     *  *
     * @param DescribePropertyUsageTopRequest $request DescribePropertyUsageTopRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyUsageTopResponse DescribePropertyUsageTopResponse
     */
    public function describePropertyUsageTopWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyUsageTop',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyUsageTopResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Uses the asset fingerprints feature to obtain the statistics on top five most frequently detected ports, processes, software, accounts, or middleware.
     *  *
     * @description Only users who purchase the Enterprise or Ultimate edition of Security Center can call this operation.
     *  *
     * @param DescribePropertyUsageTopRequest $request DescribePropertyUsageTopRequest
     *
     * @return DescribePropertyUsageTopResponse DescribePropertyUsageTopResponse
     */
    public function describePropertyUsageTop($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUsageTopWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the asset fingerprints for an account to which a server belongs.
     *  *
     * @param DescribePropertyUserDetailRequest $request DescribePropertyUserDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyUserDetailResponse DescribePropertyUserDetailResponse
     */
    public function describePropertyUserDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->isRoot)) {
            $query['IsRoot'] = $request->isRoot;
        }
        if (!Utils::isUnset($request->lastLoginTimeEnd)) {
            $query['LastLoginTimeEnd'] = $request->lastLoginTimeEnd;
        }
        if (!Utils::isUnset($request->lastLoginTimeStart)) {
            $query['LastLoginTimeStart'] = $request->lastLoginTimeStart;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyUserDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyUserDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the asset fingerprints for an account to which a server belongs.
     *  *
     * @param DescribePropertyUserDetailRequest $request DescribePropertyUserDetailRequest
     *
     * @return DescribePropertyUserDetailResponse DescribePropertyUserDetailResponse
     */
    public function describePropertyUserDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUserDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about an account.
     *  *
     * @param DescribePropertyUserItemRequest $request DescribePropertyUserItemRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyUserItemResponse DescribePropertyUserItemResponse
     */
    public function describePropertyUserItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyUserItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyUserItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about an account.
     *  *
     * @param DescribePropertyUserItemRequest $request DescribePropertyUserItemRequest
     *
     * @return DescribePropertyUserItemResponse DescribePropertyUserItemResponse
     */
    public function describePropertyUserItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUserItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the download information about a quarantined file.
     *  *
     * @param DescribeQuaraFileDownloadInfoRequest $request DescribeQuaraFileDownloadInfoRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeQuaraFileDownloadInfoResponse DescribeQuaraFileDownloadInfoResponse
     */
    public function describeQuaraFileDownloadInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->quaraFileId)) {
            $query['QuaraFileId'] = $request->quaraFileId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeQuaraFileDownloadInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeQuaraFileDownloadInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the download information about a quarantined file.
     *  *
     * @param DescribeQuaraFileDownloadInfoRequest $request DescribeQuaraFileDownloadInfoRequest
     *
     * @return DescribeQuaraFileDownloadInfoResponse DescribeQuaraFileDownloadInfoResponse
     */
    public function describeQuaraFileDownloadInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeQuaraFileDownloadInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a report export task.
     *  *
     * @param DescribeReportExportRequest $request DescribeReportExportRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeReportExportResponse DescribeReportExportResponse
     */
    public function describeReportExportWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeReportExport',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeReportExportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a report export task.
     *  *
     * @param DescribeReportExportRequest $request DescribeReportExportRequest
     *
     * @return DescribeReportExportResponse DescribeReportExportResponse
     */
    public function describeReportExport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeReportExportWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of a report recipient by using the security report feature of the System Configuration module in the Security Center console.
     *  *
     * @param DescribeReportRecipientStatusRequest $request DescribeReportRecipientStatusRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeReportRecipientStatusResponse DescribeReportRecipientStatusResponse
     */
    public function describeReportRecipientStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->recipients)) {
            $query['Recipients'] = $request->recipients;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeReportRecipientStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeReportRecipientStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of a report recipient by using the security report feature of the System Configuration module in the Security Center console.
     *  *
     * @param DescribeReportRecipientStatusRequest $request DescribeReportRecipientStatusRequest
     *
     * @return DescribeReportRecipientStatusResponse DescribeReportRecipientStatusResponse
     */
    public function describeReportRecipientStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeReportRecipientStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about restoration tasks.
     *  *
     * @description If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
     * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
     *  *
     * @param DescribeRestoreJobsRequest $request DescribeRestoreJobsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRestoreJobsResponse DescribeRestoreJobsResponse
     */
    public function describeRestoreJobsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->machineRemark)) {
            $query['MachineRemark'] = $request->machineRemark;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRestoreJobs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRestoreJobsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about restoration tasks.
     *  *
     * @description If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
     * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
     *  *
     * @param DescribeRestoreJobsRequest $request DescribeRestoreJobsRequest
     *
     * @return DescribeRestoreJobsResponse DescribeRestoreJobsResponse
     */
    public function describeRestoreJobs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRestoreJobsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries restoration tasks.
     *  *
     * @param DescribeRestorePlansRequest $request DescribeRestorePlansRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRestorePlansResponse DescribeRestorePlansResponse
     */
    public function describeRestorePlansWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->instanceName)) {
            $query['InstanceName'] = $request->instanceName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRestorePlans',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRestorePlansResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries restoration tasks.
     *  *
     * @param DescribeRestorePlansRequest $request DescribeRestorePlansRequest
     *
     * @return DescribeRestorePlansResponse DescribeRestorePlansResponse
     */
    public function describeRestorePlans($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRestorePlansWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
     *  *
     * @summary Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
     *  *
     * @description This operation is phased out. You can use the ListCheckInstanceResult operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckItemResultRequest $request DescribeRiskCheckItemResultRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskCheckItemResultResponse DescribeRiskCheckItemResultResponse
     */
    public function describeRiskCheckItemResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->itemId)) {
            $query['ItemId'] = $request->itemId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskCheckItemResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskCheckItemResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
     *  *
     * @summary Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
     *  *
     * @description This operation is phased out. You can use the ListCheckInstanceResult operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckItemResultRequest $request DescribeRiskCheckItemResultRequest
     *
     * @return DescribeRiskCheckItemResultResponse DescribeRiskCheckItemResultResponse
     */
    public function describeRiskCheckItemResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskCheckItemResultWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
     *  *
     * @summary Queries the check results of cloud service configurations by check item type or name.
     *  *
     * @description This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckResultRequest $request DescribeRiskCheckResultRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskCheckResultResponse DescribeRiskCheckResultResponse
     */
    public function describeRiskCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->itemIds)) {
            $query['ItemIds'] = $request->itemIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->queryFlag)) {
            $query['QueryFlag'] = $request->queryFlag;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
     *  *
     * @summary Queries the check results of cloud service configurations by check item type or name.
     *  *
     * @description This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckResultRequest $request DescribeRiskCheckResultRequest
     *
     * @return DescribeRiskCheckResultResponse DescribeRiskCheckResultResponse
     */
    public function describeRiskCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskCheckResultWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
     *  *
     * @summary Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
     *  *
     * @description This operation is phased out. You can use the GetCheckSummary operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckSummaryRequest $request DescribeRiskCheckSummaryRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskCheckSummaryResponse DescribeRiskCheckSummaryResponse
     */
    public function describeRiskCheckSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskCheckSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskCheckSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
     *  *
     * @summary Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
     *  *
     * @description This operation is phased out. You can use the GetCheckSummary operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckSummaryRequest $request DescribeRiskCheckSummaryRequest
     *
     * @return DescribeRiskCheckSummaryResponse DescribeRiskCheckSummaryResponse
     */
    public function describeRiskCheckSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskCheckSummaryWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskItemType is deprecated
     *  *
     * @summary Queries the types of check items in configuration assessment.
     *  *
     * @description This operation is phased out. You can use the ListCheckStandard operation instead.
     *  *
     * Deprecated
     *
     * @param DescribeRiskItemTypeRequest $request DescribeRiskItemTypeRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskItemTypeResponse DescribeRiskItemTypeResponse
     */
    public function describeRiskItemTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskItemType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskItemTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskItemType is deprecated
     *  *
     * @summary Queries the types of check items in configuration assessment.
     *  *
     * @description This operation is phased out. You can use the ListCheckStandard operation instead.
     *  *
     * Deprecated
     *
     * @param DescribeRiskItemTypeRequest $request DescribeRiskItemTypeRequest
     *
     * @return DescribeRiskItemTypeResponse DescribeRiskItemTypeResponse
     */
    public function describeRiskItemType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskItemTypeWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
     *  *
     * @summary Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
     *  *
     * @description This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
     *  *
     * Deprecated
     *
     * @param DescribeRiskListCheckResultRequest $request DescribeRiskListCheckResultRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskListCheckResultResponse DescribeRiskListCheckResultResponse
     */
    public function describeRiskListCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskListCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskListCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
     *  *
     * @summary Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
     *  *
     * @description This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
     *  *
     * Deprecated
     *
     * @param DescribeRiskListCheckResultRequest $request DescribeRiskListCheckResultRequest
     *
     * @return DescribeRiskListCheckResultResponse DescribeRiskListCheckResultResponse
     */
    public function describeRiskListCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskListCheckResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries baseline types.
     *  *
     * @param DescribeRiskTypeRequest $request DescribeRiskTypeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskTypeResponse DescribeRiskTypeResponse
     */
    public function describeRiskTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries baseline types.
     *  *
     * @param DescribeRiskTypeRequest $request DescribeRiskTypeRequest
     *
     * @return DescribeRiskTypeResponse DescribeRiskTypeResponse
     */
    public function describeRiskType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskTypeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about baselines based on baseline IDs or names.
     *  *
     * @param DescribeRisksRequest $request DescribeRisksRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRisksResponse DescribeRisksResponse
     */
    public function describeRisksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->limit)) {
            $query['Limit'] = $request->limit;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->riskName)) {
            $query['RiskName'] = $request->riskName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRisks',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRisksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about baselines based on baseline IDs or names.
     *  *
     * @param DescribeRisksRequest $request DescribeRisksRequest
     *
     * @return DescribeRisksResponse DescribeRisksResponse
     */
    public function describeRisks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRisksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
     *  *
     * @param DescribeSasPmAgentListRequest $request DescribeSasPmAgentListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSasPmAgentListResponse DescribeSasPmAgentListResponse
     */
    public function describeSasPmAgentListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSasPmAgentList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSasPmAgentListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
     *  *
     * @param DescribeSasPmAgentListRequest $request DescribeSasPmAgentListRequest
     *
     * @return DescribeSasPmAgentListResponse DescribeSasPmAgentListResponse
     */
    public function describeSasPmAgentList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSasPmAgentListWithOptions($request, $runtime);
    }

    /**
     * @summary DescribeScanTaskProgress
     *  *
     * @param DescribeScanTaskProgressRequest $request DescribeScanTaskProgressRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeScanTaskProgressResponse DescribeScanTaskProgressResponse
     */
    public function describeScanTaskProgressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeScanTaskProgress',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeScanTaskProgressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary DescribeScanTaskProgress
     *  *
     * @param DescribeScanTaskProgressRequest $request DescribeScanTaskProgressRequest
     *
     * @return DescribeScanTaskProgressResponse DescribeScanTaskProgressResponse
     */
    public function describeScanTaskProgress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeScanTaskProgressWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of virus detection tasks.
     *  *
     * @param DescribeScanTaskStatisticsRequest $request DescribeScanTaskStatisticsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeScanTaskStatisticsResponse DescribeScanTaskStatisticsResponse
     */
    public function describeScanTaskStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeScanTaskStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeScanTaskStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of virus detection tasks.
     *  *
     * @param DescribeScanTaskStatisticsRequest $request DescribeScanTaskStatisticsRequest
     *
     * @return DescribeScanTaskStatisticsResponse DescribeScanTaskStatisticsResponse
     */
    public function describeScanTaskStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeScanTaskStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the trends of the scores on the security dashboard.
     *  *
     * @param DescribeScreenScoreThreadRequest $request DescribeScreenScoreThreadRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeScreenScoreThreadResponse DescribeScreenScoreThreadResponse
     */
    public function describeScreenScoreThreadWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeScreenScoreThread',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeScreenScoreThreadResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the trends of the scores on the security dashboard.
     *  *
     * @param DescribeScreenScoreThreadRequest $request DescribeScreenScoreThreadRequest
     *
     * @return DescribeScreenScoreThreadResponse DescribeScreenScoreThreadResponse
     */
    public function describeScreenScoreThread($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeScreenScoreThreadWithOptions($request, $runtime);
    }

    /**
     * @summary 查询资产的筛选条件
     *  *
     * @param DescribeSearchConditionRequest $request DescribeSearchConditionRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSearchConditionResponse DescribeSearchConditionResponse
     */
    public function describeSearchConditionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSearchCondition',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSearchConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询资产的筛选条件
     *  *
     * @param DescribeSearchConditionRequest $request DescribeSearchConditionRequest
     *
     * @return DescribeSearchConditionResponse DescribeSearchConditionResponse
     */
    public function describeSearchCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSearchConditionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries suggestions on how to handle the risks that affect the security score.
     *  *
     * @param DescribeSecureSuggestionRequest $request DescribeSecureSuggestionRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecureSuggestionResponse DescribeSecureSuggestionResponse
     */
    public function describeSecureSuggestionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecureSuggestion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecureSuggestionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries suggestions on how to handle the risks that affect the security score.
     *  *
     * @param DescribeSecureSuggestionRequest $request DescribeSecureSuggestionRequest
     *
     * @return DescribeSecureSuggestionResponse DescribeSecureSuggestionResponse
     */
    public function describeSecureSuggestion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecureSuggestionWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
     *  *
     * @summary Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
     *  *
     * @description This operation is phased out. You can use the GetCheckConfig operation.
     *  *
     * Deprecated
     *
     * @param DescribeSecurityCheckScheduleConfigRequest $request DescribeSecurityCheckScheduleConfigRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityCheckScheduleConfigResponse DescribeSecurityCheckScheduleConfigResponse
     */
    public function describeSecurityCheckScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityCheckScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityCheckScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
     *  *
     * @summary Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
     *  *
     * @description This operation is phased out. You can use the GetCheckConfig operation.
     *  *
     * Deprecated
     *
     * @param DescribeSecurityCheckScheduleConfigRequest $request DescribeSecurityCheckScheduleConfigRequest
     *
     * @return DescribeSecurityCheckScheduleConfigResponse DescribeSecurityCheckScheduleConfigResponse
     */
    public function describeSecurityCheckScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityCheckScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of whitelist rules.
     *  *
     * @param DescribeSecurityEventMarkMissListRequest $request DescribeSecurityEventMarkMissListRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityEventMarkMissListResponse DescribeSecurityEventMarkMissListResponse
     */
    public function describeSecurityEventMarkMissListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityEventMarkMissList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityEventMarkMissListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of whitelist rules.
     *  *
     * @param DescribeSecurityEventMarkMissListRequest $request DescribeSecurityEventMarkMissListRequest
     *
     * @return DescribeSecurityEventMarkMissListResponse DescribeSecurityEventMarkMissListResponse
     */
    public function describeSecurityEventMarkMissList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityEventMarkMissListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
     *  *
     * @param DescribeSecurityEventOperationStatusRequest $request DescribeSecurityEventOperationStatusRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityEventOperationStatusResponse DescribeSecurityEventOperationStatusResponse
     */
    public function describeSecurityEventOperationStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityEventIds)) {
            $query['SecurityEventIds'] = $request->securityEventIds;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityEventOperationStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityEventOperationStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
     *  *
     * @param DescribeSecurityEventOperationStatusRequest $request DescribeSecurityEventOperationStatusRequest
     *
     * @return DescribeSecurityEventOperationStatusResponse DescribeSecurityEventOperationStatusResponse
     */
    public function describeSecurityEventOperationStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityEventOperationStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the operations that you can perform to handle an alert event.
     *  *
     * @param DescribeSecurityEventOperationsRequest $request DescribeSecurityEventOperationsRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityEventOperationsResponse DescribeSecurityEventOperationsResponse
     */
    public function describeSecurityEventOperationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityEventId)) {
            $query['SecurityEventId'] = $request->securityEventId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityEventOperations',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityEventOperationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the operations that you can perform to handle an alert event.
     *  *
     * @param DescribeSecurityEventOperationsRequest $request DescribeSecurityEventOperationsRequest
     *
     * @return DescribeSecurityEventOperationsResponse DescribeSecurityEventOperationsResponse
     */
    public function describeSecurityEventOperations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityEventOperationsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
     *  *
     * @param DescribeSecurityStatInfoRequest $request DescribeSecurityStatInfoRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityStatInfoResponse DescribeSecurityStatInfoResponse
     */
    public function describeSecurityStatInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityStatInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityStatInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
     *  *
     * @param DescribeSecurityStatInfoRequest $request DescribeSecurityStatInfoRequest
     *
     * @return DescribeSecurityStatInfoResponse DescribeSecurityStatInfoResponse
     */
    public function describeSecurityStatInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityStatInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether a service-linked role is created for Security Center.
     *  *
     * @param DescribeServiceLinkedRoleStatusRequest $request DescribeServiceLinkedRoleStatusRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeServiceLinkedRoleStatusResponse DescribeServiceLinkedRoleStatusResponse
     */
    public function describeServiceLinkedRoleStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->serviceLinkedRole)) {
            $query['ServiceLinkedRole'] = $request->serviceLinkedRole;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeServiceLinkedRoleStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeServiceLinkedRoleStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether a service-linked role is created for Security Center.
     *  *
     * @param DescribeServiceLinkedRoleStatusRequest $request DescribeServiceLinkedRoleStatusRequest
     *
     * @return DescribeServiceLinkedRoleStatusResponse DescribeServiceLinkedRoleStatusResponse
     */
    public function describeServiceLinkedRoleStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeServiceLinkedRoleStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Alibaba Cloud CLI is a tool used to manage and configure Alibaba Cloud resources. After simple installation and configuration, you can use Alibaba Cloud CLI to manage multiple Alibaba Cloud products and services and migrate your data and business to the cloud with ease.
     *  *
     * @param DescribeSimilarEventScenariosRequest $request DescribeSimilarEventScenariosRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSimilarEventScenariosResponse DescribeSimilarEventScenariosResponse
     */
    public function describeSimilarEventScenariosWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityEventId)) {
            $query['SecurityEventId'] = $request->securityEventId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSimilarEventScenarios',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSimilarEventScenariosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Alibaba Cloud CLI is a tool used to manage and configure Alibaba Cloud resources. After simple installation and configuration, you can use Alibaba Cloud CLI to manage multiple Alibaba Cloud products and services and migrate your data and business to the cloud with ease.
     *  *
     * @param DescribeSimilarEventScenariosRequest $request DescribeSimilarEventScenariosRequest
     *
     * @return DescribeSimilarEventScenariosResponse DescribeSimilarEventScenariosResponse
     */
    public function describeSimilarEventScenarios($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSimilarEventScenariosWithOptions($request, $runtime);
    }

    /**
     * @summary Queries alert events that are triggered by the same rule or of the same alert type.
     *  *
     * @param DescribeSimilarSecurityEventsRequest $request DescribeSimilarSecurityEventsRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSimilarSecurityEventsResponse DescribeSimilarSecurityEventsResponse
     */
    public function describeSimilarSecurityEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSimilarSecurityEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSimilarSecurityEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries alert events that are triggered by the same rule or of the same alert type.
     *  *
     * @param DescribeSimilarSecurityEventsRequest $request DescribeSimilarSecurityEventsRequest
     *
     * @return DescribeSimilarSecurityEventsResponse DescribeSimilarSecurityEventsResponse
     */
    public function describeSimilarSecurityEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSimilarSecurityEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the backup snapshots that are created for anti-ransomware.
     *  *
     * @param DescribeSnapshotsRequest $request DescribeSnapshotsRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSnapshotsResponse DescribeSnapshotsResponse
     */
    public function describeSnapshotsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->apiVersion)) {
            $query['ApiVersion'] = $request->apiVersion;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->isAliYunEcs)) {
            $query['IsAliYunEcs'] = $request->isAliYunEcs;
        }
        if (!Utils::isUnset($request->machineRegion)) {
            $query['MachineRegion'] = $request->machineRegion;
        }
        if (!Utils::isUnset($request->machineRemark)) {
            $query['MachineRemark'] = $request->machineRemark;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSnapshots',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSnapshotsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the backup snapshots that are created for anti-ransomware.
     *  *
     * @param DescribeSnapshotsRequest $request DescribeSnapshotsRequest
     *
     * @return DescribeSnapshotsResponse DescribeSnapshotsResponse
     */
    public function describeSnapshots($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSnapshotsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the policy templates on the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarStrategiesRequest $request DescribeSoarStrategiesRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSoarStrategiesResponse DescribeSoarStrategiesResponse
     */
    public function describeSoarStrategiesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSoarStrategies',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSoarStrategiesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the policy templates on the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarStrategiesRequest $request DescribeSoarStrategiesRequest
     *
     * @return DescribeSoarStrategiesResponse DescribeSoarStrategiesResponse
     */
    public function describeSoarStrategies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategiesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the parameters of a policy on the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarStrategyParamRequest $request DescribeSoarStrategyParamRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSoarStrategyParamResponse DescribeSoarStrategyParamResponse
     */
    public function describeSoarStrategyParamWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSoarStrategyParam',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSoarStrategyParamResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the parameters of a policy on the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarStrategyParamRequest $request DescribeSoarStrategyParamRequest
     *
     * @return DescribeSoarStrategyParamResponse DescribeSoarStrategyParamResponse
     */
    public function describeSoarStrategyParam($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategyParamWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a policy task on the Playbook page, including the execution status of the task and the process information of the task.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarStrategyTaskDetailRequest $request DescribeSoarStrategyTaskDetailRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSoarStrategyTaskDetailResponse DescribeSoarStrategyTaskDetailResponse
     */
    public function describeSoarStrategyTaskDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->strategyTaskId)) {
            $query['StrategyTaskId'] = $request->strategyTaskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSoarStrategyTaskDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSoarStrategyTaskDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a policy task on the Playbook page, including the execution status of the task and the process information of the task.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarStrategyTaskDetailRequest $request DescribeSoarStrategyTaskDetailRequest
     *
     * @return DescribeSoarStrategyTaskDetailResponse DescribeSoarStrategyTaskDetailResponse
     */
    public function describeSoarStrategyTaskDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategyTaskDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of policy tasks on the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarStrategyTasksRequest $request DescribeSoarStrategyTasksRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSoarStrategyTasksResponse DescribeSoarStrategyTasksResponse
     */
    public function describeSoarStrategyTasksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSoarStrategyTasks',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSoarStrategyTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of policy tasks on the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarStrategyTasksRequest $request DescribeSoarStrategyTasksRequest
     *
     * @return DescribeSoarStrategyTasksResponse DescribeSoarStrategyTasksResponse
     */
    public function describeSoarStrategyTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarStrategyTasksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of policies created on the Playbook page of Security Center.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarSubscribedStrategyRequest $request DescribeSoarSubscribedStrategyRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSoarSubscribedStrategyResponse DescribeSoarSubscribedStrategyResponse
     */
    public function describeSoarSubscribedStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSoarSubscribedStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSoarSubscribedStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of policies created on the Playbook page of Security Center.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param DescribeSoarSubscribedStrategyRequest $request DescribeSoarSubscribedStrategyRequest
     *
     * @return DescribeSoarSubscribedStrategyResponse DescribeSoarSubscribedStrategyResponse
     */
    public function describeSoarSubscribedStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSoarSubscribedStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about baseline check policies.
     *  *
     * @param DescribeStrategyRequest $request DescribeStrategyRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStrategyResponse DescribeStrategyResponse
     */
    public function describeStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->customType)) {
            $query['CustomType'] = $request->customType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyIds)) {
            $query['StrategyIds'] = $request->strategyIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about baseline check policies.
     *  *
     * @param DescribeStrategyRequest $request DescribeStrategyRequest
     *
     * @return DescribeStrategyResponse DescribeStrategyResponse
     */
    public function describeStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a baseline check policy.
     *  *
     * @param DescribeStrategyDetailRequest $request DescribeStrategyDetailRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStrategyDetailResponse DescribeStrategyDetailResponse
     */
    public function describeStrategyDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeStrategyDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeStrategyDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a baseline check policy.
     *  *
     * @param DescribeStrategyDetailRequest $request DescribeStrategyDetailRequest
     *
     * @return DescribeStrategyDetailResponse DescribeStrategyDetailResponse
     */
    public function describeStrategyDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyDetailWithOptions($request, $runtime);
    }

    /**
     * @summary 查询单个基线检查策略的检查结果
     *  *
     * @param DescribeStrategyExecDetailRequest $request DescribeStrategyExecDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStrategyExecDetailResponse DescribeStrategyExecDetailResponse
     */
    public function describeStrategyExecDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeStrategyExecDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeStrategyExecDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询单个基线检查策略的检查结果
     *  *
     * @param DescribeStrategyExecDetailRequest $request DescribeStrategyExecDetailRequest
     *
     * @return DescribeStrategyExecDetailResponse DescribeStrategyExecDetailResponse
     */
    public function describeStrategyExecDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyExecDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the assets to which a baseline check policy is applied.
     *  *
     * @param DescribeStrategyTargetRequest $request DescribeStrategyTargetRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStrategyTargetResponse DescribeStrategyTargetResponse
     */
    public function describeStrategyTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeStrategyTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeStrategyTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the assets to which a baseline check policy is applied.
     *  *
     * @param DescribeStrategyTargetRequest $request DescribeStrategyTargetRequest
     *
     * @return DescribeStrategyTargetResponse DescribeStrategyTargetResponse
     */
    public function describeStrategyTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
     *  *
     * @param DescribeSummaryInfoRequest $request DescribeSummaryInfoRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSummaryInfoResponse DescribeSummaryInfoResponse
     */
    public function describeSummaryInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSummaryInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSummaryInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
     *  *
     * @param DescribeSummaryInfoRequest $request DescribeSummaryInfoRequest
     *
     * @return DescribeSummaryInfoResponse DescribeSummaryInfoResponse
     */
    public function describeSummaryInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSummaryInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the time when a system vulnerability was last detected.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSupervisonInfoResponse DescribeSupervisonInfoResponse
     */
    public function describeSupervisonInfoWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeSupervisonInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSupervisonInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the time when a system vulnerability was last detected.
     *  *
     * @return DescribeSupervisonInfoResponse DescribeSupervisonInfoResponse
     */
    public function describeSupervisonInfo()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSupervisonInfoWithOptions($runtime);
    }

    /**
     * @summary Queries the regions in which the anti-ransomware feature is supported.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSupportRegionResponse DescribeSupportRegionResponse
     */
    public function describeSupportRegionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeSupportRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSupportRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the regions in which the anti-ransomware feature is supported.
     *  *
     * @return DescribeSupportRegionResponse DescribeSupportRegionResponse
     */
    public function describeSupportRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSupportRegionWithOptions($runtime);
    }

    /**
     * @summary Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
     *  *
     * @param DescribeSuspEventDetailRequest $request DescribeSuspEventDetailRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventDetailResponse DescribeSuspEventDetailResponse
     */
    public function describeSuspEventDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->suspiciousEventId)) {
            $query['SuspiciousEventId'] = $request->suspiciousEventId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEventDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
     *  *
     * @param DescribeSuspEventDetailRequest $request DescribeSuspEventDetailRequest
     *
     * @return DescribeSuspEventDetailResponse DescribeSuspEventDetailResponse
     */
    public function describeSuspEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an export task of exceptions.
     *  *
     * @param DescribeSuspEventExportInfoRequest $request DescribeSuspEventExportInfoRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventExportInfoResponse DescribeSuspEventExportInfoResponse
     */
    public function describeSuspEventExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEventExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an export task of exceptions.
     *  *
     * @param DescribeSuspEventExportInfoRequest $request DescribeSuspEventExportInfoRequest
     *
     * @return DescribeSuspEventExportInfoResponse DescribeSuspEventExportInfoResponse
     */
    public function describeSuspEventExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries quarantined files by page.
     *  *
     * @param DescribeSuspEventQuaraFilesRequest $request DescribeSuspEventQuaraFilesRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventQuaraFilesResponse DescribeSuspEventQuaraFilesResponse
     */
    public function describeSuspEventQuaraFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->groupingId)) {
            $query['GroupingId'] = $request->groupingId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->quaraTag)) {
            $query['QuaraTag'] = $request->quaraTag;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEventQuaraFiles',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventQuaraFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries quarantined files by page.
     *  *
     * @param DescribeSuspEventQuaraFilesRequest $request DescribeSuspEventQuaraFilesRequest
     *
     * @return DescribeSuspEventQuaraFilesResponse DescribeSuspEventQuaraFilesResponse
     */
    public function describeSuspEventQuaraFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventQuaraFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the user settings for exceptions.
     *  *
     * @param DescribeSuspEventUserSettingRequest $request DescribeSuspEventUserSettingRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventUserSettingResponse DescribeSuspEventUserSettingResponse
     */
    public function describeSuspEventUserSettingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEventUserSetting',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the user settings for exceptions.
     *  *
     * @param DescribeSuspEventUserSettingRequest $request DescribeSuspEventUserSettingRequest
     *
     * @return DescribeSuspEventUserSettingResponse DescribeSuspEventUserSettingResponse
     */
    public function describeSuspEventUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventUserSettingWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of alert events that are generated without aggregation.
     *  *
     * @param DescribeSuspEventsRequest $tmpReq  DescribeSuspEventsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventsResponse DescribeSuspEventsResponse
     */
    public function describeSuspEventsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeSuspEventsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->sourceAliUids)) {
            $request->sourceAliUidsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->sourceAliUids, 'SourceAliUids', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->alarmUniqueInfo)) {
            $query['AlarmUniqueInfo'] = $request->alarmUniqueInfo;
        }
        if (!Utils::isUnset($request->assetsTypeList)) {
            $query['AssetsTypeList'] = $request->assetsTypeList;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->eventNames)) {
            $query['EventNames'] = $request->eventNames;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->multiAccountActionType)) {
            $query['MultiAccountActionType'] = $request->multiAccountActionType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->operateErrorCodeList)) {
            $query['OperateErrorCodeList'] = $request->operateErrorCodeList;
        }
        if (!Utils::isUnset($request->operateTimeEnd)) {
            $query['OperateTimeEnd'] = $request->operateTimeEnd;
        }
        if (!Utils::isUnset($request->operateTimeStart)) {
            $query['OperateTimeStart'] = $request->operateTimeStart;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentEventTypes)) {
            $query['ParentEventTypes'] = $request->parentEventTypes;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sortColumn)) {
            $query['SortColumn'] = $request->sortColumn;
        }
        if (!Utils::isUnset($request->sortType)) {
            $query['SortType'] = $request->sortType;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->sourceAliUidsShrink)) {
            $query['SourceAliUids'] = $request->sourceAliUidsShrink;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->strictMode)) {
            $query['StrictMode'] = $request->strictMode;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        if (!Utils::isUnset($request->uniqueInfo)) {
            $query['UniqueInfo'] = $request->uniqueInfo;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $body = [];
        if (!Utils::isUnset($request->tacticId)) {
            $body['TacticId'] = $request->tacticId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of alert events that are generated without aggregation.
     *  *
     * @param DescribeSuspEventsRequest $request DescribeSuspEventsRequest
     *
     * @return DescribeSuspEventsResponse DescribeSuspEventsResponse
     */
    public function describeSuspEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of a specified feature.
     *  *
     * @param DescribeSuspiciousOverallConfigRequest $request DescribeSuspiciousOverallConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspiciousOverallConfigResponse DescribeSuspiciousOverallConfigResponse
     */
    public function describeSuspiciousOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspiciousOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspiciousOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of a specified feature.
     *  *
     * @param DescribeSuspiciousOverallConfigRequest $request DescribeSuspiciousOverallConfigRequest
     *
     * @return DescribeSuspiciousOverallConfigResponse DescribeSuspiciousOverallConfigResponse
     */
    public function describeSuspiciousOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspiciousOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
     *  *
     * @param DescribeSuspiciousUUIDConfigRequest $request DescribeSuspiciousUUIDConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspiciousUUIDConfigResponse DescribeSuspiciousUUIDConfigResponse
     */
    public function describeSuspiciousUUIDConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspiciousUUIDConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspiciousUUIDConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
     *  *
     * @param DescribeSuspiciousUUIDConfigRequest $request DescribeSuspiciousUUIDConfigRequest
     *
     * @return DescribeSuspiciousUUIDConfigResponse DescribeSuspiciousUUIDConfigResponse
     */
    public function describeSuspiciousUUIDConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspiciousUUIDConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of IDC scan tasks.
     *  *
     * @param DescribeSyncAssetTaskListRequest $request DescribeSyncAssetTaskListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSyncAssetTaskListResponse DescribeSyncAssetTaskListResponse
     */
    public function describeSyncAssetTaskListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSyncAssetTaskList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSyncAssetTaskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of IDC scan tasks.
     *  *
     * @param DescribeSyncAssetTaskListRequest $request DescribeSyncAssetTaskListRequest
     *
     * @return DescribeSyncAssetTaskListResponse DescribeSyncAssetTaskListResponse
     */
    public function describeSyncAssetTaskList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSyncAssetTaskListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an IDC scan task.
     *  *
     * @param DescribeSyncAssetTaskLogDetailRequest $request DescribeSyncAssetTaskLogDetailRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSyncAssetTaskLogDetailResponse DescribeSyncAssetTaskLogDetailResponse
     */
    public function describeSyncAssetTaskLogDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->rootTaskId)) {
            $query['RootTaskId'] = $request->rootTaskId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSyncAssetTaskLogDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSyncAssetTaskLogDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an IDC scan task.
     *  *
     * @param DescribeSyncAssetTaskLogDetailRequest $request DescribeSyncAssetTaskLogDetailRequest
     *
     * @return DescribeSyncAssetTaskLogDetailResponse DescribeSyncAssetTaskLogDetailResponse
     */
    public function describeSyncAssetTaskLogDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSyncAssetTaskLogDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers on which vulnerability scan is enabled.
     *  *
     * @param DescribeTargetRequest $request DescribeTargetRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTargetResponse DescribeTargetResponse
     */
    public function describeTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers on which vulnerability scan is enabled.
     *  *
     * @param DescribeTargetRequest $request DescribeTargetRequest
     *
     * @return DescribeTargetResponse DescribeTargetResponse
     */
    public function describeTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the error logs on a task that failed to fix image vulnerabilities.
     *  *
     * @param DescribeTaskErrorLogRequest $request DescribeTaskErrorLogRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTaskErrorLogResponse DescribeTaskErrorLogResponse
     */
    public function describeTaskErrorLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->buildTaskId)) {
            $query['BuildTaskId'] = $request->buildTaskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTaskErrorLog',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTaskErrorLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the error logs on a task that failed to fix image vulnerabilities.
     *  *
     * @param DescribeTaskErrorLogRequest $request DescribeTaskErrorLogRequest
     *
     * @return DescribeTaskErrorLogResponse DescribeTaskErrorLogResponse
     */
    public function describeTaskErrorLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTaskErrorLogWithOptions($request, $runtime);
    }

    /**
     * @summary Queries event statistics.
     *  *
     * @param DescribeTotalStatisticsRequest $request DescribeTotalStatisticsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTotalStatisticsResponse DescribeTotalStatisticsResponse
     */
    public function describeTotalStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTotalStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTotalStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries event statistics.
     *  *
     * @param DescribeTotalStatisticsRequest $request DescribeTotalStatisticsRequest
     *
     * @return DescribeTotalStatisticsResponse DescribeTotalStatisticsResponse
     */
    public function describeTotalStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTotalStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the trace information about alerts.
     *  *
     * @param DescribeTraceInfoDetailRequest $request DescribeTraceInfoDetailRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTraceInfoDetailResponse DescribeTraceInfoDetailResponse
     */
    public function describeTraceInfoDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->incidentTime)) {
            $query['IncidentTime'] = $request->incidentTime;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->vertexId)) {
            $query['VertexId'] = $request->vertexId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTraceInfoDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTraceInfoDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the trace information about alerts.
     *  *
     * @param DescribeTraceInfoDetailRequest $request DescribeTraceInfoDetailRequest
     *
     * @return DescribeTraceInfoDetailResponse DescribeTraceInfoDetailResponse
     */
    public function describeTraceInfoDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTraceInfoDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a trace node.
     *  *
     * @param DescribeTraceInfoNodeRequest $request DescribeTraceInfoNodeRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTraceInfoNodeResponse DescribeTraceInfoNodeResponse
     */
    public function describeTraceInfoNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->incidentTime)) {
            $query['IncidentTime'] = $request->incidentTime;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->vertexId)) {
            $query['VertexId'] = $request->vertexId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTraceInfoNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTraceInfoNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a trace node.
     *  *
     * @param DescribeTraceInfoNodeRequest $request DescribeTraceInfoNodeRequest
     *
     * @return DescribeTraceInfoNodeResponse DescribeTraceInfoNodeResponse
     */
    public function describeTraceInfoNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTraceInfoNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about databases for which anti-ransomware policies are created.
     *  *
     * @param DescribeUniBackupDatabaseRequest $request DescribeUniBackupDatabaseRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniBackupDatabaseResponse DescribeUniBackupDatabaseResponse
     */
    public function describeUniBackupDatabaseWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->databaseType)) {
            $query['DatabaseType'] = $request->databaseType;
        }
        if (!Utils::isUnset($request->instanceName)) {
            $query['InstanceName'] = $request->instanceName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->queryType)) {
            $query['QueryType'] = $request->queryType;
        }
        if (!Utils::isUnset($request->uniRegionId)) {
            $query['UniRegionId'] = $request->uniRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUniBackupDatabase',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniBackupDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about databases for which anti-ransomware policies are created.
     *  *
     * @param DescribeUniBackupDatabaseRequest $request DescribeUniBackupDatabaseRequest
     *
     * @return DescribeUniBackupDatabaseResponse DescribeUniBackupDatabaseResponse
     */
    public function describeUniBackupDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupDatabaseWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the anti-ransomware policies that are created for databases.
     *  *
     * @param DescribeUniBackupPoliciesRequest $request DescribeUniBackupPoliciesRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniBackupPoliciesResponse DescribeUniBackupPoliciesResponse
     */
    public function describeUniBackupPoliciesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->policyName)) {
            $query['PolicyName'] = $request->policyName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUniBackupPolicies',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniBackupPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the anti-ransomware policies that are created for databases.
     *  *
     * @param DescribeUniBackupPoliciesRequest $request DescribeUniBackupPoliciesRequest
     *
     * @return DescribeUniBackupPoliciesResponse DescribeUniBackupPoliciesResponse
     */
    public function describeUniBackupPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupPoliciesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an anti-ransomware policy for databases.
     *  *
     * @param DescribeUniBackupPolicyDetailRequest $request DescribeUniBackupPolicyDetailRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniBackupPolicyDetailResponse DescribeUniBackupPolicyDetailResponse
     */
    public function describeUniBackupPolicyDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUniBackupPolicyDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniBackupPolicyDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an anti-ransomware policy for databases.
     *  *
     * @param DescribeUniBackupPolicyDetailRequest $request DescribeUniBackupPolicyDetailRequest
     *
     * @return DescribeUniBackupPolicyDetailResponse DescribeUniBackupPolicyDetailResponse
     */
    public function describeUniBackupPolicyDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupPolicyDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics on backups based on anti-ransomware policies.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniBackupStatisticsResponse DescribeUniBackupStatisticsResponse
     */
    public function describeUniBackupStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeUniBackupStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniBackupStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on backups based on anti-ransomware policies.
     *  *
     * @return DescribeUniBackupStatisticsResponse DescribeUniBackupStatisticsResponse
     */
    public function describeUniBackupStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries the backup snapshots from which the data of a database can be restored.
     *  *
     * @param DescribeUniRecoverableListRequest $request DescribeUniRecoverableListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniRecoverableListResponse DescribeUniRecoverableListResponse
     */
    public function describeUniRecoverableListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->database)) {
            $query['Database'] = $request->database;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUniRecoverableList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniRecoverableListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the backup snapshots from which the data of a database can be restored.
     *  *
     * @param DescribeUniRecoverableListRequest $request DescribeUniRecoverableListRequest
     *
     * @return DescribeUniRecoverableListResponse DescribeUniRecoverableListResponse
     */
    public function describeUniRecoverableList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniRecoverableListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the region that is supported by anti-ransomware for databases.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniSupportRegionResponse DescribeUniSupportRegionResponse
     */
    public function describeUniSupportRegionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeUniSupportRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniSupportRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the region that is supported by anti-ransomware for databases.
     *  *
     * @return DescribeUniSupportRegionResponse DescribeUniSupportRegionResponse
     */
    public function describeUniSupportRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniSupportRegionWithOptions($runtime);
    }

    /**
     * @summary Queries the information about the servers to which an anti-ransomware policy is applied.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUserBackupMachinesResponse DescribeUserBackupMachinesResponse
     */
    public function describeUserBackupMachinesWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeUserBackupMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUserBackupMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers to which an anti-ransomware policy is applied.
     *  *
     * @return DescribeUserBackupMachinesResponse DescribeUserBackupMachinesResponse
     */
    public function describeUserBackupMachines()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserBackupMachinesWithOptions($runtime);
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param DescribeUserBaselineAuthorizationRequest $request DescribeUserBaselineAuthorizationRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUserBaselineAuthorizationResponse DescribeUserBaselineAuthorizationResponse
     */
    public function describeUserBaselineAuthorizationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUserBaselineAuthorization',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUserBaselineAuthorizationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param DescribeUserBaselineAuthorizationRequest $request DescribeUserBaselineAuthorizationRequest
     *
     * @return DescribeUserBaselineAuthorizationResponse DescribeUserBaselineAuthorizationResponse
     */
    public function describeUserBaselineAuthorization($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserBaselineAuthorizationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether the brute-force attacks protection feature has been authorized. The brute-force attacks protection feature cannot be used without authorization.
     *  *
     * @param DescribeUserLayoutAuthorizationRequest $request DescribeUserLayoutAuthorizationRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUserLayoutAuthorizationResponse DescribeUserLayoutAuthorizationResponse
     */
    public function describeUserLayoutAuthorizationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUserLayoutAuthorization',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUserLayoutAuthorizationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether the brute-force attacks protection feature has been authorized. The brute-force attacks protection feature cannot be used without authorization.
     *  *
     * @param DescribeUserLayoutAuthorizationRequest $request DescribeUserLayoutAuthorizationRequest
     *
     * @return DescribeUserLayoutAuthorizationResponse DescribeUserLayoutAuthorizationResponse
     */
    public function describeUserLayoutAuthorization($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserLayoutAuthorizationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the settings of a custom baseline check policy.
     *  *
     * @param DescribeUserSettingRequest $request DescribeUserSettingRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUserSettingResponse DescribeUserSettingResponse
     */
    public function describeUserSettingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUserSetting',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the settings of a custom baseline check policy.
     *  *
     * @param DescribeUserSettingRequest $request DescribeUserSettingRequest
     *
     * @return DescribeUserSettingResponse DescribeUserSettingResponse
     */
    public function describeUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserSettingWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of assets that support fixing based on vulnerability names.
     *  *
     * @param DescribeUuidsByVulNamesRequest $request DescribeUuidsByVulNamesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUuidsByVulNamesResponse DescribeUuidsByVulNamesResponse
     */
    public function describeUuidsByVulNamesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->fieldName)) {
            $query['FieldName'] = $request->fieldName;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->level)) {
            $query['Level'] = $request->level;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->searchTags)) {
            $query['SearchTags'] = $request->searchTags;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->vpcInstanceIds)) {
            $query['VpcInstanceIds'] = $request->vpcInstanceIds;
        }
        if (!Utils::isUnset($request->vulNames)) {
            $query['VulNames'] = $request->vulNames;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUuidsByVulNames',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUuidsByVulNamesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of assets that support fixing based on vulnerability names.
     *  *
     * @param DescribeUuidsByVulNamesRequest $request DescribeUuidsByVulNamesRequest
     *
     * @return DescribeUuidsByVulNamesResponse DescribeUuidsByVulNamesResponse
     */
    public function describeUuidsByVulNames($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUuidsByVulNamesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the service providers whose assets can be added to Security Center.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVendorListResponse DescribeVendorListResponse
     */
    public function describeVendorListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeVendorList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVendorListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the service providers whose assets can be added to Security Center.
     *  *
     * @return DescribeVendorListResponse DescribeVendorListResponse
     */
    public function describeVendorList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVendorListWithOptions($runtime);
    }

    /**
     * @summary Queries the details about the edition of purchased Security Center.
     *  *
     * @param DescribeVersionConfigRequest $request DescribeVersionConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVersionConfigResponse DescribeVersionConfigResponse
     */
    public function describeVersionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVersionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVersionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about the edition of purchased Security Center.
     *  *
     * @param DescribeVersionConfigRequest $request DescribeVersionConfigRequest
     *
     * @return DescribeVersionConfigResponse DescribeVersionConfigResponse
     */
    public function describeVersionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVersionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary 查询钉钉群二维码地址
     *  *
     * @param DescribeVolDingdingMessageRequest $request DescribeVolDingdingMessageRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVolDingdingMessageResponse DescribeVolDingdingMessageResponse
     */
    public function describeVolDingdingMessageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVolDingdingMessage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVolDingdingMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询钉钉群二维码地址
     *  *
     * @param DescribeVolDingdingMessageRequest $request DescribeVolDingdingMessageRequest
     *
     * @return DescribeVolDingdingMessageResponse DescribeVolDingdingMessageResponse
     */
    public function describeVolDingdingMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVolDingdingMessageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the search conditions that can be used to query honeypots.
     *  *
     * @param DescribeVpcHoneyPotCriteriaRequest $request DescribeVpcHoneyPotCriteriaRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpcHoneyPotCriteriaResponse DescribeVpcHoneyPotCriteriaResponse
     */
    public function describeVpcHoneyPotCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpcHoneyPotCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpcHoneyPotCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the search conditions that can be used to query honeypots.
     *  *
     * @param DescribeVpcHoneyPotCriteriaRequest $request DescribeVpcHoneyPotCriteriaRequest
     *
     * @return DescribeVpcHoneyPotCriteriaResponse DescribeVpcHoneyPotCriteriaResponse
     */
    public function describeVpcHoneyPotCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcHoneyPotCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries virtual private clouds (VPCs) on which honeypots are deployed.
     *  *
     * @description If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
     *  *
     * @param DescribeVpcHoneyPotListRequest $request DescribeVpcHoneyPotListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpcHoneyPotListResponse DescribeVpcHoneyPotListResponse
     */
    public function describeVpcHoneyPotListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->honeyPotExistence)) {
            $query['HoneyPotExistence'] = $request->honeyPotExistence;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->vpcName)) {
            $query['VpcName'] = $request->vpcName;
        }
        if (!Utils::isUnset($request->vpcRegionId)) {
            $query['VpcRegionId'] = $request->vpcRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpcHoneyPotList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpcHoneyPotListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries virtual private clouds (VPCs) on which honeypots are deployed.
     *  *
     * @description If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
     *  *
     * @param DescribeVpcHoneyPotListRequest $request DescribeVpcHoneyPotListRequest
     *
     * @return DescribeVpcHoneyPotListResponse DescribeVpcHoneyPotListResponse
     */
    public function describeVpcHoneyPotList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcHoneyPotListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about virtual private clouds (VPCs).
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpcListResponse DescribeVpcListResponse
     */
    public function describeVpcListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeVpcList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpcListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about virtual private clouds (VPCs).
     *  *
     * @return DescribeVpcListResponse DescribeVpcListResponse
     */
    public function describeVpcList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcListWithOptions($runtime);
    }

    /**
     * @summary Queries the status information about vulnerability scan tasks on a server.
     *  *
     * @param DescribeVulCheckTaskStatusDetailRequest $request DescribeVulCheckTaskStatusDetailRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulCheckTaskStatusDetailResponse DescribeVulCheckTaskStatusDetailResponse
     */
    public function describeVulCheckTaskStatusDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskIds)) {
            $query['TaskIds'] = $request->taskIds;
        }
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulCheckTaskStatusDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulCheckTaskStatusDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status information about vulnerability scan tasks on a server.
     *  *
     * @param DescribeVulCheckTaskStatusDetailRequest $request DescribeVulCheckTaskStatusDetailRequest
     *
     * @return DescribeVulCheckTaskStatusDetailResponse DescribeVulCheckTaskStatusDetailResponse
     */
    public function describeVulCheckTaskStatusDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulCheckTaskStatusDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of vulnerability management.
     *  *
     * @param DescribeVulConfigRequest $request DescribeVulConfigRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulConfigResponse DescribeVulConfigResponse
     */
    public function describeVulConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of vulnerability management.
     *  *
     * @param DescribeVulConfigRequest $request DescribeVulConfigRequest
     *
     * @return DescribeVulConfigResponse DescribeVulConfigResponse
     */
    public function describeVulConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the vulnerability defense statistics in Security Center.
     *  *
     * @param DescribeVulDefendCountStatisticsRequest $request DescribeVulDefendCountStatisticsRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulDefendCountStatisticsResponse DescribeVulDefendCountStatisticsResponse
     */
    public function describeVulDefendCountStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vulType)) {
            $query['VulType'] = $request->vulType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulDefendCountStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulDefendCountStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the vulnerability defense statistics in Security Center.
     *  *
     * @param DescribeVulDefendCountStatisticsRequest $request DescribeVulDefendCountStatisticsRequest
     *
     * @return DescribeVulDefendCountStatisticsResponse DescribeVulDefendCountStatisticsResponse
     */
    public function describeVulDefendCountStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulDefendCountStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a vulnerability.
     *  *
     * @param DescribeVulDetailsRequest $request DescribeVulDetailsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulDetailsResponse DescribeVulDetailsResponse
     */
    public function describeVulDetailsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulDetails',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulDetailsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a vulnerability.
     *  *
     * @param DescribeVulDetailsRequest $request DescribeVulDetailsRequest
     *
     * @return DescribeVulDetailsResponse DescribeVulDetailsResponse
     */
    public function describeVulDetails($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulDetailsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a task that exports vulnerabilities.
     *  *
     * @description If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
     *  *
     * @param DescribeVulExportInfoRequest $request DescribeVulExportInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulExportInfoResponse DescribeVulExportInfoResponse
     */
    public function describeVulExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a task that exports vulnerabilities.
     *  *
     * @description If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
     *  *
     * @param DescribeVulExportInfoRequest $request DescribeVulExportInfoRequest
     *
     * @return DescribeVulExportInfoResponse DescribeVulExportInfoResponse
     */
    public function describeVulExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of vulnerability fixes.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulFixStatisticsResponse DescribeVulFixStatisticsResponse
     */
    public function describeVulFixStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeVulFixStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulFixStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of vulnerability fixes.
     *  *
     * @return DescribeVulFixStatisticsResponse DescribeVulFixStatisticsResponse
     */
    public function describeVulFixStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulFixStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries vulnerabilities by type.
     *  *
     * @param DescribeVulListRequest $request DescribeVulListRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulListResponse DescribeVulListResponse
     */
    public function describeVulListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->attachTypes)) {
            $query['AttachTypes'] = $request->attachTypes;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->useNextToken)) {
            $query['UseNextToken'] = $request->useNextToken;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->vpcInstanceIds)) {
            $query['VpcInstanceIds'] = $request->vpcInstanceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries vulnerabilities by type.
     *  *
     * @param DescribeVulListRequest $request DescribeVulListRequest
     *
     * @return DescribeVulListResponse DescribeVulListResponse
     */
    public function describeVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the vulnerabilities that can be detected.
     *  *
     * @param DescribeVulListPageRequest $request DescribeVulListPageRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulListPageResponse DescribeVulListPageResponse
     */
    public function describeVulListPageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->cveId)) {
            $query['CveId'] = $request->cveId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->raspDefend)) {
            $query['RaspDefend'] = $request->raspDefend;
        }
        if (!Utils::isUnset($request->vulNameLike)) {
            $query['VulNameLike'] = $request->vulNameLike;
        }
        if (!Utils::isUnset($request->vulType)) {
            $query['VulType'] = $request->vulType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulListPage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulListPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the vulnerabilities that can be detected.
     *  *
     * @param DescribeVulListPageRequest $request DescribeVulListPageRequest
     *
     * @return DescribeVulListPageResponse DescribeVulListPageResponse
     */
    public function describeVulListPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulListPageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of vulnerabilities in Security Center.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulMetaCountStatisticsResponse DescribeVulMetaCountStatisticsResponse
     */
    public function describeVulMetaCountStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeVulMetaCountStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulMetaCountStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of vulnerabilities in Security Center.
     *  *
     * @return DescribeVulMetaCountStatisticsResponse DescribeVulMetaCountStatisticsResponse
     */
    public function describeVulMetaCountStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulMetaCountStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics of vulnerabilities.
     *  *
     * @param DescribeVulNumStatisticsRequest $request DescribeVulNumStatisticsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulNumStatisticsResponse DescribeVulNumStatisticsResponse
     */
    public function describeVulNumStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulNumStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulNumStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of vulnerabilities.
     *  *
     * @param DescribeVulNumStatisticsRequest $request DescribeVulNumStatisticsRequest
     *
     * @return DescribeVulNumStatisticsResponse DescribeVulNumStatisticsResponse
     */
    public function describeVulNumStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulNumStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the vulnerability scan feature for a server.
     *  *
     * @param DescribeVulTargetConfigRequest $request DescribeVulTargetConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulTargetConfigResponse DescribeVulTargetConfigResponse
     */
    public function describeVulTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the vulnerability scan feature for a server.
     *  *
     * @param DescribeVulTargetConfigRequest $request DescribeVulTargetConfigRequest
     *
     * @return DescribeVulTargetConfigResponse DescribeVulTargetConfigResponse
     */
    public function describeVulTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the vulnerability scan feature.
     *  *
     * @param DescribeVulTargetStatisticsRequest $request DescribeVulTargetStatisticsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulTargetStatisticsResponse DescribeVulTargetStatisticsResponse
     */
    public function describeVulTargetStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulTargetStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulTargetStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the vulnerability scan feature.
     *  *
     * @param DescribeVulTargetStatisticsRequest $request DescribeVulTargetStatisticsRequest
     *
     * @return DescribeVulTargetStatisticsResponse DescribeVulTargetStatisticsResponse
     */
    public function describeVulTargetStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulTargetStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the whitelist of vulnerabilities by page.
     *  *
     * @param DescribeVulWhitelistRequest $request DescribeVulWhitelistRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulWhitelistResponse DescribeVulWhitelistResponse
     */
    public function describeVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the whitelist of vulnerabilities by page.
     *  *
     * @param DescribeVulWhitelistRequest $request DescribeVulWhitelistRequest
     *
     * @return DescribeVulWhitelistResponse DescribeVulWhitelistResponse
     */
    public function describeVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a export task for a baseline check result.
     *  *
     * @param DescribeWarningExportInfoRequest $request DescribeWarningExportInfoRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWarningExportInfoResponse DescribeWarningExportInfoResponse
     */
    public function describeWarningExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWarningExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWarningExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a export task for a baseline check result.
     *  *
     * @param DescribeWarningExportInfoRequest $request DescribeWarningExportInfoRequest
     *
     * @return DescribeWarningExportInfoResponse DescribeWarningExportInfoResponse
     */
    public function describeWarningExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWarningExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
     *  *
     * @param DescribeWarningMachinesRequest $request DescribeWarningMachinesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWarningMachinesResponse DescribeWarningMachinesResponse
     */
    public function describeWarningMachinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->haveRisk)) {
            $query['HaveRisk'] = $request->haveRisk;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->machineName)) {
            $query['MachineName'] = $request->machineName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWarningMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWarningMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
     *  *
     * @param DescribeWarningMachinesRequest $request DescribeWarningMachinesRequest
     *
     * @return DescribeWarningMachinesResponse DescribeWarningMachinesResponse
     */
    public function describeWarningMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWarningMachinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers that have web tamper proofing enabled.
     *  *
     * @param DescribeWebLockBindListRequest $request DescribeWebLockBindListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockBindListResponse DescribeWebLockBindListResponse
     */
    public function describeWebLockBindListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockBindList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockBindListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers that have web tamper proofing enabled.
     *  *
     * @param DescribeWebLockBindListRequest $request DescribeWebLockBindListRequest
     *
     * @return DescribeWebLockBindListResponse DescribeWebLockBindListResponse
     */
    public function describeWebLockBindList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockBindListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of web tamper proofing for a specified server.
     *  *
     * @param DescribeWebLockConfigListRequest $request DescribeWebLockConfigListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockConfigListResponse DescribeWebLockConfigListResponse
     */
    public function describeWebLockConfigListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockConfigList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockConfigListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of web tamper proofing for a specified server.
     *  *
     * @param DescribeWebLockConfigListRequest $request DescribeWebLockConfigListRequest
     *
     * @return DescribeWebLockConfigListResponse DescribeWebLockConfigListResponse
     */
    public function describeWebLockConfigList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockConfigListWithOptions($request, $runtime);
    }

    /**
     * @summary 查询排除文件类型
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockExclusiveFileTypeResponse DescribeWebLockExclusiveFileTypeResponse
     */
    public function describeWebLockExclusiveFileTypeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeWebLockExclusiveFileType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockExclusiveFileTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询排除文件类型
     *  *
     * @return DescribeWebLockExclusiveFileTypeResponse DescribeWebLockExclusiveFileTypeResponse
     */
    public function describeWebLockExclusiveFileType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockExclusiveFileTypeWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics on changes to the files that are protected by web tamper proofing.
     *  *
     * @param DescribeWebLockFileChangeStatisticsRequest $request DescribeWebLockFileChangeStatisticsRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockFileChangeStatisticsResponse DescribeWebLockFileChangeStatisticsResponse
     */
    public function describeWebLockFileChangeStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockFileChangeStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockFileChangeStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on changes to the files that are protected by web tamper proofing.
     *  *
     * @param DescribeWebLockFileChangeStatisticsRequest $request DescribeWebLockFileChangeStatisticsRequest
     *
     * @return DescribeWebLockFileChangeStatisticsResponse DescribeWebLockFileChangeStatisticsResponse
     */
    public function describeWebLockFileChangeStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockFileChangeStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries events on web tamper proofing.
     *  *
     * @param DescribeWebLockFileEventsRequest $request DescribeWebLockFileEventsRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockFileEventsResponse DescribeWebLockFileEventsResponse
     */
    public function describeWebLockFileEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->processName)) {
            $query['ProcessName'] = $request->processName;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->tsBegin)) {
            $query['TsBegin'] = $request->tsBegin;
        }
        if (!Utils::isUnset($request->tsEnd)) {
            $query['TsEnd'] = $request->tsEnd;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockFileEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockFileEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries events on web tamper proofing.
     *  *
     * @param DescribeWebLockFileEventsRequest $request DescribeWebLockFileEventsRequest
     *
     * @return DescribeWebLockFileEventsResponse DescribeWebLockFileEventsResponse
     */
    public function describeWebLockFileEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockFileEventsWithOptions($request, $runtime);
    }

    /**
     * @summary The number of attempts.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockFileTypeSummaryResponse DescribeWebLockFileTypeSummaryResponse
     */
    public function describeWebLockFileTypeSummaryWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeWebLockFileTypeSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockFileTypeSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The number of attempts.
     *  *
     * @return DescribeWebLockFileTypeSummaryResponse DescribeWebLockFileTypeSummaryResponse
     */
    public function describeWebLockFileTypeSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockFileTypeSummaryWithOptions($runtime);
    }

    /**
     * @summary Queries the types of files that can be protected by web tamper proofing.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockInclusiveFileTypeResponse DescribeWebLockInclusiveFileTypeResponse
     */
    public function describeWebLockInclusiveFileTypeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeWebLockInclusiveFileType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockInclusiveFileTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the types of files that can be protected by web tamper proofing.
     *  *
     * @return DescribeWebLockInclusiveFileTypeResponse DescribeWebLockInclusiveFileTypeResponse
     */
    public function describeWebLockInclusiveFileType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockInclusiveFileTypeWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics on processes for web tamper proofing.
     *  *
     * @param DescribeWebLockProcessBlockStatisticsRequest $request DescribeWebLockProcessBlockStatisticsRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockProcessBlockStatisticsResponse DescribeWebLockProcessBlockStatisticsResponse
     */
    public function describeWebLockProcessBlockStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockProcessBlockStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockProcessBlockStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on processes for web tamper proofing.
     *  *
     * @param DescribeWebLockProcessBlockStatisticsRequest $request DescribeWebLockProcessBlockStatisticsRequest
     *
     * @return DescribeWebLockProcessBlockStatisticsResponse DescribeWebLockProcessBlockStatisticsResponse
     */
    public function describeWebLockProcessBlockStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockProcessBlockStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the processes for web tamper proofing.
     *  *
     * @param DescribeWebLockProcessListRequest $request DescribeWebLockProcessListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockProcessListResponse DescribeWebLockProcessListResponse
     */
    public function describeWebLockProcessListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->processName)) {
            $query['ProcessName'] = $request->processName;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockProcessList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockProcessListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the processes for web tamper proofing.
     *  *
     * @param DescribeWebLockProcessListRequest $request DescribeWebLockProcessListRequest
     *
     * @return DescribeWebLockProcessListResponse DescribeWebLockProcessListResponse
     */
    public function describeWebLockProcessList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockProcessListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of web tamper proofing.
     *  *
     * @param DescribeWebLockStatusRequest $request DescribeWebLockStatusRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockStatusResponse DescribeWebLockStatusResponse
     */
    public function describeWebLockStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of web tamper proofing.
     *  *
     * @param DescribeWebLockStatusRequest $request DescribeWebLockStatusRequest
     *
     * @return DescribeWebLockStatusResponse DescribeWebLockStatusResponse
     */
    public function describeWebLockStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of times that the files protected by web tamper proofing are changed.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockTotalFileChangeCountResponse DescribeWebLockTotalFileChangeCountResponse
     */
    public function describeWebLockTotalFileChangeCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeWebLockTotalFileChangeCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockTotalFileChangeCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of times that the files protected by web tamper proofing are changed.
     *  *
     * @return DescribeWebLockTotalFileChangeCountResponse DescribeWebLockTotalFileChangeCountResponse
     */
    public function describeWebLockTotalFileChangeCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockTotalFileChangeCountWithOptions($runtime);
    }

    /**
     * @summary Queries the custom web directories that are scanned based on the alerting feature.
     *  *
     * @param DescribeWebPathRequest $request DescribeWebPathRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebPathResponse DescribeWebPathResponse
     */
    public function describeWebPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebPath',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the custom web directories that are scanned based on the alerting feature.
     *  *
     * @param DescribeWebPathRequest $request DescribeWebPathRequest
     *
     * @return DescribeWebPathResponse DescribeWebPathResponse
     */
    public function describeWebPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebPathWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about servers that can be added or are added to application whitelist policies.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListAssetRequest $request DescribeWhiteListAssetRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWhiteListAssetResponse DescribeWhiteListAssetResponse
     */
    public function describeWhiteListAssetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->lastMaxId)) {
            $query['LastMaxId'] = $request->lastMaxId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWhiteListAsset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWhiteListAssetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about servers that can be added or are added to application whitelist policies.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListAssetRequest $request DescribeWhiteListAssetRequest
     *
     * @return DescribeWhiteListAssetResponse DescribeWhiteListAssetResponse
     */
    public function describeWhiteListAsset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListAssetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the available quota for the application whitelist feature.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListAuthorizeRequest $request DescribeWhiteListAuthorizeRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWhiteListAuthorizeResponse DescribeWhiteListAuthorizeResponse
     */
    public function describeWhiteListAuthorizeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWhiteListAuthorize',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWhiteListAuthorizeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the available quota for the application whitelist feature.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListAuthorizeRequest $request DescribeWhiteListAuthorizeRequest
     *
     * @return DescribeWhiteListAuthorizeResponse DescribeWhiteListAuthorizeResponse
     */
    public function describeWhiteListAuthorize($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListAuthorizeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers on which an application whitelist policy takes effect.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
     *  *
     * @param DescribeWhiteListEffectiveAssetsRequest $request DescribeWhiteListEffectiveAssetsRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWhiteListEffectiveAssetsResponse DescribeWhiteListEffectiveAssetsResponse
     */
    public function describeWhiteListEffectiveAssetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->needStatistics)) {
            $query['NeedStatistics'] = $request->needStatistics;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWhiteListEffectiveAssets',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWhiteListEffectiveAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers on which an application whitelist policy takes effect.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
     *  *
     * @param DescribeWhiteListEffectiveAssetsRequest $request DescribeWhiteListEffectiveAssetsRequest
     *
     * @return DescribeWhiteListEffectiveAssetsResponse DescribeWhiteListEffectiveAssetsResponse
     */
    public function describeWhiteListEffectiveAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListEffectiveAssetsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the processes that are detected in an application whitelist policy.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListProcessRequest $request DescribeWhiteListProcessRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWhiteListProcessResponse DescribeWhiteListProcessResponse
     */
    public function describeWhiteListProcessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->desc)) {
            $query['Desc'] = $request->desc;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->orderBy)) {
            $query['OrderBy'] = $request->orderBy;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->processName)) {
            $query['ProcessName'] = $request->processName;
        }
        if (!Utils::isUnset($request->processType)) {
            $query['ProcessType'] = $request->processType;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWhiteListProcess',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWhiteListProcessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the processes that are detected in an application whitelist policy.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListProcessRequest $request DescribeWhiteListProcessRequest
     *
     * @return DescribeWhiteListProcessResponse DescribeWhiteListProcessResponse
     */
    public function describeWhiteListProcess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListProcessWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of application whitelist policies.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListStrategyListRequest $request DescribeWhiteListStrategyListRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWhiteListStrategyListResponse DescribeWhiteListStrategyListResponse
     */
    public function describeWhiteListStrategyListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyIds)) {
            $query['StrategyIds'] = $request->strategyIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWhiteListStrategyList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWhiteListStrategyListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of application whitelist policies.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListStrategyListRequest $request DescribeWhiteListStrategyListRequest
     *
     * @return DescribeWhiteListStrategyListResponse DescribeWhiteListStrategyListResponse
     */
    public function describeWhiteListStrategyList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListStrategyListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of application whitelist policies.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListStrategyStatisticsRequest $request DescribeWhiteListStrategyStatisticsRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWhiteListStrategyStatisticsResponse DescribeWhiteListStrategyStatisticsResponse
     */
    public function describeWhiteListStrategyStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyIds)) {
            $query['StrategyIds'] = $request->strategyIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWhiteListStrategyStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWhiteListStrategyStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of application whitelist policies.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param DescribeWhiteListStrategyStatisticsRequest $request DescribeWhiteListStrategyStatisticsRequest
     *
     * @return DescribeWhiteListStrategyStatisticsResponse DescribeWhiteListStrategyStatisticsResponse
     */
    public function describeWhiteListStrategyStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListStrategyStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of the servers on which an application whitelist policy takes effect.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
     *  *
     * @param DescribeWhiteListStrategyUuidCountRequest $request DescribeWhiteListStrategyUuidCountRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWhiteListStrategyUuidCountResponse DescribeWhiteListStrategyUuidCountResponse
     */
    public function describeWhiteListStrategyUuidCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWhiteListStrategyUuidCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWhiteListStrategyUuidCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of the servers on which an application whitelist policy takes effect.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
     *  *
     * @param DescribeWhiteListStrategyUuidCountRequest $request DescribeWhiteListStrategyUuidCountRequest
     *
     * @return DescribeWhiteListStrategyUuidCountResponse DescribeWhiteListStrategyUuidCountResponse
     */
    public function describeWhiteListStrategyUuidCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhiteListStrategyUuidCountWithOptions($request, $runtime);
    }

    /**
     * @summary 钉钉通知测试
     *  *
     * @param DingTalkOnlineTestRequest $request DingTalkOnlineTestRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DingTalkOnlineTestResponse DingTalkOnlineTestResponse
     */
    public function dingTalkOnlineTestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DingTalkOnlineTest',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DingTalkOnlineTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 钉钉通知测试
     *  *
     * @param DingTalkOnlineTestRequest $request DingTalkOnlineTestRequest
     *
     * @return DingTalkOnlineTestResponse DingTalkOnlineTestResponse
     */
    public function dingTalkOnlineTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dingTalkOnlineTestWithOptions($request, $runtime);
    }

    /**
     * @summary Disables an IP address blocking policy that is in effect.
     *  *
     * @param DisableBruteForceRecordRequest $request DisableBruteForceRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DisableBruteForceRecordResponse DisableBruteForceRecordResponse
     */
    public function disableBruteForceRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DisableBruteForceRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DisableBruteForceRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables an IP address blocking policy that is in effect.
     *  *
     * @param DisableBruteForceRecordRequest $request DisableBruteForceRecordRequest
     *
     * @return DisableBruteForceRecordResponse DisableBruteForceRecordResponse
     */
    public function disableBruteForceRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableBruteForceRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Disables a custom IP address blocking policy for servers.
     *  *
     * @param DisableCustomBlockRecordRequest $request DisableCustomBlockRecordRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DisableCustomBlockRecordResponse DisableCustomBlockRecordResponse
     */
    public function disableCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DisableCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DisableCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables a custom IP address blocking policy for servers.
     *  *
     * @param DisableCustomBlockRecordRequest $request DisableCustomBlockRecordRequest
     *
     * @return DisableCustomBlockRecordResponse DisableCustomBlockRecordResponse
     */
    public function disableCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Enables an IP address blocking policy for a specified server.
     *  *
     * @param EnableBruteForceRecordRequest $request EnableBruteForceRecordRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableBruteForceRecordResponse EnableBruteForceRecordResponse
     */
    public function enableBruteForceRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnableBruteForceRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableBruteForceRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables an IP address blocking policy for a specified server.
     *  *
     * @param EnableBruteForceRecordRequest $request EnableBruteForceRecordRequest
     *
     * @return EnableBruteForceRecordResponse EnableBruteForceRecordResponse
     */
    public function enableBruteForceRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableBruteForceRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Enables a custom IP address blocking policy.
     *  *
     * @param EnableCustomBlockRecordRequest $request EnableCustomBlockRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableCustomBlockRecordResponse EnableCustomBlockRecordResponse
     */
    public function enableCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnableCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables a custom IP address blocking policy.
     *  *
     * @param EnableCustomBlockRecordRequest $request EnableCustomBlockRecordRequest
     *
     * @return EnableCustomBlockRecordResponse EnableCustomBlockRecordResponse
     */
    public function enableCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Enables a custom rule for an instance.
     *  *
     * @param EnableCustomInstanceBlockRecordRequest $request EnableCustomInstanceBlockRecordRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableCustomInstanceBlockRecordResponse EnableCustomInstanceBlockRecordResponse
     */
    public function enableCustomInstanceBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnableCustomInstanceBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableCustomInstanceBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables a custom rule for an instance.
     *  *
     * @param EnableCustomInstanceBlockRecordRequest $request EnableCustomInstanceBlockRecordRequest
     *
     * @return EnableCustomInstanceBlockRecordResponse EnableCustomInstanceBlockRecordResponse
     */
    public function enableCustomInstanceBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableCustomInstanceBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Enable the multi-account management feature of Security Center.
     *  *
     * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableServiceAccessResourceDirectoryResponse EnableServiceAccessResourceDirectoryResponse
     */
    public function enableServiceAccessResourceDirectoryWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'EnableServiceAccessResourceDirectory',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableServiceAccessResourceDirectoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enable the multi-account management feature of Security Center.
     *  *
     * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *  *
     * @return EnableServiceAccessResourceDirectoryResponse EnableServiceAccessResourceDirectoryResponse
     */
    public function enableServiceAccessResourceDirectory()
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableServiceAccessResourceDirectoryWithOptions($runtime);
    }

    /**
     * @summary Performs a baseline check on servers to which a specified baseline check policy is applied.
     *  *
     * @param ExecStrategyRequest $request ExecStrategyRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ExecStrategyResponse ExecStrategyResponse
     */
    public function execStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExecStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExecStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Performs a baseline check on servers to which a specified baseline check policy is applied.
     *  *
     * @param ExecStrategyRequest $request ExecStrategyRequest
     *
     * @return ExecStrategyResponse ExecStrategyResponse
     */
    public function execStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->execStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Exports a security report.
     *  *
     * @param ExportCustomizeReportRequest $request ExportCustomizeReportRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportCustomizeReportResponse ExportCustomizeReportResponse
     */
    public function exportCustomizeReportWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportType)) {
            $query['ExportType'] = $request->exportType;
        }
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportCustomizeReport',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportCustomizeReportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports a security report.
     *  *
     * @param ExportCustomizeReportRequest $request ExportCustomizeReportRequest
     *
     * @return ExportCustomizeReportResponse ExportCustomizeReportResponse
     */
    public function exportCustomizeReport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportCustomizeReportWithOptions($request, $runtime);
    }

    /**
     * @summary Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
     *  *
     * @description You can call the operation to export the following check result lists:
     * *   The list of servers on the Host page.
     * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
     * *   The list of attack analysis data on the Attack Awareness page.
     * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
     *  *
     * @param ExportRecordRequest $request ExportRecordRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportRecordResponse ExportRecordResponse
     */
    public function exportRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportFileType)) {
            $query['ExportFileType'] = $request->exportFileType;
        }
        if (!Utils::isUnset($request->exportType)) {
            $query['ExportType'] = $request->exportType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->params)) {
            $query['Params'] = $request->params;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
     *  *
     * @description You can call the operation to export the following check result lists:
     * *   The list of servers on the Host page.
     * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
     * *   The list of attack analysis data on the Attack Awareness page.
     * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
     *  *
     * @param ExportRecordRequest $request ExportRecordRequest
     *
     * @return ExportRecordResponse ExportRecordResponse
     */
    public function exportRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Exports the information about exceptions to a file.
     *  *
     * @param ExportSuspEventsRequest $request ExportSuspEventsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportSuspEventsResponse ExportSuspEventsResponse
     */
    public function exportSuspEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetsTypeList)) {
            $query['AssetsTypeList'] = $request->assetsTypeList;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->operateErrorCodeList)) {
            $query['OperateErrorCodeList'] = $request->operateErrorCodeList;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentEventTypes)) {
            $query['ParentEventTypes'] = $request->parentEventTypes;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        if (!Utils::isUnset($request->uniqueInfo)) {
            $query['UniqueInfo'] = $request->uniqueInfo;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportSuspEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportSuspEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports the information about exceptions to a file.
     *  *
     * @param ExportSuspEventsRequest $request ExportSuspEventsRequest
     *
     * @return ExportSuspEventsResponse ExportSuspEventsResponse
     */
    public function exportSuspEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportSuspEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Exports vulnerabilities.
     *  *
     * @description You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
     * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param ExportVulRequest $request ExportVulRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportVulResponse ExportVulResponse
     */
    public function exportVulWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->attachTypes)) {
            $query['AttachTypes'] = $request->attachTypes;
        }
        if (!Utils::isUnset($request->containerName)) {
            $query['ContainerName'] = $request->containerName;
        }
        if (!Utils::isUnset($request->createTsEnd)) {
            $query['CreateTsEnd'] = $request->createTsEnd;
        }
        if (!Utils::isUnset($request->createTsStart)) {
            $query['CreateTsStart'] = $request->createTsStart;
        }
        if (!Utils::isUnset($request->cveId)) {
            $query['CveId'] = $request->cveId;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->path)) {
            $query['Path'] = $request->path;
        }
        if (!Utils::isUnset($request->searchTags)) {
            $query['SearchTags'] = $request->searchTags;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->vpcInstanceIds)) {
            $query['VpcInstanceIds'] = $request->vpcInstanceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportVul',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports vulnerabilities.
     *  *
     * @description You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
     * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param ExportVulRequest $request ExportVulRequest
     *
     * @return ExportVulResponse ExportVulResponse
     */
    public function exportVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportVulWithOptions($request, $runtime);
    }

    /**
     * @summary Exports baseline check results.
     *  *
     * @param ExportWarningRequest $request ExportWarningRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportWarningResponse ExportWarningResponse
     */
    public function exportWarningWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->exportType)) {
            $query['ExportType'] = $request->exportType;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->isCleartextPwd)) {
            $query['IsCleartextPwd'] = $request->isCleartextPwd;
        }
        if (!Utils::isUnset($request->isSummaryExport)) {
            $query['IsSummaryExport'] = $request->isSummaryExport;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->riskIds)) {
            $query['RiskIds'] = $request->riskIds;
        }
        if (!Utils::isUnset($request->riskLevels)) {
            $query['RiskLevels'] = $request->riskLevels;
        }
        if (!Utils::isUnset($request->riskName)) {
            $query['RiskName'] = $request->riskName;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->subTypeNames)) {
            $query['SubTypeNames'] = $request->subTypeNames;
        }
        if (!Utils::isUnset($request->typeName)) {
            $query['TypeName'] = $request->typeName;
        }
        if (!Utils::isUnset($request->typeNames)) {
            $query['TypeNames'] = $request->typeNames;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportWarning',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportWarningResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports baseline check results.
     *  *
     * @param ExportWarningRequest $request ExportWarningRequest
     *
     * @return ExportWarningResponse ExportWarningResponse
     */
    public function exportWarning($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportWarningWithOptions($request, $runtime);
    }

    /**
     * @summary 容器网络连接
     *  *
     * @param FindContainerNetworkConnectRequest $tmpReq  FindContainerNetworkConnectRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return FindContainerNetworkConnectResponse FindContainerNetworkConnectResponse
     */
    public function findContainerNetworkConnectWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new FindContainerNetworkConnectShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->dstNode)) {
            $request->dstNodeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->dstNode, 'DstNode', 'json');
        }
        if (!Utils::isUnset($tmpReq->srcNode)) {
            $request->srcNodeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->srcNode, 'SrcNode', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dstNodeShrink)) {
            $query['DstNode'] = $request->dstNodeShrink;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->srcNodeShrink)) {
            $query['SrcNode'] = $request->srcNodeShrink;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'FindContainerNetworkConnect',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return FindContainerNetworkConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 容器网络连接
     *  *
     * @param FindContainerNetworkConnectRequest $request FindContainerNetworkConnectRequest
     *
     * @return FindContainerNetworkConnectResponse FindContainerNetworkConnectResponse
     */
    public function findContainerNetworkConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->findContainerNetworkConnectWithOptions($request, $runtime);
    }

    /**
     * @summary 完成任务自动领取奖励
     *  *
     * @param FinishGuidTaskRequest $request FinishGuidTaskRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return FinishGuidTaskResponse FinishGuidTaskResponse
     */
    public function finishGuidTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskTypeName)) {
            $query['TaskTypeName'] = $request->taskTypeName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'FinishGuidTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return FinishGuidTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 完成任务自动领取奖励
     *  *
     * @param FinishGuidTaskRequest $request FinishGuidTaskRequest
     *
     * @return FinishGuidTaskResponse FinishGuidTaskResponse
     */
    public function finishGuidTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->finishGuidTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Fixes a baseline risk item.
     *  *
     * @param FixCheckWarningsRequest $request FixCheckWarningsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return FixCheckWarningsResponse FixCheckWarningsResponse
     */
    public function fixCheckWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkParams)) {
            $query['CheckParams'] = $request->checkParams;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'FixCheckWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return FixCheckWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Fixes a baseline risk item.
     *  *
     * @param FixCheckWarningsRequest $request FixCheckWarningsRequest
     *
     * @return FixCheckWarningsResponse FixCheckWarningsResponse
     */
    public function fixCheckWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->fixCheckWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary Generates a custom dictionary of weak passwords for the baseline check feature.
     *  *
     * @param GenerateDynamicDictRequest $request GenerateDynamicDictRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GenerateDynamicDictResponse GenerateDynamicDictResponse
     */
    public function generateDynamicDictWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->argKeywords)) {
            $query['ArgKeywords'] = $request->argKeywords;
        }
        if (!Utils::isUnset($request->domains)) {
            $query['Domains'] = $request->domains;
        }
        if (!Utils::isUnset($request->names)) {
            $query['Names'] = $request->names;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GenerateDynamicDict',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GenerateDynamicDictResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Generates a custom dictionary of weak passwords for the baseline check feature.
     *  *
     * @param GenerateDynamicDictRequest $request GenerateDynamicDictRequest
     *
     * @return GenerateDynamicDictResponse GenerateDynamicDictResponse
     */
    public function generateDynamicDict($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateDynamicDictWithOptions($request, $runtime);
    }

    /**
     * @summary Generates a command that is used to add a self-managed Kubernetes cluster.
     *  *
     * @param GenerateK8sAccessInfoRequest $request GenerateK8sAccessInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GenerateK8sAccessInfoResponse GenerateK8sAccessInfoResponse
     */
    public function generateK8sAccessInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliyunYundunGatewayApiName)) {
            $query['AliyunYundunGatewayApiName'] = $request->aliyunYundunGatewayApiName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayPopName)) {
            $query['AliyunYundunGatewayPopName'] = $request->aliyunYundunGatewayPopName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayProjectName)) {
            $query['AliyunYundunGatewayProjectName'] = $request->aliyunYundunGatewayProjectName;
        }
        if (!Utils::isUnset($request->auditLogStore)) {
            $query['AuditLogStore'] = $request->auditLogStore;
        }
        if (!Utils::isUnset($request->auditProject)) {
            $query['AuditProject'] = $request->auditProject;
        }
        if (!Utils::isUnset($request->auditRegionId)) {
            $query['AuditRegionId'] = $request->auditRegionId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->expireDate)) {
            $query['ExpireDate'] = $request->expireDate;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GenerateK8sAccessInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GenerateK8sAccessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Generates a command that is used to add a self-managed Kubernetes cluster.
     *  *
     * @param GenerateK8sAccessInfoRequest $request GenerateK8sAccessInfoRequest
     *
     * @return GenerateK8sAccessInfoResponse GenerateK8sAccessInfoResponse
     */
    public function generateK8sAccessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateK8sAccessInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a one-time scan task.
     *  *
     * @param GenerateOnceTaskRequest $request GenerateOnceTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GenerateOnceTaskResponse GenerateOnceTaskResponse
     */
    public function generateOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->param)) {
            $query['Param'] = $request->param;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GenerateOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GenerateOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a one-time scan task.
     *  *
     * @param GenerateOnceTaskRequest $request GenerateOnceTaskRequest
     *
     * @return GenerateOnceTaskResponse GenerateOnceTaskResponse
     */
    public function generateOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary 获取账户标签
     *  *
     * @param GetAccountLabelRequest $request GetAccountLabelRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAccountLabelResponse GetAccountLabelResponse
     */
    public function getAccountLabelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->labelList)) {
            $query['LabelList'] = $request->labelList;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAccountLabel',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAccountLabelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取账户标签
     *  *
     * @param GetAccountLabelRequest $request GetAccountLabelRequest
     *
     * @return GetAccountLabelResponse GetAccountLabelResponse
     */
    public function getAccountLabel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAccountLabelWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a defense rule against container escapes.
     *  *
     * @description Only the Ultimate edition of Security Center supports this operation.
     *  *
     * @param GetAegisContainerPluginRuleRequest $request GetAegisContainerPluginRuleRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAegisContainerPluginRuleResponse GetAegisContainerPluginRuleResponse
     */
    public function getAegisContainerPluginRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAegisContainerPluginRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAegisContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a defense rule against container escapes.
     *  *
     * @description Only the Ultimate edition of Security Center supports this operation.
     *  *
     * @param GetAegisContainerPluginRuleRequest $request GetAegisContainerPluginRuleRequest
     *
     * @return GetAegisContainerPluginRuleResponse GetAegisContainerPluginRuleResponse
     */
    public function getAegisContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAegisContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries search conditions that can be used to search for container file protection rules.
     *  *
     * @param GetAegisContainerPluginRuleCriteriaRequest $request GetAegisContainerPluginRuleCriteriaRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAegisContainerPluginRuleCriteriaResponse GetAegisContainerPluginRuleCriteriaResponse
     */
    public function getAegisContainerPluginRuleCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAegisContainerPluginRuleCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAegisContainerPluginRuleCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries search conditions that can be used to search for container file protection rules.
     *  *
     * @param GetAegisContainerPluginRuleCriteriaRequest $request GetAegisContainerPluginRuleCriteriaRequest
     *
     * @return GetAegisContainerPluginRuleCriteriaResponse GetAegisContainerPluginRuleCriteriaResponse
     */
    public function getAegisContainerPluginRuleCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAegisContainerPluginRuleCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of agentless detection tasks.
     *  *
     * @param GetAgentlessTaskCountRequest $request GetAgentlessTaskCountRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAgentlessTaskCountResponse GetAgentlessTaskCountResponse
     */
    public function getAgentlessTaskCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAgentlessTaskCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAgentlessTaskCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of agentless detection tasks.
     *  *
     * @param GetAgentlessTaskCountRequest $request GetAgentlessTaskCountRequest
     *
     * @return GetAgentlessTaskCountResponse GetAgentlessTaskCountResponse
     */
    public function getAgentlessTaskCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAgentlessTaskCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of servers on which alerts are generated.
     *  *
     * @param GetAlarmMachineCountRequest $request GetAlarmMachineCountRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAlarmMachineCountResponse GetAlarmMachineCountResponse
     */
    public function getAlarmMachineCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAlarmMachineCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAlarmMachineCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of servers on which alerts are generated.
     *  *
     * @param GetAlarmMachineCountRequest $request GetAlarmMachineCountRequest
     *
     * @return GetAlarmMachineCountResponse GetAlarmMachineCountResponse
     */
    public function getAlarmMachineCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAlarmMachineCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the network topology between containerized applications.
     *  *
     * @param GetAppNetworkRequest $request GetAppNetworkRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAppNetworkResponse GetAppNetworkResponse
     */
    public function getAppNetworkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAppNetwork',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAppNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the network topology between containerized applications.
     *  *
     * @param GetAppNetworkRequest $request GetAppNetworkRequest
     *
     * @return GetAppNetworkResponse GetAppNetworkResponse
     */
    public function getAppNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAppNetworkWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
     *  *
     * @param GetAssetDetailByUuidRequest $request GetAssetDetailByUuidRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAssetDetailByUuidResponse GetAssetDetailByUuidResponse
     */
    public function getAssetDetailByUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAssetDetailByUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAssetDetailByUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
     *  *
     * @param GetAssetDetailByUuidRequest $request GetAssetDetailByUuidRequest
     *
     * @return GetAssetDetailByUuidResponse GetAssetDetailByUuidResponse
     */
    public function getAssetDetailByUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetDetailByUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries asset selection configurations.
     *  *
     * @param GetAssetSelectionConfigRequest $request GetAssetSelectionConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAssetSelectionConfigResponse GetAssetSelectionConfigResponse
     */
    public function getAssetSelectionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->businessType)) {
            $query['BusinessType'] = $request->businessType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAssetSelectionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAssetSelectionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries asset selection configurations.
     *  *
     * @param GetAssetSelectionConfigRequest $request GetAssetSelectionConfigRequest
     *
     * @return GetAssetSelectionConfigResponse GetAssetSelectionConfigResponse
     */
    public function getAssetSelectionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetSelectionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
     *  *
     * @param GetAssetsPropertyDetailRequest $request GetAssetsPropertyDetailRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAssetsPropertyDetailResponse GetAssetsPropertyDetailResponse
     */
    public function getAssetsPropertyDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->biz)) {
            $query['Biz'] = $request->biz;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->itemName)) {
            $query['ItemName'] = $request->itemName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->searchCriteriaList)) {
            $query['SearchCriteriaList'] = $request->searchCriteriaList;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAssetsPropertyDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAssetsPropertyDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
     *  *
     * @param GetAssetsPropertyDetailRequest $request GetAssetsPropertyDetailRequest
     *
     * @return GetAssetsPropertyDetailResponse GetAssetsPropertyDetailResponse
     */
    public function getAssetsPropertyDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetsPropertyDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
     *  *
     * @param GetAssetsPropertyItemRequest $request GetAssetsPropertyItemRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAssetsPropertyItemResponse GetAssetsPropertyItemResponse
     */
    public function getAssetsPropertyItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->biz)) {
            $query['Biz'] = $request->biz;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->searchInfo)) {
            $query['SearchInfo'] = $request->searchInfo;
        }
        if (!Utils::isUnset($request->searchItem)) {
            $query['SearchItem'] = $request->searchItem;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAssetsPropertyItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAssetsPropertyItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
     *  *
     * @param GetAssetsPropertyItemRequest $request GetAssetsPropertyItemRequest
     *
     * @return GetAssetsPropertyItemResponse GetAssetsPropertyItemResponse
     */
    public function getAssetsPropertyItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetsPropertyItemWithOptions($request, $runtime);
    }

    /**
     * @summary 查询攻击类型
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAttackTypeListResponse GetAttackTypeListResponse
     */
    public function getAttackTypeListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetAttackTypeList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAttackTypeListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询攻击类型
     *  *
     * @return GetAttackTypeListResponse GetAttackTypeListResponse
     */
    public function getAttackTypeList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAttackTypeListWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics of asset protection quota.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAuthSummaryResponse GetAuthSummaryResponse
     */
    public function getAuthSummaryWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetAuthSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAuthSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of asset protection quota.
     *  *
     * @return GetAuthSummaryResponse GetAuthSummaryResponse
     */
    public function getAuthSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAuthSummaryWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics about the numbers of assets protected by each edition of Security Center.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAuthVersionStatisticResponse GetAuthVersionStatisticResponse
     */
    public function getAuthVersionStatisticWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetAuthVersionStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAuthVersionStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics about the numbers of assets protected by each edition of Security Center.
     *  *
     * @return GetAuthVersionStatisticResponse GetAuthVersionStatisticResponse
     */
    public function getAuthVersionStatistic()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAuthVersionStatisticWithOptions($runtime);
    }

    /**
     * @summary Checks whether the managed anti-ransomware feature can automatically configure an anti-ransomware policy for servers.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBackupAutoConfigStatusResponse GetBackupAutoConfigStatusResponse
     */
    public function getBackupAutoConfigStatusWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetBackupAutoConfigStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBackupAutoConfigStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether the managed anti-ransomware feature can automatically configure an anti-ransomware policy for servers.
     *  *
     * @return GetBackupAutoConfigStatusResponse GetBackupAutoConfigStatusResponse
     */
    public function getBackupAutoConfigStatus()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBackupAutoConfigStatusWithOptions($runtime);
    }

    /**
     * @summary 查询防勒索存储统计
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBackupStorageCountResponse GetBackupStorageCountResponse
     */
    public function getBackupStorageCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetBackupStorageCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBackupStorageCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询防勒索存储统计
     *  *
     * @return GetBackupStorageCountResponse GetBackupStorageCountResponse
     */
    public function getBackupStorageCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBackupStorageCountWithOptions($runtime);
    }

    /**
     * @summary 查询用户的构建指令风险规则配置
     *  *
     * @param GetBuildRiskDefineRuleConfigRequest $request GetBuildRiskDefineRuleConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBuildRiskDefineRuleConfigResponse GetBuildRiskDefineRuleConfigResponse
     */
    public function getBuildRiskDefineRuleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetBuildRiskDefineRuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBuildRiskDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询用户的构建指令风险规则配置
     *  *
     * @param GetBuildRiskDefineRuleConfigRequest $request GetBuildRiskDefineRuleConfigRequest
     *
     * @return GetBuildRiskDefineRuleConfigResponse GetBuildRiskDefineRuleConfigResponse
     */
    public function getBuildRiskDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBuildRiskDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether the current user is qualified for the trial use of Security Center.
     *  *
     * @param GetCanTrySasRequest $request GetCanTrySasRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCanTrySasResponse GetCanTrySasResponse
     */
    public function getCanTrySasWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->fromEcs)) {
            $body['FromEcs'] = $request->fromEcs;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetCanTrySas',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCanTrySasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether the current user is qualified for the trial use of Security Center.
     *  *
     * @param GetCanTrySasRequest $request GetCanTrySasRequest
     *
     * @return GetCanTrySasResponse GetCanTrySasResponse
     */
    public function getCanTrySas($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCanTrySasWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an automatic configuration check on cloud services.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckConfigResponse GetCheckConfigResponse
     */
    public function getCheckConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetCheckConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an automatic configuration check on cloud services.
     *  *
     * @return GetCheckConfigResponse GetCheckConfigResponse
     */
    public function getCheckConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckConfigWithOptions($runtime);
    }

    /**
     * @summary Queries the details about a check item that is used for configuration assessment.
     *  *
     * @param GetCheckDetailRequest $request GetCheckDetailRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckDetailResponse GetCheckDetailResponse
     */
    public function getCheckDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a check item that is used for configuration assessment.
     *  *
     * @param GetCheckDetailRequest $request GetCheckDetailRequest
     *
     * @return GetCheckDetailResponse GetCheckDetailResponse
     */
    public function getCheckDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a configuration check task on cloud services.
     *  *
     * @param GetCheckProcessRequest $request GetCheckProcessRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckProcessResponse GetCheckProcessResponse
     */
    public function getCheckProcessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckProcess',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckProcessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a configuration check task on cloud services.
     *  *
     * @param GetCheckProcessRequest $request GetCheckProcessRequest
     *
     * @return GetCheckProcessResponse GetCheckProcessResponse
     */
    public function getCheckProcess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckProcessWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
     *  *
     * @param GetCheckRiskStatisticsRequest $request GetCheckRiskStatisticsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckRiskStatisticsResponse GetCheckRiskStatisticsResponse
     */
    public function getCheckRiskStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckRiskStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckRiskStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
     *  *
     * @param GetCheckRiskStatisticsRequest $request GetCheckRiskStatisticsRequest
     *
     * @return GetCheckRiskStatisticsResponse GetCheckRiskStatisticsResponse
     */
    public function getCheckRiskStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckRiskStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
     *  *
     * @param GetCheckSaleRequest $request GetCheckSaleRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckSaleResponse GetCheckSaleResponse
     */
    public function getCheckSaleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckSale',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckSaleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
     *  *
     * @param GetCheckSaleRequest $request GetCheckSaleRequest
     *
     * @return GetCheckSaleResponse GetCheckSaleResponse
     */
    public function getCheckSale($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckSaleWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the structure information about check items provided by the configuration assessment feature.
     *  *
     * @description You must purchase the configuration assessment feature before you can use the feature.
     *  *
     * @param GetCheckStructureRequest $request GetCheckStructureRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckStructureResponse GetCheckStructureResponse
     */
    public function getCheckStructureWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckStructure',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckStructureResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the structure information about check items provided by the configuration assessment feature.
     *  *
     * @description You must purchase the configuration assessment feature before you can use the feature.
     *  *
     * @param GetCheckStructureRequest $request GetCheckStructureRequest
     *
     * @return GetCheckStructureResponse GetCheckStructureResponse
     */
    public function getCheckStructure($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckStructureWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the summary information about the configuration checks on cloud services.
     *  *
     * @param GetCheckSummaryRequest $request GetCheckSummaryRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckSummaryResponse GetCheckSummaryResponse
     */
    public function getCheckSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->isItemStatistic)) {
            $query['IsItemStatistic'] = $request->isItemStatistic;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the summary information about the configuration checks on cloud services.
     *  *
     * @param GetCheckSummaryRequest $request GetCheckSummaryRequest
     *
     * @return GetCheckSummaryResponse GetCheckSummaryResponse
     */
    public function getCheckSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckSummaryWithOptions($request, $runtime);
    }

    /**
     * @deprecated openAPI GetClientInstallationStatistic is deprecated, please use Sas::2018-12-03::GetClientRatioStatistic instead
     *  *
     * @summary Queries the installation rate of the client on cloud assets in the specified period of time.
     *  *
     * Deprecated
     *
     * @param GetClientInstallationStatisticRequest $request GetClientInstallationStatisticRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClientInstallationStatisticResponse GetClientInstallationStatisticResponse
     */
    public function getClientInstallationStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClientInstallationStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClientInstallationStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated openAPI GetClientInstallationStatistic is deprecated, please use Sas::2018-12-03::GetClientRatioStatistic instead
     *  *
     * @summary Queries the installation rate of the client on cloud assets in the specified period of time.
     *  *
     * Deprecated
     *
     * @param GetClientInstallationStatisticRequest $request GetClientInstallationStatisticRequest
     *
     * @return GetClientInstallationStatisticResponse GetClientInstallationStatisticResponse
     */
    public function getClientInstallationStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClientInstallationStatisticWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation rate and online rate of the agent.
     *  *
     * @param GetClientRatioStatisticRequest $request GetClientRatioStatisticRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClientRatioStatisticResponse GetClientRatioStatisticResponse
     */
    public function getClientRatioStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->statisticTypes)) {
            $query['StatisticTypes'] = $request->statisticTypes;
        }
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClientRatioStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClientRatioStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation rate and online rate of the agent.
     *  *
     * @param GetClientRatioStatisticRequest $request GetClientRatioStatisticRequest
     *
     * @return GetClientRatioStatisticResponse GetClientRatioStatisticResponse
     */
    public function getClientRatioStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClientRatioStatisticWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a custom defense rule.
     *  *
     * @param GetClientUserDefineRuleRequest $request GetClientUserDefineRuleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClientUserDefineRuleResponse GetClientUserDefineRuleResponse
     */
    public function getClientUserDefineRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClientUserDefineRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a custom defense rule.
     *  *
     * @param GetClientUserDefineRuleRequest $request GetClientUserDefineRuleRequest
     *
     * @return GetClientUserDefineRuleResponse GetClientUserDefineRuleResponse
     */
    public function getClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the filter conditions that are used to search for cloud assets.
     *  *
     * @param GetCloudAssetCriteriaRequest $request GetCloudAssetCriteriaRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCloudAssetCriteriaResponse GetCloudAssetCriteriaResponse
     */
    public function getCloudAssetCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cloudAssetTypes)) {
            $query['CloudAssetTypes'] = $request->cloudAssetTypes;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCloudAssetCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCloudAssetCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the filter conditions that are used to search for cloud assets.
     *  *
     * @param GetCloudAssetCriteriaRequest $request GetCloudAssetCriteriaRequest
     *
     * @return GetCloudAssetCriteriaResponse GetCloudAssetCriteriaResponse
     */
    public function getCloudAssetCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCloudAssetCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the details of cloud assets.
     *  *
     * @param GetCloudAssetDetailRequest $request GetCloudAssetDetailRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCloudAssetDetailResponse GetCloudAssetDetailResponse
     */
    public function getCloudAssetDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetSubType)) {
            $query['AssetSubType'] = $request->assetSubType;
        }
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        if (!Utils::isUnset($request->cloudAssetInstances)) {
            $query['CloudAssetInstances'] = $request->cloudAssetInstances;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCloudAssetDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCloudAssetDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the details of cloud assets.
     *  *
     * @param GetCloudAssetDetailRequest $request GetCloudAssetDetailRequest
     *
     * @return GetCloudAssetDetailResponse GetCloudAssetDetailResponse
     */
    public function getCloudAssetDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCloudAssetDetailWithOptions($request, $runtime);
    }

    /**
     * @summary The total number of instances that are at risk.
     *  *
     * @param GetCloudAssetSummaryRequest $request GetCloudAssetSummaryRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCloudAssetSummaryResponse GetCloudAssetSummaryResponse
     */
    public function getCloudAssetSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCloudAssetSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCloudAssetSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The total number of instances that are at risk.
     *  *
     * @param GetCloudAssetSummaryRequest $request GetCloudAssetSummaryRequest
     *
     * @return GetCloudAssetSummaryResponse GetCloudAssetSummaryResponse
     */
    public function getCloudAssetSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCloudAssetSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics on baseline risk items of container clusters.
     *  *
     * @param GetClusterCheckItemWarningStatisticsRequest $request GetClusterCheckItemWarningStatisticsRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClusterCheckItemWarningStatisticsResponse GetClusterCheckItemWarningStatisticsResponse
     */
    public function getClusterCheckItemWarningStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClusterCheckItemWarningStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClusterCheckItemWarningStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on baseline risk items of container clusters.
     *  *
     * @param GetClusterCheckItemWarningStatisticsRequest $request GetClusterCheckItemWarningStatisticsRequest
     *
     * @return GetClusterCheckItemWarningStatisticsResponse GetClusterCheckItemWarningStatisticsResponse
     */
    public function getClusterCheckItemWarningStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterCheckItemWarningStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the overall information about cluster defense rules that are configured for the container firewall feature.
     *  *
     * @param GetClusterRuleSummaryRequest $request GetClusterRuleSummaryRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClusterRuleSummaryResponse GetClusterRuleSummaryResponse
     */
    public function getClusterRuleSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClusterRuleSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClusterRuleSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the overall information about cluster defense rules that are configured for the container firewall feature.
     *  *
     * @param GetClusterRuleSummaryRequest $request GetClusterRuleSummaryRequest
     *
     * @return GetClusterRuleSummaryResponse GetClusterRuleSummaryResponse
     */
    public function getClusterRuleSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterRuleSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of policies in each cluster.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClusterStrategyCountResponse GetClusterStrategyCountResponse
     */
    public function getClusterStrategyCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetClusterStrategyCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClusterStrategyCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of policies in each cluster.
     *  *
     * @return GetClusterStrategyCountResponse GetClusterStrategyCountResponse
     */
    public function getClusterStrategyCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterStrategyCountWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics on alert events that are generated for containers.
     *  *
     * @param GetClusterSuspEventStatisticsRequest $request GetClusterSuspEventStatisticsRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClusterSuspEventStatisticsResponse GetClusterSuspEventStatisticsResponse
     */
    public function getClusterSuspEventStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClusterSuspEventStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClusterSuspEventStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on alert events that are generated for containers.
     *  *
     * @param GetClusterSuspEventStatisticsRequest $request GetClusterSuspEventStatisticsRequest
     *
     * @return GetClusterSuspEventStatisticsResponse GetClusterSuspEventStatisticsResponse
     */
    public function getClusterSuspEventStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterSuspEventStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of a common switch.
     *  *
     * @param GetCommonSwitchConfigRequest $request GetCommonSwitchConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCommonSwitchConfigResponse GetCommonSwitchConfigResponse
     */
    public function getCommonSwitchConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCommonSwitchConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCommonSwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of a common switch.
     *  *
     * @param GetCommonSwitchConfigRequest $request GetCommonSwitchConfigRequest
     *
     * @return GetCommonSwitchConfigResponse GetCommonSwitchConfigResponse
     */
    public function getCommonSwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCommonSwitchConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a rule for non-image program defense.
     *  *
     * @param GetContainerDefenseRuleDetailRequest $request GetContainerDefenseRuleDetailRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetContainerDefenseRuleDetailResponse GetContainerDefenseRuleDetailResponse
     */
    public function getContainerDefenseRuleDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetContainerDefenseRuleDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetContainerDefenseRuleDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a rule for non-image program defense.
     *  *
     * @param GetContainerDefenseRuleDetailRequest $request GetContainerDefenseRuleDetailRequest
     *
     * @return GetContainerDefenseRuleDetailResponse GetContainerDefenseRuleDetailResponse
     */
    public function getContainerDefenseRuleDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getContainerDefenseRuleDetailWithOptions($request, $runtime);
    }

    /**
     * @summary 获取版本发布信息
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCurrentVersionPublishResponse GetCurrentVersionPublishResponse
     */
    public function getCurrentVersionPublishWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetCurrentVersionPublish',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCurrentVersionPublishResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取版本发布信息
     *  *
     * @return GetCurrentVersionPublishResponse GetCurrentVersionPublishResponse
     */
    public function getCurrentVersionPublish()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCurrentVersionPublishWithOptions($runtime);
    }

    /**
     * @summary Queries the security operations trends of the vulnerabilities, alerts, and baseline risks.
     *  *
     * @param GetDataTrendRequest $request GetDataTrendRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataTrendResponse GetDataTrendResponse
     */
    public function getDataTrendWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bizTypes)) {
            $query['BizTypes'] = $request->bizTypes;
        }
        if (!Utils::isUnset($request->endTimestamp)) {
            $query['EndTimestamp'] = $request->endTimestamp;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->startTimestamp)) {
            $query['StartTimestamp'] = $request->startTimestamp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDataTrend',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the security operations trends of the vulnerabilities, alerts, and baseline risks.
     *  *
     * @param GetDataTrendRequest $request GetDataTrendRequest
     *
     * @return GetDataTrendResponse GetDataTrendResponse
     */
    public function getDataTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataTrendWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the numbers of handled alerts of the precision defense type and the web tamper proofing type.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDefenceCountResponse GetDefenceCountResponse
     */
    public function getDefenceCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetDefenceCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDefenceCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the numbers of handled alerts of the precision defense type and the web tamper proofing type.
     *  *
     * @return GetDefenceCountResponse GetDefenceCountResponse
     */
    public function getDefenceCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDefenceCountWithOptions($runtime);
    }

    /**
     * @summary Obtains the usage information of the malicious file detection SDK.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileDetectApiInvokeInfoResponse GetFileDetectApiInvokeInfoResponse
     */
    public function getFileDetectApiInvokeInfoWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetFileDetectApiInvokeInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileDetectApiInvokeInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the usage information of the malicious file detection SDK.
     *  *
     * @return GetFileDetectApiInvokeInfoResponse GetFileDetectApiInvokeInfoResponse
     */
    public function getFileDetectApiInvokeInfo()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileDetectApiInvokeInfoWithOptions($runtime);
    }

    /**
     * @summary Queries the cloud sandbox check results of malicious files.
     *  *
     * @param GetFileDetectReportRequest $request GetFileDetectReportRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileDetectReportResponse GetFileDetectReportResponse
     */
    public function getFileDetectReportWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->field)) {
            $query['Field'] = $request->field;
        }
        if (!Utils::isUnset($request->fileHash)) {
            $query['FileHash'] = $request->fileHash;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceType)) {
            $query['SourceType'] = $request->sourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileDetectReport',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileDetectReportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the cloud sandbox check results of malicious files.
     *  *
     * @param GetFileDetectReportRequest $request GetFileDetectReportRequest
     *
     * @return GetFileDetectReportResponse GetFileDetectReportResponse
     */
    public function getFileDetectReport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileDetectReportWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains file detection results.
     *  *
     * @description The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param GetFileDetectResultRequest $request GetFileDetectResultRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileDetectResultResponse GetFileDetectResultResponse
     */
    public function getFileDetectResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->hashKeyList)) {
            $query['HashKeyList'] = $request->hashKeyList;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileDetectResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileDetectResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains file detection results.
     *  *
     * @description The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param GetFileDetectResultRequest $request GetFileDetectResultRequest
     *
     * @return GetFileDetectResultResponse GetFileDetectResultResponse
     */
    public function getFileDetectResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileDetectResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileProtectDashboardResponse GetFileProtectDashboardResponse
     */
    public function getFileProtectDashboardWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetFileProtectDashboard',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileProtectDashboardResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
     *  *
     * @return GetFileProtectDashboardResponse GetFileProtectDashboardResponse
     */
    public function getFileProtectDashboard()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectDashboardWithOptions($runtime);
    }

    /**
     * @summary Queries information about core file monitoring events.
     *  *
     * @param GetFileProtectEventRequest $request GetFileProtectEventRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileProtectEventResponse GetFileProtectEventResponse
     */
    public function getFileProtectEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileProtectEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileProtectEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about core file monitoring events.
     *  *
     * @param GetFileProtectEventRequest $request GetFileProtectEventRequest
     *
     * @return GetFileProtectEventResponse GetFileProtectEventResponse
     */
    public function getFileProtectEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the total number of core file monitoring events by filter condition.
     *  *
     * @param GetFileProtectEventCountRequest $request GetFileProtectEventCountRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileProtectEventCountResponse GetFileProtectEventCountResponse
     */
    public function getFileProtectEventCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileProtectEventCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileProtectEventCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the total number of core file monitoring events by filter condition.
     *  *
     * @param GetFileProtectEventCountRequest $request GetFileProtectEventCountRequest
     *
     * @return GetFileProtectEventCountResponse GetFileProtectEventCountResponse
     */
    public function getFileProtectEventCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectEventCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a core file monitoring rule based on the ID of the rule.
     *  *
     * @param GetFileProtectRuleRequest $request GetFileProtectRuleRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileProtectRuleResponse GetFileProtectRuleResponse
     */
    public function getFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a core file monitoring rule based on the ID of the rule.
     *  *
     * @param GetFileProtectRuleRequest $request GetFileProtectRuleRequest
     *
     * @return GetFileProtectRuleResponse GetFileProtectRuleResponse
     */
    public function getFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileUploadLimitResponse GetFileUploadLimitResponse
     */
    public function getFileUploadLimitWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetFileUploadLimit',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileUploadLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @return GetFileUploadLimitResponse GetFileUploadLimitResponse
     */
    public function getFileUploadLimit()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileUploadLimitWithOptions($runtime);
    }

    /**
     * @summary Obtains the URL that is used to upload a file to a honeypot.
     *  *
     * @param GetHoneyPotUploadPolicyInfoRequest $request GetHoneyPotUploadPolicyInfoRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneyPotUploadPolicyInfoResponse GetHoneyPotUploadPolicyInfoResponse
     */
    public function getHoneyPotUploadPolicyInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneyPotUploadPolicyInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneyPotUploadPolicyInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the URL that is used to upload a file to a honeypot.
     *  *
     * @param GetHoneyPotUploadPolicyInfoRequest $request GetHoneyPotUploadPolicyInfoRequest
     *
     * @return GetHoneyPotUploadPolicyInfoResponse GetHoneyPotUploadPolicyInfoResponse
     */
    public function getHoneyPotUploadPolicyInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneyPotUploadPolicyInfoWithOptions($request, $runtime);
    }

    /**
     * @param GetHoneypotAttackStatisticsRequest $request GetHoneypotAttackStatisticsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotAttackStatisticsResponse GetHoneypotAttackStatisticsResponse
     */
    public function getHoneypotAttackStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTimeStamp)) {
            $query['EndTimeStamp'] = $request->endTimeStamp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevelList)) {
            $query['RiskLevelList'] = $request->riskLevelList;
        }
        if (!Utils::isUnset($request->srcIp)) {
            $query['SrcIp'] = $request->srcIp;
        }
        if (!Utils::isUnset($request->startTimeStamp)) {
            $query['StartTimeStamp'] = $request->startTimeStamp;
        }
        if (!Utils::isUnset($request->statisticsType)) {
            $query['StatisticsType'] = $request->statisticsType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotAttackStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotAttackStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetHoneypotAttackStatisticsRequest $request GetHoneypotAttackStatisticsRequest
     *
     * @return GetHoneypotAttackStatisticsResponse GetHoneypotAttackStatisticsResponse
     */
    public function getHoneypotAttackStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotAttackStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Obtain attack trend statistics for a single attack source.
     *  *
     * @param GetHoneypotEventTrendRequest $request GetHoneypotEventTrendRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotEventTrendResponse GetHoneypotEventTrendResponse
     */
    public function getHoneypotEventTrendWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTimeStamp)) {
            $query['EndTimeStamp'] = $request->endTimeStamp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->riskLevelList)) {
            $query['RiskLevelList'] = $request->riskLevelList;
        }
        if (!Utils::isUnset($request->srcIp)) {
            $query['SrcIp'] = $request->srcIp;
        }
        if (!Utils::isUnset($request->startTimeStamp)) {
            $query['StartTimeStamp'] = $request->startTimeStamp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotEventTrend',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotEventTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtain attack trend statistics for a single attack source.
     *  *
     * @param GetHoneypotEventTrendRequest $request GetHoneypotEventTrendRequest
     *
     * @return GetHoneypotEventTrendResponse GetHoneypotEventTrendResponse
     */
    public function getHoneypotEventTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotEventTrendWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a specified management node.
     *  *
     * @param GetHoneypotNodeRequest $request GetHoneypotNodeRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotNodeResponse GetHoneypotNodeResponse
     */
    public function getHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a specified management node.
     *  *
     * @param GetHoneypotNodeRequest $request GetHoneypotNodeRequest
     *
     * @return GetHoneypotNodeResponse GetHoneypotNodeResponse
     */
    public function getHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the monitoring data of management nodes to which the cloud honeypot belongs.
     *  *
     * @param GetHoneypotNodeMetricListRequest $request GetHoneypotNodeMetricListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotNodeMetricListResponse GetHoneypotNodeMetricListResponse
     */
    public function getHoneypotNodeMetricListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->express)) {
            $query['Express'] = $request->express;
        }
        if (!Utils::isUnset($request->length)) {
            $query['Length'] = $request->length;
        }
        if (!Utils::isUnset($request->metricName)) {
            $query['MetricName'] = $request->metricName;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->period)) {
            $query['Period'] = $request->period;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotNodeMetricList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotNodeMetricListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the monitoring data of management nodes to which the cloud honeypot belongs.
     *  *
     * @param GetHoneypotNodeMetricListRequest $request GetHoneypotNodeMetricListRequest
     *
     * @return GetHoneypotNodeMetricListResponse GetHoneypotNodeMetricListResponse
     */
    public function getHoneypotNodeMetricList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotNodeMetricListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of a specified honeypot template.
     *  *
     * @param GetHoneypotPresetRequest $request GetHoneypotPresetRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotPresetResponse GetHoneypotPresetResponse
     */
    public function getHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotPresetId)) {
            $query['HoneypotPresetId'] = $request->honeypotPresetId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of a specified honeypot template.
     *  *
     * @param GetHoneypotPresetRequest $request GetHoneypotPresetRequest
     *
     * @return GetHoneypotPresetResponse GetHoneypotPresetResponse
     */
    public function getHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a specified probe.
     *  *
     * @param GetHoneypotProbeRequest $request GetHoneypotProbeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotProbeResponse GetHoneypotProbeResponse
     */
    public function getHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a specified probe.
     *  *
     * @param GetHoneypotProbeRequest $request GetHoneypotProbeRequest
     *
     * @return GetHoneypotProbeResponse GetHoneypotProbeResponse
     */
    public function getHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary 获取蜜罐使用量的统计数据
     *  *
     * @param GetHoneypotStatisticsRequest $request GetHoneypotStatisticsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotStatisticsResponse GetHoneypotStatisticsResponse
     */
    public function getHoneypotStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取蜜罐使用量的统计数据
     *  *
     * @param GetHoneypotStatisticsRequest $request GetHoneypotStatisticsRequest
     *
     * @return GetHoneypotStatisticsResponse GetHoneypotStatisticsResponse
     */
    public function getHoneypotStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries alert handling rules.
     *  *
     * @param GetImageEventOperationRequest $request GetImageEventOperationRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetImageEventOperationResponse GetImageEventOperationResponse
     */
    public function getImageEventOperationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetImageEventOperation',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries alert handling rules.
     *  *
     * @param GetImageEventOperationRequest $request GetImageEventOperationRequest
     *
     * @return GetImageEventOperationResponse GetImageEventOperationResponse
     */
    public function getImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of image scans that are performed within the last several days.
     *  *
     * @param GetImageScanNumInPeriodRequest $request GetImageScanNumInPeriodRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetImageScanNumInPeriodResponse GetImageScanNumInPeriodResponse
     */
    public function getImageScanNumInPeriodWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pastDay)) {
            $query['PastDay'] = $request->pastDay;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetImageScanNumInPeriod',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetImageScanNumInPeriodResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of image scans that are performed within the last several days.
     *  *
     * @param GetImageScanNumInPeriodRequest $request GetImageScanNumInPeriodRequest
     *
     * @return GetImageScanNumInPeriodResponse GetImageScanNumInPeriodResponse
     */
    public function getImageScanNumInPeriod($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getImageScanNumInPeriodWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a microsegmentation defense rule.
     *  *
     * @param GetInterceptionRuleDetailRequest $request GetInterceptionRuleDetailRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInterceptionRuleDetailResponse GetInterceptionRuleDetailResponse
     */
    public function getInterceptionRuleDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetInterceptionRuleDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInterceptionRuleDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a microsegmentation defense rule.
     *  *
     * @param GetInterceptionRuleDetailRequest $request GetInterceptionRuleDetailRequest
     *
     * @return GetInterceptionRuleDetailResponse GetInterceptionRuleDetailResponse
     */
    public function getInterceptionRuleDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInterceptionRuleDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of the container firewall feature.
     *  *
     * @param GetInterceptionSummaryRequest $request GetInterceptionSummaryRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInterceptionSummaryResponse GetInterceptionSummaryResponse
     */
    public function getInterceptionSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetInterceptionSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInterceptionSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of the container firewall feature.
     *  *
     * @param GetInterceptionSummaryRequest $request GetInterceptionSummaryRequest
     *
     * @return GetInterceptionSummaryResponse GetInterceptionSummaryResponse
     */
    public function getInterceptionSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInterceptionSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a specified network object that is protected by the container firewall feature.
     *  *
     * @param GetInterceptionTargetDetailRequest $request GetInterceptionTargetDetailRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInterceptionTargetDetailResponse GetInterceptionTargetDetailResponse
     */
    public function getInterceptionTargetDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->targetId)) {
            $query['TargetId'] = $request->targetId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetInterceptionTargetDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInterceptionTargetDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a specified network object that is protected by the container firewall feature.
     *  *
     * @param GetInterceptionTargetDetailRequest $request GetInterceptionTargetDetailRequest
     *
     * @return GetInterceptionTargetDetailResponse GetInterceptionTargetDetailResponse
     */
    public function getInterceptionTargetDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInterceptionTargetDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the latest scan task to determine whether the task is complete.
     *  *
     * @param GetLastOnceTaskInfoRequest $request GetLastOnceTaskInfoRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetLastOnceTaskInfoResponse GetLastOnceTaskInfoResponse
     */
    public function getLastOnceTaskInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetLastOnceTaskInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetLastOnceTaskInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the latest scan task to determine whether the task is complete.
     *  *
     * @param GetLastOnceTaskInfoRequest $request GetLastOnceTaskInfoRequest
     *
     * @return GetLastOnceTaskInfoResponse GetLastOnceTaskInfoResponse
     */
    public function getLastOnceTaskInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getLastOnceTaskInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the default region for synchronizing assets outside Alibaba Cloud.
     *  *
     * @param GetLocalDefaultRegionRequest $request GetLocalDefaultRegionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetLocalDefaultRegionResponse GetLocalDefaultRegionResponse
     */
    public function getLocalDefaultRegionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetLocalDefaultRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetLocalDefaultRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the default region for synchronizing assets outside Alibaba Cloud.
     *  *
     * @param GetLocalDefaultRegionRequest $request GetLocalDefaultRegionRequest
     *
     * @return GetLocalDefaultRegionResponse GetLocalDefaultRegionResponse
     */
    public function getLocalDefaultRegion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getLocalDefaultRegionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of a data shipping task of a log.
     *  *
     * @param GetLogMetaRequest $request GetLogMetaRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetLogMetaResponse GetLogMetaResponse
     */
    public function getLogMetaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->logStore)) {
            $query['LogStore'] = $request->logStore;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetLogMeta',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetLogMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of a data shipping task of a log.
     *  *
     * @param GetLogMetaRequest $request GetLogMetaRequest
     *
     * @return GetLogMetaResponse GetLogMetaResponse
     */
    public function getLogMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getLogMetaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param GetMaliciousFileWhitelistConfigRequest $request GetMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMaliciousFileWhitelistConfigResponse GetMaliciousFileWhitelistConfigResponse
     */
    public function getMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param GetMaliciousFileWhitelistConfigRequest $request GetMaliciousFileWhitelistConfigRequest
     *
     * @return GetMaliciousFileWhitelistConfigResponse GetMaliciousFileWhitelistConfigResponse
     */
    public function getMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of a module.
     *  *
     * @param GetModuleConfigRequest $request GetModuleConfigRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetModuleConfigResponse GetModuleConfigResponse
     */
    public function getModuleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetModuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetModuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of a module.
     *  *
     * @param GetModuleConfigRequest $request GetModuleConfigRequest
     *
     * @return GetModuleConfigResponse GetModuleConfigResponse
     */
    public function getModuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getModuleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary 获取配置合规信息接口
     *  *
     * @param GetModuleConfigStatusRequest $tmpReq  GetModuleConfigStatusRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetModuleConfigStatusResponse GetModuleConfigStatusResponse
     */
    public function getModuleConfigStatusWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new GetModuleConfigStatusShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->moduleNames)) {
            $request->moduleNamesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->moduleNames, 'ModuleNames', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->moduleNamesShrink)) {
            $query['ModuleNames'] = $request->moduleNamesShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetModuleConfigStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetModuleConfigStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取配置合规信息接口
     *  *
     * @param GetModuleConfigStatusRequest $request GetModuleConfigStatusRequest
     *
     * @return GetModuleConfigStatusResponse GetModuleConfigStatusResponse
     */
    public function getModuleConfigStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getModuleConfigStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
     *  *
     * @param GetModuleTrialAuthInfoRequest $request GetModuleTrialAuthInfoRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetModuleTrialAuthInfoResponse GetModuleTrialAuthInfoResponse
     */
    public function getModuleTrialAuthInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->moduleCode)) {
            $query['ModuleCode'] = $request->moduleCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetModuleTrialAuthInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetModuleTrialAuthInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
     *  *
     * @param GetModuleTrialAuthInfoRequest $request GetModuleTrialAuthInfoRequest
     *
     * @return GetModuleTrialAuthInfoResponse GetModuleTrialAuthInfoResponse
     */
    public function getModuleTrialAuthInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getModuleTrialAuthInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an alert event that is generated for a malicious object.
     *  *
     * @param GetObjectScanEventRequest $request GetObjectScanEventRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetObjectScanEventResponse GetObjectScanEventResponse
     */
    public function getObjectScanEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetObjectScanEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetObjectScanEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an alert event that is generated for a malicious object.
     *  *
     * @param GetObjectScanEventRequest $request GetObjectScanEventRequest
     *
     * @return GetObjectScanEventResponse GetObjectScanEventResponse
     */
    public function getObjectScanEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getObjectScanEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
     *  *
     * @param GetOnceTaskResultInfoRequest $request GetOnceTaskResultInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOnceTaskResultInfoResponse GetOnceTaskResultInfoResponse
     */
    public function getOnceTaskResultInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOnceTaskResultInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOnceTaskResultInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
     *  *
     * @param GetOnceTaskResultInfoRequest $request GetOnceTaskResultInfoRequest
     *
     * @return GetOnceTaskResultInfoResponse GetOnceTaskResultInfoResponse
     */
    public function getOnceTaskResultInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOnceTaskResultInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the baselines that are supported by at-risk image blocking.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaClusterBaseLineListResponse GetOpaClusterBaseLineListResponse
     */
    public function getOpaClusterBaseLineListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetOpaClusterBaseLineList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaClusterBaseLineListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the baselines that are supported by at-risk image blocking.
     *  *
     * @return GetOpaClusterBaseLineListResponse GetOpaClusterBaseLineListResponse
     */
    public function getOpaClusterBaseLineList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterBaseLineListWithOptions($runtime);
    }

    /**
     * @summary 查询集群镜像
     *  *
     * @param GetOpaClusterImageListRequest $request GetOpaClusterImageListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaClusterImageListResponse GetOpaClusterImageListResponse
     */
    public function getOpaClusterImageListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaClusterImageList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaClusterImageListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询集群镜像
     *  *
     * @param GetOpaClusterImageListRequest $request GetOpaClusterImageListRequest
     *
     * @return GetOpaClusterImageListResponse GetOpaClusterImageListResponse
     */
    public function getOpaClusterImageList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterImageListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
     *  *
     * @param GetOpaClusterLabelListRequest $request GetOpaClusterLabelListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaClusterLabelListResponse GetOpaClusterLabelListResponse
     */
    public function getOpaClusterLabelListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->tagName)) {
            $query['TagName'] = $request->tagName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaClusterLabelList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaClusterLabelListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
     *  *
     * @param GetOpaClusterLabelListRequest $request GetOpaClusterLabelListRequest
     *
     * @return GetOpaClusterLabelListResponse GetOpaClusterLabelListResponse
     */
    public function getOpaClusterLabelList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterLabelListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
     *  *
     * @param GetOpaClusterNamespaceListRequest $request GetOpaClusterNamespaceListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaClusterNamespaceListResponse GetOpaClusterNamespaceListResponse
     */
    public function getOpaClusterNamespaceListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->nameSpaceName)) {
            $query['NameSpaceName'] = $request->nameSpaceName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaClusterNamespaceList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaClusterNamespaceListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
     *  *
     * @param GetOpaClusterNamespaceListRequest $request GetOpaClusterNamespaceListRequest
     *
     * @return GetOpaClusterNamespaceListResponse GetOpaClusterNamespaceListResponse
     */
    public function getOpaClusterNamespaceList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterNamespaceListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
     *  *
     * @param GetOpaPluginStatusRequest $request GetOpaPluginStatusRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaPluginStatusResponse GetOpaPluginStatusResponse
     */
    public function getOpaPluginStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaPluginStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaPluginStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
     *  *
     * @param GetOpaPluginStatusRequest $request GetOpaPluginStatusRequest
     *
     * @return GetOpaPluginStatusResponse GetOpaPluginStatusResponse
     */
    public function getOpaPluginStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaPluginStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of the rule that is used to block at-risk images.
     *  *
     * @param GetOpaStrategyDetailNewRequest $request GetOpaStrategyDetailNewRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaStrategyDetailNewResponse GetOpaStrategyDetailNewResponse
     */
    public function getOpaStrategyDetailNewWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaStrategyDetailNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaStrategyDetailNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of the rule that is used to block at-risk images.
     *  *
     * @param GetOpaStrategyDetailNewRequest $request GetOpaStrategyDetailNewRequest
     *
     * @return GetOpaStrategyDetailNewResponse GetOpaStrategyDetailNewResponse
     */
    public function getOpaStrategyDetailNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaStrategyDetailNewWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaStrategyTemplateSummaryResponse GetOpaStrategyTemplateSummaryResponse
     */
    public function getOpaStrategyTemplateSummaryWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetOpaStrategyTemplateSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaStrategyTemplateSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
     *  *
     * @return GetOpaStrategyTemplateSummaryResponse GetOpaStrategyTemplateSummaryResponse
     */
    public function getOpaStrategyTemplateSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaStrategyTemplateSummaryWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics about an Object Storage Service (OSS) bucket check.
     *  *
     * @param GetOssBucketScanStatisticRequest $request GetOssBucketScanStatisticRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOssBucketScanStatisticResponse GetOssBucketScanStatisticResponse
     */
    public function getOssBucketScanStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketNameList)) {
            $query['BucketNameList'] = $request->bucketNameList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOssBucketScanStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOssBucketScanStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics about an Object Storage Service (OSS) bucket check.
     *  *
     * @param GetOssBucketScanStatisticRequest $request GetOssBucketScanStatisticRequest
     *
     * @return GetOssBucketScanStatisticResponse GetOssBucketScanStatisticResponse
     */
    public function getOssBucketScanStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOssBucketScanStatisticWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of an Object Storage Service (OSS) bucket check policy.
     *  *
     * @param GetOssScanConfigRequest $request GetOssScanConfigRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOssScanConfigResponse GetOssScanConfigResponse
     */
    public function getOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of an Object Storage Service (OSS) bucket check policy.
     *  *
     * @param GetOssScanConfigRequest $request GetOssScanConfigRequest
     *
     * @return GetOssScanConfigResponse GetOssScanConfigResponse
     */
    public function getOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations for the collection frequency of asset fingerprints.
     *  *
     * @param GetPropertyScheduleConfigRequest $request GetPropertyScheduleConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetPropertyScheduleConfigResponse GetPropertyScheduleConfigResponse
     */
    public function getPropertyScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetPropertyScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetPropertyScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations for the collection frequency of asset fingerprints.
     *  *
     * @param GetPropertyScheduleConfigRequest $request GetPropertyScheduleConfigRequest
     *
     * @return GetPropertyScheduleConfigResponse GetPropertyScheduleConfigResponse
     */
    public function getPropertyScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPropertyScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary 列举RD树
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetRdTreeResponse GetRdTreeResponse
     */
    public function getRdTreeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetRdTree',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetRdTreeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 列举RD树
     *  *
     * @return GetRdTreeResponse GetRdTreeResponse
     */
    public function getRdTree()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRdTreeWithOptions($runtime);
    }

    /**
     * @summary Queries the numbers of system defense rules and custom defense rules.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetRulesCountResponse GetRulesCountResponse
     */
    public function getRulesCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetRulesCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetRulesCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the numbers of system defense rules and custom defense rules.
     *  *
     * @return GetRulesCountResponse GetRulesCountResponse
     */
    public function getRulesCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRulesCountWithOptions($runtime);
    }

    /**
     * @summary Queries the applications that are specified in a rule for container tamper-proofing.
     *  *
     * @param GetSasContainerWebDefenseRuleApplicationRequest $request GetSasContainerWebDefenseRuleApplicationRequest
     * @param RuntimeOptions                                  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSasContainerWebDefenseRuleApplicationResponse GetSasContainerWebDefenseRuleApplicationResponse
     */
    public function getSasContainerWebDefenseRuleApplicationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSasContainerWebDefenseRuleApplication',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSasContainerWebDefenseRuleApplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the applications that are specified in a rule for container tamper-proofing.
     *  *
     * @param GetSasContainerWebDefenseRuleApplicationRequest $request GetSasContainerWebDefenseRuleApplicationRequest
     *
     * @return GetSasContainerWebDefenseRuleApplicationResponse GetSasContainerWebDefenseRuleApplicationResponse
     */
    public function getSasContainerWebDefenseRuleApplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSasContainerWebDefenseRuleApplicationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries search conditions that can be used to search for container file protection rules.
     *  *
     * @param GetSasContainerWebDefenseRuleCriteriaRequest $request GetSasContainerWebDefenseRuleCriteriaRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSasContainerWebDefenseRuleCriteriaResponse GetSasContainerWebDefenseRuleCriteriaResponse
     */
    public function getSasContainerWebDefenseRuleCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSasContainerWebDefenseRuleCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSasContainerWebDefenseRuleCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries search conditions that can be used to search for container file protection rules.
     *  *
     * @param GetSasContainerWebDefenseRuleCriteriaRequest $request GetSasContainerWebDefenseRuleCriteriaRequest
     *
     * @return GetSasContainerWebDefenseRuleCriteriaResponse GetSasContainerWebDefenseRuleCriteriaResponse
     */
    public function getSasContainerWebDefenseRuleCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSasContainerWebDefenseRuleCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of the deduction modules of the security score feature, including custom settings.
     *  *
     * @param GetSecurityScoreRuleRequest $request GetSecurityScoreRuleRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSecurityScoreRuleResponse GetSecurityScoreRuleResponse
     */
    public function getSecurityScoreRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSecurityScoreRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSecurityScoreRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of the deduction modules of the security score feature, including custom settings.
     *  *
     * @param GetSecurityScoreRuleRequest $request GetSecurityScoreRuleRequest
     *
     * @return GetSecurityScoreRuleResponse GetSecurityScoreRuleResponse
     */
    public function getSecurityScoreRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSecurityScoreRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the check rules of sensitive files.
     *  *
     * @param GetSensitiveDefineRuleConfigRequest $request GetSensitiveDefineRuleConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSensitiveDefineRuleConfigResponse GetSensitiveDefineRuleConfigResponse
     */
    public function getSensitiveDefineRuleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSensitiveDefineRuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSensitiveDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the check rules of sensitive files.
     *  *
     * @param GetSensitiveDefineRuleConfigRequest $request GetSensitiveDefineRuleConfigRequest
     *
     * @return GetSensitiveDefineRuleConfigResponse GetSensitiveDefineRuleConfigResponse
     */
    public function getSensitiveDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSensitiveDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the service trail that was delivered to ActionTrail.
     *  *
     * @param GetServiceTrailRequest $request GetServiceTrailRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetServiceTrailResponse GetServiceTrailResponse
     */
    public function getServiceTrailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetServiceTrail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetServiceTrailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the service trail that was delivered to ActionTrail.
     *  *
     * @param GetServiceTrailRequest $request GetServiceTrailRequest
     *
     * @return GetServiceTrailResponse GetServiceTrailResponse
     */
    public function getServiceTrail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getServiceTrailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
     *  *
     * @param GetStrategyTemplateDetailRequest $request GetStrategyTemplateDetailRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetStrategyTemplateDetailResponse GetStrategyTemplateDetailResponse
     */
    public function getStrategyTemplateDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetStrategyTemplateDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetStrategyTemplateDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
     *  *
     * @param GetStrategyTemplateDetailRequest $request GetStrategyTemplateDetailRequest
     *
     * @return GetStrategyTemplateDetailResponse GetStrategyTemplateDetailResponse
     */
    public function getStrategyTemplateDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getStrategyTemplateDetailWithOptions($request, $runtime);
    }

    /**
     * @summary 获取授权支持的模块列表
     *  *
     * @param GetSupportedModulesRequest $request GetSupportedModulesRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSupportedModulesResponse GetSupportedModulesResponse
     */
    public function getSupportedModulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSupportedModules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSupportedModulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取授权支持的模块列表
     *  *
     * @param GetSupportedModulesRequest $request GetSupportedModulesRequest
     *
     * @return GetSupportedModulesResponse GetSupportedModulesResponse
     */
    public function getSupportedModules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSupportedModulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics on alerts in one or more asset groups.
     *  *
     * @param GetSuspiciousStatisticsRequest $request GetSuspiciousStatisticsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSuspiciousStatisticsResponse GetSuspiciousStatisticsResponse
     */
    public function getSuspiciousStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupIdList)) {
            $query['GroupIdList'] = $request->groupIdList;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSuspiciousStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSuspiciousStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on alerts in one or more asset groups.
     *  *
     * @param GetSuspiciousStatisticsRequest $request GetSuspiciousStatisticsRequest
     *
     * @return GetSuspiciousStatisticsResponse GetSuspiciousStatisticsResponse
     */
    public function getSuspiciousStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSuspiciousStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a migration operation. For example, you can query the progress and status of a migration operation after you migrate a server from a region in the Chinese mainland to the Singapore region.
     *  *
     * @param GetSwitchRegionDetailRequest $request GetSwitchRegionDetailRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSwitchRegionDetailResponse GetSwitchRegionDetailResponse
     */
    public function getSwitchRegionDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSwitchRegionDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSwitchRegionDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a migration operation. For example, you can query the progress and status of a migration operation after you migrate a server from a region in the Chinese mainland to the Singapore region.
     *  *
     * @param GetSwitchRegionDetailRequest $request GetSwitchRegionDetailRequest
     *
     * @return GetSwitchRegionDetailResponse GetSwitchRegionDetailResponse
     */
    public function getSwitchRegionDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSwitchRegionDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the language settings of log analysis.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetUserLangResponse GetUserLangResponse
     */
    public function getUserLangWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetUserLang',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetUserLangResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the language settings of log analysis.
     *  *
     * @return GetUserLangResponse GetUserLangResponse
     */
    public function getUserLang()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getUserLangWithOptions($runtime);
    }

    /**
     * @summary Queries the configurations of a periodic virus scan task.
     *  *
     * @param GetVirusScanConfigRequest $request GetVirusScanConfigRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVirusScanConfigResponse GetVirusScanConfigResponse
     */
    public function getVirusScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVirusScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVirusScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of a periodic virus scan task.
     *  *
     * @param GetVirusScanConfigRequest $request GetVirusScanConfigRequest
     *
     * @return GetVirusScanConfigResponse GetVirusScanConfigResponse
     */
    public function getVirusScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVirusScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the latest virus scan task.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVirusScanLatestTaskStatisticResponse GetVirusScanLatestTaskStatisticResponse
     */
    public function getVirusScanLatestTaskStatisticWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetVirusScanLatestTaskStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVirusScanLatestTaskStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the latest virus scan task.
     *  *
     * @return GetVirusScanLatestTaskStatisticResponse GetVirusScanLatestTaskStatisticResponse
     */
    public function getVirusScanLatestTaskStatistic()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVirusScanLatestTaskStatisticWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics on vulnerabilities in asset groups.
     *  *
     * @param GetVulStatisticsRequest $request GetVulStatisticsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVulStatisticsResponse GetVulStatisticsResponse
     */
    public function getVulStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupIdList)) {
            $query['GroupIdList'] = $request->groupIdList;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->typeList)) {
            $query['TypeList'] = $request->typeList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVulStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVulStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on vulnerabilities in asset groups.
     *  *
     * @param GetVulStatisticsRequest $request GetVulStatisticsRequest
     *
     * @return GetVulStatisticsResponse GetVulStatisticsResponse
     */
    public function getVulStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVulStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about a vulnerability whitelist.
     *  *
     * @param GetVulWhitelistRequest $request GetVulWhitelistRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVulWhitelistResponse GetVulWhitelistResponse
     */
    public function getVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vulWhitelistId)) {
            $query['VulWhitelistId'] = $request->vulWhitelistId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about a vulnerability whitelist.
     *  *
     * @param GetVulWhitelistRequest $request GetVulWhitelistRequest
     *
     * @return GetVulWhitelistResponse GetVulWhitelistResponse
     */
    public function getVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Handles alert events.
     *  *
     * @param HandleSecurityEventsRequest $request HandleSecurityEventsRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return HandleSecurityEventsResponse HandleSecurityEventsResponse
     */
    public function handleSecurityEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->markBatch)) {
            $query['MarkBatch'] = $request->markBatch;
        }
        if (!Utils::isUnset($request->markMissParam)) {
            $query['MarkMissParam'] = $request->markMissParam;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->operationParams)) {
            $query['OperationParams'] = $request->operationParams;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->securityEventIds)) {
            $query['SecurityEventIds'] = $request->securityEventIds;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'HandleSecurityEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return HandleSecurityEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles alert events.
     *  *
     * @param HandleSecurityEventsRequest $request HandleSecurityEventsRequest
     *
     * @return HandleSecurityEventsResponse HandleSecurityEventsResponse
     */
    public function handleSecurityEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->handleSecurityEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
     *  *
     * @param HandleSimilarSecurityEventsRequest $request HandleSimilarSecurityEventsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return HandleSimilarSecurityEventsResponse HandleSimilarSecurityEventsResponse
     */
    public function handleSimilarSecurityEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->markMissParam)) {
            $query['MarkMissParam'] = $request->markMissParam;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->operationParams)) {
            $query['OperationParams'] = $request->operationParams;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'HandleSimilarSecurityEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return HandleSimilarSecurityEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
     *  *
     * @param HandleSimilarSecurityEventsRequest $request HandleSimilarSecurityEventsRequest
     *
     * @return HandleSimilarSecurityEventsResponse HandleSimilarSecurityEventsResponse
     */
    public function handleSimilarSecurityEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->handleSimilarSecurityEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
     *  *
     * @param IgnoreCheckItemsRequest $request IgnoreCheckItemsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return IgnoreCheckItemsResponse IgnoreCheckItemsResponse
     */
    public function ignoreCheckItemsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkAndRiskTypeList)) {
            $query['CheckAndRiskTypeList'] = $request->checkAndRiskTypeList;
        }
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'IgnoreCheckItems',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return IgnoreCheckItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
     *  *
     * @param IgnoreCheckItemsRequest $request IgnoreCheckItemsRequest
     *
     * @return IgnoreCheckItemsResponse IgnoreCheckItemsResponse
     */
    public function ignoreCheckItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->ignoreCheckItemsWithOptions($request, $runtime);
    }

    /**
     * @summary Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
     *  *
     * @param IgnoreHcCheckWarningsRequest $request IgnoreHcCheckWarningsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return IgnoreHcCheckWarningsResponse IgnoreHcCheckWarningsResponse
     */
    public function ignoreHcCheckWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->checkWarningIds)) {
            $query['CheckWarningIds'] = $request->checkWarningIds;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'IgnoreHcCheckWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return IgnoreHcCheckWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
     *  *
     * @param IgnoreHcCheckWarningsRequest $request IgnoreHcCheckWarningsRequest
     *
     * @return IgnoreHcCheckWarningsResponse IgnoreHcCheckWarningsResponse
     */
    public function ignoreHcCheckWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->ignoreHcCheckWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary Adds the result scanned by an IDC probe to the whitelist or ignores the scan result.
     *  *
     * @param IgnoreIdcProbeScanResultRequest $request IgnoreIdcProbeScanResultRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return IgnoreIdcProbeScanResultResponse IgnoreIdcProbeScanResultResponse
     */
    public function ignoreIdcProbeScanResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ignoreAction)) {
            $query['IgnoreAction'] = $request->ignoreAction;
        }
        if (!Utils::isUnset($request->scanResultIds)) {
            $query['ScanResultIds'] = $request->scanResultIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'IgnoreIdcProbeScanResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return IgnoreIdcProbeScanResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds the result scanned by an IDC probe to the whitelist or ignores the scan result.
     *  *
     * @param IgnoreIdcProbeScanResultRequest $request IgnoreIdcProbeScanResultRequest
     *
     * @return IgnoreIdcProbeScanResultResponse IgnoreIdcProbeScanResultResponse
     */
    public function ignoreIdcProbeScanResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->ignoreIdcProbeScanResultWithOptions($request, $runtime);
    }

    /**
     * @summary The UUID of the server on which you want to install the anti-ransomware agent. You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
     * >  You must specify at least one of the UuidList and Uuid parameters.
     *  *
     * @param InstallBackupClientRequest $request InstallBackupClientRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallBackupClientResponse InstallBackupClientResponse
     */
    public function installBackupClientWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallBackupClient',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallBackupClientResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The UUID of the server on which you want to install the anti-ransomware agent. You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
     * >  You must specify at least one of the UuidList and Uuid parameters.
     *  *
     * @param InstallBackupClientRequest $request InstallBackupClientRequest
     *
     * @return InstallBackupClientResponse InstallBackupClientResponse
     */
    public function installBackupClient($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installBackupClientWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the CloudMonitor agent on specified servers.
     *  *
     * @description > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
     *  *
     * @param InstallCloudMonitorRequest $request InstallCloudMonitorRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallCloudMonitorResponse InstallCloudMonitorResponse
     */
    public function installCloudMonitorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->agentAccessKey)) {
            $query['AgentAccessKey'] = $request->agentAccessKey;
        }
        if (!Utils::isUnset($request->agentSecretKey)) {
            $query['AgentSecretKey'] = $request->agentSecretKey;
        }
        if (!Utils::isUnset($request->argusVersion)) {
            $query['ArgusVersion'] = $request->argusVersion;
        }
        if (!Utils::isUnset($request->instanceIdList)) {
            $query['InstanceIdList'] = $request->instanceIdList;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallCloudMonitor',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallCloudMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the CloudMonitor agent on specified servers.
     *  *
     * @description > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
     *  *
     * @param InstallCloudMonitorRequest $request InstallCloudMonitorRequest
     *
     * @return InstallCloudMonitorResponse InstallCloudMonitorResponse
     */
    public function installCloudMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installCloudMonitorWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the Security Center agent on a proxy server in a hybrid cloud.
     *  *
     * @param InstallHybridProxyRequest $request InstallHybridProxyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallHybridProxyResponse InstallHybridProxyResponse
     */
    public function installHybridProxyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->installCode)) {
            $query['InstallCode'] = $request->installCode;
        }
        if (!Utils::isUnset($request->yundunUuids)) {
            $query['YundunUuids'] = $request->yundunUuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallHybridProxy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the Security Center agent on a proxy server in a hybrid cloud.
     *  *
     * @param InstallHybridProxyRequest $request InstallHybridProxyRequest
     *
     * @return InstallHybridProxyResponse InstallHybridProxyResponse
     */
    public function installHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installHybridProxyWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
     *  *
     * @param InstallPmAgentRequest $request InstallPmAgentRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallPmAgentResponse InstallPmAgentResponse
     */
    public function installPmAgentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallPmAgent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallPmAgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
     *  *
     * @param InstallPmAgentRequest $request InstallPmAgentRequest
     *
     * @return InstallPmAgentResponse InstallPmAgentResponse
     */
    public function installPmAgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installPmAgentWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the Runtime Application Self-Protection (RASP) agent on Elastic Compute Service (ECS) instances to enable automatic application protection.
     *  *
     * @param InstallRaspAttachRequest $request InstallRaspAttachRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallRaspAttachResponse InstallRaspAttachResponse
     */
    public function installRaspAttachWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->applicationId)) {
            $query['ApplicationId'] = $request->applicationId;
        }
        if (!Utils::isUnset($request->ecsUUIDList)) {
            $query['EcsUUIDList'] = $request->ecsUUIDList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallRaspAttach',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallRaspAttachResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the Runtime Application Self-Protection (RASP) agent on Elastic Compute Service (ECS) instances to enable automatic application protection.
     *  *
     * @param InstallRaspAttachRequest $request InstallRaspAttachRequest
     *
     * @return InstallRaspAttachResponse InstallRaspAttachResponse
     */
    public function installRaspAttach($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installRaspAttachWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the anti-ransomware agent for databases.
     *  *
     * @param InstallUniBackupAgentRequest $request InstallUniBackupAgentRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallUniBackupAgentResponse InstallUniBackupAgentResponse
     */
    public function installUniBackupAgentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallUniBackupAgent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallUniBackupAgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the anti-ransomware agent for databases.
     *  *
     * @param InstallUniBackupAgentRequest $request InstallUniBackupAgentRequest
     *
     * @return InstallUniBackupAgentResponse InstallUniBackupAgentResponse
     */
    public function installUniBackupAgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installUniBackupAgentWithOptions($request, $runtime);
    }

    /**
     * @summary Adds processes to the process whitelist of web tamper proofing.
     *  *
     * @param JoinWebLockProcessWhiteListRequest $request JoinWebLockProcessWhiteListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return JoinWebLockProcessWhiteListResponse JoinWebLockProcessWhiteListResponse
     */
    public function joinWebLockProcessWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->processPaths)) {
            $query['ProcessPaths'] = $request->processPaths;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'JoinWebLockProcessWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return JoinWebLockProcessWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds processes to the process whitelist of web tamper proofing.
     *  *
     * @param JoinWebLockProcessWhiteListRequest $request JoinWebLockProcessWhiteListRequest
     *
     * @return JoinWebLockProcessWhiteListResponse JoinWebLockProcessWhiteListResponse
     */
    public function joinWebLockProcessWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->joinWebLockProcessWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries members in the resource directory that is involved when the multi-account management feature is enabled.
     *  *
     * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAccountsInResourceDirectoryResponse ListAccountsInResourceDirectoryResponse
     */
    public function listAccountsInResourceDirectoryWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListAccountsInResourceDirectory',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAccountsInResourceDirectoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries members in the resource directory that is involved when the multi-account management feature is enabled.
     *  *
     * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *  *
     * @return ListAccountsInResourceDirectoryResponse ListAccountsInResourceDirectoryResponse
     */
    public function listAccountsInResourceDirectory()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAccountsInResourceDirectoryWithOptions($runtime);
    }

    /**
     * @summary Queries defense rules against container escapes.
     *  *
     * @param ListAegisContainerPluginRuleRequest $request ListAegisContainerPluginRuleRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAegisContainerPluginRuleResponse ListAegisContainerPluginRuleResponse
     */
    public function listAegisContainerPluginRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAegisContainerPluginRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAegisContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries defense rules against container escapes.
     *  *
     * @param ListAegisContainerPluginRuleRequest $request ListAegisContainerPluginRuleRequest
     *
     * @return ListAegisContainerPluginRuleResponse ListAegisContainerPluginRuleResponse
     */
    public function listAegisContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAegisContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries malicious files that are detected by agentless detection tasks.
     *  *
     * @param ListAgentlessMaliciousFilesRequest $request ListAgentlessMaliciousFilesRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessMaliciousFilesResponse ListAgentlessMaliciousFilesResponse
     */
    public function listAgentlessMaliciousFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->fuzzyMaliciousName)) {
            $query['FuzzyMaliciousName'] = $request->fuzzyMaliciousName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->maliciousMd5)) {
            $query['MaliciousMd5'] = $request->maliciousMd5;
        }
        if (!Utils::isUnset($request->maliciousType)) {
            $query['MaliciousType'] = $request->maliciousType;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAgentlessMaliciousFiles',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessMaliciousFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries malicious files that are detected by agentless detection tasks.
     *  *
     * @param ListAgentlessMaliciousFilesRequest $request ListAgentlessMaliciousFilesRequest
     *
     * @return ListAgentlessMaliciousFilesResponse ListAgentlessMaliciousFilesResponse
     */
    public function listAgentlessMaliciousFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessMaliciousFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the regions that are supported by the agentless detection feature.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessRegionResponse ListAgentlessRegionResponse
     */
    public function listAgentlessRegionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListAgentlessRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the regions that are supported by the agentless detection feature.
     *  *
     * @return ListAgentlessRegionResponse ListAgentlessRegionResponse
     */
    public function listAgentlessRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessRegionWithOptions($runtime);
    }

    /**
     * @summary Obtains the risks associated with an agentless detection event.
     *  *
     * @param ListAgentlessRelateMaliciousRequest $request ListAgentlessRelateMaliciousRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessRelateMaliciousResponse ListAgentlessRelateMaliciousResponse
     */
    public function listAgentlessRelateMaliciousWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAgentlessRelateMalicious',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessRelateMaliciousResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the risks associated with an agentless detection event.
     *  *
     * @param ListAgentlessRelateMaliciousRequest $request ListAgentlessRelateMaliciousRequest
     *
     * @return ListAgentlessRelateMaliciousResponse ListAgentlessRelateMaliciousResponse
     */
    public function listAgentlessRelateMalicious($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessRelateMaliciousWithOptions($request, $runtime);
    }

    /**
     * @summary Queries at-risk hosts that are detected by the agentless detection feature.
     *  *
     * @param ListAgentlessRiskUuidRequest $request ListAgentlessRiskUuidRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessRiskUuidResponse ListAgentlessRiskUuidResponse
     */
    public function listAgentlessRiskUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceName)) {
            $query['InstanceName'] = $request->instanceName;
        }
        if (!Utils::isUnset($request->internetIp)) {
            $query['InternetIp'] = $request->internetIp;
        }
        if (!Utils::isUnset($request->intranetIp)) {
            $query['IntranetIp'] = $request->intranetIp;
        }
        if (!Utils::isUnset($request->machineName)) {
            $query['MachineName'] = $request->machineName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->risk)) {
            $query['Risk'] = $request->risk;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAgentlessRiskUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessRiskUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries at-risk hosts that are detected by the agentless detection feature.
     *  *
     * @param ListAgentlessRiskUuidRequest $request ListAgentlessRiskUuidRequest
     *
     * @return ListAgentlessRiskUuidResponse ListAgentlessRiskUuidResponse
     */
    public function listAgentlessRiskUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessRiskUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries agentless detection tasks.
     *  *
     * @param ListAgentlessTaskRequest $request ListAgentlessTaskRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessTaskResponse ListAgentlessTaskResponse
     */
    public function listAgentlessTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->internetIp)) {
            $query['InternetIp'] = $request->internetIp;
        }
        if (!Utils::isUnset($request->intranetIp)) {
            $query['IntranetIp'] = $request->intranetIp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->machineName)) {
            $query['MachineName'] = $request->machineName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->rootTask)) {
            $query['RootTask'] = $request->rootTask;
        }
        if (!Utils::isUnset($request->rootTaskId)) {
            $query['RootTaskId'] = $request->rootTaskId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAgentlessTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries agentless detection tasks.
     *  *
     * @param ListAgentlessTaskRequest $request ListAgentlessTaskRequest
     *
     * @return ListAgentlessTaskResponse ListAgentlessTaskResponse
     */
    public function listAgentlessTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations for cleaning offline hosts whose provider cannot be identified.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAssetCleanConfigResponse ListAssetCleanConfigResponse
     */
    public function listAssetCleanConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListAssetCleanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAssetCleanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations for cleaning offline hosts whose provider cannot be identified.
     *  *
     * @return ListAssetCleanConfigResponse ListAssetCleanConfigResponse
     */
    public function listAssetCleanConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetCleanConfigWithOptions($runtime);
    }

    /**
     * @summary  获取资产列表
     *  *
     * @param ListAssetInfoPublishRequest $request ListAssetInfoPublishRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAssetInfoPublishResponse ListAssetInfoPublishResponse
     */
    public function listAssetInfoPublishWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAssetInfoPublish',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAssetInfoPublishResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary  获取资产列表
     *  *
     * @param ListAssetInfoPublishRequest $request ListAssetInfoPublishRequest
     *
     * @return ListAssetInfoPublishResponse ListAssetInfoPublishResponse
     */
    public function listAssetInfoPublish($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetInfoPublishWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of asset synchronization.
     *  *
     * @param ListAssetRefreshTaskConfigRequest $request ListAssetRefreshTaskConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAssetRefreshTaskConfigResponse ListAssetRefreshTaskConfigResponse
     */
    public function listAssetRefreshTaskConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->refreshConfigType)) {
            $query['RefreshConfigType'] = $request->refreshConfigType;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->targetId)) {
            $query['TargetId'] = $request->targetId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAssetRefreshTaskConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAssetRefreshTaskConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of asset synchronization.
     *  *
     * @param ListAssetRefreshTaskConfigRequest $request ListAssetRefreshTaskConfigRequest
     *
     * @return ListAssetRefreshTaskConfigResponse ListAssetRefreshTaskConfigResponse
     */
    public function listAssetRefreshTaskConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetRefreshTaskConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the selected assets.
     *  *
     * @param ListAssetSelectionSelectedTargetRequest $request ListAssetSelectionSelectedTargetRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAssetSelectionSelectedTargetResponse ListAssetSelectionSelectedTargetResponse
     */
    public function listAssetSelectionSelectedTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        if (!Utils::isUnset($request->targetList)) {
            $query['TargetList'] = $request->targetList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAssetSelectionSelectedTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAssetSelectionSelectedTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the selected assets.
     *  *
     * @param ListAssetSelectionSelectedTargetRequest $request ListAssetSelectionSelectedTargetRequest
     *
     * @return ListAssetSelectionSelectedTargetResponse ListAssetSelectionSelectedTargetResponse
     */
    public function listAssetSelectionSelectedTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetSelectionSelectedTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the required asset.
     *  *
     * @param ListAssetSelectionTargetRequest $request ListAssetSelectionTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAssetSelectionTargetResponse ListAssetSelectionTargetResponse
     */
    public function listAssetSelectionTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAssetSelectionTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAssetSelectionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the required asset.
     *  *
     * @param ListAssetSelectionTargetRequest $request ListAssetSelectionTargetRequest
     *
     * @return ListAssetSelectionTargetResponse ListAssetSelectionTargetResponse
     */
    public function listAssetSelectionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetSelectionTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
     *  *
     * @param ListAutoTagRulesRequest $request ListAutoTagRulesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAutoTagRulesResponse ListAutoTagRulesResponse
     */
    public function listAutoTagRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAutoTagRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAutoTagRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
     *  *
     * @param ListAutoTagRulesRequest $request ListAutoTagRulesRequest
     *
     * @return ListAutoTagRulesResponse ListAutoTagRulesResponse
     */
    public function listAutoTagRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAutoTagRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about available honeypot templates.
     *  *
     * @param ListAvailableHoneypotRequest $request ListAvailableHoneypotRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAvailableHoneypotResponse ListAvailableHoneypotResponse
     */
    public function listAvailableHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAvailableHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAvailableHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about available honeypot templates.
     *  *
     * @param ListAvailableHoneypotRequest $request ListAvailableHoneypotRequest
     *
     * @return ListAvailableHoneypotResponse ListAvailableHoneypotResponse
     */
    public function listAvailableHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAvailableHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Queries backup records.
     *  *
     * @param ListBackupRecordRequest $request ListBackupRecordRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBackupRecordResponse ListBackupRecordResponse
     */
    public function listBackupRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->backupEndTime)) {
            $query['BackupEndTime'] = $request->backupEndTime;
        }
        if (!Utils::isUnset($request->backupStartTime)) {
            $query['BackupStartTime'] = $request->backupStartTime;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->machineRemark)) {
            $query['MachineRemark'] = $request->machineRemark;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListBackupRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBackupRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries backup records.
     *  *
     * @param ListBackupRecordRequest $request ListBackupRecordRequest
     *
     * @return ListBackupRecordResponse ListBackupRecordResponse
     */
    public function listBackupRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBackupRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the whitelist rules for a baseline check item.
     *  *
     * @param ListBaselineCheckWhiteRecordRequest $tmpReq  ListBaselineCheckWhiteRecordRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBaselineCheckWhiteRecordResponse ListBaselineCheckWhiteRecordResponse
     */
    public function listBaselineCheckWhiteRecordWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListBaselineCheckWhiteRecordShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->checkIds)) {
            $request->checkIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->checkIds, 'CheckIds', 'json');
        }
        if (!Utils::isUnset($tmpReq->recordIds)) {
            $request->recordIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->recordIds, 'RecordIds', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->checkIdsShrink)) {
            $query['CheckIds'] = $request->checkIdsShrink;
        }
        if (!Utils::isUnset($request->checkItemFuzzy)) {
            $query['CheckItemFuzzy'] = $request->checkItemFuzzy;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->recordIdsShrink)) {
            $query['RecordIds'] = $request->recordIdsShrink;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListBaselineCheckWhiteRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBaselineCheckWhiteRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the whitelist rules for a baseline check item.
     *  *
     * @param ListBaselineCheckWhiteRecordRequest $request ListBaselineCheckWhiteRecordRequest
     *
     * @return ListBaselineCheckWhiteRecordResponse ListBaselineCheckWhiteRecordResponse
     */
    public function listBaselineCheckWhiteRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselineCheckWhiteRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the instances that failed a specified check item of configuration assessment.
     *  *
     * @param ListCheckInstanceResultRequest $request ListCheckInstanceResultRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckInstanceResultResponse ListCheckInstanceResultResponse
     */
    public function listCheckInstanceResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->instanceIdKey)) {
            $query['InstanceIdKey'] = $request->instanceIdKey;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->instanceNameKey)) {
            $query['InstanceNameKey'] = $request->instanceNameKey;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionIdKey)) {
            $query['RegionIdKey'] = $request->regionIdKey;
        }
        if (!Utils::isUnset($request->sortTypes)) {
            $query['SortTypes'] = $request->sortTypes;
        }
        if (!Utils::isUnset($request->statuses)) {
            $query['Statuses'] = $request->statuses;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckInstanceResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckInstanceResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the instances that failed a specified check item of configuration assessment.
     *  *
     * @param ListCheckInstanceResultRequest $request ListCheckInstanceResultRequest
     *
     * @return ListCheckInstanceResultResponse ListCheckInstanceResultResponse
     */
    public function listCheckInstanceResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckInstanceResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the check items that can be customized.
     *  *
     * @param ListCheckItemRequest $request ListCheckItemRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckItemResponse ListCheckItemResponse
     */
    public function listCheckItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the check items that can be customized.
     *  *
     * @param ListCheckItemRequest $request ListCheckItemRequest
     *
     * @return ListCheckItemResponse ListCheckItemResponse
     */
    public function listCheckItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers that are affected by baseline risks.
     *  *
     * @param ListCheckItemWarningMachineRequest $request ListCheckItemWarningMachineRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckItemWarningMachineResponse ListCheckItemWarningMachineResponse
     */
    public function listCheckItemWarningMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->riskType)) {
            $query['RiskType'] = $request->riskType;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckItemWarningMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckItemWarningMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers that are affected by baseline risks.
     *  *
     * @param ListCheckItemWarningMachineRequest $request ListCheckItemWarningMachineRequest
     *
     * @return ListCheckItemWarningMachineResponse ListCheckItemWarningMachineResponse
     */
    public function listCheckItemWarningMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemWarningMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the risk statistics of check items by page.
     *  *
     * @param ListCheckItemWarningSummaryRequest $request ListCheckItemWarningSummaryRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckItemWarningSummaryResponse ListCheckItemWarningSummaryResponse
     */
    public function listCheckItemWarningSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkItemFuzzy)) {
            $query['CheckItemFuzzy'] = $request->checkItemFuzzy;
        }
        if (!Utils::isUnset($request->checkLevel)) {
            $query['CheckLevel'] = $request->checkLevel;
        }
        if (!Utils::isUnset($request->checkType)) {
            $query['CheckType'] = $request->checkType;
        }
        if (!Utils::isUnset($request->checkWarningStatus)) {
            $query['CheckWarningStatus'] = $request->checkWarningStatus;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskType)) {
            $query['RiskType'] = $request->riskType;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckItemWarningSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckItemWarningSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk statistics of check items by page.
     *  *
     * @param ListCheckItemWarningSummaryRequest $request ListCheckItemWarningSummaryRequest
     *
     * @return ListCheckItemWarningSummaryResponse ListCheckItemWarningSummaryResponse
     */
    public function listCheckItemWarningSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemWarningSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of the risk items that are detected in the configuration checks on cloud services.
     *  *
     * @param ListCheckResultRequest $request ListCheckResultRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckResultResponse ListCheckResultResponse
     */
    public function listCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->checkKey)) {
            $query['CheckKey'] = $request->checkKey;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->customParam)) {
            $query['CustomParam'] = $request->customParam;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->instanceTypes)) {
            $query['InstanceTypes'] = $request->instanceTypes;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->requirementIds)) {
            $query['RequirementIds'] = $request->requirementIds;
        }
        if (!Utils::isUnset($request->riskLevels)) {
            $query['RiskLevels'] = $request->riskLevels;
        }
        if (!Utils::isUnset($request->sortTypes)) {
            $query['SortTypes'] = $request->sortTypes;
        }
        if (!Utils::isUnset($request->standardIds)) {
            $query['StandardIds'] = $request->standardIds;
        }
        if (!Utils::isUnset($request->statuses)) {
            $query['Statuses'] = $request->statuses;
        }
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of the risk items that are detected in the configuration checks on cloud services.
     *  *
     * @param ListCheckResultRequest $request ListCheckResultRequest
     *
     * @return ListCheckResultResponse ListCheckResultResponse
     */
    public function listCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the standards of configuration checks.
     *  *
     * @param ListCheckStandardRequest $request ListCheckStandardRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckStandardResponse ListCheckStandardResponse
     */
    public function listCheckStandardWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->instanceSubTypes)) {
            $query['InstanceSubTypes'] = $request->instanceSubTypes;
        }
        if (!Utils::isUnset($request->instanceTypes)) {
            $query['InstanceTypes'] = $request->instanceTypes;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckStandard',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckStandardResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the standards of configuration checks.
     *  *
     * @param ListCheckStandardRequest $request ListCheckStandardRequest
     *
     * @return ListCheckStandardResponse ListCheckStandardResponse
     */
    public function listCheckStandard($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckStandardWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the types of check items that meet the specified conditions based on the ID of a baseline.
     *  *
     * @param ListCheckTypesRequest $request ListCheckTypesRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckTypesResponse ListCheckTypesResponse
     */
    public function listCheckTypesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->showChecks)) {
            $query['ShowChecks'] = $request->showChecks;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckTypes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the types of check items that meet the specified conditions based on the ID of a baseline.
     *  *
     * @param ListCheckTypesRequest $request ListCheckTypesRequest
     *
     * @return ListCheckTypesResponse ListCheckTypesResponse
     */
    public function listCheckTypes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckTypesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
     *  *
     * @param ListClientAlertModeRequest $request ListClientAlertModeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClientAlertModeResponse ListClientAlertModeResponse
     */
    public function listClientAlertModeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClientAlertMode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClientAlertModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
     *  *
     * @param ListClientAlertModeRequest $request ListClientAlertModeRequest
     *
     * @return ListClientAlertModeResponse ListClientAlertModeResponse
     */
    public function listClientAlertMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClientAlertModeWithOptions($request, $runtime);
    }

    /**
     * @summary 获取客户端支持的所有用户自定义类型
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClientUserDefineRuleTypesResponse ListClientUserDefineRuleTypesResponse
     */
    public function listClientUserDefineRuleTypesWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListClientUserDefineRuleTypes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClientUserDefineRuleTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取客户端支持的所有用户自定义类型
     *  *
     * @return ListClientUserDefineRuleTypesResponse ListClientUserDefineRuleTypesResponse
     */
    public function listClientUserDefineRuleTypes()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClientUserDefineRuleTypesWithOptions($runtime);
    }

    /**
     * @summary Queries custom defense rules.
     *  *
     * @param ListClientUserDefineRulesRequest $request ListClientUserDefineRulesRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClientUserDefineRulesResponse ListClientUserDefineRulesResponse
     */
    public function listClientUserDefineRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClientUserDefineRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClientUserDefineRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries custom defense rules.
     *  *
     * @param ListClientUserDefineRulesRequest $request ListClientUserDefineRulesRequest
     *
     * @return ListClientUserDefineRulesResponse ListClientUserDefineRulesResponse
     */
    public function listClientUserDefineRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClientUserDefineRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries cloud service assets.
     *  *
     * @param ListCloudAssetInstancesRequest $request ListCloudAssetInstancesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCloudAssetInstancesResponse ListCloudAssetInstancesResponse
     */
    public function listCloudAssetInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cloudAssetTypes)) {
            $query['CloudAssetTypes'] = $request->cloudAssetTypes;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCloudAssetInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCloudAssetInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries cloud service assets.
     *  *
     * @param ListCloudAssetInstancesRequest $request ListCloudAssetInstancesRequest
     *
     * @return ListCloudAssetInstancesResponse ListCloudAssetInstancesResponse
     */
    public function listCloudAssetInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCloudAssetInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the synchronization region configurations of other clouds on a site.
     *  *
     * @param ListCloudVendorRegionsRequest $request ListCloudVendorRegionsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCloudVendorRegionsResponse ListCloudVendorRegionsResponse
     */
    public function listCloudVendorRegionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCloudVendorRegions',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCloudVendorRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the synchronization region configurations of other clouds on a site.
     *  *
     * @param ListCloudVendorRegionsRequest $request ListCloudVendorRegionsRequest
     *
     * @return ListCloudVendorRegionsResponse ListCloudVendorRegionsResponse
     */
    public function listCloudVendorRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCloudVendorRegionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the protection status of the container firewall.
     *  *
     * @param ListClusterCnnfStatusDetailRequest $request ListClusterCnnfStatusDetailRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClusterCnnfStatusDetailResponse ListClusterCnnfStatusDetailResponse
     */
    public function listClusterCnnfStatusDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClusterCnnfStatusDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClusterCnnfStatusDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the protection status of the container firewall.
     *  *
     * @param ListClusterCnnfStatusDetailRequest $request ListClusterCnnfStatusDetailRequest
     *
     * @return ListClusterCnnfStatusDetailResponse ListClusterCnnfStatusDetailResponse
     */
    public function listClusterCnnfStatusDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterCnnfStatusDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the defense rules that are created for a cluster.
     *  *
     * @param ListClusterInterceptionConfigRequest $request ListClusterInterceptionConfigRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClusterInterceptionConfigResponse ListClusterInterceptionConfigResponse
     */
    public function listClusterInterceptionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterCNNFStatus)) {
            $query['ClusterCNNFStatus'] = $request->clusterCNNFStatus;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClusterInterceptionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClusterInterceptionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the defense rules that are created for a cluster.
     *  *
     * @param ListClusterInterceptionConfigRequest $request ListClusterInterceptionConfigRequest
     *
     * @return ListClusterInterceptionConfigResponse ListClusterInterceptionConfigResponse
     */
    public function listClusterInterceptionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterInterceptionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of plug-ins on clusters.
     *  *
     * @param ListClusterPluginInfoRequest $request ListClusterPluginInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClusterPluginInfoResponse ListClusterPluginInfoResponse
     */
    public function listClusterPluginInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pluginName)) {
            $query['PluginName'] = $request->pluginName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClusterPluginInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClusterPluginInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of plug-ins on clusters.
     *  *
     * @param ListClusterPluginInfoRequest $request ListClusterPluginInfoRequest
     *
     * @return ListClusterPluginInfoResponse ListClusterPluginInfoResponse
     */
    public function listClusterPluginInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterPluginInfoWithOptions($request, $runtime);
    }

    /**
     * @summary 获取压缩包检测结果。
     *  *
     * @param ListCompressFileDetectResultRequest $request ListCompressFileDetectResultRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCompressFileDetectResultResponse ListCompressFileDetectResultResponse
     */
    public function listCompressFileDetectResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->hashKey)) {
            $query['HashKey'] = $request->hashKey;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCompressFileDetectResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCompressFileDetectResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取压缩包检测结果。
     *  *
     * @param ListCompressFileDetectResultRequest $request ListCompressFileDetectResultRequest
     *
     * @return ListCompressFileDetectResultResponse ListCompressFileDetectResultResponse
     */
    public function listCompressFileDetectResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCompressFileDetectResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of rules for non-image program defense.
     *  *
     * @param ListContainerDefenseRuleRequest $request ListContainerDefenseRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListContainerDefenseRuleResponse ListContainerDefenseRuleResponse
     */
    public function listContainerDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->conditions)) {
            $query['Conditions'] = $request->conditions;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->isDefaultRule)) {
            $query['IsDefaultRule'] = $request->isDefaultRule;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListContainerDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of rules for non-image program defense.
     *  *
     * @param ListContainerDefenseRuleRequest $request ListContainerDefenseRuleRequest
     *
     * @return ListContainerDefenseRuleResponse ListContainerDefenseRuleResponse
     */
    public function listContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of clusters that are included in a rule for non-image program defense.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListContainerDefenseRuleClustersResponse ListContainerDefenseRuleClustersResponse
     */
    public function listContainerDefenseRuleClustersWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListContainerDefenseRuleClusters',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListContainerDefenseRuleClustersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of clusters that are included in a rule for non-image program defense.
     *  *
     * @return ListContainerDefenseRuleClustersResponse ListContainerDefenseRuleClustersResponse
     */
    public function listContainerDefenseRuleClusters()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listContainerDefenseRuleClustersWithOptions($runtime);
    }

    /**
     * @summary Queries the IDs and names of rules configured for proactive defense for containers.
     *  *
     * @param ListCriteriaStrategyRequest $request ListCriteriaStrategyRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCriteriaStrategyResponse ListCriteriaStrategyResponse
     */
    public function listCriteriaStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->label)) {
            $query['Label'] = $request->label;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCriteriaStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCriteriaStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the IDs and names of rules configured for proactive defense for containers.
     *  *
     * @param ListCriteriaStrategyRequest $request ListCriteriaStrategyRequest
     *
     * @return ListCriteriaStrategyResponse ListCriteriaStrategyResponse
     */
    public function listCriteriaStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCriteriaStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries core file monitoring rules that meet the specified filter condition.
     *  *
     * @param ListFileProtectEventRequest $request ListFileProtectEventRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileProtectEventResponse ListFileProtectEventResponse
     */
    public function listFileProtectEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alertLevels)) {
            $query['AlertLevels'] = $request->alertLevels;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceName)) {
            $query['InstanceName'] = $request->instanceName;
        }
        if (!Utils::isUnset($request->internetIp)) {
            $query['InternetIp'] = $request->internetIp;
        }
        if (!Utils::isUnset($request->intranetIp)) {
            $query['IntranetIp'] = $request->intranetIp;
        }
        if (!Utils::isUnset($request->operation)) {
            $query['Operation'] = $request->operation;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListFileProtectEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileProtectEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries core file monitoring rules that meet the specified filter condition.
     *  *
     * @param ListFileProtectEventRequest $request ListFileProtectEventRequest
     *
     * @return ListFileProtectEventResponse ListFileProtectEventResponse
     */
    public function listFileProtectEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileProtectEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
     *  *
     * @param ListFileProtectPluginStatusRequest $request ListFileProtectPluginStatusRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileProtectPluginStatusResponse ListFileProtectPluginStatusResponse
     */
    public function listFileProtectPluginStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->switchId)) {
            $query['SwitchId'] = $request->switchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListFileProtectPluginStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileProtectPluginStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
     *  *
     * @param ListFileProtectPluginStatusRequest $request ListFileProtectPluginStatusRequest
     *
     * @return ListFileProtectPluginStatusResponse ListFileProtectPluginStatusResponse
     */
    public function listFileProtectPluginStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileProtectPluginStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries core file monitoring rules.
     *  *
     * @param ListFileProtectRuleRequest $request ListFileProtectRuleRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileProtectRuleResponse ListFileProtectRuleResponse
     */
    public function listFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alertLevel)) {
            $query['AlertLevel'] = $request->alertLevel;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->platform)) {
            $query['Platform'] = $request->platform;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries core file monitoring rules.
     *  *
     * @param ListFileProtectRuleRequest $request ListFileProtectRuleRequest
     *
     * @return ListFileProtectRuleResponse ListFileProtectRuleResponse
     */
    public function listFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the server groups.
     *  *
     * @param ListGroupsRequest $request ListGroupsRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListGroupsResponse ListGroupsResponse
     */
    public function listGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->useNextToken)) {
            $query['UseNextToken'] = $request->useNextToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListGroups',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the server groups.
     *  *
     * @param ListGroupsRequest $request ListGroupsRequest
     *
     * @return ListGroupsResponse ListGroupsResponse
     */
    public function listGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about honeypots.
     *  *
     * @param ListHoneypotRequest $request ListHoneypotRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotResponse ListHoneypotResponse
     */
    public function listHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->honeypotIds)) {
            $query['HoneypotIds'] = $request->honeypotIds;
        }
        if (!Utils::isUnset($request->honeypotName)) {
            $query['HoneypotName'] = $request->honeypotName;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about honeypots.
     *  *
     * @param ListHoneypotRequest $request ListHoneypotRequest
     *
     * @return ListHoneypotResponse ListHoneypotResponse
     */
    public function listHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about alert events that are generated.
     *  *
     * @param ListHoneypotAlarmEventsRequest $request ListHoneypotAlarmEventsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotAlarmEventsResponse ListHoneypotAlarmEventsResponse
     */
    public function listHoneypotAlarmEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotAlarmEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotAlarmEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about alert events that are generated.
     *  *
     * @param ListHoneypotAlarmEventsRequest $request ListHoneypotAlarmEventsRequest
     *
     * @return ListHoneypotAlarmEventsResponse ListHoneypotAlarmEventsResponse
     */
    public function listHoneypotAlarmEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotAlarmEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the attacker profile based on the source IP address of the attack.
     *  *
     * @param ListHoneypotAttackerPortraitRequest $request ListHoneypotAttackerPortraitRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotAttackerPortraitResponse ListHoneypotAttackerPortraitResponse
     */
    public function listHoneypotAttackerPortraitWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTimeStamp)) {
            $query['EndTimeStamp'] = $request->endTimeStamp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->srcIp)) {
            $query['SrcIp'] = $request->srcIp;
        }
        if (!Utils::isUnset($request->startTimeStamp)) {
            $query['StartTimeStamp'] = $request->startTimeStamp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotAttackerPortrait',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotAttackerPortraitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the attacker profile based on the source IP address of the attack.
     *  *
     * @param ListHoneypotAttackerPortraitRequest $request ListHoneypotAttackerPortraitRequest
     *
     * @return ListHoneypotAttackerPortraitResponse ListHoneypotAttackerPortraitResponse
     */
    public function listHoneypotAttackerPortrait($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotAttackerPortraitWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the attack source IP addresses that are used to attack a honeypot.
     *  *
     * @param ListHoneypotAttackerSourceRequest $request ListHoneypotAttackerSourceRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotAttackerSourceResponse ListHoneypotAttackerSourceResponse
     */
    public function listHoneypotAttackerSourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTimeStamp)) {
            $query['EndTimeStamp'] = $request->endTimeStamp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevelList)) {
            $query['RiskLevelList'] = $request->riskLevelList;
        }
        if (!Utils::isUnset($request->srcIp)) {
            $query['SrcIp'] = $request->srcIp;
        }
        if (!Utils::isUnset($request->startTimeStamp)) {
            $query['StartTimeStamp'] = $request->startTimeStamp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotAttackerSource',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotAttackerSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the attack source IP addresses that are used to attack a honeypot.
     *  *
     * @param ListHoneypotAttackerSourceRequest $request ListHoneypotAttackerSourceRequest
     *
     * @return ListHoneypotAttackerSourceResponse ListHoneypotAttackerSourceResponse
     */
    public function listHoneypotAttackerSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotAttackerSourceWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an intrusion event in a honeypot.
     *  *
     * @param ListHoneypotEventFlowsRequest $request ListHoneypotEventFlowsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotEventFlowsResponse ListHoneypotEventFlowsResponse
     */
    public function listHoneypotEventFlowsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->requestId)) {
            $query['RequestId'] = $request->requestId;
        }
        if (!Utils::isUnset($request->securityEventId)) {
            $query['SecurityEventId'] = $request->securityEventId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotEventFlows',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotEventFlowsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an intrusion event in a honeypot.
     *  *
     * @param ListHoneypotEventFlowsRequest $request ListHoneypotEventFlowsRequest
     *
     * @return ListHoneypotEventFlowsResponse ListHoneypotEventFlowsResponse
     */
    public function listHoneypotEventFlows($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotEventFlowsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the intrusion events detected by honeypots.
     *  *
     * @param ListHoneypotEventsRequest $request ListHoneypotEventsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotEventsResponse ListHoneypotEventsResponse
     */
    public function listHoneypotEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the intrusion events detected by honeypots.
     *  *
     * @param ListHoneypotEventsRequest $request ListHoneypotEventsRequest
     *
     * @return ListHoneypotEventsResponse ListHoneypotEventsResponse
     */
    public function listHoneypotEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about management nodes.
     *  *
     * @param ListHoneypotNodeRequest $request ListHoneypotNodeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotNodeResponse ListHoneypotNodeResponse
     */
    public function listHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about management nodes.
     *  *
     * @param ListHoneypotNodeRequest $request ListHoneypotNodeRequest
     *
     * @return ListHoneypotNodeResponse ListHoneypotNodeResponse
     */
    public function listHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries honeypot templates.
     *  *
     * @param ListHoneypotPresetRequest $request ListHoneypotPresetRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotPresetResponse ListHoneypotPresetResponse
     */
    public function listHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->presetName)) {
            $query['PresetName'] = $request->presetName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries honeypot templates.
     *  *
     * @param ListHoneypotPresetRequest $request ListHoneypotPresetRequest
     *
     * @return ListHoneypotPresetResponse ListHoneypotPresetResponse
     */
    public function listHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries probes.
     *  *
     * @param ListHoneypotProbeRequest $request ListHoneypotProbeRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotProbeResponse ListHoneypotProbeResponse
     */
    public function listHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->displayName)) {
            $query['DisplayName'] = $request->displayName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->probeStatus)) {
            $query['ProbeStatus'] = $request->probeStatus;
        }
        if (!Utils::isUnset($request->probeType)) {
            $query['ProbeType'] = $request->probeType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries probes.
     *  *
     * @param ListHoneypotProbeRequest $request ListHoneypotProbeRequest
     *
     * @return ListHoneypotProbeResponse ListHoneypotProbeResponse
     */
    public function listHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary 查询已安装的探针
     *  *
     * @param ListHoneypotProbeUuidRequest $request ListHoneypotProbeUuidRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotProbeUuidResponse ListHoneypotProbeUuidResponse
     */
    public function listHoneypotProbeUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->controlNodeId)) {
            $query['ControlNodeId'] = $request->controlNodeId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeType)) {
            $query['ProbeType'] = $request->probeType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotProbeUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotProbeUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询已安装的探针
     *  *
     * @param ListHoneypotProbeUuidRequest $request ListHoneypotProbeUuidRequest
     *
     * @return ListHoneypotProbeUuidResponse ListHoneypotProbeUuidResponse
     */
    public function listHoneypotProbeUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotProbeUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the types of risky image build commands.
     *  *
     * @param ListImageBuildRiskItemRequest $request ListImageBuildRiskItemRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListImageBuildRiskItemResponse ListImageBuildRiskItemResponse
     */
    public function listImageBuildRiskItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListImageBuildRiskItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListImageBuildRiskItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the types of risky image build commands.
     *  *
     * @param ListImageBuildRiskItemRequest $request ListImageBuildRiskItemRequest
     *
     * @return ListImageBuildRiskItemResponse ListImageBuildRiskItemResponse
     */
    public function listImageBuildRiskItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageBuildRiskItemWithOptions($request, $runtime);
    }

    /**
     * @summary The region ID of the image.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListImageRegistryRegionResponse ListImageRegistryRegionResponse
     */
    public function listImageRegistryRegionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListImageRegistryRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListImageRegistryRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The region ID of the image.
     *  *
     * @return ListImageRegistryRegionResponse ListImageRegistryRegionResponse
     */
    public function listImageRegistryRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageRegistryRegionWithOptions($runtime);
    }

    /**
     * @summary Queries security information about a container image.
     *  *
     * @param ListImageRiskRequest $request ListImageRiskRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListImageRiskResponse ListImageRiskResponse
     */
    public function listImageRiskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListImageRisk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListImageRiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries security information about a container image.
     *  *
     * @param ListImageRiskRequest $request ListImageRiskRequest
     *
     * @return ListImageRiskResponse ListImageRiskResponse
     */
    public function listImageRisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageRiskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the asset types and asset subtypes for configuration assessment.
     *  *
     * @param ListInstanceCatalogRequest $request ListInstanceCatalogRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceCatalogResponse ListInstanceCatalogResponse
     */
    public function listInstanceCatalogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->requirementIds)) {
            $query['RequirementIds'] = $request->requirementIds;
        }
        if (!Utils::isUnset($request->standardIds)) {
            $query['StandardIds'] = $request->standardIds;
        }
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceCatalog',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceCatalogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the asset types and asset subtypes for configuration assessment.
     *  *
     * @param ListInstanceCatalogRequest $request ListInstanceCatalogRequest
     *
     * @return ListInstanceCatalogResponse ListInstanceCatalogResponse
     */
    public function listInstanceCatalog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceCatalogWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the risk levels of instances.
     *  *
     * @param ListInstanceRiskLevelsRequest $request ListInstanceRiskLevelsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceRiskLevelsResponse ListInstanceRiskLevelsResponse
     */
    public function listInstanceRiskLevelsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceList)) {
            $query['InstanceList'] = $request->instanceList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceRiskLevels',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceRiskLevelsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk levels of instances.
     *  *
     * @param ListInstanceRiskLevelsRequest $request ListInstanceRiskLevelsRequest
     *
     * @return ListInstanceRiskLevelsResponse ListInstanceRiskLevelsResponse
     */
    public function listInstanceRiskLevels($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceRiskLevelsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics about risks in instances.
     *  *
     * @param ListInstanceRiskNumRequest $request ListInstanceRiskNumRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceRiskNumResponse ListInstanceRiskNumResponse
     */
    public function listInstanceRiskNumWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceList)) {
            $query['InstanceList'] = $request->instanceList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceRiskNum',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceRiskNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics about risks in instances.
     *  *
     * @param ListInstanceRiskNumRequest $request ListInstanceRiskNumRequest
     *
     * @return ListInstanceRiskNumResponse ListInstanceRiskNumResponse
     */
    public function listInstanceRiskNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceRiskNumWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alerts generated by defense rules.
     *  *
     * @param ListInterceptionHistoryRequest $request ListInterceptionHistoryRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInterceptionHistoryResponse ListInterceptionHistoryResponse
     */
    public function listInterceptionHistoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->historyName)) {
            $query['HistoryName'] = $request->historyName;
        }
        if (!Utils::isUnset($request->interceptionTypes)) {
            $query['InterceptionTypes'] = $request->interceptionTypes;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInterceptionHistory',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInterceptionHistoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alerts generated by defense rules.
     *  *
     * @param ListInterceptionHistoryRequest $request ListInterceptionHistoryRequest
     *
     * @return ListInterceptionHistoryResponse ListInterceptionHistoryResponse
     */
    public function listInterceptionHistory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInterceptionHistoryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries defense rules that are configured for the container firewall feature.
     *  *
     * @param ListInterceptionRulePageRequest $request ListInterceptionRulePageRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInterceptionRulePageResponse ListInterceptionRulePageResponse
     */
    public function listInterceptionRulePageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInterceptionRulePage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInterceptionRulePageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries defense rules that are configured for the container firewall feature.
     *  *
     * @param ListInterceptionRulePageRequest $request ListInterceptionRulePageRequest
     *
     * @return ListInterceptionRulePageResponse ListInterceptionRulePageResponse
     */
    public function listInterceptionRulePage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInterceptionRulePageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the network objects that are protected by the container firewall feature.
     *  *
     * @param ListInterceptionTargetPageRequest $request ListInterceptionTargetPageRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInterceptionTargetPageResponse ListInterceptionTargetPageResponse
     */
    public function listInterceptionTargetPageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageList)) {
            $query['ImageList'] = $request->imageList;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->tagList)) {
            $query['TagList'] = $request->tagList;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInterceptionTargetPage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInterceptionTargetPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the network objects that are protected by the container firewall feature.
     *  *
     * @param ListInterceptionTargetPageRequest $request ListInterceptionTargetPageRequest
     *
     * @return ListInterceptionTargetPageResponse ListInterceptionTargetPageResponse
     */
    public function listInterceptionTargetPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInterceptionTargetPageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about Kubernetes clusters that are added to Security Center.
     *  *
     * @description You can use this operation to query the access information about Kubernetes clusters.
     *  *
     * @param ListK8sAccessInfoRequest $request ListK8sAccessInfoRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListK8sAccessInfoResponse ListK8sAccessInfoResponse
     */
    public function listK8sAccessInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliyunYundunGatewayApiName)) {
            $query['AliyunYundunGatewayApiName'] = $request->aliyunYundunGatewayApiName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayPopName)) {
            $query['AliyunYundunGatewayPopName'] = $request->aliyunYundunGatewayPopName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayProjectName)) {
            $query['AliyunYundunGatewayProjectName'] = $request->aliyunYundunGatewayProjectName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListK8sAccessInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListK8sAccessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about Kubernetes clusters that are added to Security Center.
     *  *
     * @description You can use this operation to query the access information about Kubernetes clusters.
     *  *
     * @param ListK8sAccessInfoRequest $request ListK8sAccessInfoRequest
     *
     * @return ListK8sAccessInfoResponse ListK8sAccessInfoResponse
     */
    public function listK8sAccessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listK8sAccessInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the regions supported by the log delivery feature that uses the pay-as-you-go billing method.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLogShipperRegionsResponse ListLogShipperRegionsResponse
     */
    public function listLogShipperRegionsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListLogShipperRegions',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListLogShipperRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the regions supported by the log delivery feature that uses the pay-as-you-go billing method.
     *  *
     * @return ListLogShipperRegionsResponse ListLogShipperRegionsResponse
     */
    public function listLogShipperRegions()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLogShipperRegionsWithOptions($runtime);
    }

    /**
     * @summary Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param ListMaliciousFileWhitelistConfigsRequest $request ListMaliciousFileWhitelistConfigsRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMaliciousFileWhitelistConfigsResponse ListMaliciousFileWhitelistConfigsResponse
     */
    public function listMaliciousFileWhitelistConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListMaliciousFileWhitelistConfigs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMaliciousFileWhitelistConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param ListMaliciousFileWhitelistConfigsRequest $request ListMaliciousFileWhitelistConfigsRequest
     *
     * @return ListMaliciousFileWhitelistConfigsResponse ListMaliciousFileWhitelistConfigsResponse
     */
    public function listMaliciousFileWhitelistConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMaliciousFileWhitelistConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries alerts that are generated for malicious files.
     *  *
     * @param ListObjectScanEventRequest $request ListObjectScanEventRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListObjectScanEventResponse ListObjectScanEventResponse
     */
    public function listObjectScanEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->md5)) {
            $query['Md5'] = $request->md5;
        }
        if (!Utils::isUnset($request->ossKey)) {
            $query['OssKey'] = $request->ossKey;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentEventId)) {
            $query['ParentEventId'] = $request->parentEventId;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListObjectScanEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListObjectScanEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries alerts that are generated for malicious files.
     *  *
     * @param ListObjectScanEventRequest $request ListObjectScanEventRequest
     *
     * @return ListObjectScanEventResponse ListObjectScanEventResponse
     */
    public function listObjectScanEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listObjectScanEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries at-risk image blocking rules.
     *  *
     * @param ListOpaClusterStrategyNewRequest $request ListOpaClusterStrategyNewRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListOpaClusterStrategyNewResponse ListOpaClusterStrategyNewResponse
     */
    public function listOpaClusterStrategyNewWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->label)) {
            $query['Label'] = $request->label;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListOpaClusterStrategyNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListOpaClusterStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries at-risk image blocking rules.
     *  *
     * @param ListOpaClusterStrategyNewRequest $request ListOpaClusterStrategyNewRequest
     *
     * @return ListOpaClusterStrategyNewResponse ListOpaClusterStrategyNewResponse
     */
    public function listOpaClusterStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOpaClusterStrategyNewWithOptions($request, $runtime);
    }

    /**
     * @summary Queries Object Storage Service (OSS) buckets.
     *  *
     * @param ListOssBucketRequest $request ListOssBucketRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListOssBucketResponse ListOssBucketResponse
     */
    public function listOssBucketWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListOssBucket',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListOssBucketResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries Object Storage Service (OSS) buckets.
     *  *
     * @param ListOssBucketRequest $request ListOssBucketRequest
     *
     * @return ListOssBucketResponse ListOssBucketResponse
     */
    public function listOssBucket($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOssBucketWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the risk information of an Object Storage Service (OSS) bucket.
     *  *
     * @param ListOssBucketScanInfoRequest $request ListOssBucketScanInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListOssBucketScanInfoResponse ListOssBucketScanInfoResponse
     */
    public function listOssBucketScanInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fuzzBucketName)) {
            $query['FuzzBucketName'] = $request->fuzzBucketName;
        }
        if (!Utils::isUnset($request->hasRisk)) {
            $query['HasRisk'] = $request->hasRisk;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListOssBucketScanInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListOssBucketScanInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk information of an Object Storage Service (OSS) bucket.
     *  *
     * @param ListOssBucketScanInfoRequest $request ListOssBucketScanInfoRequest
     *
     * @return ListOssBucketScanInfoResponse ListOssBucketScanInfoResponse
     */
    public function listOssBucketScanInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOssBucketScanInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of an Object Storage Service (OSS) file detection policy.
     *  *
     * @param ListOssScanConfigRequest $request ListOssScanConfigRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListOssScanConfigResponse ListOssScanConfigResponse
     */
    public function listOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of an Object Storage Service (OSS) file detection policy.
     *  *
     * @param ListOssScanConfigRequest $request ListOssScanConfigRequest
     *
     * @return ListOssScanConfigResponse ListOssScanConfigResponse
     */
    public function listOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about plug-ins on a server.
     *  *
     * @param ListPluginForUuidRequest $tmpReq  ListPluginForUuidRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPluginForUuidResponse ListPluginForUuidResponse
     */
    public function listPluginForUuidWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListPluginForUuidShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->types)) {
            $request->typesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->types, 'Types', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->typesShrink)) {
            $query['Types'] = $request->typesShrink;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPluginForUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPluginForUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about plug-ins on a server.
     *  *
     * @param ListPluginForUuidRequest $request ListPluginForUuidRequest
     *
     * @return ListPluginForUuidResponse ListPluginForUuidResponse
     */
    public function listPluginForUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPluginForUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the security risks of a pod.
     *  *
     * @param ListPodRiskRequest $request ListPodRiskRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPodRiskResponse ListPodRiskResponse
     */
    public function listPodRiskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->podName)) {
            $query['PodName'] = $request->podName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPodRisk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPodRiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the security risks of a pod.
     *  *
     * @param ListPodRiskRequest $request ListPodRiskRequest
     *
     * @return ListPodRiskResponse ListPodRiskResponse
     */
    public function listPodRisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPodRiskWithOptions($request, $runtime);
    }

    /**
     * @summary 获取私有K8s列表
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPrivateK8sResponse ListPrivateK8sResponse
     */
    public function listPrivateK8sWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListPrivateK8s',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPrivateK8sResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取私有K8s列表
     *  *
     * @return ListPrivateK8sResponse ListPrivateK8sResponse
     */
    public function listPrivateK8s()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrivateK8sWithOptions($runtime);
    }

    /**
     * @summary Queries image repositories.
     *  *
     * @param ListPrivateRegistryListRequest $request ListPrivateRegistryListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPrivateRegistryListResponse ListPrivateRegistryListResponse
     */
    public function listPrivateRegistryListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->registryType)) {
            $query['RegistryType'] = $request->registryType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPrivateRegistryList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPrivateRegistryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries image repositories.
     *  *
     * @param ListPrivateRegistryListRequest $request ListPrivateRegistryListRequest
     *
     * @return ListPrivateRegistryListResponse ListPrivateRegistryListResponse
     */
    public function listPrivateRegistryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrivateRegistryListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of image repositories of each type.
     *  *
     * @param ListPrivateRegistryTypeRequest $request ListPrivateRegistryTypeRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPrivateRegistryTypeResponse ListPrivateRegistryTypeResponse
     */
    public function listPrivateRegistryTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPrivateRegistryType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPrivateRegistryTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of image repositories of each type.
     *  *
     * @param ListPrivateRegistryTypeRequest $request ListPrivateRegistryTypeRequest
     *
     * @return ListPrivateRegistryTypeResponse ListPrivateRegistryTypeResponse
     */
    public function listPrivateRegistryType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrivateRegistryTypeWithOptions($request, $runtime);
    }

    /**
     * @summary 查询发布批次
     *  *
     * @param ListPublishBatchRequest $request ListPublishBatchRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPublishBatchResponse ListPublishBatchResponse
     */
    public function listPublishBatchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->batchName)) {
            $query['BatchName'] = $request->batchName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->upgradeVersion)) {
            $query['UpgradeVersion'] = $request->upgradeVersion;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPublishBatch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPublishBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询发布批次
     *  *
     * @param ListPublishBatchRequest $request ListPublishBatchRequest
     *
     * @return ListPublishBatchResponse ListPublishBatchResponse
     */
    public function listPublishBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPublishBatchWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation information of one or more Runtime Application Self-protection-enabled (RASP-enabled) applications.
     *  *
     * @param ListQueryRaspAppInfoRequest $request ListQueryRaspAppInfoRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListQueryRaspAppInfoResponse ListQueryRaspAppInfoResponse
     */
    public function listQueryRaspAppInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListQueryRaspAppInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListQueryRaspAppInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation information of one or more Runtime Application Self-protection-enabled (RASP-enabled) applications.
     *  *
     * @param ListQueryRaspAppInfoRequest $request ListQueryRaspAppInfoRequest
     *
     * @return ListQueryRaspAppInfoResponse ListQueryRaspAppInfoResponse
     */
    public function listQueryRaspAppInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQueryRaspAppInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the automatic management policies of members that are added to Security Center for multi-account management. The members in the automatic control management directory are automatically added to the member list of Security Center.
     *  *
     * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListRdDefaultSyncListResponse ListRdDefaultSyncListResponse
     */
    public function listRdDefaultSyncListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListRdDefaultSyncList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListRdDefaultSyncListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the automatic management policies of members that are added to Security Center for multi-account management. The members in the automatic control management directory are automatically added to the member list of Security Center.
     *  *
     * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
     *  *
     * @return ListRdDefaultSyncListResponse ListRdDefaultSyncListResponse
     */
    public function listRdDefaultSyncList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRdDefaultSyncListWithOptions($runtime);
    }

    /**
     * @summary Queries the network objects based on which a specified cluster is protected.
     *  *
     * @param ListRuleTargetAllRequest $request ListRuleTargetAllRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListRuleTargetAllResponse ListRuleTargetAllResponse
     */
    public function listRuleTargetAllWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListRuleTargetAll',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListRuleTargetAllResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the network objects based on which a specified cluster is protected.
     *  *
     * @param ListRuleTargetAllRequest $request ListRuleTargetAllRequest
     *
     * @return ListRuleTargetAllResponse ListRuleTargetAllResponse
     */
    public function listRuleTargetAll($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRuleTargetAllWithOptions($request, $runtime);
    }

    /**
     * @summary Queries rules for container tamper-proofing.
     *  *
     * @param ListSasContainerWebDefenseRuleRequest $request ListSasContainerWebDefenseRuleRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSasContainerWebDefenseRuleResponse ListSasContainerWebDefenseRuleResponse
     */
    public function listSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListSasContainerWebDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries rules for container tamper-proofing.
     *  *
     * @param ListSasContainerWebDefenseRuleRequest $request ListSasContainerWebDefenseRuleRequest
     *
     * @return ListSasContainerWebDefenseRuleResponse ListSasContainerWebDefenseRuleResponse
     */
    public function listSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries supported file suffixes.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSupportObjectSuffixResponse ListSupportObjectSuffixResponse
     */
    public function listSupportObjectSuffixWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListSupportObjectSuffix',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSupportObjectSuffixResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries supported file suffixes.
     *  *
     * @return ListSupportObjectSuffixResponse ListSupportObjectSuffixResponse
     */
    public function listSupportObjectSuffix()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSupportObjectSuffixWithOptions($runtime);
    }

    /**
     * @summary Queries the details about the aggregation types of system defense rules.
     *  *
     * @param ListSystemAggregationRulesRequest $request ListSystemAggregationRulesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSystemAggregationRulesResponse ListSystemAggregationRulesResponse
     */
    public function listSystemAggregationRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListSystemAggregationRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSystemAggregationRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about the aggregation types of system defense rules.
     *  *
     * @param ListSystemAggregationRulesRequest $request ListSystemAggregationRulesRequest
     *
     * @return ListSystemAggregationRulesResponse ListSystemAggregationRulesResponse
     */
    public function listSystemAggregationRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemAggregationRulesWithOptions($request, $runtime);
    }

    /**
     * @summary 查询对用户生效的系统规则类型
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSystemClientRuleTypesResponse ListSystemClientRuleTypesResponse
     */
    public function listSystemClientRuleTypesWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListSystemClientRuleTypes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSystemClientRuleTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询对用户生效的系统规则类型
     *  *
     * @return ListSystemClientRuleTypesResponse ListSystemClientRuleTypesResponse
     */
    public function listSystemClientRuleTypes()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemClientRuleTypesWithOptions($runtime);
    }

    /**
     * @summary Queries system defense rules.
     *  *
     * @param ListSystemClientRulesRequest $request ListSystemClientRulesRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSystemClientRulesResponse ListSystemClientRulesResponse
     */
    public function listSystemClientRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aggregationIds)) {
            $query['AggregationIds'] = $request->aggregationIds;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->isContainer)) {
            $query['IsContainer'] = $request->isContainer;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleTypes)) {
            $query['RuleTypes'] = $request->ruleTypes;
        }
        if (!Utils::isUnset($request->systemType)) {
            $query['SystemType'] = $request->systemType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListSystemClientRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSystemClientRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries system defense rules.
     *  *
     * @param ListSystemClientRulesRequest $request ListSystemClientRulesRequest
     *
     * @return ListSystemClientRulesResponse ListSystemClientRulesResponse
     */
    public function listSystemClientRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemClientRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the aggregation types of system defense rules.
     *  *
     * @param ListSystemRuleAggregationTypesRequest $request ListSystemRuleAggregationTypesRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSystemRuleAggregationTypesResponse ListSystemRuleAggregationTypesResponse
     */
    public function listSystemRuleAggregationTypesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListSystemRuleAggregationTypes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSystemRuleAggregationTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the aggregation types of system defense rules.
     *  *
     * @param ListSystemRuleAggregationTypesRequest $request ListSystemRuleAggregationTypesRequest
     *
     * @return ListSystemRuleAggregationTypesResponse ListSystemRuleAggregationTypesResponse
     */
    public function listSystemRuleAggregationTypes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemRuleAggregationTypesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries tasks that are not complete by task type.
     *  *
     * @param ListUnfinishedOnceTaskRequest $request ListUnfinishedOnceTaskRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListUnfinishedOnceTaskResponse ListUnfinishedOnceTaskResponse
     */
    public function listUnfinishedOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListUnfinishedOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListUnfinishedOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries tasks that are not complete by task type.
     *  *
     * @param ListUnfinishedOnceTaskRequest $request ListUnfinishedOnceTaskRequest
     *
     * @return ListUnfinishedOnceTaskResponse ListUnfinishedOnceTaskResponse
     */
    public function listUnfinishedOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUnfinishedOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers whose Security Center agent is not installed.
     *  *
     * @param ListUninstallAegisMachinesRequest $request ListUninstallAegisMachinesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListUninstallAegisMachinesResponse ListUninstallAegisMachinesResponse
     */
    public function listUninstallAegisMachinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->os)) {
            $query['Os'] = $request->os;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionIdStr)) {
            $query['RegionIdStr'] = $request->regionIdStr;
        }
        if (!Utils::isUnset($request->regionNo)) {
            $query['RegionNo'] = $request->regionNo;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListUninstallAegisMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListUninstallAegisMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers whose Security Center agent is not installed.
     *  *
     * @param ListUninstallAegisMachinesRequest $request ListUninstallAegisMachinesRequest
     *
     * @return ListUninstallAegisMachinesResponse ListUninstallAegisMachinesResponse
     */
    public function listUninstallAegisMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUninstallAegisMachinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries protected assets by using the paths to specific web directories.
     *  *
     * @param ListUuidsByWebPathRequest $request ListUuidsByWebPathRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListUuidsByWebPathResponse ListUuidsByWebPathResponse
     */
    public function listUuidsByWebPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->webPath)) {
            $query['WebPath'] = $request->webPath;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListUuidsByWebPath',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListUuidsByWebPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries protected assets by using the paths to specific web directories.
     *  *
     * @param ListUuidsByWebPathRequest $request ListUuidsByWebPathRequest
     *
     * @return ListUuidsByWebPathResponse ListUuidsByWebPathResponse
     */
    public function listUuidsByWebPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUuidsByWebPathWithOptions($request, $runtime);
    }

    /**
     * @summary Queries servers on which virus detection and removal tasks are performed.
     *  *
     * @param ListVirusScanMachineRequest $request ListVirusScanMachineRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVirusScanMachineResponse ListVirusScanMachineResponse
     */
    public function listVirusScanMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVirusScanMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVirusScanMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries servers on which virus detection and removal tasks are performed.
     *  *
     * @param ListVirusScanMachineRequest $request ListVirusScanMachineRequest
     *
     * @return ListVirusScanMachineResponse ListVirusScanMachineResponse
     */
    public function listVirusScanMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirusScanMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alert events that are generated for viruses detected on a server.
     *  *
     * @param ListVirusScanMachineEventRequest $request ListVirusScanMachineEventRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVirusScanMachineEventResponse ListVirusScanMachineEventResponse
     */
    public function listVirusScanMachineEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->operateTaskId)) {
            $query['OperateTaskId'] = $request->operateTaskId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVirusScanMachineEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVirusScanMachineEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert events that are generated for viruses detected on a server.
     *  *
     * @param ListVirusScanMachineEventRequest $request ListVirusScanMachineEventRequest
     *
     * @return ListVirusScanMachineEventResponse ListVirusScanMachineEventResponse
     */
    public function listVirusScanMachineEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirusScanMachineEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries virus scan tasks based on conditions such as the task type, task status, and server information.
     *  *
     * @param ListVirusScanTaskRequest $request ListVirusScanTaskRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVirusScanTaskResponse ListVirusScanTaskResponse
     */
    public function listVirusScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->internetIp)) {
            $query['InternetIp'] = $request->internetIp;
        }
        if (!Utils::isUnset($request->intranetIp)) {
            $query['IntranetIp'] = $request->intranetIp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->machineName)) {
            $query['MachineName'] = $request->machineName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->rootTask)) {
            $query['RootTask'] = $request->rootTask;
        }
        if (!Utils::isUnset($request->rootTaskId)) {
            $query['RootTaskId'] = $request->rootTaskId;
        }
        if (!Utils::isUnset($request->scanType)) {
            $query['ScanType'] = $request->scanType;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVirusScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVirusScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries virus scan tasks based on conditions such as the task type, task status, and server information.
     *  *
     * @param ListVirusScanTaskRequest $request ListVirusScanTaskRequest
     *
     * @return ListVirusScanTaskResponse ListVirusScanTaskResponse
     */
    public function listVirusScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirusScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the existing configurations of vulnerabilities that can be automatically fixed.
     *  *
     * @param ListVulAutoRepairConfigRequest $request ListVulAutoRepairConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVulAutoRepairConfigResponse ListVulAutoRepairConfigResponse
     */
    public function listVulAutoRepairConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVulAutoRepairConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVulAutoRepairConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the existing configurations of vulnerabilities that can be automatically fixed.
     *  *
     * @param ListVulAutoRepairConfigRequest $request ListVulAutoRepairConfigRequest
     *
     * @return ListVulAutoRepairConfigResponse ListVulAutoRepairConfigResponse
     */
    public function listVulAutoRepairConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVulAutoRepairConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the global configurations of vulnerability detection.
     *  *
     * @param ListVulGlobalConfigRequest $request ListVulGlobalConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVulGlobalConfigResponse ListVulGlobalConfigResponse
     */
    public function listVulGlobalConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configKey)) {
            $query['ConfigKey'] = $request->configKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVulGlobalConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVulGlobalConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the global configurations of vulnerability detection.
     *  *
     * @param ListVulGlobalConfigRequest $request ListVulGlobalConfigRequest
     *
     * @return ListVulGlobalConfigResponse ListVulGlobalConfigResponse
     */
    public function listVulGlobalConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVulGlobalConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
     *  *
     * @param MarkMonitorAccountsRequest $request MarkMonitorAccountsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return MarkMonitorAccountsResponse MarkMonitorAccountsResponse
     */
    public function markMonitorAccountsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accountIds)) {
            $query['AccountIds'] = $request->accountIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'MarkMonitorAccounts',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return MarkMonitorAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
     *  *
     * @param MarkMonitorAccountsRequest $request MarkMonitorAccountsRequest
     *
     * @return MarkMonitorAccountsResponse MarkMonitorAccountsResponse
     */
    public function markMonitorAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->markMonitorAccountsWithOptions($request, $runtime);
    }

    /**
     * @summary Handles AccessKey pair leaks.
     *  *
     * @param ModifyAccessKeyLeakDealRequest $request ModifyAccessKeyLeakDealRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAccessKeyLeakDealResponse ModifyAccessKeyLeakDealResponse
     */
    public function modifyAccessKeyLeakDealWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->idList)) {
            $query['IdList'] = $request->idList;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAccessKeyLeakDeal',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAccessKeyLeakDealResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles AccessKey pair leaks.
     *  *
     * @param ModifyAccessKeyLeakDealRequest $request ModifyAccessKeyLeakDealRequest
     *
     * @return ModifyAccessKeyLeakDealResponse ModifyAccessKeyLeakDealResponse
     */
    public function modifyAccessKeyLeakDeal($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAccessKeyLeakDealWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a defense rule against brute-force attacks.
     *  *
     * @param ModifyAntiBruteForceRuleRequest $request ModifyAntiBruteForceRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAntiBruteForceRuleResponse ModifyAntiBruteForceRuleResponse
     */
    public function modifyAntiBruteForceRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defaultRule)) {
            $query['DefaultRule'] = $request->defaultRule;
        }
        if (!Utils::isUnset($request->failCount)) {
            $query['FailCount'] = $request->failCount;
        }
        if (!Utils::isUnset($request->forbiddenTime)) {
            $query['ForbiddenTime'] = $request->forbiddenTime;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->span)) {
            $query['Span'] = $request->span;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAntiBruteForceRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a defense rule against brute-force attacks.
     *  *
     * @param ModifyAntiBruteForceRuleRequest $request ModifyAntiBruteForceRuleRequest
     *
     * @return ModifyAntiBruteForceRuleResponse ModifyAntiBruteForceRuleResponse
     */
    public function modifyAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Configures a scan cycle for application vulnerabilities.
     *  *
     * @param ModifyAppVulScanCycleRequest $request ModifyAppVulScanCycleRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAppVulScanCycleResponse ModifyAppVulScanCycleResponse
     */
    public function modifyAppVulScanCycleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cycle)) {
            $query['Cycle'] = $request->cycle;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAppVulScanCycle',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAppVulScanCycleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures a scan cycle for application vulnerabilities.
     *  *
     * @param ModifyAppVulScanCycleRequest $request ModifyAppVulScanCycleRequest
     *
     * @return ModifyAppVulScanCycleResponse ModifyAppVulScanCycleResponse
     */
    public function modifyAppVulScanCycle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAppVulScanCycleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
     *  *
     * @param ModifyAssetCleanConfigRequest $request ModifyAssetCleanConfigRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAssetCleanConfigResponse ModifyAssetCleanConfigResponse
     */
    public function modifyAssetCleanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetCleanConfigs)) {
            $query['AssetCleanConfigs'] = $request->assetCleanConfigs;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAssetCleanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAssetCleanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
     *  *
     * @param ModifyAssetCleanConfigRequest $request ModifyAssetCleanConfigRequest
     *
     * @return ModifyAssetCleanConfigResponse ModifyAssetCleanConfigResponse
     */
    public function modifyAssetCleanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAssetCleanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the server group to which specified servers belong.
     *  *
     * @description You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
     * ### Limits
     * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param ModifyAssetGroupRequest $request ModifyAssetGroupRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAssetGroupResponse ModifyAssetGroupResponse
     */
    public function modifyAssetGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAssetGroup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAssetGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the server group to which specified servers belong.
     *  *
     * @description You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
     * ### Limits
     * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param ModifyAssetGroupRequest $request ModifyAssetGroupRequest
     *
     * @return ModifyAssetGroupResponse ModifyAssetGroupResponse
     */
    public function modifyAssetGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAssetGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the importance of an asset.
     *  *
     * @param ModifyAssetImportantRequest $request ModifyAssetImportantRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAssetImportantResponse ModifyAssetImportantResponse
     */
    public function modifyAssetImportantWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->importantCode)) {
            $query['ImportantCode'] = $request->importantCode;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAssetImportant',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAssetImportantResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the importance of an asset.
     *  *
     * @param ModifyAssetImportantRequest $request ModifyAssetImportantRequest
     *
     * @return ModifyAssetImportantResponse ModifyAssetImportantResponse
     */
    public function modifyAssetImportant($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAssetImportantWithOptions($request, $runtime);
    }

    /**
     * @summary 修改证明者
     *  *
     * @param ModifyAttestorRequest $request ModifyAttestorRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAttestorResponse ModifyAttestorResponse
     */
    public function modifyAttestorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->keyId)) {
            $query['KeyId'] = $request->keyId;
        }
        if (!Utils::isUnset($request->keyRegionId)) {
            $query['KeyRegionId'] = $request->keyRegionId;
        }
        if (!Utils::isUnset($request->keyVersionId)) {
            $query['KeyVersionId'] = $request->keyVersionId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAttestor',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAttestorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 修改证明者
     *  *
     * @param ModifyAttestorRequest $request ModifyAttestorRequest
     *
     * @return ModifyAttestorResponse ModifyAttestorResponse
     */
    public function modifyAttestor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAttestorWithOptions($request, $runtime);
    }

    /**
     * @summary Specifies the number of days after which a detected vulnerability is automatically deleted.
     *  *
     * @param ModifyAutoDelConfigRequest $request ModifyAutoDelConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAutoDelConfigResponse ModifyAutoDelConfigResponse
     */
    public function modifyAutoDelConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->days)) {
            $query['Days'] = $request->days;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAutoDelConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAutoDelConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Specifies the number of days after which a detected vulnerability is automatically deleted.
     *  *
     * @param ModifyAutoDelConfigRequest $request ModifyAutoDelConfigRequest
     *
     * @return ModifyAutoDelConfigResponse ModifyAutoDelConfigResponse
     */
    public function modifyAutoDelConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAutoDelConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an anti-ransomware policy.
     *  *
     * @param ModifyBackupPolicyRequest $tmpReq  ModifyBackupPolicyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyBackupPolicyResponse ModifyBackupPolicyResponse
     */
    public function modifyBackupPolicyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyBackupPolicyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->policy)) {
            $request->policyShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->policy, 'Policy', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->policyShrink)) {
            $query['Policy'] = $request->policyShrink;
        }
        if (!Utils::isUnset($request->policyRegionId)) {
            $query['PolicyRegionId'] = $request->policyRegionId;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an anti-ransomware policy.
     *  *
     * @param ModifyBackupPolicyRequest $request ModifyBackupPolicyRequest
     *
     * @return ModifyBackupPolicyResponse ModifyBackupPolicyResponse
     */
    public function modifyBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables an anti-ransomware policy.
     *  *
     * @param ModifyBackupPolicyStatusRequest $request ModifyBackupPolicyStatusRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyBackupPolicyStatusResponse ModifyBackupPolicyStatusResponse
     */
    public function modifyBackupPolicyStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyBackupPolicyStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyBackupPolicyStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables an anti-ransomware policy.
     *  *
     * @param ModifyBackupPolicyStatusRequest $request ModifyBackupPolicyStatusRequest
     *
     * @return ModifyBackupPolicyStatusResponse ModifyBackupPolicyStatusResponse
     */
    public function modifyBackupPolicyStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBackupPolicyStatusWithOptions($request, $runtime);
    }

    /**
     * @summary 修改日志容量
     *  *
     * @param ModifyClearLogstoreStorageRequest $request ModifyClearLogstoreStorageRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClearLogstoreStorageResponse ModifyClearLogstoreStorageResponse
     */
    public function modifyClearLogstoreStorageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->userLogStore)) {
            $query['UserLogStore'] = $request->userLogStore;
        }
        if (!Utils::isUnset($request->userProject)) {
            $query['UserProject'] = $request->userProject;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClearLogstoreStorage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClearLogstoreStorageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 修改日志容量
     *  *
     * @param ModifyClearLogstoreStorageRequest $request ModifyClearLogstoreStorageRequest
     *
     * @return ModifyClearLogstoreStorageResponse ModifyClearLogstoreStorageResponse
     */
    public function modifyClearLogstoreStorage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClearLogstoreStorageWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the resource configurations of the Security Center agent.
     *  *
     * @param ModifyClientConfSetupRequest $request ModifyClientConfSetupRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClientConfSetupResponse ModifyClientConfSetupResponse
     */
    public function modifyClientConfSetupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyConfig)) {
            $query['StrategyConfig'] = $request->strategyConfig;
        }
        if (!Utils::isUnset($request->strategyTag)) {
            $query['StrategyTag'] = $request->strategyTag;
        }
        if (!Utils::isUnset($request->strategyTagValue)) {
            $query['StrategyTagValue'] = $request->strategyTagValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClientConfSetup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClientConfSetupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the resource configurations of the Security Center agent.
     *  *
     * @param ModifyClientConfSetupRequest $request ModifyClientConfSetupRequest
     *
     * @return ModifyClientConfSetupResponse ModifyClientConfSetupResponse
     */
    public function modifyClientConfSetup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClientConfSetupWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an agent configuration policy.
     *  *
     * @param ModifyClientConfStrategyRequest $request ModifyClientConfStrategyRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClientConfStrategyResponse ModifyClientConfStrategyResponse
     */
    public function modifyClientConfStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->tagExt)) {
            $query['TagExt'] = $request->tagExt;
        }
        if (!Utils::isUnset($request->tagValue)) {
            $query['TagValue'] = $request->tagValue;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClientConfStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClientConfStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an agent configuration policy.
     *  *
     * @param ModifyClientConfStrategyRequest $request ModifyClientConfStrategyRequest
     *
     * @return ModifyClientConfStrategyResponse ModifyClientConfStrategyResponse
     */
    public function modifyClientConfStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClientConfStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a custom defense rule.
     *  *
     * @param ModifyClientUserDefineRuleRequest $request ModifyClientUserDefineRuleRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClientUserDefineRuleResponse ModifyClientUserDefineRuleResponse
     */
    public function modifyClientUserDefineRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->actionType)) {
            $query['ActionType'] = $request->actionType;
        }
        if (!Utils::isUnset($request->cmdline)) {
            $query['Cmdline'] = $request->cmdline;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->filePath)) {
            $query['FilePath'] = $request->filePath;
        }
        if (!Utils::isUnset($request->IP)) {
            $query['IP'] = $request->IP;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->md5List)) {
            $query['Md5List'] = $request->md5List;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->newFilePath)) {
            $query['NewFilePath'] = $request->newFilePath;
        }
        if (!Utils::isUnset($request->parentCmdline)) {
            $query['ParentCmdline'] = $request->parentCmdline;
        }
        if (!Utils::isUnset($request->parentProcPath)) {
            $query['ParentProcPath'] = $request->parentProcPath;
        }
        if (!Utils::isUnset($request->platform)) {
            $query['Platform'] = $request->platform;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->portStr)) {
            $query['PortStr'] = $request->portStr;
        }
        if (!Utils::isUnset($request->procPath)) {
            $query['ProcPath'] = $request->procPath;
        }
        if (!Utils::isUnset($request->registryContent)) {
            $query['RegistryContent'] = $request->registryContent;
        }
        if (!Utils::isUnset($request->registryKey)) {
            $query['RegistryKey'] = $request->registryKey;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClientUserDefineRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a custom defense rule.
     *  *
     * @param ModifyClientUserDefineRuleRequest $request ModifyClientUserDefineRuleRequest
     *
     * @return ModifyClientUserDefineRuleResponse ModifyClientUserDefineRuleResponse
     */
    public function modifyClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * @summary 多云资产配置修改ak信息
     *  *
     * @param ModifyCloudVendorAccountAKRequest $request ModifyCloudVendorAccountAKRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCloudVendorAccountAKResponse ModifyCloudVendorAccountAKResponse
     */
    public function modifyCloudVendorAccountAKWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->authIds)) {
            $query['AuthIds'] = $request->authIds;
        }
        if (!Utils::isUnset($request->authModules)) {
            $query['AuthModules'] = $request->authModules;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->regions)) {
            $query['Regions'] = $request->regions;
        }
        if (!Utils::isUnset($request->secretId)) {
            $query['SecretId'] = $request->secretId;
        }
        if (!Utils::isUnset($request->secretKey)) {
            $query['SecretKey'] = $request->secretKey;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->subscriptionIds)) {
            $query['SubscriptionIds'] = $request->subscriptionIds;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $query['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCloudVendorAccountAK',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCloudVendorAccountAKResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 多云资产配置修改ak信息
     *  *
     * @param ModifyCloudVendorAccountAKRequest $request ModifyCloudVendorAccountAKRequest
     *
     * @return ModifyCloudVendorAccountAKResponse ModifyCloudVendorAccountAKResponse
     */
    public function modifyCloudVendorAccountAK($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCloudVendorAccountAKWithOptions($request, $runtime);
    }

    /**
     * @summary Fixes the blocking status of clusters whose status is Normal to be confirmed.
     *  *
     * @param ModifyClusterCnnfStatusUserConfirmRequest $request ModifyClusterCnnfStatusUserConfirmRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClusterCnnfStatusUserConfirmResponse ModifyClusterCnnfStatusUserConfirmResponse
     */
    public function modifyClusterCnnfStatusUserConfirmWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        if (!Utils::isUnset($request->userConfirm)) {
            $query['UserConfirm'] = $request->userConfirm;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClusterCnnfStatusUserConfirm',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClusterCnnfStatusUserConfirmResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Fixes the blocking status of clusters whose status is Normal to be confirmed.
     *  *
     * @param ModifyClusterCnnfStatusUserConfirmRequest $request ModifyClusterCnnfStatusUserConfirmRequest
     *
     * @return ModifyClusterCnnfStatusUserConfirmResponse ModifyClusterCnnfStatusUserConfirmResponse
     */
    public function modifyClusterCnnfStatusUserConfirm($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClusterCnnfStatusUserConfirmWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the priority to fix vulnerabilities.
     *  *
     * @param ModifyConcernNecessityRequest $request ModifyConcernNecessityRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyConcernNecessityResponse ModifyConcernNecessityResponse
     */
    public function modifyConcernNecessityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->concernNecessity)) {
            $query['ConcernNecessity'] = $request->concernNecessity;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyConcernNecessity',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyConcernNecessityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the priority to fix vulnerabilities.
     *  *
     * @param ModifyConcernNecessityRequest $request ModifyConcernNecessityRequest
     *
     * @return ModifyConcernNecessityResponse ModifyConcernNecessityResponse
     */
    public function modifyConcernNecessity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyConcernNecessityWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a rule for non-image program defense.
     *  *
     * @param ModifyContainerDefenseRuleRequest $tmpReq  ModifyContainerDefenseRuleRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyContainerDefenseRuleResponse ModifyContainerDefenseRuleResponse
     */
    public function modifyContainerDefenseRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyContainerDefenseRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->whitelist)) {
            $request->whitelistShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->whitelist, 'Whitelist', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->scope)) {
            $query['Scope'] = $request->scope;
        }
        if (!Utils::isUnset($request->whitelistShrink)) {
            $query['Whitelist'] = $request->whitelistShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyContainerDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a rule for non-image program defense.
     *  *
     * @param ModifyContainerDefenseRuleRequest $request ModifyContainerDefenseRuleRequest
     *
     * @return ModifyContainerDefenseRuleResponse ModifyContainerDefenseRuleResponse
     */
    public function modifyContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the status of non-image program defense rules.
     *  *
     * @param ModifyContainerDefenseRuleSwitchRequest $request ModifyContainerDefenseRuleSwitchRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyContainerDefenseRuleSwitchResponse ModifyContainerDefenseRuleSwitchResponse
     */
    public function modifyContainerDefenseRuleSwitchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleIds)) {
            $query['RuleIds'] = $request->ruleIds;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyContainerDefenseRuleSwitch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyContainerDefenseRuleSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the status of non-image program defense rules.
     *  *
     * @param ModifyContainerDefenseRuleSwitchRequest $request ModifyContainerDefenseRuleSwitchRequest
     *
     * @return ModifyContainerDefenseRuleSwitchResponse ModifyContainerDefenseRuleSwitchResponse
     */
    public function modifyContainerDefenseRuleSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerDefenseRuleSwitchWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the defense rule against container escapes.
     *  *
     * @param ModifyContainerPluginRuleRequest $request ModifyContainerPluginRuleRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyContainerPluginRuleResponse ModifyContainerPluginRuleResponse
     */
    public function modifyContainerPluginRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->selectedPolicy)) {
            $query['SelectedPolicy'] = $request->selectedPolicy;
        }
        if (!Utils::isUnset($request->whiteImages)) {
            $query['WhiteImages'] = $request->whiteImages;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyContainerPluginRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the defense rule against container escapes.
     *  *
     * @param ModifyContainerPluginRuleRequest $request ModifyContainerPluginRuleRequest
     *
     * @return ModifyContainerPluginRuleResponse ModifyContainerPluginRuleResponse
     */
    public function modifyContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of vulnerability scan for a running container.
     *  *
     * @param ModifyContainerScanConfigRequest $request ModifyContainerScanConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyContainerScanConfigResponse ModifyContainerScanConfigResponse
     */
    public function modifyContainerScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appNames)) {
            $query['AppNames'] = $request->appNames;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyContainerScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyContainerScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of vulnerability scan for a running container.
     *  *
     * @param ModifyContainerScanConfigRequest $request ModifyContainerScanConfigRequest
     *
     * @return ModifyContainerScanConfigResponse ModifyContainerScanConfigResponse
     */
    public function modifyContainerScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
     *  *
     * @param ModifyCreateVulWhitelistRequest $request ModifyCreateVulWhitelistRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCreateVulWhitelistResponse ModifyCreateVulWhitelistResponse
     */
    public function modifyCreateVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->targetInfo)) {
            $query['TargetInfo'] = $request->targetInfo;
        }
        if (!Utils::isUnset($request->whitelist)) {
            $query['Whitelist'] = $request->whitelist;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCreateVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCreateVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
     *  *
     * @param ModifyCreateVulWhitelistRequest $request ModifyCreateVulWhitelistRequest
     *
     * @return ModifyCreateVulWhitelistResponse ModifyCreateVulWhitelistResponse
     */
    public function modifyCreateVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCreateVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a custom IP address blocking policy.
     *  *
     * @param ModifyCustomBlockRecordRequest $request ModifyCustomBlockRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCustomBlockRecordResponse ModifyCustomBlockRecordResponse
     */
    public function modifyCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->expireTime)) {
            $query['ExpireTime'] = $request->expireTime;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a custom IP address blocking policy.
     *  *
     * @param ModifyCustomBlockRecordRequest $request ModifyCustomBlockRecordRequest
     *
     * @return ModifyCustomBlockRecordResponse ModifyCustomBlockRecordResponse
     */
    public function modifyCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
     *  *
     * @param ModifyCycleTaskRequest $request ModifyCycleTaskRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCycleTaskResponse ModifyCycleTaskResponse
     */
    public function modifyCycleTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        if (!Utils::isUnset($request->enable)) {
            $query['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->firstDateStr)) {
            $query['FirstDateStr'] = $request->firstDateStr;
        }
        if (!Utils::isUnset($request->intervalPeriod)) {
            $query['IntervalPeriod'] = $request->intervalPeriod;
        }
        if (!Utils::isUnset($request->param)) {
            $query['Param'] = $request->param;
        }
        if (!Utils::isUnset($request->periodUnit)) {
            $query['PeriodUnit'] = $request->periodUnit;
        }
        if (!Utils::isUnset($request->targetEndTime)) {
            $query['TargetEndTime'] = $request->targetEndTime;
        }
        if (!Utils::isUnset($request->targetStartTime)) {
            $query['TargetStartTime'] = $request->targetStartTime;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCycleTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCycleTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
     *  *
     * @param ModifyCycleTaskRequest $request ModifyCycleTaskRequest
     *
     * @return ModifyCycleTaskResponse ModifyCycleTaskResponse
     */
    public function modifyCycleTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCycleTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the notification status of a DingTalk chatbot.
     *  *
     * @description You can call this operation only if you use Security Center Enterprise.
     *  *
     * @param ModifyDingTalkStatusRequest $request ModifyDingTalkStatusRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyDingTalkStatusResponse ModifyDingTalkStatusResponse
     */
    public function modifyDingTalkStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyDingTalkStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyDingTalkStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the notification status of a DingTalk chatbot.
     *  *
     * @description You can call this operation only if you use Security Center Enterprise.
     *  *
     * @param ModifyDingTalkStatusRequest $request ModifyDingTalkStatusRequest
     *
     * @return ModifyDingTalkStatusResponse ModifyDingTalkStatusResponse
     */
    public function modifyDingTalkStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDingTalkStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Runs a scan task for urgent vulnerabilities.
     *  *
     * @param ModifyEmgVulSubmitRequest $request ModifyEmgVulSubmitRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyEmgVulSubmitResponse ModifyEmgVulSubmitResponse
     */
    public function modifyEmgVulSubmitWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->userAgreement)) {
            $query['UserAgreement'] = $request->userAgreement;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyEmgVulSubmit',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyEmgVulSubmitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Runs a scan task for urgent vulnerabilities.
     *  *
     * @param ModifyEmgVulSubmitRequest $request ModifyEmgVulSubmitRequest
     *
     * @return ModifyEmgVulSubmitResponse ModifyEmgVulSubmitResponse
     */
    public function modifyEmgVulSubmit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyEmgVulSubmitWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the name of a server group.
     *  *
     * @param ModifyGroupPropertyRequest $request ModifyGroupPropertyRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyGroupPropertyResponse ModifyGroupPropertyResponse
     */
    public function modifyGroupPropertyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->data)) {
            $query['Data'] = $request->data;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyGroupProperty',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyGroupPropertyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the name of a server group.
     *  *
     * @param ModifyGroupPropertyRequest $request ModifyGroupPropertyRequest
     *
     * @return ModifyGroupPropertyResponse ModifyGroupPropertyResponse
     */
    public function modifyGroupProperty($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyGroupPropertyWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of an IDC probe.
     *  *
     * @param ModifyIdcProbeRequest $request ModifyIdcProbeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyIdcProbeResponse ModifyIdcProbeResponse
     */
    public function modifyIdcProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->idcName)) {
            $query['IdcName'] = $request->idcName;
        }
        if (!Utils::isUnset($request->idcRegion)) {
            $query['IdcRegion'] = $request->idcRegion;
        }
        if (!Utils::isUnset($request->intervalPeriod)) {
            $query['IntervalPeriod'] = $request->intervalPeriod;
        }
        if (!Utils::isUnset($request->ipSegments)) {
            $query['IpSegments'] = $request->ipSegments;
        }
        if (!Utils::isUnset($request->linuxPort)) {
            $query['LinuxPort'] = $request->linuxPort;
        }
        if (!Utils::isUnset($request->periodUnit)) {
            $query['PeriodUnit'] = $request->periodUnit;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->winPort)) {
            $query['WinPort'] = $request->winPort;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyIdcProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyIdcProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of an IDC probe.
     *  *
     * @param ModifyIdcProbeRequest $request ModifyIdcProbeRequest
     *
     * @return ModifyIdcProbeResponse ModifyIdcProbeResponse
     */
    public function modifyIdcProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyIdcProbeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of a scheduled image fix.
     *  *
     * @param ModifyImageFixCycleConfigRequest $request ModifyImageFixCycleConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyImageFixCycleConfigResponse ModifyImageFixCycleConfigResponse
     */
    public function modifyImageFixCycleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->imageFixCycle)) {
            $body['ImageFixCycle'] = $request->imageFixCycle;
        }
        if (!Utils::isUnset($request->imageFixSwitch)) {
            $body['ImageFixSwitch'] = $request->imageFixSwitch;
        }
        if (!Utils::isUnset($request->imageFixTarget)) {
            $body['ImageFixTarget'] = $request->imageFixTarget;
        }
        if (!Utils::isUnset($request->imageTimeRange)) {
            $body['ImageTimeRange'] = $request->imageTimeRange;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ModifyImageFixCycleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyImageFixCycleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of a scheduled image fix.
     *  *
     * @param ModifyImageFixCycleConfigRequest $request ModifyImageFixCycleConfigRequest
     *
     * @return ModifyImageFixCycleConfigResponse ModifyImageFixCycleConfigResponse
     */
    public function modifyImageFixCycleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyImageFixCycleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the transfer time of an image repository.
     *  *
     * @param ModifyImageRegistryRequest $request ModifyImageRegistryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyImageRegistryResponse ModifyImageRegistryResponse
     */
    public function modifyImageRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->id)) {
            $body['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->password)) {
            $body['Password'] = $request->password;
        }
        if (!Utils::isUnset($request->transPerHour)) {
            $body['TransPerHour'] = $request->transPerHour;
        }
        if (!Utils::isUnset($request->userName)) {
            $body['UserName'] = $request->userName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ModifyImageRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyImageRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the transfer time of an image repository.
     *  *
     * @param ModifyImageRegistryRequest $request ModifyImageRegistryRequest
     *
     * @return ModifyImageRegistryResponse ModifyImageRegistryResponse
     */
    public function modifyImageRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyImageRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the defense rule against brute-force attacks that is applied to a specified server.
     *  *
     * @param ModifyInstanceAntiBruteForceRuleRequest $request ModifyInstanceAntiBruteForceRuleRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyInstanceAntiBruteForceRuleResponse ModifyInstanceAntiBruteForceRuleResponse
     */
    public function modifyInstanceAntiBruteForceRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->newRuleId)) {
            $query['NewRuleId'] = $request->newRuleId;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyInstanceAntiBruteForceRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyInstanceAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the defense rule against brute-force attacks that is applied to a specified server.
     *  *
     * @param ModifyInstanceAntiBruteForceRuleRequest $request ModifyInstanceAntiBruteForceRuleRequest
     *
     * @return ModifyInstanceAntiBruteForceRuleResponse ModifyInstanceAntiBruteForceRuleResponse
     */
    public function modifyInstanceAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInstanceAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a proactive defense rule for containers.
     *  *
     * @param ModifyInterceptionRuleRequest $tmpReq  ModifyInterceptionRuleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyInterceptionRuleResponse ModifyInterceptionRuleResponse
     */
    public function modifyInterceptionRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyInterceptionRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->dstTarget)) {
            $request->dstTargetShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->dstTarget, 'DstTarget', 'json');
        }
        if (!Utils::isUnset($tmpReq->srcTarget)) {
            $request->srcTargetShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->srcTarget, 'SrcTarget', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dstTargetShrink)) {
            $query['DstTarget'] = $request->dstTargetShrink;
        }
        if (!Utils::isUnset($request->interceptType)) {
            $query['InterceptType'] = $request->interceptType;
        }
        if (!Utils::isUnset($request->orderIndex)) {
            $query['OrderIndex'] = $request->orderIndex;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        if (!Utils::isUnset($request->srcTargetShrink)) {
            $query['SrcTarget'] = $request->srcTargetShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyInterceptionRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyInterceptionRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a proactive defense rule for containers.
     *  *
     * @param ModifyInterceptionRuleRequest $request ModifyInterceptionRuleRequest
     *
     * @return ModifyInterceptionRuleResponse ModifyInterceptionRuleResponse
     */
    public function modifyInterceptionRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInterceptionRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables a proactive defense rule for containers.
     *  *
     * @param ModifyInterceptionRuleSwitchRequest $request ModifyInterceptionRuleSwitchRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyInterceptionRuleSwitchResponse ModifyInterceptionRuleSwitchResponse
     */
    public function modifyInterceptionRuleSwitchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->ruleIds)) {
            $query['RuleIds'] = $request->ruleIds;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyInterceptionRuleSwitch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyInterceptionRuleSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables a proactive defense rule for containers.
     *  *
     * @param ModifyInterceptionRuleSwitchRequest $request ModifyInterceptionRuleSwitchRequest
     *
     * @return ModifyInterceptionRuleSwitchResponse ModifyInterceptionRuleSwitchResponse
     */
    public function modifyInterceptionRuleSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInterceptionRuleSwitchWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the information about a network object of the container firewall feature.
     *  *
     * @param ModifyInterceptionTargetRequest $request ModifyInterceptionTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyInterceptionTargetResponse ModifyInterceptionTargetResponse
     */
    public function modifyInterceptionTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->imageList)) {
            $query['ImageList'] = $request->imageList;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->tagList)) {
            $query['TagList'] = $request->tagList;
        }
        if (!Utils::isUnset($request->targetId)) {
            $query['TargetId'] = $request->targetId;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyInterceptionTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyInterceptionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the information about a network object of the container firewall feature.
     *  *
     * @param ModifyInterceptionTargetRequest $request ModifyInterceptionTargetRequest
     *
     * @return ModifyInterceptionTargetResponse ModifyInterceptionTargetResponse
     */
    public function modifyInterceptionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInterceptionTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables the log analysis feature.
     *  *
     * @param ModifyLogMetaStatusRequest $request ModifyLogMetaStatusRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLogMetaStatusResponse ModifyLogMetaStatusResponse
     */
    public function modifyLogMetaStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->logStore)) {
            $query['LogStore'] = $request->logStore;
        }
        if (!Utils::isUnset($request->project)) {
            $query['Project'] = $request->project;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyLogMetaStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyLogMetaStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables the log analysis feature.
     *  *
     * @param ModifyLogMetaStatusRequest $request ModifyLogMetaStatusRequest
     *
     * @return ModifyLogMetaStatusResponse ModifyLogMetaStatusResponse
     */
    public function modifyLogMetaStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLogMetaStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the logon configuration for a specified asset.
     *  *
     * @param ModifyLoginBaseConfigRequest $request ModifyLoginBaseConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLoginBaseConfigResponse ModifyLoginBaseConfigResponse
     */
    public function modifyLoginBaseConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyLoginBaseConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyLoginBaseConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the logon configuration for a specified asset.
     *  *
     * @param ModifyLoginBaseConfigRequest $request ModifyLoginBaseConfigRequest
     *
     * @return ModifyLoginBaseConfigResponse ModifyLoginBaseConfigResponse
     */
    public function modifyLoginBaseConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLoginBaseConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables the logon security settings for an asset.
     *  *
     * @param ModifyLoginSwitchConfigRequest $request ModifyLoginSwitchConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLoginSwitchConfigResponse ModifyLoginSwitchConfigResponse
     */
    public function modifyLoginSwitchConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->item)) {
            $query['Item'] = $request->item;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyLoginSwitchConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyLoginSwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables the logon security settings for an asset.
     *  *
     * @param ModifyLoginSwitchConfigRequest $request ModifyLoginSwitchConfigRequest
     *
     * @return ModifyLoginSwitchConfigResponse ModifyLoginSwitchConfigResponse
     */
    public function modifyLoginSwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLoginSwitchConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies notification settings.
     *  *
     * @param ModifyNoticeConfigRequest $request ModifyNoticeConfigRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyNoticeConfigResponse ModifyNoticeConfigResponse
     */
    public function modifyNoticeConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->project)) {
            $query['Project'] = $request->project;
        }
        if (!Utils::isUnset($request->route)) {
            $query['Route'] = $request->route;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->timeLimit)) {
            $query['TimeLimit'] = $request->timeLimit;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyNoticeConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyNoticeConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies notification settings.
     *  *
     * @param ModifyNoticeConfigRequest $request ModifyNoticeConfigRequest
     *
     * @return ModifyNoticeConfigResponse ModifyNoticeConfigResponse
     */
    public function modifyNoticeConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNoticeConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Activates Simple Log Service.
     *  *
     * @description **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
     *  *
     * @param ModifyOpenLogShipperRequest $request ModifyOpenLogShipperRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyOpenLogShipperResponse ModifyOpenLogShipperResponse
     */
    public function modifyOpenLogShipperWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyOpenLogShipper',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyOpenLogShipperResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Activates Simple Log Service.
     *  *
     * @description **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
     *  *
     * @param ModifyOpenLogShipperRequest $request ModifyOpenLogShipperRequest
     *
     * @return ModifyOpenLogShipperResponse ModifyOpenLogShipperResponse
     */
    public function modifyOpenLogShipper($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyOpenLogShipperWithOptions($request, $runtime);
    }

    /**
     * @summary Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
     *  *
     * @param ModifyOperateVulRequest $request ModifyOperateVulRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyOperateVulResponse ModifyOperateVulResponse
     */
    public function modifyOperateVulWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->info)) {
            $query['Info'] = $request->info;
        }
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyOperateVul',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyOperateVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
     *  *
     * @param ModifyOperateVulRequest $request ModifyOperateVulRequest
     *
     * @return ModifyOperateVulResponse ModifyOperateVulResponse
     */
    public function modifyOperateVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyOperateVulWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the switch settings of pay-as-you-go modules.
     *  *
     * @param ModifyPostPayModuleSwitchRequest $request ModifyPostPayModuleSwitchRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyPostPayModuleSwitchResponse ModifyPostPayModuleSwitchResponse
     */
    public function modifyPostPayModuleSwitchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->postPayInstanceId)) {
            $query['PostPayInstanceId'] = $request->postPayInstanceId;
        }
        if (!Utils::isUnset($request->postPayModuleSwitch)) {
            $query['PostPayModuleSwitch'] = $request->postPayModuleSwitch;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyPostPayModuleSwitch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyPostPayModuleSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the switch settings of pay-as-you-go modules.
     *  *
     * @param ModifyPostPayModuleSwitchRequest $request ModifyPostPayModuleSwitchRequest
     *
     * @return ModifyPostPayModuleSwitchResponse ModifyPostPayModuleSwitchResponse
     */
    public function modifyPostPayModuleSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPostPayModuleSwitchWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a process to or removes a process from the whitelist by using the application whitelist feature.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param ModifyProcessWhiteListRequest $request ModifyProcessWhiteListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyProcessWhiteListResponse ModifyProcessWhiteListResponse
     */
    public function modifyProcessWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->md5s)) {
            $query['Md5s'] = $request->md5s;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyProcessWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyProcessWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a process to or removes a process from the whitelist by using the application whitelist feature.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param ModifyProcessWhiteListRequest $request ModifyProcessWhiteListRequest
     *
     * @return ModifyProcessWhiteListResponse ModifyProcessWhiteListResponse
     */
    public function modifyProcessWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyProcessWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary The new collection frequency of asset fingerprints. Valid values:
     * *   **0**: disabled, which indicates that the asset fingerprints are not automatically or periodically collected.
     * *   **1**: collects asset fingerprints once an hour.
     * *   **3**: collects asset fingerprints once every 3 hours.
     * *   **12**: collects asset fingerprints once every 12 hours.
     * *   **24**: collects asset fingerprints once a day.
     * *   **168**: collects asset fingerprints once every 7 days.
     *  *
     * @param ModifyPropertyScheduleConfigRequest $request ModifyPropertyScheduleConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyPropertyScheduleConfigResponse ModifyPropertyScheduleConfigResponse
     */
    public function modifyPropertyScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->scheduleTime)) {
            $query['ScheduleTime'] = $request->scheduleTime;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyPropertyScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyPropertyScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The new collection frequency of asset fingerprints. Valid values:
     * *   **0**: disabled, which indicates that the asset fingerprints are not automatically or periodically collected.
     * *   **1**: collects asset fingerprints once an hour.
     * *   **3**: collects asset fingerprints once every 3 hours.
     * *   **12**: collects asset fingerprints once every 12 hours.
     * *   **24**: collects asset fingerprints once a day.
     * *   **168**: collects asset fingerprints once every 7 days.
     *  *
     * @param ModifyPropertyScheduleConfigRequest $request ModifyPropertyScheduleConfigRequest
     *
     * @return ModifyPropertyScheduleConfigResponse ModifyPropertyScheduleConfigResponse
     */
    public function modifyPropertyScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPropertyScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Performs security check tasks on servers with a few clicks.
     *  *
     * @param ModifyPushAllTaskRequest $request ModifyPushAllTaskRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyPushAllTaskResponse ModifyPushAllTaskResponse
     */
    public function modifyPushAllTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->tasks)) {
            $query['Tasks'] = $request->tasks;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyPushAllTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyPushAllTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Performs security check tasks on servers with a few clicks.
     *  *
     * @param ModifyPushAllTaskRequest $request ModifyPushAllTaskRequest
     *
     * @return ModifyPushAllTaskResponse ModifyPushAllTaskResponse
     */
    public function modifyPushAllTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPushAllTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Refreshes the list of processes that are associated with a Linux software vulnerability.
     *  *
     * @param ModifyRefreshProcessInfoRequest $request ModifyRefreshProcessInfoRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyRefreshProcessInfoResponse ModifyRefreshProcessInfoResponse
     */
    public function modifyRefreshProcessInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyRefreshProcessInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyRefreshProcessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Refreshes the list of processes that are associated with a Linux software vulnerability.
     *  *
     * @param ModifyRefreshProcessInfoRequest $request ModifyRefreshProcessInfoRequest
     *
     * @return ModifyRefreshProcessInfoResponse ModifyRefreshProcessInfoResponse
     */
    public function modifyRefreshProcessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRefreshProcessInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a rule for container tamper-proofing.
     *  *
     * @param ModifySasContainerWebDefenseRuleRequest $request ModifySasContainerWebDefenseRuleRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySasContainerWebDefenseRuleResponse ModifySasContainerWebDefenseRuleResponse
     */
    public function modifySasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pathConfDTOList)) {
            $query['PathConfDTOList'] = $request->pathConfDTOList;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifySasContainerWebDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a rule for container tamper-proofing.
     *  *
     * @param ModifySasContainerWebDefenseRuleRequest $request ModifySasContainerWebDefenseRuleRequest
     *
     * @return ModifySasContainerWebDefenseRuleResponse ModifySasContainerWebDefenseRuleResponse
     */
    public function modifySasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies common filter conditions to search for assets.
     *  *
     * @param ModifySearchConditionRequest $request ModifySearchConditionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySearchConditionResponse ModifySearchConditionResponse
     */
    public function modifySearchConditionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->filterConditions)) {
            $query['FilterConditions'] = $request->filterConditions;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifySearchCondition',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySearchConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies common filter conditions to search for assets.
     *  *
     * @param ModifySearchConditionRequest $request ModifySearchConditionRequest
     *
     * @return ModifySearchConditionResponse ModifySearchConditionResponse
     */
    public function modifySearchCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySearchConditionWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ModifySecurityCheckScheduleConfig is deprecated
     *  *
     * @summary Specifies the time when an automatic configuration check is performed on cloud services.
     *  *
     * @description This operation is phased out. You can use the ChangeCheckConfig operation.
     *  *
     * Deprecated
     *
     * @param ModifySecurityCheckScheduleConfigRequest $request ModifySecurityCheckScheduleConfigRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySecurityCheckScheduleConfigResponse ModifySecurityCheckScheduleConfigResponse
     */
    public function modifySecurityCheckScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->daysOfWeek)) {
            $query['DaysOfWeek'] = $request->daysOfWeek;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifySecurityCheckScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySecurityCheckScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ModifySecurityCheckScheduleConfig is deprecated
     *  *
     * @summary Specifies the time when an automatic configuration check is performed on cloud services.
     *  *
     * @description This operation is phased out. You can use the ChangeCheckConfig operation.
     *  *
     * Deprecated
     *
     * @param ModifySecurityCheckScheduleConfigRequest $request ModifySecurityCheckScheduleConfigRequest
     *
     * @return ModifySecurityCheckScheduleConfigResponse ModifySecurityCheckScheduleConfigResponse
     */
    public function modifySecurityCheckScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySecurityCheckScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the alert handling rule for alerts that are added to the whitelist by asset.
     *  *
     * @param ModifySecurityEventMarkMissIndividuallyRequest $request ModifySecurityEventMarkMissIndividuallyRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySecurityEventMarkMissIndividuallyResponse ModifySecurityEventMarkMissIndividuallyResponse
     */
    public function modifySecurityEventMarkMissIndividuallyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->deleteMarkMissParam)) {
            $body['DeleteMarkMissParam'] = $request->deleteMarkMissParam;
        }
        if (!Utils::isUnset($request->from)) {
            $body['From'] = $request->from;
        }
        if (!Utils::isUnset($request->insertMarkMissParam)) {
            $body['InsertMarkMissParam'] = $request->insertMarkMissParam;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ModifySecurityEventMarkMissIndividually',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySecurityEventMarkMissIndividuallyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the alert handling rule for alerts that are added to the whitelist by asset.
     *  *
     * @param ModifySecurityEventMarkMissIndividuallyRequest $request ModifySecurityEventMarkMissIndividuallyRequest
     *
     * @return ModifySecurityEventMarkMissIndividuallyResponse ModifySecurityEventMarkMissIndividuallyResponse
     */
    public function modifySecurityEventMarkMissIndividually($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySecurityEventMarkMissIndividuallyWithOptions($request, $runtime);
    }

    /**
     * @summary Creates or deletes a policy template on the My Policies tab of the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param ModifySoarStrategySubscribeRequest $request ModifySoarStrategySubscribeRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySoarStrategySubscribeResponse ModifySoarStrategySubscribeResponse
     */
    public function modifySoarStrategySubscribeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->subscribeStatus)) {
            $query['SubscribeStatus'] = $request->subscribeStatus;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifySoarStrategySubscribe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySoarStrategySubscribeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates or deletes a policy template on the My Policies tab of the Playbook page.
     *  *
     * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
     *  *
     * @param ModifySoarStrategySubscribeRequest $request ModifySoarStrategySubscribeRequest
     *
     * @return ModifySoarStrategySubscribeResponse ModifySoarStrategySubscribeResponse
     */
    public function modifySoarStrategySubscribe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySoarStrategySubscribeWithOptions($request, $runtime);
    }

    /**
     * @summary Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
     *  *
     * @param ModifyStartVulScanRequest $request ModifyStartVulScanRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyStartVulScanResponse ModifyStartVulScanResponse
     */
    public function modifyStartVulScanWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyStartVulScan',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyStartVulScanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
     *  *
     * @param ModifyStartVulScanRequest $request ModifyStartVulScanRequest
     *
     * @return ModifyStartVulScanResponse ModifyStartVulScanResponse
     */
    public function modifyStartVulScan($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStartVulScanWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a baseline check policy.
     *  *
     * @param ModifyStrategyRequest $request ModifyStrategyRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyStrategyResponse ModifyStrategyResponse
     */
    public function modifyStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->customType)) {
            $query['CustomType'] = $request->customType;
        }
        if (!Utils::isUnset($request->cycleDays)) {
            $query['CycleDays'] = $request->cycleDays;
        }
        if (!Utils::isUnset($request->cycleStartTime)) {
            $query['CycleStartTime'] = $request->cycleStartTime;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->riskCustomParams)) {
            $query['RiskCustomParams'] = $request->riskCustomParams;
        }
        if (!Utils::isUnset($request->riskSubTypeName)) {
            $query['RiskSubTypeName'] = $request->riskSubTypeName;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a baseline check policy.
     *  *
     * @param ModifyStrategyRequest $request ModifyStrategyRequest
     *
     * @return ModifyStrategyResponse ModifyStrategyResponse
     */
    public function modifyStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param ModifyStrategyTargetRequest $request ModifyStrategyTargetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyStrategyTargetResponse ModifyStrategyTargetResponse
     */
    public function modifyStrategyTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyStrategyTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyStrategyTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param ModifyStrategyTargetRequest $request ModifyStrategyTargetRequest
     *
     * @return ModifyStrategyTargetResponse ModifyStrategyTargetResponse
     */
    public function modifyStrategyTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStrategyTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the names of the tags that are added to assets, or modifies the tags for assets.
     *  *
     * @param ModifyTagWithUuidRequest $request ModifyTagWithUuidRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyTagWithUuidResponse ModifyTagWithUuidResponse
     */
    public function modifyTagWithUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->tagId)) {
            $query['TagId'] = $request->tagId;
        }
        if (!Utils::isUnset($request->tagList)) {
            $query['TagList'] = $request->tagList;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyTagWithUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyTagWithUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the names of the tags that are added to assets, or modifies the tags for assets.
     *  *
     * @param ModifyTagWithUuidRequest $request ModifyTagWithUuidRequest
     *
     * @return ModifyTagWithUuidResponse ModifyTagWithUuidResponse
     */
    public function modifyTagWithUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyTagWithUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an anti-ransomware policy for databases.
     *  *
     * @param ModifyUniBackupPolicyRequest $tmpReq  ModifyUniBackupPolicyRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyUniBackupPolicyResponse ModifyUniBackupPolicyResponse
     */
    public function modifyUniBackupPolicyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyUniBackupPolicyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->fullPlan)) {
            $request->fullPlanShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->fullPlan, 'FullPlan', 'json');
        }
        if (!Utils::isUnset($tmpReq->incPlan)) {
            $request->incPlanShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->incPlan, 'IncPlan', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->accountName)) {
            $query['AccountName'] = $request->accountName;
        }
        if (!Utils::isUnset($request->accountPassword)) {
            $query['AccountPassword'] = $request->accountPassword;
        }
        if (!Utils::isUnset($request->fullPlanShrink)) {
            $query['FullPlan'] = $request->fullPlanShrink;
        }
        if (!Utils::isUnset($request->incPlanShrink)) {
            $query['IncPlan'] = $request->incPlanShrink;
        }
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->policyName)) {
            $query['PolicyName'] = $request->policyName;
        }
        if (!Utils::isUnset($request->policyStatus)) {
            $query['PolicyStatus'] = $request->policyStatus;
        }
        if (!Utils::isUnset($request->retention)) {
            $query['Retention'] = $request->retention;
        }
        if (!Utils::isUnset($request->speedLimiter)) {
            $query['SpeedLimiter'] = $request->speedLimiter;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyUniBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyUniBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an anti-ransomware policy for databases.
     *  *
     * @param ModifyUniBackupPolicyRequest $request ModifyUniBackupPolicyRequest
     *
     * @return ModifyUniBackupPolicyResponse ModifyUniBackupPolicyResponse
     */
    public function modifyUniBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyUniBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ModifyVpcHoneyPot is deprecated
     *  *
     * @summary Enables or disables a honeypot.
     *  *
     * Deprecated
     *
     * @param ModifyVpcHoneyPotRequest $request ModifyVpcHoneyPotRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpcHoneyPotResponse ModifyVpcHoneyPotResponse
     */
    public function modifyVpcHoneyPotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeyPotAction)) {
            $query['HoneyPotAction'] = $request->honeyPotAction;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpcHoneyPot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpcHoneyPotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ModifyVpcHoneyPot is deprecated
     *  *
     * @summary Enables or disables a honeypot.
     *  *
     * Deprecated
     *
     * @param ModifyVpcHoneyPotRequest $request ModifyVpcHoneyPotRequest
     *
     * @return ModifyVpcHoneyPotResponse ModifyVpcHoneyPotResponse
     */
    public function modifyVpcHoneyPot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpcHoneyPotWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of the vulnerability scan feature.
     *  *
     * @param ModifyVulConfigRequest $request ModifyVulConfigRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVulConfigResponse ModifyVulConfigResponse
     */
    public function modifyVulConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVulConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVulConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of the vulnerability scan feature.
     *  *
     * @param ModifyVulConfigRequest $request ModifyVulConfigRequest
     *
     * @return ModifyVulConfigResponse ModifyVulConfigResponse
     */
    public function modifyVulConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of the vulnerability scan feature for a server.
     *  *
     * @param ModifyVulTargetRequest $request ModifyVulTargetRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVulTargetResponse ModifyVulTargetResponse
     */
    public function modifyVulTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVulTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVulTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of the vulnerability scan feature for a server.
     *  *
     * @param ModifyVulTargetRequest $request ModifyVulTargetRequest
     *
     * @return ModifyVulTargetResponse ModifyVulTargetResponse
     */
    public function modifyVulTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Configures vulnerability scan for a server.
     *  *
     * @param ModifyVulTargetConfigRequest $request ModifyVulTargetConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVulTargetConfigResponse ModifyVulTargetConfigResponse
     */
    public function modifyVulTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVulTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVulTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures vulnerability scan for a server.
     *  *
     * @param ModifyVulTargetConfigRequest $request ModifyVulTargetConfigRequest
     *
     * @return ModifyVulTargetConfigResponse ModifyVulTargetConfigResponse
     */
    public function modifyVulTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the servers that are added to a vulnerability whitelist.
     *  *
     * @param ModifyVulWhitelistTargetRequest $request ModifyVulWhitelistTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVulWhitelistTargetResponse ModifyVulWhitelistTargetResponse
     */
    public function modifyVulWhitelistTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->targetInfo)) {
            $query['TargetInfo'] = $request->targetInfo;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVulWhitelistTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVulWhitelistTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the servers that are added to a vulnerability whitelist.
     *  *
     * @param ModifyVulWhitelistTargetRequest $request ModifyVulWhitelistTargetRequest
     *
     * @return ModifyVulWhitelistTargetResponse ModifyVulWhitelistTargetResponse
     */
    public function modifyVulWhitelistTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulWhitelistTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a directory to protect for a specified server.
     *  *
     * @param ModifyWebLockCreateConfigRequest $request ModifyWebLockCreateConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockCreateConfigResponse ModifyWebLockCreateConfigResponse
     */
    public function modifyWebLockCreateConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defenceMode)) {
            $query['DefenceMode'] = $request->defenceMode;
        }
        if (!Utils::isUnset($request->dir)) {
            $query['Dir'] = $request->dir;
        }
        if (!Utils::isUnset($request->exclusiveDir)) {
            $query['ExclusiveDir'] = $request->exclusiveDir;
        }
        if (!Utils::isUnset($request->exclusiveFile)) {
            $query['ExclusiveFile'] = $request->exclusiveFile;
        }
        if (!Utils::isUnset($request->exclusiveFileType)) {
            $query['ExclusiveFileType'] = $request->exclusiveFileType;
        }
        if (!Utils::isUnset($request->inclusiveFile)) {
            $query['InclusiveFile'] = $request->inclusiveFile;
        }
        if (!Utils::isUnset($request->inclusiveFileType)) {
            $query['InclusiveFileType'] = $request->inclusiveFileType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->localBackupDir)) {
            $query['LocalBackupDir'] = $request->localBackupDir;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockCreateConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockCreateConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a directory to protect for a specified server.
     *  *
     * @param ModifyWebLockCreateConfigRequest $request ModifyWebLockCreateConfigRequest
     *
     * @return ModifyWebLockCreateConfigResponse ModifyWebLockCreateConfigResponse
     */
    public function modifyWebLockCreateConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockCreateConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a directory on a specified server from the protected directories of web tamper proofing.
     *  *
     * @description After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
     *  *
     * @param ModifyWebLockDeleteConfigRequest $request ModifyWebLockDeleteConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockDeleteConfigResponse ModifyWebLockDeleteConfigResponse
     */
    public function modifyWebLockDeleteConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockDeleteConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockDeleteConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a directory on a specified server from the protected directories of web tamper proofing.
     *  *
     * @description After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
     *  *
     * @param ModifyWebLockDeleteConfigRequest $request ModifyWebLockDeleteConfigRequest
     *
     * @return ModifyWebLockDeleteConfigResponse ModifyWebLockDeleteConfigResponse
     */
    public function modifyWebLockDeleteConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockDeleteConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the status of processes for web tamper proofing.
     *  *
     * @param ModifyWebLockProcessStatusRequest $request ModifyWebLockProcessStatusRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockProcessStatusResponse ModifyWebLockProcessStatusResponse
     */
    public function modifyWebLockProcessStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dealAll)) {
            $query['DealAll'] = $request->dealAll;
        }
        if (!Utils::isUnset($request->operateInfo)) {
            $query['OperateInfo'] = $request->operateInfo;
        }
        if (!Utils::isUnset($request->processPath)) {
            $query['ProcessPath'] = $request->processPath;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockProcessStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockProcessStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the status of processes for web tamper proofing.
     *  *
     * @param ModifyWebLockProcessStatusRequest $request ModifyWebLockProcessStatusRequest
     *
     * @return ModifyWebLockProcessStatusResponse ModifyWebLockProcessStatusResponse
     */
    public function modifyWebLockProcessStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockProcessStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Refreshes the status of the web tamper proofing feature for a server.
     *  *
     * @description If an exception occurs when you enable or disable the web tamper proofing feature for a server, you can call this operation to refresh the status of the web tamper proofing feature.
     *  *
     * @param ModifyWebLockRefreshRequest $request ModifyWebLockRefreshRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockRefreshResponse ModifyWebLockRefreshResponse
     */
    public function modifyWebLockRefreshWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockRefresh',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockRefreshResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Refreshes the status of the web tamper proofing feature for a server.
     *  *
     * @description If an exception occurs when you enable or disable the web tamper proofing feature for a server, you can call this operation to refresh the status of the web tamper proofing feature.
     *  *
     * @param ModifyWebLockRefreshRequest $request ModifyWebLockRefreshRequest
     *
     * @return ModifyWebLockRefreshResponse ModifyWebLockRefreshResponse
     */
    public function modifyWebLockRefresh($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockRefreshWithOptions($request, $runtime);
    }

    /**
     * @summary Enables web tamper proofing for a specified server.
     *  *
     * @param ModifyWebLockStartRequest $request ModifyWebLockStartRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockStartResponse ModifyWebLockStartResponse
     */
    public function modifyWebLockStartWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defenceMode)) {
            $query['DefenceMode'] = $request->defenceMode;
        }
        if (!Utils::isUnset($request->dir)) {
            $query['Dir'] = $request->dir;
        }
        if (!Utils::isUnset($request->exclusiveDir)) {
            $query['ExclusiveDir'] = $request->exclusiveDir;
        }
        if (!Utils::isUnset($request->exclusiveFile)) {
            $query['ExclusiveFile'] = $request->exclusiveFile;
        }
        if (!Utils::isUnset($request->exclusiveFileType)) {
            $query['ExclusiveFileType'] = $request->exclusiveFileType;
        }
        if (!Utils::isUnset($request->inclusiveFileType)) {
            $query['InclusiveFileType'] = $request->inclusiveFileType;
        }
        if (!Utils::isUnset($request->localBackupDir)) {
            $query['LocalBackupDir'] = $request->localBackupDir;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockStart',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockStartResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables web tamper proofing for a specified server.
     *  *
     * @param ModifyWebLockStartRequest $request ModifyWebLockStartRequest
     *
     * @return ModifyWebLockStartResponse ModifyWebLockStartResponse
     */
    public function modifyWebLockStart($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockStartWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables web tamper proofing for a server.
     *  *
     * @param ModifyWebLockStatusRequest $request ModifyWebLockStatusRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockStatusResponse ModifyWebLockStatusResponse
     */
    public function modifyWebLockStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables web tamper proofing for a server.
     *  *
     * @param ModifyWebLockStatusRequest $request ModifyWebLockStatusRequest
     *
     * @return ModifyWebLockStatusResponse ModifyWebLockStatusResponse
     */
    public function modifyWebLockStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Disables web tamper proofing for a specified server.
     *  *
     * @param ModifyWebLockUnbindRequest $request ModifyWebLockUnbindRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockUnbindResponse ModifyWebLockUnbindResponse
     */
    public function modifyWebLockUnbindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockUnbind',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockUnbindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables web tamper proofing for a specified server.
     *  *
     * @param ModifyWebLockUnbindRequest $request ModifyWebLockUnbindRequest
     *
     * @return ModifyWebLockUnbindResponse ModifyWebLockUnbindResponse
     */
    public function modifyWebLockUnbind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockUnbindWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the protection policy for a specified server.
     *  *
     * @param ModifyWebLockUpdateConfigRequest $request ModifyWebLockUpdateConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockUpdateConfigResponse ModifyWebLockUpdateConfigResponse
     */
    public function modifyWebLockUpdateConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defenceMode)) {
            $query['DefenceMode'] = $request->defenceMode;
        }
        if (!Utils::isUnset($request->dir)) {
            $query['Dir'] = $request->dir;
        }
        if (!Utils::isUnset($request->exclusiveDir)) {
            $query['ExclusiveDir'] = $request->exclusiveDir;
        }
        if (!Utils::isUnset($request->exclusiveFile)) {
            $query['ExclusiveFile'] = $request->exclusiveFile;
        }
        if (!Utils::isUnset($request->exclusiveFileType)) {
            $query['ExclusiveFileType'] = $request->exclusiveFileType;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->inclusiveFile)) {
            $query['InclusiveFile'] = $request->inclusiveFile;
        }
        if (!Utils::isUnset($request->inclusiveFileType)) {
            $query['InclusiveFileType'] = $request->inclusiveFileType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->localBackupDir)) {
            $query['LocalBackupDir'] = $request->localBackupDir;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockUpdateConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockUpdateConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the protection policy for a specified server.
     *  *
     * @param ModifyWebLockUpdateConfigRequest $request ModifyWebLockUpdateConfigRequest
     *
     * @return ModifyWebLockUpdateConfigResponse ModifyWebLockUpdateConfigResponse
     */
    public function modifyWebLockUpdateConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockUpdateConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a custom web directory.
     *  *
     * @param ModifyWebPathRequest $request ModifyWebPathRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebPathResponse ModifyWebPathResponse
     */
    public function modifyWebPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebPath',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a custom web directory.
     *  *
     * @param ModifyWebPathRequest $request ModifyWebPathRequest
     *
     * @return ModifyWebPathResponse ModifyWebPathResponse
     */
    public function modifyWebPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebPathWithOptions($request, $runtime);
    }

    /**
     * @summary Enables the automatic configuration of anti-ransomware policies for servers in the managed anti-ransomware feature. You can call this operation only after you purchase the managed anti-ransomware feature.
     *  *
     * @param OpenBackupAutoConfigRequest $request OpenBackupAutoConfigRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenBackupAutoConfigResponse OpenBackupAutoConfigResponse
     */
    public function openBackupAutoConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->maxBatchSize)) {
            $query['MaxBatchSize'] = $request->maxBatchSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OpenBackupAutoConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OpenBackupAutoConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables the automatic configuration of anti-ransomware policies for servers in the managed anti-ransomware feature. You can call this operation only after you purchase the managed anti-ransomware feature.
     *  *
     * @param OpenBackupAutoConfigRequest $request OpenBackupAutoConfigRequest
     *
     * @return OpenBackupAutoConfigResponse OpenBackupAutoConfigResponse
     */
    public function openBackupAutoConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openBackupAutoConfigWithOptions($request, $runtime);
    }

    /**
     * @summary 开启按量购买
     *  *
     * @param OpenPartialBuyRequest $request OpenPartialBuyRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenPartialBuyResponse OpenPartialBuyResponse
     */
    public function openPartialBuyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OpenPartialBuy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OpenPartialBuyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 开启按量购买
     *  *
     * @param OpenPartialBuyRequest $request OpenPartialBuyRequest
     *
     * @return OpenPartialBuyResponse OpenPartialBuyResponse
     */
    public function openPartialBuy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openPartialBuyWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables sensitive file scan.
     *  *
     * @param OpenSensitiveFileScanRequest $request OpenSensitiveFileScanRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenSensitiveFileScanResponse OpenSensitiveFileScanResponse
     */
    public function openSensitiveFileScanWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->switchOn)) {
            $query['SwitchOn'] = $request->switchOn;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OpenSensitiveFileScan',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OpenSensitiveFileScanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables sensitive file scan.
     *  *
     * @param OpenSensitiveFileScanRequest $request OpenSensitiveFileScanRequest
     *
     * @return OpenSensitiveFileScanResponse OpenSensitiveFileScanResponse
     */
    public function openSensitiveFileScan($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openSensitiveFileScanWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the Security Center agent on servers.
     *  *
     * @param OperateAgentClientInstallRequest $request OperateAgentClientInstallRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateAgentClientInstallResponse OperateAgentClientInstallResponse
     */
    public function operateAgentClientInstallWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->os)) {
            $query['Os'] = $request->os;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateAgentClientInstall',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateAgentClientInstallResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the Security Center agent on servers.
     *  *
     * @param OperateAgentClientInstallRequest $request OperateAgentClientInstallRequest
     *
     * @return OperateAgentClientInstallResponse OperateAgentClientInstallResponse
     */
    public function operateAgentClientInstall($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateAgentClientInstallWithOptions($request, $runtime);
    }

    /**
     * @summary Adds or deletes container applications for tamper proofing.
     *  *
     * @param OperateApplicationRequest $request OperateApplicationRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateApplicationResponse OperateApplicationResponse
     */
    public function operateApplicationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->containerWebDefenseApplicationDTOS)) {
            $query['ContainerWebDefenseApplicationDTOS'] = $request->containerWebDefenseApplicationDTOS;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateApplication',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateApplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds or deletes container applications for tamper proofing.
     *  *
     * @param OperateApplicationRequest $request OperateApplicationRequest
     *
     * @return OperateApplicationResponse OperateApplicationResponse
     */
    public function operateApplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateApplicationWithOptions($request, $runtime);
    }

    /**
     * @summary Manages an Object Storage Service (OSS) bucket check task.
     *  *
     * @param OperateBucketScanTaskRequest $request OperateBucketScanTaskRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateBucketScanTaskResponse OperateBucketScanTaskResponse
     */
    public function operateBucketScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->operateCode)) {
            $query['OperateCode'] = $request->operateCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateBucketScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateBucketScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Manages an Object Storage Service (OSS) bucket check task.
     *  *
     * @param OperateBucketScanTaskRequest $request OperateBucketScanTaskRequest
     *
     * @return OperateBucketScanTaskResponse OperateBucketScanTaskResponse
     */
    public function operateBucketScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateBucketScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables a feature by type.
     *  *
     * @param OperateCommonOverallConfigRequest $request OperateCommonOverallConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateCommonOverallConfigResponse OperateCommonOverallConfigResponse
     */
    public function operateCommonOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->noTargetAsOn)) {
            $query['NoTargetAsOn'] = $request->noTargetAsOn;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateCommonOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateCommonOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables a feature by type.
     *  *
     * @param OperateCommonOverallConfigRequest $request OperateCommonOverallConfigRequest
     *
     * @return OperateCommonOverallConfigResponse OperateCommonOverallConfigResponse
     */
    public function operateCommonOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateCommonOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
     *  *
     * @param OperateCommonTargetConfigRequest $request OperateCommonTargetConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateCommonTargetConfigResponse OperateCommonTargetConfigResponse
     */
    public function operateCommonTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fieldName)) {
            $query['FieldName'] = $request->fieldName;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->targetOperations)) {
            $query['TargetOperations'] = $request->targetOperations;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateCommonTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateCommonTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
     *  *
     * @param OperateCommonTargetConfigRequest $request OperateCommonTargetConfigRequest
     *
     * @return OperateCommonTargetConfigResponse OperateCommonTargetConfigResponse
     */
    public function operateCommonTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateCommonTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
     *  *
     * @param OperateImageBaselineWhitelistRequest $request OperateImageBaselineWhitelistRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateImageBaselineWhitelistResponse OperateImageBaselineWhitelistResponse
     */
    public function operateImageBaselineWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineItemKeyList)) {
            $query['BaselineItemKeyList'] = $request->baselineItemKeyList;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->operation)) {
            $query['Operation'] = $request->operation;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateImageBaselineWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateImageBaselineWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
     *  *
     * @param OperateImageBaselineWhitelistRequest $request OperateImageBaselineWhitelistRequest
     *
     * @return OperateImageBaselineWhitelistResponse OperateImageBaselineWhitelistResponse
     */
    public function operateImageBaselineWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateImageBaselineWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
     *  *
     * @param OperateImageVulRequest $request OperateImageVulRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateImageVulResponse OperateImageVulResponse
     */
    public function operateImageVulWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->info)) {
            $query['Info'] = $request->info;
        }
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateImageVul',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateImageVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
     *  *
     * @param OperateImageVulRequest $request OperateImageVulRequest
     *
     * @return OperateImageVulResponse OperateImageVulResponse
     */
    public function operateImageVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateImageVulWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables a feature that detects exceptions.
     *  *
     * @param OperateSuspiciousOverallConfigRequest $request OperateSuspiciousOverallConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateSuspiciousOverallConfigResponse OperateSuspiciousOverallConfigResponse
     */
    public function operateSuspiciousOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->noTargetAsOn)) {
            $query['NoTargetAsOn'] = $request->noTargetAsOn;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateSuspiciousOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateSuspiciousOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables a feature that detects exceptions.
     *  *
     * @param OperateSuspiciousOverallConfigRequest $request OperateSuspiciousOverallConfigRequest
     *
     * @return OperateSuspiciousOverallConfigResponse OperateSuspiciousOverallConfigResponse
     */
    public function operateSuspiciousOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateSuspiciousOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures the scope on which proactive defense takes effect.
     *  *
     * @param OperateSuspiciousTargetConfigRequest $request OperateSuspiciousTargetConfigRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateSuspiciousTargetConfigResponse OperateSuspiciousTargetConfigResponse
     */
    public function operateSuspiciousTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->targetOperations)) {
            $query['TargetOperations'] = $request->targetOperations;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateSuspiciousTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateSuspiciousTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures the scope on which proactive defense takes effect.
     *  *
     * @param OperateSuspiciousTargetConfigRequest $request OperateSuspiciousTargetConfigRequest
     *
     * @return OperateSuspiciousTargetConfigResponse OperateSuspiciousTargetConfigResponse
     */
    public function operateSuspiciousTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateSuspiciousTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the status of a rule for container tamper-proofing.
     *  *
     * @param OperateSwitchStatusRequest $request OperateSwitchStatusRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateSwitchStatusResponse OperateSwitchStatusResponse
     */
    public function operateSwitchStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateSwitchStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateSwitchStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the status of a rule for container tamper-proofing.
     *  *
     * @param OperateSwitchStatusRequest $request OperateSwitchStatusRequest
     *
     * @return OperateSwitchStatusResponse OperateSwitchStatusResponse
     */
    public function operateSwitchStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateSwitchStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
     *  *
     * @param OperateVirusEventsRequest $request OperateVirusEventsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateVirusEventsResponse OperateVirusEventsResponse
     */
    public function operateVirusEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->operationAll)) {
            $query['OperationAll'] = $request->operationAll;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->operationRange)) {
            $query['OperationRange'] = $request->operationRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateVirusEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateVirusEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
     *  *
     * @param OperateVirusEventsRequest $request OperateVirusEventsRequest
     *
     * @return OperateVirusEventsResponse OperateVirusEventsResponse
     */
    public function operateVirusEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateVirusEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Fixes Linux software vulnerabilities.
     *  *
     * @param OperateVulsRequest $request OperateVulsRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateVulsResponse OperateVulsResponse
     */
    public function operateVulsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->vulNames)) {
            $query['VulNames'] = $request->vulNames;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateVuls',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateVulsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Fixes Linux software vulnerabilities.
     *  *
     * @param OperateVulsRequest $request OperateVulsRequest
     *
     * @return OperateVulsResponse OperateVulsResponse
     */
    public function operateVuls($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateVulsWithOptions($request, $runtime);
    }

    /**
     * @summary Handles alert events that are generated for web tamper proofing.
     *  *
     * @param OperateWebLockFileEventsRequest $request OperateWebLockFileEventsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateWebLockFileEventsResponse OperateWebLockFileEventsResponse
     */
    public function operateWebLockFileEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dealAll)) {
            $query['DealAll'] = $request->dealAll;
        }
        if (!Utils::isUnset($request->eventIds)) {
            $query['EventIds'] = $request->eventIds;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateWebLockFileEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateWebLockFileEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles alert events that are generated for web tamper proofing.
     *  *
     * @param OperateWebLockFileEventsRequest $request OperateWebLockFileEventsRequest
     *
     * @return OperateWebLockFileEventsResponse OperateWebLockFileEventsResponse
     */
    public function operateWebLockFileEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateWebLockFileEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Cancels ignoring alert events.
     *  *
     * @param OperationCancelIgnoreSuspEventRequest $request OperationCancelIgnoreSuspEventRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return OperationCancelIgnoreSuspEventResponse OperationCancelIgnoreSuspEventResponse
     */
    public function operationCancelIgnoreSuspEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->securityEventIds)) {
            $query['SecurityEventIds'] = $request->securityEventIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperationCancelIgnoreSuspEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperationCancelIgnoreSuspEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Cancels ignoring alert events.
     *  *
     * @param OperationCancelIgnoreSuspEventRequest $request OperationCancelIgnoreSuspEventRequest
     *
     * @return OperationCancelIgnoreSuspEventResponse OperationCancelIgnoreSuspEventResponse
     */
    public function operationCancelIgnoreSuspEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operationCancelIgnoreSuspEventWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the chart of a security report.
     *  *
     * @param OperationCustomizeReportChartRequest $request OperationCustomizeReportChartRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return OperationCustomizeReportChartResponse OperationCustomizeReportChartResponse
     */
    public function operationCustomizeReportChartWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->chartIds)) {
            $query['ChartIds'] = $request->chartIds;
        }
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperationCustomizeReportChart',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperationCustomizeReportChartResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the chart of a security report.
     *  *
     * @param OperationCustomizeReportChartRequest $request OperationCustomizeReportChartRequest
     *
     * @return OperationCustomizeReportChartResponse OperationCustomizeReportChartResponse
     */
    public function operationCustomizeReportChart($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operationCustomizeReportChartWithOptions($request, $runtime);
    }

    /**
     * @summary Handles multiple exceptions at a time.
     *  *
     * @param OperationSuspEventsRequest $request OperationSuspEventsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return OperationSuspEventsResponse OperationSuspEventsResponse
     */
    public function operationSuspEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->operation)) {
            $query['Operation'] = $request->operation;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->subOperation)) {
            $query['SubOperation'] = $request->subOperation;
        }
        if (!Utils::isUnset($request->suspiciousEventIds)) {
            $query['SuspiciousEventIds'] = $request->suspiciousEventIds;
        }
        if (!Utils::isUnset($request->warnType)) {
            $query['WarnType'] = $request->warnType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperationSuspEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperationSuspEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles multiple exceptions at a time.
     *  *
     * @param OperationSuspEventsRequest $request OperationSuspEventsRequest
     *
     * @return OperationSuspEventsResponse OperationSuspEventsResponse
     */
    public function operationSuspEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operationSuspEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries image repositories by page.
     *  *
     * @param PageImageRegistryRequest $request PageImageRegistryRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return PageImageRegistryResponse PageImageRegistryResponse
     */
    public function pageImageRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->currentPage)) {
            $body['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->registryNameLike)) {
            $body['RegistryNameLike'] = $request->registryNameLike;
        }
        if (!Utils::isUnset($request->registryTypeInList)) {
            $body['RegistryTypeInList'] = $request->registryTypeInList;
        }
        if (!Utils::isUnset($request->registryTypeNotInList)) {
            $body['RegistryTypeNotInList'] = $request->registryTypeNotInList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'PageImageRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PageImageRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries image repositories by page.
     *  *
     * @param PageImageRegistryRequest $request PageImageRegistryRequest
     *
     * @return PageImageRegistryResponse PageImageRegistryResponse
     */
    public function pageImageRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->pageImageRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables the Security Center agent.
     *  *
     * @param PauseClientRequest $request PauseClientRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return PauseClientResponse PauseClientResponse
     */
    public function pauseClientWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PauseClient',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PauseClientResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables the Security Center agent.
     *  *
     * @param PauseClientRequest $request PauseClientRequest
     *
     * @return PauseClientResponse PauseClientResponse
     */
    public function pauseClient($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->pauseClientWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an image scan task.
     *  *
     * @description Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
     *  *
     * @param PublicCreateImageScanTaskRequest $request PublicCreateImageScanTaskRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return PublicCreateImageScanTaskResponse PublicCreateImageScanTaskResponse
     */
    public function publicCreateImageScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->digests)) {
            $query['Digests'] = $request->digests;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->regionIds)) {
            $query['RegionIds'] = $request->regionIds;
        }
        if (!Utils::isUnset($request->registryTypes)) {
            $query['RegistryTypes'] = $request->registryTypes;
        }
        if (!Utils::isUnset($request->repoIds)) {
            $query['RepoIds'] = $request->repoIds;
        }
        if (!Utils::isUnset($request->repoNames)) {
            $query['RepoNames'] = $request->repoNames;
        }
        if (!Utils::isUnset($request->repoNamespaces)) {
            $query['RepoNamespaces'] = $request->repoNamespaces;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PublicCreateImageScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublicCreateImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an image scan task.
     *  *
     * @description Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
     *  *
     * @param PublicCreateImageScanTaskRequest $request PublicCreateImageScanTaskRequest
     *
     * @return PublicCreateImageScanTaskResponse PublicCreateImageScanTaskResponse
     */
    public function publicCreateImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publicCreateImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary 预检测，不会实际创建扫描任务，返回本次扫描涉及的镜像数量和消耗授权数量。
     *  *
     * @param PublicPreCheckImageScanTaskRequest $request PublicPreCheckImageScanTaskRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return PublicPreCheckImageScanTaskResponse PublicPreCheckImageScanTaskResponse
     */
    public function publicPreCheckImageScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->digests)) {
            $query['Digests'] = $request->digests;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->regionIds)) {
            $query['RegionIds'] = $request->regionIds;
        }
        if (!Utils::isUnset($request->registryTypes)) {
            $query['RegistryTypes'] = $request->registryTypes;
        }
        if (!Utils::isUnset($request->repoIds)) {
            $query['RepoIds'] = $request->repoIds;
        }
        if (!Utils::isUnset($request->repoNames)) {
            $query['RepoNames'] = $request->repoNames;
        }
        if (!Utils::isUnset($request->repoNamespaces)) {
            $query['RepoNamespaces'] = $request->repoNamespaces;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PublicPreCheckImageScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublicPreCheckImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 预检测，不会实际创建扫描任务，返回本次扫描涉及的镜像数量和消耗授权数量。
     *  *
     * @param PublicPreCheckImageScanTaskRequest $request PublicPreCheckImageScanTaskRequest
     *
     * @return PublicPreCheckImageScanTaskResponse PublicPreCheckImageScanTaskResponse
     */
    public function publicPreCheckImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publicPreCheckImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Adds images to Security Center and creates an image scan task to scan the images.
     *  *
     * @param PublicSyncAndCreateImageScanTaskRequest $request PublicSyncAndCreateImageScanTaskRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return PublicSyncAndCreateImageScanTaskResponse PublicSyncAndCreateImageScanTaskResponse
     */
    public function publicSyncAndCreateImageScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->images)) {
            $query['Images'] = $request->images;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PublicSyncAndCreateImageScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublicSyncAndCreateImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds images to Security Center and creates an image scan task to scan the images.
     *  *
     * @param PublicSyncAndCreateImageScanTaskRequest $request PublicSyncAndCreateImageScanTaskRequest
     *
     * @return PublicSyncAndCreateImageScanTaskResponse PublicSyncAndCreateImageScanTaskResponse
     */
    public function publicSyncAndCreateImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publicSyncAndCreateImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary 通过UUID获取资产详情，可跨账号
     *  *
     * @param QueryAssetDetailByUUIDRequest $request QueryAssetDetailByUUIDRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryAssetDetailByUUIDResponse QueryAssetDetailByUUIDResponse
     */
    public function queryAssetDetailByUUIDWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->requests)) {
            $body['Requests'] = $request->requests;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryAssetDetailByUUID',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryAssetDetailByUUIDResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 通过UUID获取资产详情，可跨账号
     *  *
     * @param QueryAssetDetailByUUIDRequest $request QueryAssetDetailByUUIDRequest
     *
     * @return QueryAssetDetailByUUIDResponse QueryAssetDetailByUUIDResponse
     */
    public function queryAssetDetailByUUID($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryAssetDetailByUUIDWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of alert events in each attack phase.
     *  *
     * @param QueryAttackCountRequest $request QueryAttackCountRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryAttackCountResponse QueryAttackCountResponse
     */
    public function queryAttackCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $body = [];
        if (!Utils::isUnset($request->from)) {
            $body['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryAttackCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryAttackCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of alert events in each attack phase.
     *  *
     * @param QueryAttackCountRequest $request QueryAttackCountRequest
     *
     * @return QueryAttackCountResponse QueryAttackCountResponse
     */
    public function queryAttackCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryAttackCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a database scan task.
     *  *
     * @param QueryDiscoverDatabaseRequest $request QueryDiscoverDatabaseRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryDiscoverDatabaseResponse QueryDiscoverDatabaseResponse
     */
    public function queryDiscoverDatabaseWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->createMark)) {
            $query['CreateMark'] = $request->createMark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryDiscoverDatabase',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryDiscoverDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a database scan task.
     *  *
     * @param QueryDiscoverDatabaseRequest $request QueryDiscoverDatabaseRequest
     *
     * @return QueryDiscoverDatabaseResponse QueryDiscoverDatabaseResponse
     */
    public function queryDiscoverDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryDiscoverDatabaseWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the ID of an asset group by using the name of the asset group.
     *  *
     * @description You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param QueryGroupIdByGroupNameRequest $request QueryGroupIdByGroupNameRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryGroupIdByGroupNameResponse QueryGroupIdByGroupNameResponse
     */
    public function queryGroupIdByGroupNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupName)) {
            $query['GroupName'] = $request->groupName;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryGroupIdByGroupName',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryGroupIdByGroupNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the ID of an asset group by using the name of the asset group.
     *  *
     * @description You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param QueryGroupIdByGroupNameRequest $request QueryGroupIdByGroupNameRequest
     *
     * @return QueryGroupIdByGroupNameResponse QueryGroupIdByGroupNameResponse
     */
    public function queryGroupIdByGroupName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryGroupIdByGroupNameWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whitelist rules.
     *  *
     * @param QueryGroupedSecurityEventMarkMissListRequest $request QueryGroupedSecurityEventMarkMissListRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryGroupedSecurityEventMarkMissListResponse QueryGroupedSecurityEventMarkMissListResponse
     */
    public function queryGroupedSecurityEventMarkMissListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->disposalWay)) {
            $query['DisposalWay'] = $request->disposalWay;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->currentPage)) {
            $body['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventName)) {
            $body['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->from)) {
            $body['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $body['Remark'] = $request->remark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryGroupedSecurityEventMarkMissList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryGroupedSecurityEventMarkMissListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whitelist rules.
     *  *
     * @param QueryGroupedSecurityEventMarkMissListRequest $request QueryGroupedSecurityEventMarkMissListRequest
     *
     * @return QueryGroupedSecurityEventMarkMissListResponse QueryGroupedSecurityEventMarkMissListResponse
     */
    public function queryGroupedSecurityEventMarkMissList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryGroupedSecurityEventMarkMissListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of beginner tasks. Security Center provides rewards for users who complete tasks. The rewards include the quota for a value-added feature and log storage capacity.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryGuidTaskListResponse QueryGuidTaskListResponse
     */
    public function queryGuidTaskListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'QueryGuidTaskList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryGuidTaskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of beginner tasks. Security Center provides rewards for users who complete tasks. The rewards include the quota for a value-added feature and log storage capacity.
     *  *
     * @return QueryGuidTaskListResponse QueryGuidTaskListResponse
     */
    public function queryGuidTaskList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryGuidTaskListWithOptions($runtime);
    }

    /**
     * @summary Queries the icons that correspond to nodes and edges.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentIconListResponse QueryIncidentIconListResponse
     */
    public function queryIncidentIconListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'QueryIncidentIconList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentIconListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the icons that correspond to nodes and edges.
     *  *
     * @return QueryIncidentIconListResponse QueryIncidentIconListResponse
     */
    public function queryIncidentIconList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentIconListWithOptions($runtime);
    }

    /**
     * @summary Queries whether a node can be drilled down.
     *  *
     * @param QueryIncidentSubNodesCountRequest $request QueryIncidentSubNodesCountRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentSubNodesCountResponse QueryIncidentSubNodesCountResponse
     */
    public function queryIncidentSubNodesCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->body)) {
            $body['body'] = $request->body;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentSubNodesCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentSubNodesCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether a node can be drilled down.
     *  *
     * @param QueryIncidentSubNodesCountRequest $request QueryIncidentSubNodesCountRequest
     *
     * @return QueryIncidentSubNodesCountResponse QueryIncidentSubNodesCountResponse
     */
    public function queryIncidentSubNodesCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentSubNodesCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the provenance graph of an event by using the event ID.
     *  *
     * @param QueryIncidentTracingDetailRequest $request QueryIncidentTracingDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentTracingDetailResponse QueryIncidentTracingDetailResponse
     */
    public function queryIncidentTracingDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->incidentId)) {
            $body['IncidentId'] = $request->incidentId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentTracingDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentTracingDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the provenance graph of an event by using the event ID.
     *  *
     * @param QueryIncidentTracingDetailRequest $request QueryIncidentTracingDetailRequest
     *
     * @return QueryIncidentTracingDetailResponse QueryIncidentTracingDetailResponse
     */
    public function queryIncidentTracingDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentTracingDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether an event has a provenance graph based on the event ID.
     *  *
     * @param QueryIncidentTracingJudgeRequest $request QueryIncidentTracingJudgeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentTracingJudgeResponse QueryIncidentTracingJudgeResponse
     */
    public function queryIncidentTracingJudgeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->incidentId)) {
            $body['IncidentId'] = $request->incidentId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentTracingJudge',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentTracingJudgeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether an event has a provenance graph based on the event ID.
     *  *
     * @param QueryIncidentTracingJudgeRequest $request QueryIncidentTracingJudgeRequest
     *
     * @return QueryIncidentTracingJudgeResponse QueryIncidentTracingJudgeResponse
     */
    public function queryIncidentTracingJudge($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentTracingJudgeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the extended information about an event node.
     *  *
     * @param QueryIncidentVertexExtendInfoRequest $request QueryIncidentVertexExtendInfoRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentVertexExtendInfoResponse QueryIncidentVertexExtendInfoResponse
     */
    public function queryIncidentVertexExtendInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->offset)) {
            $body['Offset'] = $request->offset;
        }
        if (!Utils::isUnset($request->relationType)) {
            $body['RelationType'] = $request->relationType;
        }
        if (!Utils::isUnset($request->size)) {
            $body['Size'] = $request->size;
        }
        if (!Utils::isUnset($request->vertexId)) {
            $body['VertexId'] = $request->vertexId;
        }
        if (!Utils::isUnset($request->vertexLabel)) {
            $body['VertexLabel'] = $request->vertexLabel;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentVertexExtendInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentVertexExtendInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the extended information about an event node.
     *  *
     * @param QueryIncidentVertexExtendInfoRequest $request QueryIncidentVertexExtendInfoRequest
     *
     * @return QueryIncidentVertexExtendInfoResponse QueryIncidentVertexExtendInfoResponse
     */
    public function queryIncidentVertexExtendInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentVertexExtendInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the detailed information about an event node.
     *  *
     * @param QueryIncidentVertexNodesRequest $tmpReq  QueryIncidentVertexNodesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentVertexNodesResponse QueryIncidentVertexNodesResponse
     */
    public function queryIncidentVertexNodesWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new QueryIncidentVertexNodesShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->edgeLabelList)) {
            $request->edgeLabelListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->edgeLabelList, 'EdgeLabelList', 'simple');
        }
        $body = [];
        if (!Utils::isUnset($request->edgeLabelListShrink)) {
            $body['EdgeLabelList'] = $request->edgeLabelListShrink;
        }
        if (!Utils::isUnset($request->offset)) {
            $body['Offset'] = $request->offset;
        }
        if (!Utils::isUnset($request->size)) {
            $body['Size'] = $request->size;
        }
        if (!Utils::isUnset($request->vertexId)) {
            $body['VertexId'] = $request->vertexId;
        }
        if (!Utils::isUnset($request->vertexLabel)) {
            $body['VertexLabel'] = $request->vertexLabel;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentVertexNodes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentVertexNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the detailed information about an event node.
     *  *
     * @param QueryIncidentVertexNodesRequest $request QueryIncidentVertexNodesRequest
     *
     * @return QueryIncidentVertexNodesResponse QueryIncidentVertexNodesResponse
     */
    public function queryIncidentVertexNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentVertexNodesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the retention period of images that are stored in a Jenkins image repository.
     *  *
     * @param QueryJenkinsImageRegistryPersistenceDayRequest $request QueryJenkinsImageRegistryPersistenceDayRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryJenkinsImageRegistryPersistenceDayResponse QueryJenkinsImageRegistryPersistenceDayResponse
     */
    public function queryJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryJenkinsImageRegistryPersistenceDay',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryJenkinsImageRegistryPersistenceDayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the retention period of images that are stored in a Jenkins image repository.
     *  *
     * @param QueryJenkinsImageRegistryPersistenceDayRequest $request QueryJenkinsImageRegistryPersistenceDayRequest
     *
     * @return QueryJenkinsImageRegistryPersistenceDayResponse QueryJenkinsImageRegistryPersistenceDayResponse
     */
    public function queryJenkinsImageRegistryPersistenceDay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the result of a database precheck task.
     *  *
     * @param QueryPreCheckDatabaseRequest $request QueryPreCheckDatabaseRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryPreCheckDatabaseResponse QueryPreCheckDatabaseResponse
     */
    public function queryPreCheckDatabaseWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceUuid)) {
            $query['InstanceUuid'] = $request->instanceUuid;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->uniRegionId)) {
            $query['UniRegionId'] = $request->uniRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryPreCheckDatabase',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryPreCheckDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the result of a database precheck task.
     *  *
     * @param QueryPreCheckDatabaseRequest $request QueryPreCheckDatabaseRequest
     *
     * @return QueryPreCheckDatabaseResponse QueryPreCheckDatabaseResponse
     */
    public function queryPreCheckDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryPreCheckDatabaseWithOptions($request, $runtime);
    }

    /**
     * @summary Restarts a server. Only Windows servers are supported.
     *  *
     * @param RebootMachineRequest $request RebootMachineRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return RebootMachineResponse RebootMachineResponse
     */
    public function rebootMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RebootMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RebootMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Restarts a server. Only Windows servers are supported.
     *  *
     * @param RebootMachineRequest $request RebootMachineRequest
     *
     * @return RebootMachineResponse RebootMachineResponse
     */
    public function rebootMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rebootMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Receives a reward that allows you to enable a free trial of the cloud honeypot feature or the feature of SDK for malicious file detection. You can receive a reward after you complete the required task.
     *  *
     * @param ReceiveFunctionTrialRewardByAliUidRequest $request ReceiveFunctionTrialRewardByAliUidRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return ReceiveFunctionTrialRewardByAliUidResponse ReceiveFunctionTrialRewardByAliUidResponse
     */
    public function receiveFunctionTrialRewardByAliUidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->functionName)) {
            $query['FunctionName'] = $request->functionName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ReceiveFunctionTrialRewardByAliUid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ReceiveFunctionTrialRewardByAliUidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Receives a reward that allows you to enable a free trial of the cloud honeypot feature or the feature of SDK for malicious file detection. You can receive a reward after you complete the required task.
     *  *
     * @param ReceiveFunctionTrialRewardByAliUidRequest $request ReceiveFunctionTrialRewardByAliUidRequest
     *
     * @return ReceiveFunctionTrialRewardByAliUidResponse ReceiveFunctionTrialRewardByAliUidResponse
     */
    public function receiveFunctionTrialRewardByAliUid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->receiveFunctionTrialRewardByAliUidWithOptions($request, $runtime);
    }

    /**
     * @summary Synchronizes assets.
     *  *
     * @param RefreshAssetsRequest $request RefreshAssetsRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return RefreshAssetsResponse RefreshAssetsResponse
     */
    public function refreshAssetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        if (!Utils::isUnset($request->cloudAssetSubType)) {
            $query['CloudAssetSubType'] = $request->cloudAssetSubType;
        }
        if (!Utils::isUnset($request->cloudAssetType)) {
            $query['CloudAssetType'] = $request->cloudAssetType;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RefreshAssets',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RefreshAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Synchronizes assets.
     *  *
     * @param RefreshAssetsRequest $request RefreshAssetsRequest
     *
     * @return RefreshAssetsResponse RefreshAssetsResponse
     */
    public function refreshAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshAssetsWithOptions($request, $runtime);
    }

    /**
     * @summary Refreshes the statistics of container assets in the Assets module.
     *  *
     * @param RefreshContainerAssetsRequest $request RefreshContainerAssetsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return RefreshContainerAssetsResponse RefreshContainerAssetsResponse
     */
    public function refreshContainerAssetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RefreshContainerAssets',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RefreshContainerAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Refreshes the statistics of container assets in the Assets module.
     *  *
     * @param RefreshContainerAssetsRequest $request RefreshContainerAssetsRequest
     *
     * @return RefreshContainerAssetsResponse RefreshContainerAssetsResponse
     */
    public function refreshContainerAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshContainerAssetsWithOptions($request, $runtime);
    }

    /**
     * @summary Refreshes the list of Object Storage Service (OSS) buckets.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return RefreshOssBucketScanInfoResponse RefreshOssBucketScanInfoResponse
     */
    public function refreshOssBucketScanInfoWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'RefreshOssBucketScanInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RefreshOssBucketScanInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Refreshes the list of Object Storage Service (OSS) buckets.
     *  *
     * @return RefreshOssBucketScanInfoResponse RefreshOssBucketScanInfoResponse
     */
    public function refreshOssBucketScanInfo()
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshOssBucketScanInfoWithOptions($runtime);
    }

    /**
     * @summary 刷新仓库token
     *  *
     * @param RefreshRegistryTokenRequest $request RefreshRegistryTokenRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return RefreshRegistryTokenResponse RefreshRegistryTokenResponse
     */
    public function refreshRegistryTokenWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->registryId)) {
            $query['RegistryId'] = $request->registryId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RefreshRegistryToken',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RefreshRegistryTokenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 刷新仓库token
     *  *
     * @param RefreshRegistryTokenRequest $request RefreshRegistryTokenRequest
     *
     * @return RefreshRegistryTokenResponse RefreshRegistryTokenResponse
     */
    public function refreshRegistryToken($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshRegistryTokenWithOptions($request, $runtime);
    }

    /**
     * @summary 释放云安全中心实例
     *  *
     * @param ReleaseSasInstanceRequest $request ReleaseSasInstanceRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ReleaseSasInstanceResponse ReleaseSasInstanceResponse
     */
    public function releaseSasInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->chargeType)) {
            $body['ChargeType'] = $request->chargeType;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ReleaseSasInstance',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ReleaseSasInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 释放云安全中心实例
     *  *
     * @param ReleaseSasInstanceRequest $request ReleaseSasInstanceRequest
     *
     * @return ReleaseSasInstanceResponse ReleaseSasInstanceResponse
     */
    public function releaseSasInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseSasInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Removes an instance from the whitelist.
     *  *
     * @param RemoveCheckInstanceResultWhiteListRequest $request RemoveCheckInstanceResultWhiteListRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveCheckInstanceResultWhiteListResponse RemoveCheckInstanceResultWhiteListResponse
     */
    public function removeCheckInstanceResultWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveCheckInstanceResultWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveCheckInstanceResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes an instance from the whitelist.
     *  *
     * @param RemoveCheckInstanceResultWhiteListRequest $request RemoveCheckInstanceResultWhiteListRequest
     *
     * @return RemoveCheckInstanceResultWhiteListResponse RemoveCheckInstanceResultWhiteListResponse
     */
    public function removeCheckInstanceResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeCheckInstanceResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Removes check items from the whitelist.
     *  *
     * @param RemoveCheckResultWhiteListRequest $request RemoveCheckResultWhiteListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveCheckResultWhiteListResponse RemoveCheckResultWhiteListResponse
     */
    public function removeCheckResultWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkGroupId)) {
            $query['CheckGroupId'] = $request->checkGroupId;
        }
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveCheckResultWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveCheckResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes check items from the whitelist.
     *  *
     * @param RemoveCheckResultWhiteListRequest $request RemoveCheckResultWhiteListRequest
     *
     * @return RemoveCheckResultWhiteListResponse RemoveCheckResultWhiteListResponse
     */
    public function removeCheckResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeCheckResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Resets a honeypot.
     *  *
     * @param ResetHoneypotRequest $request ResetHoneypotRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ResetHoneypotResponse ResetHoneypotResponse
     */
    public function resetHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ResetHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ResetHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Resets a honeypot.
     *  *
     * @param ResetHoneypotRequest $request ResetHoneypotRequest
     *
     * @return ResetHoneypotResponse ResetHoneypotResponse
     */
    public function resetHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resetHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Resets and upgrades the log analysis feature. You can call this operation only when the log analysis feature uses the pay-as-you-go billing method.
     *  *
     * @param ResetLogShipperRequest $request ResetLogShipperRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ResetLogShipperResponse ResetLogShipperResponse
     */
    public function resetLogShipperWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->hotTtl)) {
            $query['HotTtl'] = $request->hotTtl;
        }
        if (!Utils::isUnset($request->logMetaList)) {
            $query['LogMetaList'] = $request->logMetaList;
        }
        if (!Utils::isUnset($request->ttl)) {
            $query['Ttl'] = $request->ttl;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ResetLogShipper',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ResetLogShipperResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Resets and upgrades the log analysis feature. You can call this operation only when the log analysis feature uses the pay-as-you-go billing method.
     *  *
     * @param ResetLogShipperRequest $request ResetLogShipperRequest
     *
     * @return ResetLogShipperResponse ResetLogShipperResponse
     */
    public function resetLogShipper($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resetLogShipperWithOptions($request, $runtime);
    }

    /**
     * @summary Retries agentless detection tasks.
     *  *
     * @param RetryAgentlessTaskRequest $request RetryAgentlessTaskRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return RetryAgentlessTaskResponse RetryAgentlessTaskResponse
     */
    public function retryAgentlessTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RetryAgentlessTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RetryAgentlessTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Retries agentless detection tasks.
     *  *
     * @param RetryAgentlessTaskRequest $request RetryAgentlessTaskRequest
     *
     * @return RetryAgentlessTaskResponse RetryAgentlessTaskResponse
     */
    public function retryAgentlessTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->retryAgentlessTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Retry installing the honeypot probe.
     *  *
     * @param RetryInstallProbeRequest $request RetryInstallProbeRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return RetryInstallProbeResponse RetryInstallProbeResponse
     */
    public function retryInstallProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RetryInstallProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RetryInstallProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Retry installing the honeypot probe.
     *  *
     * @param RetryInstallProbeRequest $request RetryInstallProbeRequest
     *
     * @return RetryInstallProbeResponse RetryInstallProbeResponse
     */
    public function retryInstallProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->retryInstallProbeWithOptions($request, $runtime);
    }

    /**
     * @summary 取消对文件隔离箱中文件的隔离
     *  *
     * @param RollbackSuspEventQuaraFileRequest $request RollbackSuspEventQuaraFileRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return RollbackSuspEventQuaraFileResponse RollbackSuspEventQuaraFileResponse
     */
    public function rollbackSuspEventQuaraFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->quaraFileId)) {
            $query['QuaraFileId'] = $request->quaraFileId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RollbackSuspEventQuaraFile',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RollbackSuspEventQuaraFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 取消对文件隔离箱中文件的隔离
     *  *
     * @param RollbackSuspEventQuaraFileRequest $request RollbackSuspEventQuaraFileRequest
     *
     * @return RollbackSuspEventQuaraFileResponse RollbackSuspEventQuaraFileResponse
     */
    public function rollbackSuspEventQuaraFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rollbackSuspEventQuaraFileWithOptions($request, $runtime);
    }

    /**
     * @summary SasInstallCode
     *  *
     * @param SasInstallCodeRequest $request SasInstallCodeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return SasInstallCodeResponse SasInstallCodeResponse
     */
    public function sasInstallCodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SasInstallCode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SasInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary SasInstallCode
     *  *
     * @param SasInstallCodeRequest $request SasInstallCodeRequest
     *
     * @return SasInstallCodeResponse SasInstallCodeResponse
     */
    public function sasInstallCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sasInstallCodeWithOptions($request, $runtime);
    }

    /**
     * @summary Saves the configurations of a custom security report.
     *  *
     * @param SaveCustomizeReportConfigRequest $request SaveCustomizeReportConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return SaveCustomizeReportConfigResponse SaveCustomizeReportConfigResponse
     */
    public function saveCustomizeReportConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupType)) {
            $query['GroupType'] = $request->groupType;
        }
        if (!Utils::isUnset($request->pinnedTime)) {
            $query['PinnedTime'] = $request->pinnedTime;
        }
        if (!Utils::isUnset($request->recipients)) {
            $query['Recipients'] = $request->recipients;
        }
        if (!Utils::isUnset($request->reportDays)) {
            $query['ReportDays'] = $request->reportDays;
        }
        if (!Utils::isUnset($request->reportEndDate)) {
            $query['ReportEndDate'] = $request->reportEndDate;
        }
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        if (!Utils::isUnset($request->reportLang)) {
            $query['ReportLang'] = $request->reportLang;
        }
        if (!Utils::isUnset($request->reportSendType)) {
            $query['ReportSendType'] = $request->reportSendType;
        }
        if (!Utils::isUnset($request->reportStartDate)) {
            $query['ReportStartDate'] = $request->reportStartDate;
        }
        if (!Utils::isUnset($request->reportStatus)) {
            $query['ReportStatus'] = $request->reportStatus;
        }
        if (!Utils::isUnset($request->reportType)) {
            $query['ReportType'] = $request->reportType;
        }
        if (!Utils::isUnset($request->reportVersion)) {
            $query['ReportVersion'] = $request->reportVersion;
        }
        if (!Utils::isUnset($request->sendEndTime)) {
            $query['SendEndTime'] = $request->sendEndTime;
        }
        if (!Utils::isUnset($request->sendPeriodDays)) {
            $query['SendPeriodDays'] = $request->sendPeriodDays;
        }
        if (!Utils::isUnset($request->sendPeriodType)) {
            $query['SendPeriodType'] = $request->sendPeriodType;
        }
        if (!Utils::isUnset($request->sendStartTime)) {
            $query['SendStartTime'] = $request->sendStartTime;
        }
        if (!Utils::isUnset($request->targetGroups)) {
            $query['TargetGroups'] = $request->targetGroups;
        }
        if (!Utils::isUnset($request->targetUids)) {
            $query['TargetUids'] = $request->targetUids;
        }
        if (!Utils::isUnset($request->title)) {
            $query['Title'] = $request->title;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SaveCustomizeReportConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SaveCustomizeReportConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Saves the configurations of a custom security report.
     *  *
     * @param SaveCustomizeReportConfigRequest $request SaveCustomizeReportConfigRequest
     *
     * @return SaveCustomizeReportConfigResponse SaveCustomizeReportConfigResponse
     */
    public function saveCustomizeReportConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveCustomizeReportConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Saves a baseline check policy for images.
     *  *
     * @param SaveImageBaselineStrategyRequest $request SaveImageBaselineStrategyRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return SaveImageBaselineStrategyResponse SaveImageBaselineStrategyResponse
     */
    public function saveImageBaselineStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineItemList)) {
            $query['BaselineItemList'] = $request->baselineItemList;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SaveImageBaselineStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SaveImageBaselineStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Saves a baseline check policy for images.
     *  *
     * @param SaveImageBaselineStrategyRequest $request SaveImageBaselineStrategyRequest
     *
     * @return SaveImageBaselineStrategyResponse SaveImageBaselineStrategyResponse
     */
    public function saveImageBaselineStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveImageBaselineStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Saves alert settings.
     *  *
     * @param SaveSuspEventUserSettingRequest $request SaveSuspEventUserSettingRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return SaveSuspEventUserSettingResponse SaveSuspEventUserSettingResponse
     */
    public function saveSuspEventUserSettingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->levelsOn)) {
            $query['LevelsOn'] = $request->levelsOn;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SaveSuspEventUserSetting',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SaveSuspEventUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Saves alert settings.
     *  *
     * @param SaveSuspEventUserSettingRequest $request SaveSuspEventUserSettingRequest
     *
     * @return SaveSuspEventUserSettingResponse SaveSuspEventUserSettingResponse
     */
    public function saveSuspEventUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveSuspEventUserSettingWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an application whitelist policy.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or enabled the feature, you can call this operation.
     *  *
     * @param SaveWhiteListStrategyRequest $request SaveWhiteListStrategyRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return SaveWhiteListStrategyResponse SaveWhiteListStrategyResponse
     */
    public function saveWhiteListStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        if (!Utils::isUnset($request->studyTime)) {
            $query['StudyTime'] = $request->studyTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SaveWhiteListStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SaveWhiteListStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an application whitelist policy.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or enabled the feature, you can call this operation.
     *  *
     * @param SaveWhiteListStrategyRequest $request SaveWhiteListStrategyRequest
     *
     * @return SaveWhiteListStrategyResponse SaveWhiteListStrategyResponse
     */
    public function saveWhiteListStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveWhiteListStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary 编辑应用白名单策略配置的服务器
     *  *
     * @param SaveWhiteListStrategyAssetsRequest $request SaveWhiteListStrategyAssetsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return SaveWhiteListStrategyAssetsResponse SaveWhiteListStrategyAssetsResponse
     */
    public function saveWhiteListStrategyAssetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->operations)) {
            $query['Operations'] = $request->operations;
        }
        if (!Utils::isUnset($request->relationType)) {
            $query['RelationType'] = $request->relationType;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SaveWhiteListStrategyAssets',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SaveWhiteListStrategyAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 编辑应用白名单策略配置的服务器
     *  *
     * @param SaveWhiteListStrategyAssetsRequest $request SaveWhiteListStrategyAssetsRequest
     *
     * @return SaveWhiteListStrategyAssetsResponse SaveWhiteListStrategyAssetsResponse
     */
    public function saveWhiteListStrategyAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveWhiteListStrategyAssetsWithOptions($request, $runtime);
    }

    /**
     * @summary Sends a security report to an email address that you specify. You can send only a security report whose statistics are collected in a custom time range.
     *  *
     * @param SendCustomizeReportRequest $request SendCustomizeReportRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return SendCustomizeReportResponse SendCustomizeReportResponse
     */
    public function sendCustomizeReportWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SendCustomizeReport',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SendCustomizeReportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sends a security report to an email address that you specify. You can send only a security report whose statistics are collected in a custom time range.
     *  *
     * @param SendCustomizeReportRequest $request SendCustomizeReportRequest
     *
     * @return SendCustomizeReportResponse SendCustomizeReportResponse
     */
    public function sendCustomizeReport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sendCustomizeReportWithOptions($request, $runtime);
    }

    /**
     * @summary 设置用户的构建指令风险规则配置
     *  *
     * @param SetBuildRiskDefineRuleConfigRequest $request SetBuildRiskDefineRuleConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return SetBuildRiskDefineRuleConfigResponse SetBuildRiskDefineRuleConfigResponse
     */
    public function setBuildRiskDefineRuleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetBuildRiskDefineRuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetBuildRiskDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 设置用户的构建指令风险规则配置
     *  *
     * @param SetBuildRiskDefineRuleConfigRequest $request SetBuildRiskDefineRuleConfigRequest
     *
     * @return SetBuildRiskDefineRuleConfigResponse SetBuildRiskDefineRuleConfigResponse
     */
    public function setBuildRiskDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setBuildRiskDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures the status of the container firewall feature.
     *  *
     * @param SetClusterInterceptionConfigRequest $request SetClusterInterceptionConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return SetClusterInterceptionConfigResponse SetClusterInterceptionConfigResponse
     */
    public function setClusterInterceptionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        if (!Utils::isUnset($request->switchOn)) {
            $query['SwitchOn'] = $request->switchOn;
        }
        if (!Utils::isUnset($request->switchType)) {
            $query['SwitchType'] = $request->switchType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetClusterInterceptionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetClusterInterceptionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures the status of the container firewall feature.
     *  *
     * @param SetClusterInterceptionConfigRequest $request SetClusterInterceptionConfigRequest
     *
     * @return SetClusterInterceptionConfigResponse SetClusterInterceptionConfigResponse
     */
    public function setClusterInterceptionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setClusterInterceptionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary 设置镜像构建风险状态。
     *  *
     * @param SetImageBuildRiskStatusRequest $request SetImageBuildRiskStatusRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return SetImageBuildRiskStatusResponse SetImageBuildRiskStatusResponse
     */
    public function setImageBuildRiskStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->imageUuids)) {
            $query['ImageUuids'] = $request->imageUuids;
        }
        if (!Utils::isUnset($request->riskKey)) {
            $query['RiskKey'] = $request->riskKey;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetImageBuildRiskStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetImageBuildRiskStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 设置镜像构建风险状态。
     *  *
     * @param SetImageBuildRiskStatusRequest $request SetImageBuildRiskStatusRequest
     *
     * @return SetImageBuildRiskStatusResponse SetImageBuildRiskStatusResponse
     */
    public function setImageBuildRiskStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setImageBuildRiskStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the status of sensitive files in an image.
     *  *
     * @param SetImageSensitiveFileStatusRequest $request SetImageSensitiveFileStatusRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return SetImageSensitiveFileStatusResponse SetImageSensitiveFileStatusResponse
     */
    public function setImageSensitiveFileStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->imageUuids)) {
            $query['ImageUuids'] = $request->imageUuids;
        }
        if (!Utils::isUnset($request->sensitiveFileKey)) {
            $query['SensitiveFileKey'] = $request->sensitiveFileKey;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetImageSensitiveFileStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetImageSensitiveFileStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the status of sensitive files in an image.
     *  *
     * @param SetImageSensitiveFileStatusRequest $request SetImageSensitiveFileStatusRequest
     *
     * @return SetImageSensitiveFileStatusResponse SetImageSensitiveFileStatusResponse
     */
    public function setImageSensitiveFileStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setImageSensitiveFileStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Specifies a cycle to scan images for image repositories. Unit: days.
     *  *
     * @param SetRegistryScanDayNumRequest $request SetRegistryScanDayNumRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return SetRegistryScanDayNumResponse SetRegistryScanDayNumResponse
     */
    public function setRegistryScanDayNumWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->scanDayNum)) {
            $query['ScanDayNum'] = $request->scanDayNum;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetRegistryScanDayNum',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetRegistryScanDayNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Specifies a cycle to scan images for image repositories. Unit: days.
     *  *
     * @param SetRegistryScanDayNumRequest $request SetRegistryScanDayNumRequest
     *
     * @return SetRegistryScanDayNumResponse SetRegistryScanDayNumResponse
     */
    public function setRegistryScanDayNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setRegistryScanDayNumWithOptions($request, $runtime);
    }

    /**
     * @summary Configure the check rules of sensitive files.
     *  *
     * @param SetSensitiveDefineRuleConfigRequest $request SetSensitiveDefineRuleConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return SetSensitiveDefineRuleConfigResponse SetSensitiveDefineRuleConfigResponse
     */
    public function setSensitiveDefineRuleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetSensitiveDefineRuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetSensitiveDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configure the check rules of sensitive files.
     *  *
     * @param SetSensitiveDefineRuleConfigRequest $request SetSensitiveDefineRuleConfigRequest
     *
     * @return SetSensitiveDefineRuleConfigResponse SetSensitiveDefineRuleConfigResponse
     */
    public function setSensitiveDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSensitiveDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures the regions from which you want to synchronize assets.
     *  *
     * @param SetSyncRefreshRegionRequest $request SetSyncRefreshRegionRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return SetSyncRefreshRegionResponse SetSyncRefreshRegionResponse
     */
    public function setSyncRefreshRegionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defaultRegion)) {
            $query['DefaultRegion'] = $request->defaultRegion;
        }
        if (!Utils::isUnset($request->regionIds)) {
            $query['RegionIds'] = $request->regionIds;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetSyncRefreshRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetSyncRefreshRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures the regions from which you want to synchronize assets.
     *  *
     * @param SetSyncRefreshRegionRequest $request SetSyncRefreshRegionRequest
     *
     * @return SetSyncRefreshRegionResponse SetSyncRefreshRegionResponse
     */
    public function setSyncRefreshRegion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSyncRefreshRegionWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI StartBaselineSecurityCheck is deprecated
     *  *
     * @summary Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
     *  *
     * Deprecated
     *
     * @param StartBaselineSecurityCheckRequest $request StartBaselineSecurityCheckRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return StartBaselineSecurityCheckResponse StartBaselineSecurityCheckResponse
     */
    public function startBaselineSecurityCheckWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->itemIds)) {
            $query['ItemIds'] = $request->itemIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartBaselineSecurityCheck',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartBaselineSecurityCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI StartBaselineSecurityCheck is deprecated
     *  *
     * @summary Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
     *  *
     * Deprecated
     *
     * @param StartBaselineSecurityCheckRequest $request StartBaselineSecurityCheckRequest
     *
     * @return StartBaselineSecurityCheckResponse StartBaselineSecurityCheckResponse
     */
    public function startBaselineSecurityCheck($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startBaselineSecurityCheckWithOptions($request, $runtime);
    }

    /**
     * @summary Starts a database scan task.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return StartDiscoverDatabaseTaskResponse StartDiscoverDatabaseTaskResponse
     */
    public function startDiscoverDatabaseTaskWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'StartDiscoverDatabaseTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartDiscoverDatabaseTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a database scan task.
     *  *
     * @return StartDiscoverDatabaseTaskResponse StartDiscoverDatabaseTaskResponse
     */
    public function startDiscoverDatabaseTask()
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDiscoverDatabaseTaskWithOptions($runtime);
    }

    /**
     * @summary Starts a honeypot.
     *  *
     * @param StartHoneypotRequest $request StartHoneypotRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return StartHoneypotResponse StartHoneypotResponse
     */
    public function startHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a honeypot.
     *  *
     * @param StartHoneypotRequest $request StartHoneypotRequest
     *
     * @return StartHoneypotResponse StartHoneypotResponse
     */
    public function startHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Starts an IDC scan task.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return StartIdcProbeScanResponse StartIdcProbeScanResponse
     */
    public function startIdcProbeScanWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'StartIdcProbeScan',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartIdcProbeScanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts an IDC scan task.
     *  *
     * @return StartIdcProbeScanResponse StartIdcProbeScanResponse
     */
    public function startIdcProbeScan()
    {
        $runtime = new RuntimeOptions([]);

        return $this->startIdcProbeScanWithOptions($runtime);
    }

    /**
     * @summary Starts a database precheck task.
     *  *
     * @param StartPreCheckDatabaseRequest $request StartPreCheckDatabaseRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return StartPreCheckDatabaseResponse StartPreCheckDatabaseResponse
     */
    public function startPreCheckDatabaseWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->databaseType)) {
            $query['DatabaseType'] = $request->databaseType;
        }
        if (!Utils::isUnset($request->instanceUuid)) {
            $query['InstanceUuid'] = $request->instanceUuid;
        }
        if (!Utils::isUnset($request->uniRegionId)) {
            $query['UniRegionId'] = $request->uniRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartPreCheckDatabase',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartPreCheckDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a database precheck task.
     *  *
     * @param StartPreCheckDatabaseRequest $request StartPreCheckDatabaseRequest
     *
     * @return StartPreCheckDatabaseResponse StartPreCheckDatabaseResponse
     */
    public function startPreCheckDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startPreCheckDatabaseWithOptions($request, $runtime);
    }

    /**
     * @summary Performs a virus scan task on a server or multiple servers.
     *  *
     * @param StartVirusScanTaskRequest $request StartVirusScanTaskRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return StartVirusScanTaskResponse StartVirusScanTaskResponse
     */
    public function startVirusScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->targetInfo)) {
            $query['TargetInfo'] = $request->targetInfo;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartVirusScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartVirusScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Performs a virus scan task on a server or multiple servers.
     *  *
     * @param StartVirusScanTaskRequest $request StartVirusScanTaskRequest
     *
     * @return StartVirusScanTaskResponse StartVirusScanTaskResponse
     */
    public function startVirusScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startVirusScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a honeypot.
     *  *
     * @param StopHoneypotRequest $request StopHoneypotRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return StopHoneypotResponse StopHoneypotResponse
     */
    public function stopHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StopHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StopHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a honeypot.
     *  *
     * @param StopHoneypotRequest $request StopHoneypotRequest
     *
     * @return StopHoneypotResponse StopHoneypotResponse
     */
    public function stopHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Submits a configuration assessment task.
     *  *
     * @param SubmitCheckRequest $request SubmitCheckRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return SubmitCheckResponse SubmitCheckResponse
     */
    public function submitCheckWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SubmitCheck',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SubmitCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Submits a configuration assessment task.
     *  *
     * @param SubmitCheckRequest $request SubmitCheckRequest
     *
     * @return SubmitCheckResponse SubmitCheckResponse
     */
    public function submitCheck($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitCheckWithOptions($request, $runtime);
    }

    /**
     * @summary 修复回滚任务下发
     *  *
     * @param SubmitOperationTaskRequest $request SubmitOperationTaskRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return SubmitOperationTaskResponse SubmitOperationTaskResponse
     */
    public function submitOperationTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->dimensionType)) {
            $query['DimensionType'] = $request->dimensionType;
        }
        if (!Utils::isUnset($request->operationTaskInstances)) {
            $query['OperationTaskInstances'] = $request->operationTaskInstances;
        }
        if (!Utils::isUnset($request->repairTempParam)) {
            $query['RepairTempParam'] = $request->repairTempParam;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SubmitOperationTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SubmitOperationTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 修复回滚任务下发
     *  *
     * @param SubmitOperationTaskRequest $request SubmitOperationTaskRequest
     *
     * @return SubmitOperationTaskResponse SubmitOperationTaskResponse
     */
    public function submitOperationTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitOperationTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Triggers ISO 27001 compliance checks of Security Center.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return TriggerCheckResponse TriggerCheckResponse
     */
    public function triggerCheckWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'TriggerCheck',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TriggerCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Triggers ISO 27001 compliance checks of Security Center.
     *  *
     * @return TriggerCheckResponse TriggerCheckResponse
     */
    public function triggerCheck()
    {
        $runtime = new RuntimeOptions([]);

        return $this->triggerCheckWithOptions($runtime);
    }

    /**
     * @summary 解绑客户端代理
     *  *
     * @param UnBindHybridProxyRequest $request UnBindHybridProxyRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UnBindHybridProxyResponse UnBindHybridProxyResponse
     */
    public function unBindHybridProxyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->yundunUuids)) {
            $query['YundunUuids'] = $request->yundunUuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnBindHybridProxy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnBindHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 解绑客户端代理
     *  *
     * @param UnBindHybridProxyRequest $request UnBindHybridProxyRequest
     *
     * @return UnBindHybridProxyResponse UnBindHybridProxyResponse
     */
    public function unBindHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unBindHybridProxyWithOptions($request, $runtime);
    }

    /**
     * @summary Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
     *  *
     * @param UnMarkMonitorAccountsRequest $request UnMarkMonitorAccountsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UnMarkMonitorAccountsResponse UnMarkMonitorAccountsResponse
     */
    public function unMarkMonitorAccountsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accountIds)) {
            $query['AccountIds'] = $request->accountIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnMarkMonitorAccounts',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnMarkMonitorAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
     *  *
     * @param UnMarkMonitorAccountsRequest $request UnMarkMonitorAccountsRequest
     *
     * @return UnMarkMonitorAccountsResponse UnMarkMonitorAccountsResponse
     */
    public function unMarkMonitorAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unMarkMonitorAccountsWithOptions($request, $runtime);
    }

    /**
     * @summary Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
     *  *
     * @description If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
     * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
     * **Prerequisites**
     * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
     * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
     *  *
     * @param UnbindAegisRequest $request UnbindAegisRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return UnbindAegisResponse UnbindAegisResponse
     */
    public function unbindAegisWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnbindAegis',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnbindAegisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
     *  *
     * @description If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
     * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
     * **Prerequisites**
     * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
     * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
     *  *
     * @param UnbindAegisRequest $request UnbindAegisRequest
     *
     * @return UnbindAegisResponse UnbindAegisResponse
     */
    public function unbindAegis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unbindAegisWithOptions($request, $runtime);
    }

    /**
     * @summary Uninstalls the anti-ransomware agent.
     *  *
     * @param UninstallBackupClientRequest $request UninstallBackupClientRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UninstallBackupClientResponse UninstallBackupClientResponse
     */
    public function uninstallBackupClientWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UninstallBackupClient',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UninstallBackupClientResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Uninstalls the anti-ransomware agent.
     *  *
     * @param UninstallBackupClientRequest $request UninstallBackupClientRequest
     *
     * @return UninstallBackupClientResponse UninstallBackupClientResponse
     */
    public function uninstallBackupClient($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uninstallBackupClientWithOptions($request, $runtime);
    }

    /**
     * @summary Uninstalls the Runtime Application Self-Protection (RASP) agent that is installed on Elastic Compute Service (ECS) instances to enable automatic application protection.
     *  *
     * @param UninstallRaspAttachRequest $request UninstallRaspAttachRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return UninstallRaspAttachResponse UninstallRaspAttachResponse
     */
    public function uninstallRaspAttachWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->applicationId)) {
            $query['ApplicationId'] = $request->applicationId;
        }
        if (!Utils::isUnset($request->ecsUUIDList)) {
            $query['EcsUUIDList'] = $request->ecsUUIDList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UninstallRaspAttach',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UninstallRaspAttachResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Uninstalls the Runtime Application Self-Protection (RASP) agent that is installed on Elastic Compute Service (ECS) instances to enable automatic application protection.
     *  *
     * @param UninstallRaspAttachRequest $request UninstallRaspAttachRequest
     *
     * @return UninstallRaspAttachResponse UninstallRaspAttachResponse
     */
    public function uninstallRaspAttach($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uninstallRaspAttachWithOptions($request, $runtime);
    }

    /**
     * @summary Uninstalls the database backup agent.
     *  *
     * @param UninstallUniBackupAgentRequest $request UninstallUniBackupAgentRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UninstallUniBackupAgentResponse UninstallUniBackupAgentResponse
     */
    public function uninstallUniBackupAgentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UninstallUniBackupAgent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UninstallUniBackupAgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Uninstalls the database backup agent.
     *  *
     * @param UninstallUniBackupAgentRequest $request UninstallUniBackupAgentRequest
     *
     * @return UninstallUniBackupAgentResponse UninstallUniBackupAgentResponse
     */
    public function uninstallUniBackupAgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uninstallUniBackupAgentWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the status of the honeypot installation time.
     *  *
     * @param UpdateAlarmEventRequest $request UpdateAlarmEventRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateAlarmEventResponse UpdateAlarmEventResponse
     */
    public function updateAlarmEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alarmEventIdList)) {
            $body['AlarmEventIdList'] = $request->alarmEventIdList;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $body['OperationCode'] = $request->operationCode;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateAlarmEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateAlarmEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the status of the honeypot installation time.
     *  *
     * @param UpdateAlarmEventRequest $request UpdateAlarmEventRequest
     *
     * @return UpdateAlarmEventResponse UpdateAlarmEventResponse
     */
    public function updateAlarmEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAlarmEventWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the whitelist rule for a baseline check item.
     *  *
     * @param UpdateBaselineCheckWhiteRecordRequest $request UpdateBaselineCheckWhiteRecordRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateBaselineCheckWhiteRecordResponse UpdateBaselineCheckWhiteRecordResponse
     */
    public function updateBaselineCheckWhiteRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->recordId)) {
            $query['RecordId'] = $request->recordId;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateBaselineCheckWhiteRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateBaselineCheckWhiteRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the whitelist rule for a baseline check item.
     *  *
     * @param UpdateBaselineCheckWhiteRecordRequest $request UpdateBaselineCheckWhiteRecordRequest
     *
     * @return UpdateBaselineCheckWhiteRecordResponse UpdateBaselineCheckWhiteRecordResponse
     */
    public function updateBaselineCheckWhiteRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBaselineCheckWhiteRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies alerting settings for servers.
     *  *
     * @param UpdateClientAlertModeRequest $request UpdateClientAlertModeRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateClientAlertModeResponse UpdateClientAlertModeResponse
     */
    public function updateClientAlertModeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateClientAlertMode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateClientAlertModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies alerting settings for servers.
     *  *
     * @param UpdateClientAlertModeRequest $request UpdateClientAlertModeRequest
     *
     * @return UpdateClientAlertModeResponse UpdateClientAlertModeResponse
     */
    public function updateClientAlertMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateClientAlertModeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the settings of common switches.
     *  *
     * @param UpdateCommonSwitchConfigRequest $request UpdateCommonSwitchConfigRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateCommonSwitchConfigResponse UpdateCommonSwitchConfigResponse
     */
    public function updateCommonSwitchConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->targetDefault)) {
            $query['TargetDefault'] = $request->targetDefault;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateCommonSwitchConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateCommonSwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the settings of common switches.
     *  *
     * @param UpdateCommonSwitchConfigRequest $request UpdateCommonSwitchConfigRequest
     *
     * @return UpdateCommonSwitchConfigResponse UpdateCommonSwitchConfigResponse
     */
    public function updateCommonSwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCommonSwitchConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the status of a security report.
     *  *
     * @param UpdateCustomizeReportStatusRequest $request UpdateCustomizeReportStatusRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateCustomizeReportStatusResponse UpdateCustomizeReportStatusResponse
     */
    public function updateCustomizeReportStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pinnedTime)) {
            $query['PinnedTime'] = $request->pinnedTime;
        }
        if (!Utils::isUnset($request->reportId)) {
            $query['ReportId'] = $request->reportId;
        }
        if (!Utils::isUnset($request->reportStatus)) {
            $query['ReportStatus'] = $request->reportStatus;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateCustomizeReportStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateCustomizeReportStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the status of a security report.
     *  *
     * @param UpdateCustomizeReportStatusRequest $request UpdateCustomizeReportStatusRequest
     *
     * @return UpdateCustomizeReportStatusResponse UpdateCustomizeReportStatusResponse
     */
    public function updateCustomizeReportStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCustomizeReportStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the status of core file monitoring events reported by the Security Center agent.
     *  *
     * @param UpdateFileProtectEventStatusRequest $request UpdateFileProtectEventStatusRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileProtectEventStatusResponse UpdateFileProtectEventStatusResponse
     */
    public function updateFileProtectEventStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateFileProtectEventStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileProtectEventStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the status of core file monitoring events reported by the Security Center agent.
     *  *
     * @param UpdateFileProtectEventStatusRequest $request UpdateFileProtectEventStatusRequest
     *
     * @return UpdateFileProtectEventStatusResponse UpdateFileProtectEventStatusResponse
     */
    public function updateFileProtectEventStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileProtectEventStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Adds remarks to core file monitoring events reported by the Security Center agent.
     *  *
     * @param UpdateFileProtectRemarkRequest $request UpdateFileProtectRemarkRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileProtectRemarkResponse UpdateFileProtectRemarkResponse
     */
    public function updateFileProtectRemarkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateFileProtectRemark',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileProtectRemarkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds remarks to core file monitoring events reported by the Security Center agent.
     *  *
     * @param UpdateFileProtectRemarkRequest $request UpdateFileProtectRemarkRequest
     *
     * @return UpdateFileProtectRemarkResponse UpdateFileProtectRemarkResponse
     */
    public function updateFileProtectRemark($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileProtectRemarkWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the content of a core file monitoring rule based on the ID of the rule.
     *  *
     * @param UpdateFileProtectRuleRequest $request UpdateFileProtectRuleRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileProtectRuleResponse UpdateFileProtectRuleResponse
     */
    public function updateFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alertLevel)) {
            $query['AlertLevel'] = $request->alertLevel;
        }
        if (!Utils::isUnset($request->fileOps)) {
            $query['FileOps'] = $request->fileOps;
        }
        if (!Utils::isUnset($request->filePaths)) {
            $query['FilePaths'] = $request->filePaths;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->procPaths)) {
            $query['ProcPaths'] = $request->procPaths;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the content of a core file monitoring rule based on the ID of the rule.
     *  *
     * @param UpdateFileProtectRuleRequest $request UpdateFileProtectRuleRequest
     *
     * @return UpdateFileProtectRuleResponse UpdateFileProtectRuleResponse
     */
    public function updateFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param UpdateFileUploadLimitRequest $request UpdateFileUploadLimitRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileUploadLimitResponse UpdateFileUploadLimitResponse
     */
    public function updateFileUploadLimitWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->limit)) {
            $query['Limit'] = $request->limit;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateFileUploadLimit',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileUploadLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param UpdateFileUploadLimitRequest $request UpdateFileUploadLimitRequest
     *
     * @return UpdateFileUploadLimitResponse UpdateFileUploadLimitResponse
     */
    public function updateFileUploadLimit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileUploadLimitWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a specified honeypot.
     *  *
     * @param UpdateHoneypotRequest $request UpdateHoneypotRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotResponse UpdateHoneypotResponse
     */
    public function updateHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->honeypotName)) {
            $query['HoneypotName'] = $request->honeypotName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->meta)) {
            $query['Meta'] = $request->meta;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a specified honeypot.
     *  *
     * @param UpdateHoneypotRequest $request UpdateHoneypotRequest
     *
     * @return UpdateHoneypotResponse UpdateHoneypotResponse
     */
    public function updateHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a specified management node.
     *  *
     * @param UpdateHoneypotNodeRequest $request UpdateHoneypotNodeRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotNodeResponse UpdateHoneypotNodeResponse
     */
    public function updateHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->availableProbeNum)) {
            $query['AvailableProbeNum'] = $request->availableProbeNum;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->securityGroupProbeIpList)) {
            $query['SecurityGroupProbeIpList'] = $request->securityGroupProbeIpList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a specified management node.
     *  *
     * @param UpdateHoneypotNodeRequest $request UpdateHoneypotNodeRequest
     *
     * @return UpdateHoneypotNodeResponse UpdateHoneypotNodeResponse
     */
    public function updateHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of the specified honeypot template.
     *  *
     * @param UpdateHoneypotPresetRequest $request UpdateHoneypotPresetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotPresetResponse UpdateHoneypotPresetResponse
     */
    public function updateHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->honeypotPresetId)) {
            $query['HoneypotPresetId'] = $request->honeypotPresetId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->meta)) {
            $query['Meta'] = $request->meta;
        }
        if (!Utils::isUnset($request->presetName)) {
            $query['PresetName'] = $request->presetName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of the specified honeypot template.
     *  *
     * @param UpdateHoneypotPresetRequest $request UpdateHoneypotPresetRequest
     *
     * @return UpdateHoneypotPresetResponse UpdateHoneypotPresetResponse
     */
    public function updateHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the attributes of a specified probe.
     *  *
     * @param UpdateHoneypotProbeRequest $request UpdateHoneypotProbeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotProbeResponse UpdateHoneypotProbeResponse
     */
    public function updateHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->arp)) {
            $query['Arp'] = $request->arp;
        }
        if (!Utils::isUnset($request->displayName)) {
            $query['DisplayName'] = $request->displayName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->ping)) {
            $query['Ping'] = $request->ping;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        if (!Utils::isUnset($request->serviceIpList)) {
            $query['ServiceIpList'] = $request->serviceIpList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the attributes of a specified probe.
     *  *
     * @param UpdateHoneypotProbeRequest $request UpdateHoneypotProbeRequest
     *
     * @return UpdateHoneypotProbeResponse UpdateHoneypotProbeResponse
     */
    public function updateHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a probe service.
     *  *
     * @param UpdateHoneypotProbeBindRequest $request UpdateHoneypotProbeBindRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotProbeBindResponse UpdateHoneypotProbeBindResponse
     */
    public function updateHoneypotProbeBindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bindId)) {
            $query['BindId'] = $request->bindId;
        }
        if (!Utils::isUnset($request->bindPortList)) {
            $query['BindPortList'] = $request->bindPortList;
        }
        if (!Utils::isUnset($request->bindType)) {
            $query['BindType'] = $request->bindType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ports)) {
            $query['Ports'] = $request->ports;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        if (!Utils::isUnset($request->serviceIpList)) {
            $query['ServiceIpList'] = $request->serviceIpList;
        }
        if (!Utils::isUnset($request->setStatus)) {
            $query['SetStatus'] = $request->setStatus;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypotProbeBind',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotProbeBindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a probe service.
     *  *
     * @param UpdateHoneypotProbeBindRequest $request UpdateHoneypotProbeBindRequest
     *
     * @return UpdateHoneypotProbeBindResponse UpdateHoneypotProbeBindResponse
     */
    public function updateHoneypotProbeBind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotProbeBindWithOptions($request, $runtime);
    }

    /**
     * @summary Updates an alert handling rule.
     *  *
     * @param UpdateImageEventOperationRequest $request UpdateImageEventOperationRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateImageEventOperationResponse UpdateImageEventOperationResponse
     */
    public function updateImageEventOperationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->scenarios)) {
            $query['Scenarios'] = $request->scenarios;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateImageEventOperation',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates an alert handling rule.
     *  *
     * @param UpdateImageEventOperationRequest $request UpdateImageEventOperationRequest
     *
     * @return UpdateImageEventOperationResponse UpdateImageEventOperationResponse
     */
    public function updateImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the vulnerability whitelist of an image.
     *  *
     * @param UpdateImageVulWhitelistTargetRequest $request UpdateImageVulWhitelistTargetRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateImageVulWhitelistTargetResponse UpdateImageVulWhitelistTargetResponse
     */
    public function updateImageVulWhitelistTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateImageVulWhitelistTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateImageVulWhitelistTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the vulnerability whitelist of an image.
     *  *
     * @param UpdateImageVulWhitelistTargetRequest $request UpdateImageVulWhitelistTargetRequest
     *
     * @return UpdateImageVulWhitelistTargetResponse UpdateImageVulWhitelistTargetResponse
     */
    public function updateImageVulWhitelistTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateImageVulWhitelistTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name of a Jenkins image repository.
     *  *
     * @param UpdateJenkinsImageRegistryNameRequest $request UpdateJenkinsImageRegistryNameRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateJenkinsImageRegistryNameResponse UpdateJenkinsImageRegistryNameResponse
     */
    public function updateJenkinsImageRegistryNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->registryId)) {
            $body['RegistryId'] = $request->registryId;
        }
        if (!Utils::isUnset($request->registryName)) {
            $body['RegistryName'] = $request->registryName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateJenkinsImageRegistryName',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateJenkinsImageRegistryNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name of a Jenkins image repository.
     *  *
     * @param UpdateJenkinsImageRegistryNameRequest $request UpdateJenkinsImageRegistryNameRequest
     *
     * @return UpdateJenkinsImageRegistryNameResponse UpdateJenkinsImageRegistryNameResponse
     */
    public function updateJenkinsImageRegistryName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateJenkinsImageRegistryNameWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the retention period of images that are stored in a Jenkins image repository.
     *  *
     * @param UpdateJenkinsImageRegistryPersistenceDayRequest $request UpdateJenkinsImageRegistryPersistenceDayRequest
     * @param RuntimeOptions                                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateJenkinsImageRegistryPersistenceDayResponse UpdateJenkinsImageRegistryPersistenceDayResponse
     */
    public function updateJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->persistenceDay)) {
            $body['PersistenceDay'] = $request->persistenceDay;
        }
        if (!Utils::isUnset($request->registryId)) {
            $body['RegistryId'] = $request->registryId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateJenkinsImageRegistryPersistenceDay',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateJenkinsImageRegistryPersistenceDayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the retention period of images that are stored in a Jenkins image repository.
     *  *
     * @param UpdateJenkinsImageRegistryPersistenceDayRequest $request UpdateJenkinsImageRegistryPersistenceDayRequest
     *
     * @return UpdateJenkinsImageRegistryPersistenceDayResponse UpdateJenkinsImageRegistryPersistenceDayResponse
     */
    public function updateJenkinsImageRegistryPersistenceDay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param UpdateMaliciousFileWhitelistConfigRequest $request UpdateMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMaliciousFileWhitelistConfigResponse UpdateMaliciousFileWhitelistConfigResponse
     */
    public function updateMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->field)) {
            $query['Field'] = $request->field;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->operator)) {
            $query['Operator'] = $request->operator;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->targetValue)) {
            $query['TargetValue'] = $request->targetValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param UpdateMaliciousFileWhitelistConfigRequest $request UpdateMaliciousFileWhitelistConfigRequest
     *
     * @return UpdateMaliciousFileWhitelistConfigResponse UpdateMaliciousFileWhitelistConfigResponse
     */
    public function updateMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the blocking rule for at-risk images.
     *  *
     * @param UpdateOpaStrategyNewRequest $tmpReq  UpdateOpaStrategyNewRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateOpaStrategyNewResponse UpdateOpaStrategyNewResponse
     */
    public function updateOpaStrategyNewWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateOpaStrategyNewShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->alarmDetail)) {
            $request->alarmDetailShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->alarmDetail, 'AlarmDetail', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->alarmDetailShrink)) {
            $query['AlarmDetail'] = $request->alarmDetailShrink;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->label)) {
            $query['Label'] = $request->label;
        }
        if (!Utils::isUnset($request->maliciousImage)) {
            $query['MaliciousImage'] = $request->maliciousImage;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->scopes)) {
            $query['Scopes'] = $request->scopes;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        if (!Utils::isUnset($request->strategyTemplateId)) {
            $query['StrategyTemplateId'] = $request->strategyTemplateId;
        }
        if (!Utils::isUnset($request->unScanedImage)) {
            $query['UnScanedImage'] = $request->unScanedImage;
        }
        if (!Utils::isUnset($request->whiteList)) {
            $query['WhiteList'] = $request->whiteList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateOpaStrategyNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateOpaStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the blocking rule for at-risk images.
     *  *
     * @param UpdateOpaStrategyNewRequest $request UpdateOpaStrategyNewRequest
     *
     * @return UpdateOpaStrategyNewResponse UpdateOpaStrategyNewResponse
     */
    public function updateOpaStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateOpaStrategyNewWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the configurations of a bucket check policy.
     *  *
     * @param UpdateOssScanConfigRequest $request UpdateOssScanConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateOssScanConfigResponse UpdateOssScanConfigResponse
     */
    public function updateOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allKeyPrefix)) {
            $query['AllKeyPrefix'] = $request->allKeyPrefix;
        }
        if (!Utils::isUnset($request->bucketNameList)) {
            $query['BucketNameList'] = $request->bucketNameList;
        }
        if (!Utils::isUnset($request->decompressMaxFileCount)) {
            $query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }
        if (!Utils::isUnset($request->decompressMaxLayer)) {
            $query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }
        if (!Utils::isUnset($request->decryptionList)) {
            $query['DecryptionList'] = $request->decryptionList;
        }
        if (!Utils::isUnset($request->enable)) {
            $query['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->keyPrefixList)) {
            $query['KeyPrefixList'] = $request->keyPrefixList;
        }
        if (!Utils::isUnset($request->keySuffixList)) {
            $query['KeySuffixList'] = $request->keySuffixList;
        }
        if (!Utils::isUnset($request->lastModifiedStartTime)) {
            $query['LastModifiedStartTime'] = $request->lastModifiedStartTime;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->scanDayList)) {
            $query['ScanDayList'] = $request->scanDayList;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the configurations of a bucket check policy.
     *  *
     * @param UpdateOssScanConfigRequest $request UpdateOssScanConfigRequest
     *
     * @return UpdateOssScanConfigResponse UpdateOssScanConfigResponse
     */
    public function updateOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary 修改自动升级开关
     *  *
     * @param UpdatePublishAutoUpgradeRequest $request UpdatePublishAutoUpgradeRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdatePublishAutoUpgradeResponse UpdatePublishAutoUpgradeResponse
     */
    public function updatePublishAutoUpgradeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoUpgrade)) {
            $query['AutoUpgrade'] = $request->autoUpgrade;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdatePublishAutoUpgrade',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdatePublishAutoUpgradeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 修改自动升级开关
     *  *
     * @param UpdatePublishAutoUpgradeRequest $request UpdatePublishAutoUpgradeRequest
     *
     * @return UpdatePublishAutoUpgradeResponse UpdatePublishAutoUpgradeResponse
     */
    public function updatePublishAutoUpgrade($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublishAutoUpgradeWithOptions($request, $runtime);
    }

    /**
     * @summary 更新发布批次
     *  *
     * @param UpdatePublishBatchRequest $request UpdatePublishBatchRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdatePublishBatchResponse UpdatePublishBatchResponse
     */
    public function updatePublishBatchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->batchId)) {
            $query['BatchId'] = $request->batchId;
        }
        if (!Utils::isUnset($request->batchName)) {
            $query['BatchName'] = $request->batchName;
        }
        if (!Utils::isUnset($request->interval)) {
            $query['Interval'] = $request->interval;
        }
        if (!Utils::isUnset($request->operationBase)) {
            $query['OperationBase'] = $request->operationBase;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdatePublishBatch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdatePublishBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 更新发布批次
     *  *
     * @param UpdatePublishBatchRequest $request UpdatePublishBatchRequest
     *
     * @return UpdatePublishBatchResponse UpdatePublishBatchResponse
     */
    public function updatePublishBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublishBatchWithOptions($request, $runtime);
    }

    /**
     * @summary  修改升级时间
     *  *
     * @param UpdatePublishCronRequest $request UpdatePublishCronRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdatePublishCronResponse UpdatePublishCronResponse
     */
    public function updatePublishCronWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cron)) {
            $query['Cron'] = $request->cron;
        }
        if (!Utils::isUnset($request->cronDay)) {
            $query['CronDay'] = $request->cronDay;
        }
        if (!Utils::isUnset($request->cronTime)) {
            $query['CronTime'] = $request->cronTime;
        }
        if (!Utils::isUnset($request->cronType)) {
            $query['CronType'] = $request->cronType;
        }
        if (!Utils::isUnset($request->duration)) {
            $query['Duration'] = $request->duration;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdatePublishCron',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdatePublishCronResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary  修改升级时间
     *  *
     * @param UpdatePublishCronRequest $request UpdatePublishCronRequest
     *
     * @return UpdatePublishCronResponse UpdatePublishCronResponse
     */
    public function updatePublishCron($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublishCronWithOptions($request, $runtime);
    }

    /**
     * @summary  修改灰度开关
     *  *
     * @param UpdatePublishGraySwitchRequest $request UpdatePublishGraySwitchRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdatePublishGraySwitchResponse UpdatePublishGraySwitchResponse
     */
    public function updatePublishGraySwitchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->graySwitchStatus)) {
            $query['GraySwitchStatus'] = $request->graySwitchStatus;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdatePublishGraySwitch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdatePublishGraySwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary  修改灰度开关
     *  *
     * @param UpdatePublishGraySwitchRequest $request UpdatePublishGraySwitchRequest
     *
     * @return UpdatePublishGraySwitchResponse UpdatePublishGraySwitchResponse
     */
    public function updatePublishGraySwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePublishGraySwitchWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the unique identifier of an asset selection.
     *  *
     * @param UpdateSelectionKeyByTypeRequest $request UpdateSelectionKeyByTypeRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateSelectionKeyByTypeResponse UpdateSelectionKeyByTypeResponse
     */
    public function updateSelectionKeyByTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->businessType)) {
            $query['BusinessType'] = $request->businessType;
        }
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateSelectionKeyByType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateSelectionKeyByTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the unique identifier of an asset selection.
     *  *
     * @param UpdateSelectionKeyByTypeRequest $request UpdateSelectionKeyByTypeRequest
     *
     * @return UpdateSelectionKeyByTypeResponse UpdateSelectionKeyByTypeResponse
     */
    public function updateSelectionKeyByType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateSelectionKeyByTypeWithOptions($request, $runtime);
    }

    /**
     * @summary 修改目标批次
     *  *
     * @param UpdateTargetListByBatchRequest $request UpdateTargetListByBatchRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTargetListByBatchResponse UpdateTargetListByBatchResponse
     */
    public function updateTargetListByBatchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->batchId)) {
            $query['BatchId'] = $request->batchId;
        }
        if (!Utils::isUnset($request->operationList)) {
            $query['OperationList'] = $request->operationList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTargetListByBatch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTargetListByBatchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 修改目标批次
     *  *
     * @param UpdateTargetListByBatchRequest $request UpdateTargetListByBatchRequest
     *
     * @return UpdateTargetListByBatchResponse UpdateTargetListByBatchResponse
     */
    public function updateTargetListByBatch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTargetListByBatchWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the status of an application whitelist policy.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param UpdateWhiteListStrategyStatusRequest $request UpdateWhiteListStrategyStatusRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateWhiteListStrategyStatusResponse UpdateWhiteListStrategyStatusResponse
     */
    public function updateWhiteListStrategyStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->strategyIds)) {
            $query['StrategyIds'] = $request->strategyIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateWhiteListStrategyStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateWhiteListStrategyStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the status of an application whitelist policy.
     *  *
     * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
     *  *
     * @param UpdateWhiteListStrategyStatusRequest $request UpdateWhiteListStrategyStatusRequest
     *
     * @return UpdateWhiteListStrategyStatusResponse UpdateWhiteListStrategyStatusResponse
     */
    public function updateWhiteListStrategyStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateWhiteListStrategyStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Upgrades the version of an anti-ransomware policy.
     *  *
     * @param UpgradeBackupPolicyVersionRequest $request UpgradeBackupPolicyVersionRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return UpgradeBackupPolicyVersionResponse UpgradeBackupPolicyVersionResponse
     */
    public function upgradeBackupPolicyVersionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpgradeBackupPolicyVersion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpgradeBackupPolicyVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Upgrades the version of an anti-ransomware policy.
     *  *
     * @param UpgradeBackupPolicyVersionRequest $request UpgradeBackupPolicyVersionRequest
     *
     * @return UpgradeBackupPolicyVersionResponse UpgradeBackupPolicyVersionResponse
     */
    public function upgradeBackupPolicyVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeBackupPolicyVersionWithOptions($request, $runtime);
    }

    /**
     * @summary Upgrades the version of the management node to which a honeypot belongs.
     *  *
     * @param UpgradeHoneypotNodeRequest $request UpgradeHoneypotNodeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return UpgradeHoneypotNodeResponse UpgradeHoneypotNodeResponse
     */
    public function upgradeHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allowHoneypotAccessInternet)) {
            $query['AllowHoneypotAccessInternet'] = $request->allowHoneypotAccessInternet;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpgradeHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpgradeHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Upgrades the version of the management node to which a honeypot belongs.
     *  *
     * @param UpgradeHoneypotNodeRequest $request UpgradeHoneypotNodeRequest
     *
     * @return UpgradeHoneypotNodeResponse UpgradeHoneypotNodeResponse
     */
    public function upgradeHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary 升级客户端
     *  *
     * @param UpgradeVersionByUuidsRequest $request UpgradeVersionByUuidsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpgradeVersionByUuidsResponse UpgradeVersionByUuidsResponse
     */
    public function upgradeVersionByUuidsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->upgradeVersion)) {
            $query['UpgradeVersion'] = $request->upgradeVersion;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpgradeVersionByUuids',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpgradeVersionByUuidsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 升级客户端
     *  *
     * @param UpgradeVersionByUuidsRequest $request UpgradeVersionByUuidsRequest
     *
     * @return UpgradeVersionByUuidsResponse UpgradeVersionByUuidsResponse
     */
    public function upgradeVersionByUuids($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeVersionByUuidsWithOptions($request, $runtime);
    }

    /**
     * @summary Uploads a honeypot file.
     *  *
     * @param UploadedHoneyPotFileRequest $request UploadedHoneyPotFileRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UploadedHoneyPotFileResponse UploadedHoneyPotFileResponse
     */
    public function uploadedHoneyPotFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileKey)) {
            $query['FileKey'] = $request->fileKey;
        }
        if (!Utils::isUnset($request->fileName)) {
            $query['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->fileType)) {
            $query['FileType'] = $request->fileType;
        }
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->templateExtra)) {
            $query['TemplateExtra'] = $request->templateExtra;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UploadedHoneyPotFile',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UploadedHoneyPotFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Uploads a honeypot file.
     *  *
     * @param UploadedHoneyPotFileRequest $request UploadedHoneyPotFileRequest
     *
     * @return UploadedHoneyPotFileResponse UploadedHoneyPotFileResponse
     */
    public function uploadedHoneyPotFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uploadedHoneyPotFileWithOptions($request, $runtime);
    }

    /**
     * @summary Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
     *  *
     * @param ValidateHcWarningsRequest $request ValidateHcWarningsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ValidateHcWarningsResponse ValidateHcWarningsResponse
     */
    public function validateHcWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->riskIds)) {
            $query['RiskIds'] = $request->riskIds;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ValidateHcWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ValidateHcWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
     *  *
     * @param ValidateHcWarningsRequest $request ValidateHcWarningsRequest
     *
     * @return ValidateHcWarningsResponse ValidateHcWarningsResponse
     */
    public function validateHcWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->validateHcWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary Verifies the instances on which risks are detected based on a check item.
     *  *
     * @param VerifyCheckInstanceResultRequest $request VerifyCheckInstanceResultRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return VerifyCheckInstanceResultResponse VerifyCheckInstanceResultResponse
     */
    public function verifyCheckInstanceResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'VerifyCheckInstanceResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return VerifyCheckInstanceResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Verifies the instances on which risks are detected based on a check item.
     *  *
     * @param VerifyCheckInstanceResultRequest $request VerifyCheckInstanceResultRequest
     *
     * @return VerifyCheckInstanceResultResponse VerifyCheckInstanceResultResponse
     */
    public function verifyCheckInstanceResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyCheckInstanceResultWithOptions($request, $runtime);
    }

    /**
     * @summary Verifies risk items that are detected based on check items.
     *  *
     * @param VerifyCheckResultRequest $request VerifyCheckResultRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return VerifyCheckResultResponse VerifyCheckResultResponse
     */
    public function verifyCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'VerifyCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return VerifyCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Verifies risk items that are detected based on check items.
     *  *
     * @param VerifyCheckResultRequest $request VerifyCheckResultRequest
     *
     * @return VerifyCheckResultResponse VerifyCheckResultResponse
     */
    public function verifyCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyCheckResultWithOptions($request, $runtime);
    }
}
