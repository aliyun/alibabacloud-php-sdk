<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Sas\V20181203;

use AlibabaCloud\Endpoint\Endpoint;
use AlibabaCloud\OpenApiUtil\OpenApiUtilClient;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddAssetSelectionCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddAssetSelectionCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckInstanceResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckInstanceResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddCheckResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerDefenseRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageVulWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddImageVulWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddInstallCodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPrivateRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddPrivateRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasModuleTrialRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddSasModuleTrialResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddTagWithUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddTagWithUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddUninstallClientsByUuidsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddUninstallClientsByUuidsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddVpcHoneyPotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AddVpcHoneyPotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\AdvanceSecurityEventOperationsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\AdvanceSecurityEventOperationsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchDeleteMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchDeleteMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchOperateCommonOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchOperateCommonOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchUpdateMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BatchUpdateMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindAuthToMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindAuthToMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\BindHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CancelOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CancelOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeAssetRefreshTaskConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeAssetRefreshTaskConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckConfigShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckCustomConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeCheckCustomConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeSecurityScoreRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeSecurityScoreRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeUserLangRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ChangeUserLangResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckQuaraFileIdRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckQuaraFileIdResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckSecurityEventIdRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckSecurityEventIdResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckUserHasEcsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CheckUserHasEcsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ConfirmVirusEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ConfirmVirusEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAgentlessScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAgentlessScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAssetSelectionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateAssetSelectionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskByAppNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskByAppNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateContainerScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCycleTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateCycleTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectUploadUrlRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileDetectUploadUrlResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileUploadLimitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateFileUploadLimitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeBindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeBindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateInterceptionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateJenkinsImageRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateMaliciousNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaClusterPluginRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaClusterPluginResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOpaStrategyNewShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAssetGroupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateAssetGroupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateDingTalkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOrUpdateDingTalkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssBucketScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssBucketScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRestoreJobRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateRestoreJobResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceLinkedRoleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceLinkedRoleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceTrailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateServiceTrailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSimilarSecurityEventsQueryTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSimilarSecurityEventsQueryTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSuspEventNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateSuspEventNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniRestorePlanRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateUniRestorePlanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVirusScanOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVirusScanOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVulAutoRepairConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\CreateVulAutoRepairConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBinarySecurityPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteBinarySecurityPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCycleTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteCycleTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteGroupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteGroupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeBindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeBindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteImageVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInstallCodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteInterceptionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteK8sAccessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteK8sAccessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteLoginBaseConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteLoginBaseConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousNoteRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteMaliciousNoteResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOpaStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOpaStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeletePrivateRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeletePrivateRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSecurityEventMarkMissListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSecurityEventMarkMissListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteServiceTrailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteServiceTrailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSuspEventNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteSuspEventNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteTagWithUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteTagWithUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteUniBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteUniBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVpcHoneyPotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVpcHoneyPotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulAutoRepairConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulAutoRepairConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DeleteVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccessKeyLeakDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccessKeyLeakDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccesskeyLeakListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAccesskeyLeakListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedMaliciousFileImagesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAffectedMaliciousFileImagesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentInstallStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAgentInstallStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventStackInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAlarmEventStackInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllEntityResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllGroupsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllGroupsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllImageBaselineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAllImageBaselineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAntiBruteForceRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAntiBruteForceRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAppVulScanCycleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetDetailByUuidsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsSecurityEventSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetsSecurityEventSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAssetSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttachRecordsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttachRecordsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttackAnalysisDataRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAttackAnalysisDataResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeAutoDelConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupClientsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupClientsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackUpExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackUpExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupMachineStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupMachineStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPoliciesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPoliciesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBackupRestoreCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceRecordsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceRecordsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeBruteForceSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCanFixVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCanFixVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckEcsWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckEcsWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckFixDetailsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckFixDetailsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCheckWarningSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfSetupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfSetupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClientConfStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudCenterInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudCenterInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCloudProductFieldStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterBasicInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterBasicInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterInfoListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterInfoListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterNetworkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterNetworkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterVulStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeClusterVulStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetResultListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCommonTargetResultListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeConcernNecessityRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeConcernNecessityResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerAppsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerAppsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerTagsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeContainerTagsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCountNotScannedImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCountScannedImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockRecordsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCustomBlockRecordsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCycleTaskListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeCycleTaskListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDefaultProxyInstallVersionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDingTalkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDingTalkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeDomainListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEmgUserAgreementResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEmgVulItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEmgVulItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventLevelCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventLevelCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventOnStageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeEventOnStageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExcludeSystemPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExcludeSystemPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedCheckWarningRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedCheckWarningResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedInstanceListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedStatisticsDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedStatisticsDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeExposedStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFieldStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFieldStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFixUsedCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFrontVulPatchListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeFrontVulPatchListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedContainerInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedContainerInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedMaliciousFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedMaliciousFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedTagsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedTagsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupedVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupStructRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeGroupStructResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHcExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHcExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotAuthRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotAuthResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotSuspStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeHoneyPotSuspStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineCheckSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineItemListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineItemListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageBaselineStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageEventOperationPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageFixCycleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageFixTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageFixTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageGroupedVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageGroupedVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInfoListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInfoListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageLatestScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageLatestScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListBySensitiveFileRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListBySensitiveFileResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListBySensitiveFileShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListWithBaselineNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageListWithBaselineNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoDetailListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoDetailListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRepoListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageScanAuthCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageScanAuthorizationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileByKeyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileByKeyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileByKeyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageSensitiveFileListShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeImageVulWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCaptchaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCaptchaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstallCodesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceAntiBruteForceRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceAntiBruteForceRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceRebootStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceRebootStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeInstanceStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIpTagsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeIpTagsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLatestScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLoginBaseConfigsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLoginBaseConfigsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLoginSwitchConfigsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogMetaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogMetaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogShipperStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogShipperStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogstoreStorageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeLogstoreStorageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMachineCanRebootRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMachineCanRebootResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMatchedMaliciousNamesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMatchedMaliciousNamesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeModuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeMonitorAccountsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNoticeConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNoticeConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNsasSuspEventTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeNsasSuspEventTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOfflineMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOfflineMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskLeafRecordPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskLeafRecordPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyCronItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyPortItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyProcItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScaItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertySoftwareItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyTypeScaItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyTypeScaItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUsageNewestRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUsageNewestResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribePropertyUserItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeQuaraFileDownloadInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeQuaraFileDownloadInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestoreJobsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestoreJobsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestorePlansRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRestorePlansResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckItemResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckItemResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskCheckSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskItemTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskItemTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskListCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskListCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRisksRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRisksResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeRiskTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSasPmAgentListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSasPmAgentListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskProgressRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskProgressResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeScanTaskStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSearchConditionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSearchConditionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecureSuggestionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecureSuggestionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityCheckScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityCheckScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventMarkMissListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventMarkMissListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityEventOperationStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityStatInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSecurityStatInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeServiceLinkedRoleStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeServiceLinkedRoleStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarEventScenariosRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarEventScenariosResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarSecurityEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSimilarSecurityEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSnapshotsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSnapshotsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyExecDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyExecDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeStrategyTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSummaryInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSummaryInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSupportRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventQuaraFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventQuaraFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspEventUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousUUIDConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeSuspiciousUUIDConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTaskErrorLogRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTaskErrorLogResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTotalStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTotalStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeTraceInfoNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPoliciesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPoliciesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPolicyDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniBackupPolicyDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniRecoverableListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniRecoverableListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUniSupportRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserBackupMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserBaselineAuthorizationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserBaselineAuthorizationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserLayoutAuthorizationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUserLayoutAuthorizationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUuidsByVulNamesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeUuidsByVulNamesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVendorListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVersionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVersionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcHoneyPotListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVpcListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulCheckTaskStatusDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulCheckTaskStatusDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDetailsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulDetailsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulFixStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulNumStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulNumStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulTargetStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningExportInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningExportInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWarningMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockBindListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockBindListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockConfigListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockConfigListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockExclusiveFileTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileChangeStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileChangeStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockFileTypeSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockInclusiveFileTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessBlockStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessBlockStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockProcessListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebLockTotalFileChangeCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DescribeWebPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableBruteForceRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableBruteForceRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\DisableCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableBruteForceRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableBruteForceRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomInstanceBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\EnableCustomInstanceBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExecStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExecStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportSuspEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportSuspEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportWarningRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ExportWarningResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\FindContainerNetworkConnectRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FindContainerNetworkConnectResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\FindContainerNetworkConnectShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FixCheckWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\FixCheckWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateK8sAccessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateK8sAccessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GenerateOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAegisContainerPluginRuleCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAgentlessTaskCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAlarmMachineCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAlarmMachineCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAppNetworkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAppNetworkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetDetailByUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetDetailByUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetSelectionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetSelectionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAssetsPropertyItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetAuthVersionStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetBackupStorageCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckProcessRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckProcessResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckRiskStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckRiskStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSaleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSaleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCheckSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientInstallationStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientInstallationStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientRatioStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientRatioStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCloudAssetSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterCheckItemWarningStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterCheckItemWarningStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterRuleSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterRuleSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterStrategyCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterSuspEventStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetClusterSuspEventStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCommonSwitchConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetCommonSwitchConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetContainerDefenseRuleDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetContainerDefenseRuleDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectApiInvokeInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectReportRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectReportResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileDetectResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectDashboardResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetFileUploadLimitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotAttackStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotAttackStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotEventTrendRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotEventTrendResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeMetricListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeMetricListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneypotStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneyPotUploadPolicyInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetHoneyPotUploadPolicyInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageScanNumInPeriodRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetImageScanNumInPeriodResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionRuleDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionRuleDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionTargetDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetInterceptionTargetDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLastOnceTaskInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLastOnceTaskInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLogMetaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetLogMetaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleTrialAuthInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetModuleTrialAuthInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetObjectScanEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetObjectScanEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOnceTaskResultInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOnceTaskResultInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterBaseLineListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterImageListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterImageListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterLabelListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterLabelListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterNamespaceListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaClusterNamespaceListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaPluginStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaPluginStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaStrategyDetailNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaStrategyDetailNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOpaStrategyTemplateSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssBucketScanStatisticRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssBucketScanStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetPropertyScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetPropertyScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetRulesCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleApplicationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleApplicationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleCriteriaRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSasContainerWebDefenseRuleCriteriaResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSecurityScoreRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSecurityScoreRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSensitiveDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSensitiveDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServiceTrailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetServiceTrailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetStrategyTemplateDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetStrategyTemplateDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSuspiciousStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSuspiciousStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSwitchRegionDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetSwitchRegionDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetUserLangResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVirusScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVirusScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVirusScanLatestTaskStatisticResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulStatisticsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulStatisticsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\GetVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSecurityEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSecurityEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSimilarSecurityEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\HandleSimilarSecurityEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreCheckItemsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreCheckItemsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreHcCheckWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\IgnoreHcCheckWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallBackupClientRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallBackupClientResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallCloudMonitorRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallCloudMonitorResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallHybridProxyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallHybridProxyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallPmAgentRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallPmAgentResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallRaspAttachRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallRaspAttachResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallUniBackupAgentRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\InstallUniBackupAgentResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\JoinWebLockProcessWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\JoinWebLockProcessWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAegisContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAegisContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessMaliciousFilesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessMaliciousFilesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRelateMaliciousRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRelateMaliciousResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRiskUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessRiskUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAgentlessTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetCleanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetRefreshTaskConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetRefreshTaskConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionSelectedTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionSelectedTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAssetSelectionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAvailableHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListAvailableHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBackupRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListBackupRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckInstanceResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckInstanceResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningSummaryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckItemWarningSummaryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckStandardRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckStandardResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckTypesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCheckTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientAlertModeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientAlertModeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientUserDefineRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientUserDefineRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClientUserDefineRuleTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetInstancesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudAssetInstancesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudVendorRegionsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCloudVendorRegionsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterCnnfStatusDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterCnnfStatusDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterInterceptionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterInterceptionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterPluginInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListClusterPluginInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCompressFileDetectResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCompressFileDetectResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListContainerDefenseRuleClustersResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCriteriaStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListCriteriaStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectPluginStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectPluginStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListGroupsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListGroupsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAlarmEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAlarmEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerPortraitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerPortraitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerSourceRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotAttackerSourceResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventFlowsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventFlowsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotProbeUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageBuildRiskItemRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageBuildRiskItemResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRegistryRegionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRiskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListImageRiskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceCatalogRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceCatalogResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskLevelsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskLevelsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskNumRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInstanceRiskNumResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionHistoryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionHistoryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionRulePageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionRulePageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionTargetPageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListInterceptionTargetPageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListK8sAccessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListK8sAccessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMaliciousFileWhitelistConfigsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListMaliciousFileWhitelistConfigsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListObjectScanEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListObjectScanEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOpaClusterStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOpaClusterStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketScanInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssBucketScanInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPluginForUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPluginForUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPluginForUuidShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPodRiskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPodRiskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListPrivateRegistryTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListQueryRaspAppInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListQueryRaspAppInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListRuleTargetAllRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListRuleTargetAllResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSupportObjectSuffixResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemAggregationRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemAggregationRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemClientRulesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemClientRulesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemClientRuleTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemRuleAggregationTypesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListSystemRuleAggregationTypesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUnfinishedOnceTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUnfinishedOnceTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUninstallAegisMachinesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUninstallAegisMachinesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUuidsByWebPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListUuidsByWebPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVirusScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulAutoRepairConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulAutoRepairConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulGlobalConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ListVulGlobalConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\MarkMonitorAccountsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\MarkMonitorAccountsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAccessKeyLeakDealRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAccessKeyLeakDealResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAppVulScanCycleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAppVulScanCycleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetCleanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetCleanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetGroupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetGroupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetImportantRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAssetImportantResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAutoDelConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyAutoDelConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyBackupPolicyStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClearLogstoreStorageRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClearLogstoreStorageResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfSetupRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfSetupResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientConfStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientUserDefineRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClientUserDefineRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClusterCnnfStatusUserConfirmRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyClusterCnnfStatusUserConfirmResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyConcernNecessityRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyConcernNecessityResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleSwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerDefenseRuleSwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerPluginRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerPluginRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyContainerScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCreateVulWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCreateVulWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCustomBlockRecordRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCustomBlockRecordResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCycleTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyCycleTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyEmgVulSubmitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyEmgVulSubmitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyGroupPropertyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyGroupPropertyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageFixCycleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageFixCycleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyImageRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInstanceAntiBruteForceRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInstanceAntiBruteForceRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleSwitchRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionRuleSwitchResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyInterceptionTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginBaseConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginBaseConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginSwitchConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLoginSwitchConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLogMetaStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyLogMetaStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyNoticeConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyNoticeConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOpenLogShipperRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOpenLogShipperResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOperateVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyOperateVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPropertyScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPropertyScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPushAllTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyPushAllTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRefreshProcessInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRefreshProcessInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRiskCheckStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRiskCheckStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRiskSingleResultStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyRiskSingleResultStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySasContainerWebDefenseRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySasContainerWebDefenseRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityCheckScheduleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityCheckScheduleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityEventMarkMissIndividuallyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifySecurityEventMarkMissIndividuallyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStartVulScanRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStartVulScanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyStrategyTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyTagWithUuidRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyTagWithUuidResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyUniBackupPolicyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyUniBackupPolicyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyUniBackupPolicyShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVpcHoneyPotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVpcHoneyPotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulWhitelistTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyVulWhitelistTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockCreateConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockCreateConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockDeleteConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockDeleteConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockProcessStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockProcessStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStartRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStartResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUnbindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUnbindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUpdateConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebLockUpdateConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebPathRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ModifyWebPathResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenPartialBuyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenPartialBuyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenSensitiveFileScanRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OpenSensitiveFileScanResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateAgentClientInstallRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateAgentClientInstallResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateApplicationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateApplicationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateBucketScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateBucketScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateCommonTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageBaselineWhitelistRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageBaselineWhitelistResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageVulRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateImageVulResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousOverallConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousOverallConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousTargetConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSuspiciousTargetConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSwitchStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateSwitchStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVirusEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVirusEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVulsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateVulsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateWebLockFileEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperateWebLockFileEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCancelIgnoreSuspEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationCancelIgnoreSuspEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationSuspEventsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\OperationSuspEventsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PageImageRegistryRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PageImageRegistryResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PauseClientRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PauseClientResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicCreateImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicCreateImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicPreCheckImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicPreCheckImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicSyncAndCreateImageScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\PublicSyncAndCreateImageScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryAttackCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryAttackCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryDiscoverDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryDiscoverDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupedSecurityEventMarkMissListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupedSecurityEventMarkMissListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupIdByGroupNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryGroupIdByGroupNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentIconListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentSubNodesCountRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentSubNodesCountResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentTracingDetailRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentTracingDetailResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentTracingJudgeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentTracingJudgeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexExtendInfoRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexExtendInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexNodesRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexNodesResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryIncidentVertexNodesShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryJenkinsImageRegistryPersistenceDayRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryJenkinsImageRegistryPersistenceDayResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryPreCheckDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\QueryPreCheckDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RebootMachineRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RebootMachineResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshContainerAssetsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshContainerAssetsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RefreshOssBucketScanInfoResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReleaseSasInstanceRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ReleaseSasInstanceResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckInstanceResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckInstanceResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckResultWhiteListRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RemoveCheckResultWhiteListResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ResetHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryAgentlessTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryAgentlessTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryInstallProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RetryInstallProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\RollbackSuspEventQuaraFileRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\RollbackSuspEventQuaraFileResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SasInstallCodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SasInstallCodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveImageBaselineStrategyRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveImageBaselineStrategyResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveSuspEventUserSettingRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SaveSuspEventUserSettingResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetClusterInterceptionConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetClusterInterceptionConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageSensitiveFileStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetImageSensitiveFileStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetRegistryScanDayNumRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetRegistryScanDayNumResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSensitiveDefineRuleConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SetSensitiveDefineRuleConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartBaselineSecurityCheckRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartBaselineSecurityCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartDiscoverDatabaseTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartPreCheckDatabaseRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartPreCheckDatabaseResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartVirusScanTaskRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StartVirusScanTaskResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\StopHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\StopHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitCheckRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\SubmitCheckResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnbindAegisRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnbindAegisResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallBackupClientRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallBackupClientResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallRaspAttachRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallRaspAttachResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallUniBackupAgentRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UninstallUniBackupAgentResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnMarkMonitorAccountsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UnMarkMonitorAccountsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAlarmEventRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateAlarmEventResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateClientAlertModeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateClientAlertModeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCommonSwitchConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateCommonSwitchConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectEventStatusRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectEventStatusResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRemarkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRemarkResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRuleRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileProtectRuleResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileUploadLimitRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateFileUploadLimitResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotNodeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotNodeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotPresetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotPresetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeBindRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeBindResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotProbeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateHoneypotResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageEventOperationRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageEventOperationResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageVulWhitelistTargetRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateImageVulWhitelistTargetResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryNameRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryNameResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryPersistenceDayRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateJenkinsImageRegistryPersistenceDayResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateMaliciousFileWhitelistConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateMaliciousFileWhitelistConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOpaStrategyNewRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOpaStrategyNewResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOpaStrategyNewShrinkRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOssScanConfigRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateOssScanConfigResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateSelectionKeyByTypeRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpdateSelectionKeyByTypeResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeBackupPolicyVersionRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UpgradeBackupPolicyVersionResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\UploadedHoneyPotFileRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\UploadedHoneyPotFileResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\ValidateHcWarningsRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\ValidateHcWarningsResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckInstanceResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckInstanceResultResponse;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckResultRequest;
use AlibabaCloud\SDK\Sas\V20181203\Models\VerifyCheckResultResponse;
use AlibabaCloud\Tea\Utils\Utils;
use AlibabaCloud\Tea\Utils\Utils\RuntimeOptions;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;

class Sas extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap  = [
            'cn-qingdao'            => 'tds.aliyuncs.com',
            'cn-beijing'            => 'tds.aliyuncs.com',
            'cn-zhangjiakou'        => 'tds.aliyuncs.com',
            'cn-huhehaote'          => 'tds.aliyuncs.com',
            'cn-wulanchabu'         => 'tds.aliyuncs.com',
            'cn-hangzhou'           => 'tds.aliyuncs.com',
            'cn-shanghai'           => 'tds.aliyuncs.com',
            'cn-nanjing'            => 'tds.aliyuncs.com',
            'cn-fuzhou'             => 'tds.aliyuncs.com',
            'cn-shenzhen'           => 'tds.aliyuncs.com',
            'cn-heyuan'             => 'tds.aliyuncs.com',
            'cn-guangzhou'          => 'tds.aliyuncs.com',
            'ap-southeast-2'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-6'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-northeast-2'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-3'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-northeast-1'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-7'        => 'tds.ap-southeast-1.aliyuncs.com',
            'cn-chengdu'            => 'tds.aliyuncs.com',
            'ap-southeast-1'        => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-southeast-5'        => 'tds.ap-southeast-1.aliyuncs.com',
            'cn-hongkong'           => 'tds.aliyuncs.com',
            'eu-central-1'          => 'tds.ap-southeast-1.aliyuncs.com',
            'us-east-1'             => 'tds.ap-southeast-1.aliyuncs.com',
            'us-west-1'             => 'tds.ap-southeast-1.aliyuncs.com',
            'eu-west-1'             => 'tds.ap-southeast-1.aliyuncs.com',
            'me-east-1'             => 'tds.ap-southeast-1.aliyuncs.com',
            'me-central-1'          => 'tds.ap-southeast-1.aliyuncs.com',
            'ap-south-1'            => 'tds.ap-southeast-1.aliyuncs.com',
            'cn-beijing-finance-1'  => 'tds.aliyuncs.com',
            'cn-hangzhou-finance'   => 'tds.aliyuncs.com',
            'cn-shanghai-finance-1' => 'tds.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'tds.aliyuncs.com',
            'cn-heyuan-acdr-1'      => 'tds.aliyuncs.com',
            'cn-north-2-gov-1'      => 'tds.aliyuncs.com',
            'cn-qingdao-acdr-ut-1'  => 'tds.aliyuncs.com',
            'cn-shanghai-mybk'      => 'tds.aliyuncs.com',
            'cn-wuhan-lr'           => 'tds.aliyuncs.com',
            'cn-zhengzhou-jva'      => 'tds.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('sas', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (!Utils::empty_($endpoint)) {
            return $endpoint;
        }
        if (!Utils::isUnset($endpointMap) && !Utils::empty_(@$endpointMap[$regionId])) {
            return @$endpointMap[$regionId];
        }

        return Endpoint::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * @summary Select an operation for assets.
     *  *
     * @param AddAssetSelectionCriteriaRequest $request AddAssetSelectionCriteriaRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return AddAssetSelectionCriteriaResponse AddAssetSelectionCriteriaResponse
     */
    public function addAssetSelectionCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaOperation)) {
            $query['CriteriaOperation'] = $request->criteriaOperation;
        }
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        if (!Utils::isUnset($request->targetOperationList)) {
            $query['TargetOperationList'] = $request->targetOperationList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddAssetSelectionCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddAssetSelectionCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Select an operation for assets.
     *  *
     * @param AddAssetSelectionCriteriaRequest $request AddAssetSelectionCriteriaRequest
     *
     * @return AddAssetSelectionCriteriaResponse AddAssetSelectionCriteriaResponse
     */
    public function addAssetSelectionCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addAssetSelectionCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Adds check items to the whitelist for instances.
     *  *
     * @param AddCheckInstanceResultWhiteListRequest $request AddCheckInstanceResultWhiteListRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCheckInstanceResultWhiteListResponse AddCheckInstanceResultWhiteListResponse
     */
    public function addCheckInstanceResultWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkGroupId)) {
            $query['CheckGroupId'] = $request->checkGroupId;
        }
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddCheckInstanceResultWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddCheckInstanceResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds check items to the whitelist for instances.
     *  *
     * @param AddCheckInstanceResultWhiteListRequest $request AddCheckInstanceResultWhiteListRequest
     *
     * @return AddCheckInstanceResultWhiteListResponse AddCheckInstanceResultWhiteListResponse
     */
    public function addCheckInstanceResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCheckInstanceResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Adds check items to the whitelist.
     *  *
     * @param AddCheckResultWhiteListRequest $request AddCheckResultWhiteListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddCheckResultWhiteListResponse AddCheckResultWhiteListResponse
     */
    public function addCheckResultWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddCheckResultWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddCheckResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds check items to the whitelist.
     *  *
     * @param AddCheckResultWhiteListRequest $request AddCheckResultWhiteListRequest
     *
     * @return AddCheckResultWhiteListResponse AddCheckResultWhiteListResponse
     */
    public function addCheckResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addCheckResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a custom defense rule.
     *  *
     * @param AddClientUserDefineRuleRequest $request AddClientUserDefineRuleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddClientUserDefineRuleResponse AddClientUserDefineRuleResponse
     */
    public function addClientUserDefineRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->actionType)) {
            $query['ActionType'] = $request->actionType;
        }
        if (!Utils::isUnset($request->cmdline)) {
            $query['Cmdline'] = $request->cmdline;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->filePath)) {
            $query['FilePath'] = $request->filePath;
        }
        if (!Utils::isUnset($request->IP)) {
            $query['IP'] = $request->IP;
        }
        if (!Utils::isUnset($request->md5List)) {
            $query['Md5List'] = $request->md5List;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->newFilePath)) {
            $query['NewFilePath'] = $request->newFilePath;
        }
        if (!Utils::isUnset($request->parentCmdline)) {
            $query['ParentCmdline'] = $request->parentCmdline;
        }
        if (!Utils::isUnset($request->parentProcPath)) {
            $query['ParentProcPath'] = $request->parentProcPath;
        }
        if (!Utils::isUnset($request->platform)) {
            $query['Platform'] = $request->platform;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->portStr)) {
            $query['PortStr'] = $request->portStr;
        }
        if (!Utils::isUnset($request->procPath)) {
            $query['ProcPath'] = $request->procPath;
        }
        if (!Utils::isUnset($request->registryContent)) {
            $query['RegistryContent'] = $request->registryContent;
        }
        if (!Utils::isUnset($request->registryKey)) {
            $query['RegistryKey'] = $request->registryKey;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddClientUserDefineRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a custom defense rule.
     *  *
     * @param AddClientUserDefineRuleRequest $request AddClientUserDefineRuleRequest
     *
     * @return AddClientUserDefineRuleResponse AddClientUserDefineRuleResponse
     */
    public function addClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a rule for non-image program defense.
     *  *
     * @param AddContainerDefenseRuleRequest $tmpReq  AddContainerDefenseRuleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddContainerDefenseRuleResponse AddContainerDefenseRuleResponse
     */
    public function addContainerDefenseRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new AddContainerDefenseRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->whitelist)) {
            $request->whitelistShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->whitelist, 'Whitelist', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->scope)) {
            $query['Scope'] = $request->scope;
        }
        if (!Utils::isUnset($request->whitelistShrink)) {
            $query['Whitelist'] = $request->whitelistShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddContainerDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a rule for non-image program defense.
     *  *
     * @param AddContainerDefenseRuleRequest $request AddContainerDefenseRuleRequest
     *
     * @return AddContainerDefenseRuleResponse AddContainerDefenseRuleResponse
     */
    public function addContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a defense rule against container escapes.
     *  *
     * @param AddContainerPluginRuleRequest $request AddContainerPluginRuleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddContainerPluginRuleResponse AddContainerPluginRuleResponse
     */
    public function addContainerPluginRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleTemplateId)) {
            $query['RuleTemplateId'] = $request->ruleTemplateId;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->selectedPolicy)) {
            $query['SelectedPolicy'] = $request->selectedPolicy;
        }
        if (!Utils::isUnset($request->whiteImages)) {
            $query['WhiteImages'] = $request->whiteImages;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddContainerPluginRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a defense rule against container escapes.
     *  *
     * @param AddContainerPluginRuleRequest $request AddContainerPluginRuleRequest
     *
     * @return AddContainerPluginRuleResponse AddContainerPluginRuleResponse
     */
    public function addContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an alert handling rule.
     *  *
     * @param AddImageEventOperationRequest $request AddImageEventOperationRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddImageEventOperationResponse AddImageEventOperationResponse
     */
    public function addImageEventOperationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->conditions)) {
            $query['Conditions'] = $request->conditions;
        }
        if (!Utils::isUnset($request->eventKey)) {
            $query['EventKey'] = $request->eventKey;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->eventType)) {
            $query['EventType'] = $request->eventType;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->scenarios)) {
            $query['Scenarios'] = $request->scenarios;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddImageEventOperation',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an alert handling rule.
     *  *
     * @param AddImageEventOperationRequest $request AddImageEventOperationRequest
     *
     * @return AddImageEventOperationResponse AddImageEventOperationResponse
     */
    public function addImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * @summary Adds image vulnerabilities to the whitelist.
     *  *
     * @param AddImageVulWhiteListRequest $request AddImageVulWhiteListRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return AddImageVulWhiteListResponse AddImageVulWhiteListResponse
     */
    public function addImageVulWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->whitelist)) {
            $query['Whitelist'] = $request->whitelist;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddImageVulWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddImageVulWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds image vulnerabilities to the whitelist.
     *  *
     * @param AddImageVulWhiteListRequest $request AddImageVulWhiteListRequest
     *
     * @return AddImageVulWhiteListResponse AddImageVulWhiteListResponse
     */
    public function addImageVulWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addImageVulWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a command that is used to install the Security Center agent.
     *  *
     * @param AddInstallCodeRequest $request AddInstallCodeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return AddInstallCodeResponse AddInstallCodeResponse
     */
    public function addInstallCodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->expiredDate)) {
            $query['ExpiredDate'] = $request->expiredDate;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->onlyImage)) {
            $query['OnlyImage'] = $request->onlyImage;
        }
        if (!Utils::isUnset($request->os)) {
            $query['Os'] = $request->os;
        }
        if (!Utils::isUnset($request->proxyCluster)) {
            $query['ProxyCluster'] = $request->proxyCluster;
        }
        if (!Utils::isUnset($request->vendorName)) {
            $query['VendorName'] = $request->vendorName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddInstallCode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a command that is used to install the Security Center agent.
     *  *
     * @param AddInstallCodeRequest $request AddInstallCodeRequest
     *
     * @return AddInstallCodeResponse AddInstallCodeResponse
     */
    public function addInstallCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addInstallCodeWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a self-managed image repository.
     *  *
     * @param AddPrivateRegistryRequest $request AddPrivateRegistryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return AddPrivateRegistryResponse AddPrivateRegistryResponse
     */
    public function addPrivateRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->extraParam)) {
            $query['ExtraParam'] = $request->extraParam;
        }
        if (!Utils::isUnset($request->netType)) {
            $query['NetType'] = $request->netType;
        }
        if (!Utils::isUnset($request->password)) {
            $query['Password'] = $request->password;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->protocolType)) {
            $query['ProtocolType'] = $request->protocolType;
        }
        if (!Utils::isUnset($request->registryHostIp)) {
            $query['RegistryHostIp'] = $request->registryHostIp;
        }
        if (!Utils::isUnset($request->registryRegionId)) {
            $query['RegistryRegionId'] = $request->registryRegionId;
        }
        if (!Utils::isUnset($request->registryType)) {
            $query['RegistryType'] = $request->registryType;
        }
        if (!Utils::isUnset($request->registryVersion)) {
            $query['RegistryVersion'] = $request->registryVersion;
        }
        if (!Utils::isUnset($request->transPerHour)) {
            $query['TransPerHour'] = $request->transPerHour;
        }
        if (!Utils::isUnset($request->userName)) {
            $query['UserName'] = $request->userName;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddPrivateRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddPrivateRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a self-managed image repository.
     *  *
     * @param AddPrivateRegistryRequest $request AddPrivateRegistryRequest
     *
     * @return AddPrivateRegistryResponse AddPrivateRegistryResponse
     */
    public function addPrivateRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addPrivateRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a rule for container tamper-proofing.
     *  *
     * @param AddSasContainerWebDefenseRuleRequest $request AddSasContainerWebDefenseRuleRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return AddSasContainerWebDefenseRuleResponse AddSasContainerWebDefenseRuleResponse
     */
    public function addSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pathConfDTOList)) {
            $query['PathConfDTOList'] = $request->pathConfDTOList;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddSasContainerWebDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a rule for container tamper-proofing.
     *  *
     * @param AddSasContainerWebDefenseRuleRequest $request AddSasContainerWebDefenseRuleRequest
     *
     * @return AddSasContainerWebDefenseRuleResponse AddSasContainerWebDefenseRuleResponse
     */
    public function addSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis.
     *  *
     * @param AddSasModuleTrialRequest $request AddSasModuleTrialRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return AddSasModuleTrialResponse AddSasModuleTrialResponse
     */
    public function addSasModuleTrialWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->moduleCode)) {
            $query['ModuleCode'] = $request->moduleCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddSasModuleTrial',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddSasModuleTrialResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis.
     *  *
     * @param AddSasModuleTrialRequest $request AddSasModuleTrialRequest
     *
     * @return AddSasModuleTrialResponse AddSasModuleTrialResponse
     */
    public function addSasModuleTrial($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addSasModuleTrialWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a tag to assets.
     *  *
     * @description Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
     *  *
     * @param AddTagWithUuidRequest $request AddTagWithUuidRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return AddTagWithUuidResponse AddTagWithUuidResponse
     */
    public function addTagWithUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tagName)) {
            $query['TagName'] = $request->tagName;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddTagWithUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddTagWithUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a tag to assets.
     *  *
     * @description Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
     *  *
     * @param AddTagWithUuidRequest $request AddTagWithUuidRequest
     *
     * @return AddTagWithUuidResponse AddTagWithUuidResponse
     */
    public function addTagWithUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addTagWithUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Adds servers from which you want to uninstall the Security Center agent.
     *  *
     * @param AddUninstallClientsByUuidsRequest $request AddUninstallClientsByUuidsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return AddUninstallClientsByUuidsResponse AddUninstallClientsByUuidsResponse
     */
    public function addUninstallClientsByUuidsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->callMethod)) {
            $query['CallMethod'] = $request->callMethod;
        }
        if (!Utils::isUnset($request->feedback)) {
            $query['Feedback'] = $request->feedback;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddUninstallClientsByUuids',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddUninstallClientsByUuidsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds servers from which you want to uninstall the Security Center agent.
     *  *
     * @param AddUninstallClientsByUuidsRequest $request AddUninstallClientsByUuidsRequest
     *
     * @return AddUninstallClientsByUuidsResponse AddUninstallClientsByUuidsResponse
     */
    public function addUninstallClientsByUuids($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addUninstallClientsByUuidsWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a honeypot.
     *  *
     * @param AddVpcHoneyPotRequest $request AddVpcHoneyPotRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return AddVpcHoneyPotResponse AddVpcHoneyPotResponse
     */
    public function addVpcHoneyPotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddVpcHoneyPot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddVpcHoneyPotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a honeypot.
     *  *
     * @param AddVpcHoneyPotRequest $request AddVpcHoneyPotRequest
     *
     * @return AddVpcHoneyPotResponse AddVpcHoneyPotResponse
     */
    public function addVpcHoneyPot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addVpcHoneyPotWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of an advanced whitelist rule.
     *  *
     * @param AdvanceSecurityEventOperationsRequest $request AdvanceSecurityEventOperationsRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return AdvanceSecurityEventOperationsResponse AdvanceSecurityEventOperationsResponse
     */
    public function advanceSecurityEventOperationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->eventType)) {
            $query['EventType'] = $request->eventType;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AdvanceSecurityEventOperations',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AdvanceSecurityEventOperationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of an advanced whitelist rule.
     *  *
     * @param AdvanceSecurityEventOperationsRequest $request AdvanceSecurityEventOperationsRequest
     *
     * @return AdvanceSecurityEventOperationsResponse AdvanceSecurityEventOperationsResponse
     */
    public function advanceSecurityEventOperations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->advanceSecurityEventOperationsWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
     *  *
     * @param BatchDeleteMaliciousFileWhitelistConfigRequest $request BatchDeleteMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchDeleteMaliciousFileWhitelistConfigResponse BatchDeleteMaliciousFileWhitelistConfigResponse
     */
    public function batchDeleteMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configIdList)) {
            $query['ConfigIdList'] = $request->configIdList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BatchDeleteMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BatchDeleteMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
     *  *
     * @param BatchDeleteMaliciousFileWhitelistConfigRequest $request BatchDeleteMaliciousFileWhitelistConfigRequest
     *
     * @return BatchDeleteMaliciousFileWhitelistConfigResponse BatchDeleteMaliciousFileWhitelistConfigResponse
     */
    public function batchDeleteMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchDeleteMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables multiple features in proactive defense at a time.
     *  *
     * @param BatchOperateCommonOverallConfigRequest $request BatchOperateCommonOverallConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchOperateCommonOverallConfigResponse BatchOperateCommonOverallConfigResponse
     */
    public function batchOperateCommonOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->typeList)) {
            $query['TypeList'] = $request->typeList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BatchOperateCommonOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BatchOperateCommonOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables multiple features in proactive defense at a time.
     *  *
     * @param BatchOperateCommonOverallConfigRequest $request BatchOperateCommonOverallConfigRequest
     *
     * @return BatchOperateCommonOverallConfigResponse BatchOperateCommonOverallConfigResponse
     */
    public function batchOperateCommonOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchOperateCommonOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
     *  *
     * @param BatchUpdateMaliciousFileWhitelistConfigRequest $request BatchUpdateMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return BatchUpdateMaliciousFileWhitelistConfigResponse BatchUpdateMaliciousFileWhitelistConfigResponse
     */
    public function batchUpdateMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configList)) {
            $query['ConfigList'] = $request->configList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BatchUpdateMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BatchUpdateMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
     *  *
     * @param BatchUpdateMaliciousFileWhitelistConfigRequest $request BatchUpdateMaliciousFileWhitelistConfigRequest
     *
     * @return BatchUpdateMaliciousFileWhitelistConfigResponse BatchUpdateMaliciousFileWhitelistConfigResponse
     */
    public function batchUpdateMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->batchUpdateMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Binds servers to Security Center or unbinds servers from Security Center.
     *  *
     * @param BindAuthToMachineRequest $request BindAuthToMachineRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return BindAuthToMachineResponse BindAuthToMachineResponse
     */
    public function bindAuthToMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->authVersion)) {
            $query['AuthVersion'] = $request->authVersion;
        }
        if (!Utils::isUnset($request->autoBind)) {
            $query['AutoBind'] = $request->autoBind;
        }
        if (!Utils::isUnset($request->bind)) {
            $query['Bind'] = $request->bind;
        }
        if (!Utils::isUnset($request->bindAll)) {
            $query['BindAll'] = $request->bindAll;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->isPreBind)) {
            $query['IsPreBind'] = $request->isPreBind;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->ntmVersion)) {
            $query['NtmVersion'] = $request->ntmVersion;
        }
        if (!Utils::isUnset($request->preBindOrderId)) {
            $query['PreBindOrderId'] = $request->preBindOrderId;
        }
        if (!Utils::isUnset($request->unBind)) {
            $query['UnBind'] = $request->unBind;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BindAuthToMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BindAuthToMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Binds servers to Security Center or unbinds servers from Security Center.
     *  *
     * @param BindAuthToMachineRequest $request BindAuthToMachineRequest
     *
     * @return BindAuthToMachineResponse BindAuthToMachineResponse
     */
    public function bindAuthToMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->bindAuthToMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
     *  *
     * @param BindHybridProxyRequest $request BindHybridProxyRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return BindHybridProxyResponse BindHybridProxyResponse
     */
    public function bindHybridProxyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->yundunUuids)) {
            $query['YundunUuids'] = $request->yundunUuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'BindHybridProxy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return BindHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
     *  *
     * @param BindHybridProxyRequest $request BindHybridProxyRequest
     *
     * @return BindHybridProxyResponse BindHybridProxyResponse
     */
    public function bindHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->bindHybridProxyWithOptions($request, $runtime);
    }

    /**
     * @summary Cancels the main task.
     *  *
     * @param CancelOnceTaskRequest $request CancelOnceTaskRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CancelOnceTaskResponse CancelOnceTaskResponse
     */
    public function cancelOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CancelOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CancelOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Cancels the main task.
     *  *
     * @param CancelOnceTaskRequest $request CancelOnceTaskRequest
     *
     * @return CancelOnceTaskResponse CancelOnceTaskResponse
     */
    public function cancelOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the interval of asset synchronization configurations.
     *  *
     * @param ChangeAssetRefreshTaskConfigRequest $request ChangeAssetRefreshTaskConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeAssetRefreshTaskConfigResponse ChangeAssetRefreshTaskConfigResponse
     */
    public function changeAssetRefreshTaskConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetRefreshConfigs)) {
            $query['AssetRefreshConfigs'] = $request->assetRefreshConfigs;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeAssetRefreshTaskConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeAssetRefreshTaskConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the interval of asset synchronization configurations.
     *  *
     * @param ChangeAssetRefreshTaskConfigRequest $request ChangeAssetRefreshTaskConfigRequest
     *
     * @return ChangeAssetRefreshTaskConfigResponse ChangeAssetRefreshTaskConfigResponse
     */
    public function changeAssetRefreshTaskConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeAssetRefreshTaskConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration items of the configuration assessment feature.
     *  *
     * @param ChangeCheckConfigRequest $tmpReq  ChangeCheckConfigRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeCheckConfigResponse ChangeCheckConfigResponse
     */
    public function changeCheckConfigWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ChangeCheckConfigShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->configRequirementIds)) {
            $request->configRequirementIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->configRequirementIds, 'ConfigRequirementIds', 'json');
        }
        if (!Utils::isUnset($tmpReq->configStandardIds)) {
            $request->configStandardIdsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->configStandardIds, 'ConfigStandardIds', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->addedCheck)) {
            $query['AddedCheck'] = $request->addedCheck;
        }
        if (!Utils::isUnset($request->configRequirementIdsShrink)) {
            $query['ConfigRequirementIds'] = $request->configRequirementIdsShrink;
        }
        if (!Utils::isUnset($request->configStandardIdsShrink)) {
            $query['ConfigStandardIds'] = $request->configStandardIdsShrink;
        }
        if (!Utils::isUnset($request->configure)) {
            $query['Configure'] = $request->configure;
        }
        if (!Utils::isUnset($request->cycleDays)) {
            $query['CycleDays'] = $request->cycleDays;
        }
        if (!Utils::isUnset($request->enableAddCheck)) {
            $query['EnableAddCheck'] = $request->enableAddCheck;
        }
        if (!Utils::isUnset($request->enableAutoCheck)) {
            $query['EnableAutoCheck'] = $request->enableAutoCheck;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->removedCheck)) {
            $query['RemovedCheck'] = $request->removedCheck;
        }
        if (!Utils::isUnset($request->standardIds)) {
            $query['StandardIds'] = $request->standardIds;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeCheckConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeCheckConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration items of the configuration assessment feature.
     *  *
     * @param ChangeCheckConfigRequest $request ChangeCheckConfigRequest
     *
     * @return ChangeCheckConfigResponse ChangeCheckConfigResponse
     */
    public function changeCheckConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeCheckConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the custom configuration items of a check item.
     *  *
     * @param ChangeCheckCustomConfigRequest $request ChangeCheckCustomConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeCheckCustomConfigResponse ChangeCheckCustomConfigResponse
     */
    public function changeCheckCustomConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->customConfigs)) {
            $query['CustomConfigs'] = $request->customConfigs;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repairConfigs)) {
            $query['RepairConfigs'] = $request->repairConfigs;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeCheckCustomConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeCheckCustomConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the custom configuration items of a check item.
     *  *
     * @param ChangeCheckCustomConfigRequest $request ChangeCheckCustomConfigRequest
     *
     * @return ChangeCheckCustomConfigResponse ChangeCheckCustomConfigResponse
     */
    public function changeCheckCustomConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeCheckCustomConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the details of the deduction modules of the security score feature, including custom settings.
     *  *
     * @param ChangeSecurityScoreRuleRequest $request ChangeSecurityScoreRuleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeSecurityScoreRuleResponse ChangeSecurityScoreRuleResponse
     */
    public function changeSecurityScoreRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resetSecurityScoreRule)) {
            $query['ResetSecurityScoreRule'] = $request->resetSecurityScoreRule;
        }
        if (!Utils::isUnset($request->securityScoreRuleList)) {
            $query['SecurityScoreRuleList'] = $request->securityScoreRuleList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeSecurityScoreRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeSecurityScoreRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the details of the deduction modules of the security score feature, including custom settings.
     *  *
     * @param ChangeSecurityScoreRuleRequest $request ChangeSecurityScoreRuleRequest
     *
     * @return ChangeSecurityScoreRuleResponse ChangeSecurityScoreRuleResponse
     */
    public function changeSecurityScoreRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeSecurityScoreRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
     *  *
     * @param ChangeUserLangRequest $request ChangeUserLangRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeUserLangResponse ChangeUserLangResponse
     */
    public function changeUserLangWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->userLang)) {
            $query['UserLang'] = $request->userLang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeUserLang',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeUserLangResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
     *  *
     * @param ChangeUserLangRequest $request ChangeUserLangRequest
     *
     * @return ChangeUserLangResponse ChangeUserLangResponse
     */
    public function changeUserLang($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeUserLangWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether the IDs of quarantined files are valid.
     *  *
     * @param CheckQuaraFileIdRequest $request CheckQuaraFileIdRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckQuaraFileIdResponse CheckQuaraFileIdResponse
     */
    public function checkQuaraFileIdWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->quaraFileIds)) {
            $query['QuaraFileIds'] = $request->quaraFileIds;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckQuaraFileId',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckQuaraFileIdResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether the IDs of quarantined files are valid.
     *  *
     * @param CheckQuaraFileIdRequest $request CheckQuaraFileIdRequest
     *
     * @return CheckQuaraFileIdResponse CheckQuaraFileIdResponse
     */
    public function checkQuaraFileId($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkQuaraFileIdWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
     *  *
     * @param CheckSecurityEventIdRequest $request CheckSecurityEventIdRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckSecurityEventIdResponse CheckSecurityEventIdResponse
     */
    public function checkSecurityEventIdWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->securityEventIds)) {
            $query['SecurityEventIds'] = $request->securityEventIds;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckSecurityEventId',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckSecurityEventIdResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
     *  *
     * @param CheckSecurityEventIdRequest $request CheckSecurityEventIdRequest
     *
     * @return CheckSecurityEventIdResponse CheckSecurityEventIdResponse
     */
    public function checkSecurityEventId($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkSecurityEventIdWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether Elastic Compute Service (ECS) instances exist.
     *  *
     * @param CheckUserHasEcsRequest $request CheckUserHasEcsRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckUserHasEcsResponse CheckUserHasEcsResponse
     */
    public function checkUserHasEcsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckUserHasEcs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckUserHasEcsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether Elastic Compute Service (ECS) instances exist.
     *  *
     * @param CheckUserHasEcsRequest $request CheckUserHasEcsRequest
     *
     * @return CheckUserHasEcsResponse CheckUserHasEcsResponse
     */
    public function checkUserHasEcs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkUserHasEcsWithOptions($request, $runtime);
    }

    /**
     * @summary Confirms the alert events that you want to handle.
     *  *
     * @param ConfirmVirusEventsRequest $request ConfirmVirusEventsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ConfirmVirusEventsResponse ConfirmVirusEventsResponse
     */
    public function confirmVirusEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->operationAll)) {
            $query['OperationAll'] = $request->operationAll;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->operationRange)) {
            $query['OperationRange'] = $request->operationRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ConfirmVirusEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ConfirmVirusEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Confirms the alert events that you want to handle.
     *  *
     * @param ConfirmVirusEventsRequest $request ConfirmVirusEventsRequest
     *
     * @return ConfirmVirusEventsResponse ConfirmVirusEventsResponse
     */
    public function confirmVirusEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->confirmVirusEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an agentless detection task.
     *  *
     * @param CreateAgentlessScanTaskRequest $request CreateAgentlessScanTaskRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateAgentlessScanTaskResponse CreateAgentlessScanTaskResponse
     */
    public function createAgentlessScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->autoDeleteDays)) {
            $query['AutoDeleteDays'] = $request->autoDeleteDays;
        }
        if (!Utils::isUnset($request->releaseAfterScan)) {
            $query['ReleaseAfterScan'] = $request->releaseAfterScan;
        }
        if (!Utils::isUnset($request->scanDataDisk)) {
            $query['ScanDataDisk'] = $request->scanDataDisk;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateAgentlessScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateAgentlessScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an agentless detection task.
     *  *
     * @param CreateAgentlessScanTaskRequest $request CreateAgentlessScanTaskRequest
     *
     * @return CreateAgentlessScanTaskResponse CreateAgentlessScanTaskResponse
     */
    public function createAgentlessScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAgentlessScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a defense rule against brute-force attacks.
     *  *
     * @param CreateAntiBruteForceRuleRequest $request CreateAntiBruteForceRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateAntiBruteForceRuleResponse CreateAntiBruteForceRuleResponse
     */
    public function createAntiBruteForceRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defaultRule)) {
            $query['DefaultRule'] = $request->defaultRule;
        }
        if (!Utils::isUnset($request->failCount)) {
            $query['FailCount'] = $request->failCount;
        }
        if (!Utils::isUnset($request->forbiddenTime)) {
            $query['ForbiddenTime'] = $request->forbiddenTime;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->span)) {
            $query['Span'] = $request->span;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateAntiBruteForceRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a defense rule against brute-force attacks.
     *  *
     * @param CreateAntiBruteForceRuleRequest $request CreateAntiBruteForceRuleRequest
     *
     * @return CreateAntiBruteForceRuleResponse CreateAntiBruteForceRuleResponse
     */
    public function createAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Create asset selection configurations.
     *  *
     * @param CreateAssetSelectionConfigRequest $request CreateAssetSelectionConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateAssetSelectionConfigResponse CreateAssetSelectionConfigResponse
     */
    public function createAssetSelectionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->businessType)) {
            $query['BusinessType'] = $request->businessType;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateAssetSelectionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateAssetSelectionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Create asset selection configurations.
     *  *
     * @param CreateAssetSelectionConfigRequest $request CreateAssetSelectionConfigRequest
     *
     * @return CreateAssetSelectionConfigResponse CreateAssetSelectionConfigResponse
     */
    public function createAssetSelectionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAssetSelectionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an anti-ransomware policy for servers.
     *  *
     * @param CreateBackupPolicyRequest $tmpReq  CreateBackupPolicyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateBackupPolicyResponse CreateBackupPolicyResponse
     */
    public function createBackupPolicyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateBackupPolicyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->policy)) {
            $request->policyShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->policy, 'Policy', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->policyShrink)) {
            $query['Policy'] = $request->policyShrink;
        }
        if (!Utils::isUnset($request->policyRegionId)) {
            $query['PolicyRegionId'] = $request->policyRegionId;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an anti-ransomware policy for servers.
     *  *
     * @param CreateBackupPolicyRequest $request CreateBackupPolicyRequest
     *
     * @return CreateBackupPolicyResponse CreateBackupPolicyResponse
     */
    public function createBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a container scan task.
     *  *
     * @param CreateContainerScanTaskRequest $request CreateContainerScanTaskRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateContainerScanTaskResponse CreateContainerScanTaskResponse
     */
    public function createContainerScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerIds)) {
            $query['ContainerIds'] = $request->containerIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateContainerScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateContainerScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a container scan task.
     *  *
     * @param CreateContainerScanTaskRequest $request CreateContainerScanTaskRequest
     *
     * @return CreateContainerScanTaskResponse CreateContainerScanTaskResponse
     */
    public function createContainerScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createContainerScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a scan task for a running container application based on the application name.
     *  *
     * @param CreateContainerScanTaskByAppNameRequest $request CreateContainerScanTaskByAppNameRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateContainerScanTaskByAppNameResponse CreateContainerScanTaskByAppNameResponse
     */
    public function createContainerScanTaskByAppNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appNames)) {
            $query['AppNames'] = $request->appNames;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateContainerScanTaskByAppName',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateContainerScanTaskByAppNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a scan task for a running container application based on the application name.
     *  *
     * @param CreateContainerScanTaskByAppNameRequest $request CreateContainerScanTaskByAppNameRequest
     *
     * @return CreateContainerScanTaskByAppNameResponse CreateContainerScanTaskByAppNameResponse
     */
    public function createContainerScanTaskByAppName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createContainerScanTaskByAppNameWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an IP address blocking policy for one or more servers.
     *  *
     * @param CreateCustomBlockRecordRequest $request CreateCustomBlockRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateCustomBlockRecordResponse CreateCustomBlockRecordResponse
     */
    public function createCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->expireTime)) {
            $query['ExpireTime'] = $request->expireTime;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an IP address blocking policy for one or more servers.
     *  *
     * @param CreateCustomBlockRecordRequest $request CreateCustomBlockRecordRequest
     *
     * @return CreateCustomBlockRecordResponse CreateCustomBlockRecordResponse
     */
    public function createCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *  *
     * @param CreateCycleTaskRequest $request CreateCycleTaskRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateCycleTaskResponse CreateCycleTaskResponse
     */
    public function createCycleTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->enable)) {
            $query['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->firstDateStr)) {
            $query['FirstDateStr'] = $request->firstDateStr;
        }
        if (!Utils::isUnset($request->intervalPeriod)) {
            $query['IntervalPeriod'] = $request->intervalPeriod;
        }
        if (!Utils::isUnset($request->param)) {
            $query['Param'] = $request->param;
        }
        if (!Utils::isUnset($request->periodUnit)) {
            $query['PeriodUnit'] = $request->periodUnit;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->targetEndTime)) {
            $query['TargetEndTime'] = $request->targetEndTime;
        }
        if (!Utils::isUnset($request->targetStartTime)) {
            $query['TargetStartTime'] = $request->targetStartTime;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateCycleTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateCycleTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *  *
     * @param CreateCycleTaskRequest $request CreateCycleTaskRequest
     *
     * @return CreateCycleTaskResponse CreateCycleTaskResponse
     */
    public function createCycleTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCycleTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Pushes a file to the cloud for detection.
     *  *
     * @description You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param CreateFileDetectRequest $request CreateFileDetectRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileDetectResponse CreateFileDetectResponse
     */
    public function createFileDetectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->decompress)) {
            $query['Decompress'] = $request->decompress;
        }
        if (!Utils::isUnset($request->decompressMaxFileCount)) {
            $query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }
        if (!Utils::isUnset($request->decompressMaxLayer)) {
            $query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }
        if (!Utils::isUnset($request->downloadUrl)) {
            $query['DownloadUrl'] = $request->downloadUrl;
        }
        if (!Utils::isUnset($request->hashKey)) {
            $query['HashKey'] = $request->hashKey;
        }
        if (!Utils::isUnset($request->ossKey)) {
            $query['OssKey'] = $request->ossKey;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFileDetect',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileDetectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Pushes a file to the cloud for detection.
     *  *
     * @description You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param CreateFileDetectRequest $request CreateFileDetectRequest
     *
     * @return CreateFileDetectResponse CreateFileDetectResponse
     */
    public function createFileDetect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileDetectWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the parameters that are required to upload a file for detection.
     *  *
     * @description You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
     * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param CreateFileDetectUploadUrlRequest $request CreateFileDetectUploadUrlRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileDetectUploadUrlResponse CreateFileDetectUploadUrlResponse
     */
    public function createFileDetectUploadUrlWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->hashKeyContextList)) {
            $query['HashKeyContextList'] = $request->hashKeyContextList;
        }
        if (!Utils::isUnset($request->hashKeyList)) {
            $query['HashKeyList'] = $request->hashKeyList;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFileDetectUploadUrl',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileDetectUploadUrlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the parameters that are required to upload a file for detection.
     *  *
     * @description You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
     * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
     * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param CreateFileDetectUploadUrlRequest $request CreateFileDetectUploadUrlRequest
     *
     * @return CreateFileDetectUploadUrlResponse CreateFileDetectUploadUrlResponse
     */
    public function createFileDetectUploadUrl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileDetectUploadUrlWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a core file monitoring rule.
     *  *
     * @param CreateFileProtectRuleRequest $request CreateFileProtectRuleRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileProtectRuleResponse CreateFileProtectRuleResponse
     */
    public function createFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alertLevel)) {
            $query['AlertLevel'] = $request->alertLevel;
        }
        if (!Utils::isUnset($request->fileOps)) {
            $query['FileOps'] = $request->fileOps;
        }
        if (!Utils::isUnset($request->filePaths)) {
            $query['FilePaths'] = $request->filePaths;
        }
        if (!Utils::isUnset($request->procPaths)) {
            $query['ProcPaths'] = $request->procPaths;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->switchId)) {
            $query['SwitchId'] = $request->switchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a core file monitoring rule.
     *  *
     * @param CreateFileProtectRuleRequest $request CreateFileProtectRuleRequest
     *
     * @return CreateFileProtectRuleResponse CreateFileProtectRuleResponse
     */
    public function createFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Specifies the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param CreateFileUploadLimitRequest $request CreateFileUploadLimitRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileUploadLimitResponse CreateFileUploadLimitResponse
     */
    public function createFileUploadLimitWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->limit)) {
            $query['Limit'] = $request->limit;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateFileUploadLimit',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileUploadLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Specifies the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param CreateFileUploadLimitRequest $request CreateFileUploadLimitRequest
     *
     * @return CreateFileUploadLimitResponse CreateFileUploadLimitResponse
     */
    public function createFileUploadLimit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileUploadLimitWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a honeypot.
     *  *
     * @param CreateHoneypotRequest $request CreateHoneypotRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotResponse CreateHoneypotResponse
     */
    public function createHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotImageId)) {
            $query['HoneypotImageId'] = $request->honeypotImageId;
        }
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->honeypotName)) {
            $query['HoneypotName'] = $request->honeypotName;
        }
        if (!Utils::isUnset($request->meta)) {
            $query['Meta'] = $request->meta;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a honeypot.
     *  *
     * @param CreateHoneypotRequest $request CreateHoneypotRequest
     *
     * @return CreateHoneypotResponse CreateHoneypotResponse
     */
    public function createHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a management node.
     *  *
     * @param CreateHoneypotNodeRequest $request CreateHoneypotNodeRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotNodeResponse CreateHoneypotNodeResponse
     */
    public function createHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allowHoneypotAccessInternet)) {
            $query['AllowHoneypotAccessInternet'] = $request->allowHoneypotAccessInternet;
        }
        if (!Utils::isUnset($request->availableProbeNum)) {
            $query['AvailableProbeNum'] = $request->availableProbeNum;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->securityGroupProbeIpList)) {
            $query['SecurityGroupProbeIpList'] = $request->securityGroupProbeIpList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a management node.
     *  *
     * @param CreateHoneypotNodeRequest $request CreateHoneypotNodeRequest
     *
     * @return CreateHoneypotNodeResponse CreateHoneypotNodeResponse
     */
    public function createHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a honeypot template.
     *  *
     * @param CreateHoneypotPresetRequest $request CreateHoneypotPresetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotPresetResponse CreateHoneypotPresetResponse
     */
    public function createHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->meta)) {
            $query['Meta'] = $request->meta;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->presetName)) {
            $query['PresetName'] = $request->presetName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a honeypot template.
     *  *
     * @param CreateHoneypotPresetRequest $request CreateHoneypotPresetRequest
     *
     * @return CreateHoneypotPresetResponse CreateHoneypotPresetResponse
     */
    public function createHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a probe.
     *  *
     * @param CreateHoneypotProbeRequest $request CreateHoneypotProbeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotProbeResponse CreateHoneypotProbeResponse
     */
    public function createHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->arp)) {
            $query['Arp'] = $request->arp;
        }
        if (!Utils::isUnset($request->businessGroupId)) {
            $query['BusinessGroupId'] = $request->businessGroupId;
        }
        if (!Utils::isUnset($request->controlNodeId)) {
            $query['ControlNodeId'] = $request->controlNodeId;
        }
        if (!Utils::isUnset($request->displayName)) {
            $query['DisplayName'] = $request->displayName;
        }
        if (!Utils::isUnset($request->honeypotBindList)) {
            $query['HoneypotBindList'] = $request->honeypotBindList;
        }
        if (!Utils::isUnset($request->ping)) {
            $query['Ping'] = $request->ping;
        }
        if (!Utils::isUnset($request->probeType)) {
            $query['ProbeType'] = $request->probeType;
        }
        if (!Utils::isUnset($request->probeVersion)) {
            $query['ProbeVersion'] = $request->probeVersion;
        }
        if (!Utils::isUnset($request->proxyIp)) {
            $query['ProxyIp'] = $request->proxyIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a probe.
     *  *
     * @param CreateHoneypotProbeRequest $request CreateHoneypotProbeRequest
     *
     * @return CreateHoneypotProbeResponse CreateHoneypotProbeResponse
     */
    public function createHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a monitoring or forwarding service for a probe.
     *  *
     * @param CreateHoneypotProbeBindRequest $request CreateHoneypotProbeBindRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateHoneypotProbeBindResponse CreateHoneypotProbeBindResponse
     */
    public function createHoneypotProbeBindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bindPortList)) {
            $query['BindPortList'] = $request->bindPortList;
        }
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        if (!Utils::isUnset($request->serviceIpList)) {
            $query['ServiceIpList'] = $request->serviceIpList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateHoneypotProbeBind',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateHoneypotProbeBindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a monitoring or forwarding service for a probe.
     *  *
     * @param CreateHoneypotProbeBindRequest $request CreateHoneypotProbeBindRequest
     *
     * @return CreateHoneypotProbeBindResponse CreateHoneypotProbeBindResponse
     */
    public function createHoneypotProbeBind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createHoneypotProbeBindWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a defense rule in the container firewall module.
     *  *
     * @param CreateInterceptionRuleRequest $tmpReq  CreateInterceptionRuleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateInterceptionRuleResponse CreateInterceptionRuleResponse
     */
    public function createInterceptionRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateInterceptionRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->dstTargetList)) {
            $request->dstTargetListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->dstTargetList, 'DstTargetList', 'json');
        }
        if (!Utils::isUnset($tmpReq->srcTarget)) {
            $request->srcTargetShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->srcTarget, 'SrcTarget', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->dstTargetListShrink)) {
            $query['DstTargetList'] = $request->dstTargetListShrink;
        }
        if (!Utils::isUnset($request->interceptType)) {
            $query['InterceptType'] = $request->interceptType;
        }
        if (!Utils::isUnset($request->orderIndex)) {
            $query['OrderIndex'] = $request->orderIndex;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->srcTargetShrink)) {
            $query['SrcTarget'] = $request->srcTargetShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateInterceptionRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateInterceptionRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a defense rule in the container firewall module.
     *  *
     * @param CreateInterceptionRuleRequest $request CreateInterceptionRuleRequest
     *
     * @return CreateInterceptionRuleResponse CreateInterceptionRuleResponse
     */
    public function createInterceptionRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createInterceptionRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a defense object.
     *  *
     * @param CreateInterceptionTargetRequest $request CreateInterceptionTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateInterceptionTargetResponse CreateInterceptionTargetResponse
     */
    public function createInterceptionTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->imageList)) {
            $query['ImageList'] = $request->imageList;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->tagList)) {
            $query['TagList'] = $request->tagList;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateInterceptionTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateInterceptionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a defense object.
     *  *
     * @param CreateInterceptionTargetRequest $request CreateInterceptionTargetRequest
     *
     * @return CreateInterceptionTargetResponse CreateInterceptionTargetResponse
     */
    public function createInterceptionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createInterceptionTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a Jenkins image repository.
     *  *
     * @param CreateJenkinsImageRegistryRequest $request CreateJenkinsImageRegistryRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateJenkinsImageRegistryResponse CreateJenkinsImageRegistryResponse
     */
    public function createJenkinsImageRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->domainName)) {
            $body['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->extraParam)) {
            $body['ExtraParam'] = $request->extraParam;
        }
        if (!Utils::isUnset($request->netType)) {
            $body['NetType'] = $request->netType;
        }
        if (!Utils::isUnset($request->password)) {
            $body['Password'] = $request->password;
        }
        if (!Utils::isUnset($request->persistenceDay)) {
            $body['PersistenceDay'] = $request->persistenceDay;
        }
        if (!Utils::isUnset($request->protocolType)) {
            $body['ProtocolType'] = $request->protocolType;
        }
        if (!Utils::isUnset($request->regionId)) {
            $body['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->registryHostIp)) {
            $body['RegistryHostIp'] = $request->registryHostIp;
        }
        if (!Utils::isUnset($request->registryName)) {
            $body['RegistryName'] = $request->registryName;
        }
        if (!Utils::isUnset($request->registryType)) {
            $body['RegistryType'] = $request->registryType;
        }
        if (!Utils::isUnset($request->registryVersion)) {
            $body['RegistryVersion'] = $request->registryVersion;
        }
        if (!Utils::isUnset($request->transPerHour)) {
            $body['TransPerHour'] = $request->transPerHour;
        }
        if (!Utils::isUnset($request->userName)) {
            $body['UserName'] = $request->userName;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $body['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->whiteList)) {
            $body['WhiteList'] = $request->whiteList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateJenkinsImageRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateJenkinsImageRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a Jenkins image repository.
     *  *
     * @param CreateJenkinsImageRegistryRequest $request CreateJenkinsImageRegistryRequest
     *
     * @return CreateJenkinsImageRegistryResponse CreateJenkinsImageRegistryResponse
     */
    public function createJenkinsImageRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createJenkinsImageRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param CreateMaliciousFileWhitelistConfigRequest $request CreateMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMaliciousFileWhitelistConfigResponse CreateMaliciousFileWhitelistConfigResponse
     */
    public function createMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->field)) {
            $query['Field'] = $request->field;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->operator)) {
            $query['Operator'] = $request->operator;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->targetValue)) {
            $query['TargetValue'] = $request->targetValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param CreateMaliciousFileWhitelistConfigRequest $request CreateMaliciousFileWhitelistConfigRequest
     *
     * @return CreateMaliciousFileWhitelistConfigResponse CreateMaliciousFileWhitelistConfigResponse
     */
    public function createMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds remarks to alert events for agentless detection.
     *  *
     * @param CreateMaliciousNoteRequest $request CreateMaliciousNoteRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMaliciousNoteResponse CreateMaliciousNoteResponse
     */
    public function createMaliciousNoteWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->note)) {
            $query['Note'] = $request->note;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateMaliciousNote',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateMaliciousNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds remarks to alert events for agentless detection.
     *  *
     * @param CreateMaliciousNoteRequest $request CreateMaliciousNoteRequest
     *
     * @return CreateMaliciousNoteResponse CreateMaliciousNoteResponse
     */
    public function createMaliciousNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMaliciousNoteWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
     *  *
     * @param CreateOpaClusterPluginRequest $request CreateOpaClusterPluginRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOpaClusterPluginResponse CreateOpaClusterPluginResponse
     */
    public function createOpaClusterPluginWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOpaClusterPlugin',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOpaClusterPluginResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
     *  *
     * @param CreateOpaClusterPluginRequest $request CreateOpaClusterPluginRequest
     *
     * @return CreateOpaClusterPluginResponse CreateOpaClusterPluginResponse
     */
    public function createOpaClusterPlugin($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOpaClusterPluginWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a rule to block at-risk images.
     *  *
     * @param CreateOpaStrategyNewRequest $tmpReq  CreateOpaStrategyNewRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOpaStrategyNewResponse CreateOpaStrategyNewResponse
     */
    public function createOpaStrategyNewWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateOpaStrategyNewShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->alarmDetail)) {
            $request->alarmDetailShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->alarmDetail, 'AlarmDetail', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->alarmDetailShrink)) {
            $query['AlarmDetail'] = $request->alarmDetailShrink;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->label)) {
            $query['Label'] = $request->label;
        }
        if (!Utils::isUnset($request->maliciousImage)) {
            $query['MaliciousImage'] = $request->maliciousImage;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->scopes)) {
            $query['Scopes'] = $request->scopes;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        if (!Utils::isUnset($request->strategyTemplateId)) {
            $query['StrategyTemplateId'] = $request->strategyTemplateId;
        }
        if (!Utils::isUnset($request->unScanedImage)) {
            $query['UnScanedImage'] = $request->unScanedImage;
        }
        if (!Utils::isUnset($request->whiteList)) {
            $query['WhiteList'] = $request->whiteList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOpaStrategyNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOpaStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a rule to block at-risk images.
     *  *
     * @param CreateOpaStrategyNewRequest $request CreateOpaStrategyNewRequest
     *
     * @return CreateOpaStrategyNewResponse CreateOpaStrategyNewResponse
     */
    public function createOpaStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOpaStrategyNewWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
     *  *
     * @description A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
     *  *
     * @param CreateOrUpdateAssetGroupRequest $request CreateOrUpdateAssetGroupRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOrUpdateAssetGroupResponse CreateOrUpdateAssetGroupResponse
     */
    public function createOrUpdateAssetGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->groupName)) {
            $query['GroupName'] = $request->groupName;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOrUpdateAssetGroup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOrUpdateAssetGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
     *  *
     * @description A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
     *  *
     * @param CreateOrUpdateAssetGroupRequest $request CreateOrUpdateAssetGroupRequest
     *
     * @return CreateOrUpdateAssetGroupResponse CreateOrUpdateAssetGroupResponse
     */
    public function createOrUpdateAssetGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOrUpdateAssetGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Creates or modifies a DingTalk chatbot that sends notifications.
     *  *
     * @param CreateOrUpdateDingTalkRequest $request CreateOrUpdateDingTalkRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOrUpdateDingTalkResponse CreateOrUpdateDingTalkResponse
     */
    public function createOrUpdateDingTalkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configList)) {
            $query['ConfigList'] = $request->configList;
        }
        if (!Utils::isUnset($request->dingTalkLang)) {
            $query['DingTalkLang'] = $request->dingTalkLang;
        }
        if (!Utils::isUnset($request->groupIdList)) {
            $query['GroupIdList'] = $request->groupIdList;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->intervalTime)) {
            $query['IntervalTime'] = $request->intervalTime;
        }
        if (!Utils::isUnset($request->ruleActionName)) {
            $query['RuleActionName'] = $request->ruleActionName;
        }
        if (!Utils::isUnset($request->sendUrl)) {
            $query['SendUrl'] = $request->sendUrl;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOrUpdateDingTalk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOrUpdateDingTalkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates or modifies a DingTalk chatbot that sends notifications.
     *  *
     * @param CreateOrUpdateDingTalkRequest $request CreateOrUpdateDingTalkRequest
     *
     * @return CreateOrUpdateDingTalkResponse CreateOrUpdateDingTalkResponse
     */
    public function createOrUpdateDingTalk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOrUpdateDingTalkWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a bucket check task.
     *  *
     * @param CreateOssBucketScanTaskRequest $request CreateOssBucketScanTaskRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOssBucketScanTaskResponse CreateOssBucketScanTaskResponse
     */
    public function createOssBucketScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allKeyPrefix)) {
            $query['AllKeyPrefix'] = $request->allKeyPrefix;
        }
        if (!Utils::isUnset($request->bucketNameList)) {
            $query['BucketNameList'] = $request->bucketNameList;
        }
        if (!Utils::isUnset($request->decompressMaxFileCount)) {
            $query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }
        if (!Utils::isUnset($request->decompressMaxLayer)) {
            $query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }
        if (!Utils::isUnset($request->excludeKeySuffixList)) {
            $query['ExcludeKeySuffixList'] = $request->excludeKeySuffixList;
        }
        if (!Utils::isUnset($request->keyPrefixList)) {
            $query['KeyPrefixList'] = $request->keyPrefixList;
        }
        if (!Utils::isUnset($request->keySuffixList)) {
            $query['KeySuffixList'] = $request->keySuffixList;
        }
        if (!Utils::isUnset($request->scanMode)) {
            $query['ScanMode'] = $request->scanMode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOssBucketScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOssBucketScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a bucket check task.
     *  *
     * @param CreateOssBucketScanTaskRequest $request CreateOssBucketScanTaskRequest
     *
     * @return CreateOssBucketScanTaskResponse CreateOssBucketScanTaskResponse
     */
    public function createOssBucketScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOssBucketScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a scan policy.
     *  *
     * @param CreateOssScanConfigRequest $request CreateOssScanConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateOssScanConfigResponse CreateOssScanConfigResponse
     */
    public function createOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allKeyPrefix)) {
            $query['AllKeyPrefix'] = $request->allKeyPrefix;
        }
        if (!Utils::isUnset($request->bucketNameList)) {
            $query['BucketNameList'] = $request->bucketNameList;
        }
        if (!Utils::isUnset($request->decompressMaxFileCount)) {
            $query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }
        if (!Utils::isUnset($request->decompressMaxLayer)) {
            $query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }
        if (!Utils::isUnset($request->enable)) {
            $query['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->keyPrefixList)) {
            $query['KeyPrefixList'] = $request->keyPrefixList;
        }
        if (!Utils::isUnset($request->keySuffixList)) {
            $query['KeySuffixList'] = $request->keySuffixList;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->scanDayList)) {
            $query['ScanDayList'] = $request->scanDayList;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a scan policy.
     *  *
     * @param CreateOssScanConfigRequest $request CreateOssScanConfigRequest
     *
     * @return CreateOssScanConfigResponse CreateOssScanConfigResponse
     */
    public function createOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a restoration task.
     *  *
     * @param CreateRestoreJobRequest $request CreateRestoreJobRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRestoreJobResponse CreateRestoreJobResponse
     */
    public function createRestoreJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->includes)) {
            $query['Includes'] = $request->includes;
        }
        if (!Utils::isUnset($request->snapshotHash)) {
            $query['SnapshotHash'] = $request->snapshotHash;
        }
        if (!Utils::isUnset($request->snapshotId)) {
            $query['SnapshotId'] = $request->snapshotId;
        }
        if (!Utils::isUnset($request->snapshotVersion)) {
            $query['SnapshotVersion'] = $request->snapshotVersion;
        }
        if (!Utils::isUnset($request->sourceType)) {
            $query['SourceType'] = $request->sourceType;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->vaultId)) {
            $query['VaultId'] = $request->vaultId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateRestoreJob',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateRestoreJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a restoration task.
     *  *
     * @param CreateRestoreJobRequest $request CreateRestoreJobRequest
     *
     * @return CreateRestoreJobResponse CreateRestoreJobResponse
     */
    public function createRestoreJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRestoreJobWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a service-linked role and authorizes Security Center to access cloud resources.
     *  *
     * @description For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
     *  *
     * @param CreateServiceLinkedRoleRequest $request CreateServiceLinkedRoleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateServiceLinkedRoleResponse CreateServiceLinkedRoleResponse
     */
    public function createServiceLinkedRoleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->serviceLinkedRole)) {
            $query['ServiceLinkedRole'] = $request->serviceLinkedRole;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateServiceLinkedRole',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateServiceLinkedRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a service-linked role and authorizes Security Center to access cloud resources.
     *  *
     * @description For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
     *  *
     * @param CreateServiceLinkedRoleRequest $request CreateServiceLinkedRoleRequest
     *
     * @return CreateServiceLinkedRoleResponse CreateServiceLinkedRoleResponse
     */
    public function createServiceLinkedRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createServiceLinkedRoleWithOptions($request, $runtime);
    }

    /**
     * @summary Create a service trail.
     *  *
     * @param CreateServiceTrailRequest $request CreateServiceTrailRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateServiceTrailResponse CreateServiceTrailResponse
     */
    public function createServiceTrailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateServiceTrail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateServiceTrailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Create a service trail.
     *  *
     * @param CreateServiceTrailRequest $request CreateServiceTrailRequest
     *
     * @return CreateServiceTrailResponse CreateServiceTrailResponse
     */
    public function createServiceTrail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createServiceTrailWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a task to query alert events that are triggered by the same rule or of the same alert type.
     *  *
     * @param CreateSimilarSecurityEventsQueryTaskRequest $request CreateSimilarSecurityEventsQueryTaskRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateSimilarSecurityEventsQueryTaskResponse CreateSimilarSecurityEventsQueryTaskResponse
     */
    public function createSimilarSecurityEventsQueryTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityEventId)) {
            $query['SecurityEventId'] = $request->securityEventId;
        }
        if (!Utils::isUnset($request->similarEventScenarioCode)) {
            $query['SimilarEventScenarioCode'] = $request->similarEventScenarioCode;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateSimilarSecurityEventsQueryTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateSimilarSecurityEventsQueryTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a task to query alert events that are triggered by the same rule or of the same alert type.
     *  *
     * @param CreateSimilarSecurityEventsQueryTaskRequest $request CreateSimilarSecurityEventsQueryTaskRequest
     *
     * @return CreateSimilarSecurityEventsQueryTaskResponse CreateSimilarSecurityEventsQueryTaskResponse
     */
    public function createSimilarSecurityEventsQueryTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSimilarSecurityEventsQueryTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Adds remarks to an alert event.
     *  *
     * @param CreateSuspEventNoteRequest $request CreateSuspEventNoteRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateSuspEventNoteResponse CreateSuspEventNoteResponse
     */
    public function createSuspEventNoteWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->note)) {
            $query['Note'] = $request->note;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateSuspEventNote',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateSuspEventNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds remarks to an alert event.
     *  *
     * @param CreateSuspEventNoteRequest $request CreateSuspEventNoteRequest
     *
     * @return CreateSuspEventNoteResponse CreateSuspEventNoteResponse
     */
    public function createSuspEventNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSuspEventNoteWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an anti-ransomware policy for a database.
     *  *
     * @param CreateUniBackupPolicyRequest $tmpReq  CreateUniBackupPolicyRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateUniBackupPolicyResponse CreateUniBackupPolicyResponse
     */
    public function createUniBackupPolicyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateUniBackupPolicyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->fullPlan)) {
            $request->fullPlanShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->fullPlan, 'FullPlan', 'json');
        }
        if (!Utils::isUnset($tmpReq->incPlan)) {
            $request->incPlanShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->incPlan, 'IncPlan', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->accountName)) {
            $query['AccountName'] = $request->accountName;
        }
        if (!Utils::isUnset($request->accountPassword)) {
            $query['AccountPassword'] = $request->accountPassword;
        }
        if (!Utils::isUnset($request->databaseAddByUser)) {
            $query['DatabaseAddByUser'] = $request->databaseAddByUser;
        }
        if (!Utils::isUnset($request->databaseType)) {
            $query['DatabaseType'] = $request->databaseType;
        }
        if (!Utils::isUnset($request->fullPlanShrink)) {
            $query['FullPlan'] = $request->fullPlanShrink;
        }
        if (!Utils::isUnset($request->incPlanShrink)) {
            $query['IncPlan'] = $request->incPlanShrink;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->policyName)) {
            $query['PolicyName'] = $request->policyName;
        }
        if (!Utils::isUnset($request->retention)) {
            $query['Retention'] = $request->retention;
        }
        if (!Utils::isUnset($request->speedLimiter)) {
            $query['SpeedLimiter'] = $request->speedLimiter;
        }
        if (!Utils::isUnset($request->uniRegionId)) {
            $query['UniRegionId'] = $request->uniRegionId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateUniBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateUniBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an anti-ransomware policy for a database.
     *  *
     * @param CreateUniBackupPolicyRequest $request CreateUniBackupPolicyRequest
     *
     * @return CreateUniBackupPolicyResponse CreateUniBackupPolicyResponse
     */
    public function createUniBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUniBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a restoration task for a database.
     *  *
     * @param CreateUniRestorePlanRequest $request CreateUniRestorePlanRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateUniRestorePlanResponse CreateUniRestorePlanResponse
     */
    public function createUniRestorePlanWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->database)) {
            $query['Database'] = $request->database;
        }
        if (!Utils::isUnset($request->instanceUuid)) {
            $query['InstanceUuid'] = $request->instanceUuid;
        }
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->resetScn)) {
            $query['ResetScn'] = $request->resetScn;
        }
        if (!Utils::isUnset($request->resetTime)) {
            $query['ResetTime'] = $request->resetTime;
        }
        if (!Utils::isUnset($request->restoreInfo)) {
            $query['RestoreInfo'] = $request->restoreInfo;
        }
        if (!Utils::isUnset($request->timePoint)) {
            $query['TimePoint'] = $request->timePoint;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateUniRestorePlan',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateUniRestorePlanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a restoration task for a database.
     *  *
     * @param CreateUniRestorePlanRequest $request CreateUniRestorePlanRequest
     *
     * @return CreateUniRestorePlanResponse CreateUniRestorePlanResponse
     */
    public function createUniRestorePlan($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUniRestorePlanWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a one-time virus scan task that is immediately executed.
     *  *
     * @param CreateVirusScanOnceTaskRequest $request CreateVirusScanOnceTaskRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVirusScanOnceTaskResponse CreateVirusScanOnceTaskResponse
     */
    public function createVirusScanOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->scanPath)) {
            $query['ScanPath'] = $request->scanPath;
        }
        if (!Utils::isUnset($request->scanType)) {
            $query['ScanType'] = $request->scanType;
        }
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVirusScanOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVirusScanOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a one-time virus scan task that is immediately executed.
     *  *
     * @param CreateVirusScanOnceTaskRequest $request CreateVirusScanOnceTaskRequest
     *
     * @return CreateVirusScanOnceTaskResponse CreateVirusScanOnceTaskResponse
     */
    public function createVirusScanOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVirusScanOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
     *  *
     * @param CreateVulAutoRepairConfigRequest $request CreateVulAutoRepairConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateVulAutoRepairConfigResponse CreateVulAutoRepairConfigResponse
     */
    public function createVulAutoRepairConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->vulAutoRepairConfigList)) {
            $query['VulAutoRepairConfigList'] = $request->vulAutoRepairConfigList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateVulAutoRepairConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateVulAutoRepairConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
     *  *
     * @param CreateVulAutoRepairConfigRequest $request CreateVulAutoRepairConfigRequest
     *
     * @return CreateVulAutoRepairConfigResponse CreateVulAutoRepairConfigResponse
     */
    public function createVulAutoRepairConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createVulAutoRepairConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the specified defense rules against brute-force attacks.
     *  *
     * @param DeleteAntiBruteForceRuleRequest $request DeleteAntiBruteForceRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteAntiBruteForceRuleResponse DeleteAntiBruteForceRuleResponse
     */
    public function deleteAntiBruteForceRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteAntiBruteForceRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the specified defense rules against brute-force attacks.
     *  *
     * @param DeleteAntiBruteForceRuleRequest $request DeleteAntiBruteForceRuleRequest
     *
     * @return DeleteAntiBruteForceRuleResponse DeleteAntiBruteForceRuleResponse
     */
    public function deleteAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an anti-ransomware policy.
     *  *
     * @param DeleteBackupPolicyRequest $request DeleteBackupPolicyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBackupPolicyResponse DeleteBackupPolicyResponse
     */
    public function deleteBackupPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an anti-ransomware policy.
     *  *
     * @param DeleteBackupPolicyRequest $request DeleteBackupPolicyRequest
     *
     * @return DeleteBackupPolicyResponse DeleteBackupPolicyResponse
     */
    public function deleteBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
     *  *
     * @param DeleteBackupPolicyMachineRequest $request DeleteBackupPolicyMachineRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBackupPolicyMachineResponse DeleteBackupPolicyMachineResponse
     */
    public function deleteBackupPolicyMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBackupPolicyMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBackupPolicyMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
     *  *
     * @param DeleteBackupPolicyMachineRequest $request DeleteBackupPolicyMachineRequest
     *
     * @return DeleteBackupPolicyMachineResponse DeleteBackupPolicyMachineResponse
     */
    public function deleteBackupPolicyMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupPolicyMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a binary security policy from the container signature feature.
     *  *
     * @param DeleteBinarySecurityPolicyRequest $request DeleteBinarySecurityPolicyRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBinarySecurityPolicyResponse DeleteBinarySecurityPolicyResponse
     */
    public function deleteBinarySecurityPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteBinarySecurityPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBinarySecurityPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a binary security policy from the container signature feature.
     *  *
     * @param DeleteBinarySecurityPolicyRequest $request DeleteBinarySecurityPolicyRequest
     *
     * @return DeleteBinarySecurityPolicyResponse DeleteBinarySecurityPolicyResponse
     */
    public function deleteBinarySecurityPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBinarySecurityPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes specified custom defense rules.
     *  *
     * @param DeleteClientUserDefineRuleRequest $request DeleteClientUserDefineRuleRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteClientUserDefineRuleResponse DeleteClientUserDefineRuleResponse
     */
    public function deleteClientUserDefineRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->idList)) {
            $query['IdList'] = $request->idList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteClientUserDefineRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes specified custom defense rules.
     *  *
     * @param DeleteClientUserDefineRuleRequest $request DeleteClientUserDefineRuleRequest
     *
     * @return DeleteClientUserDefineRuleResponse DeleteClientUserDefineRuleResponse
     */
    public function deleteClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a rule for non-image program defense.
     *  *
     * @param DeleteContainerDefenseRuleRequest $request DeleteContainerDefenseRuleRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteContainerDefenseRuleResponse DeleteContainerDefenseRuleResponse
     */
    public function deleteContainerDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleIds)) {
            $query['RuleIds'] = $request->ruleIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteContainerDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a rule for non-image program defense.
     *  *
     * @param DeleteContainerDefenseRuleRequest $request DeleteContainerDefenseRuleRequest
     *
     * @return DeleteContainerDefenseRuleResponse DeleteContainerDefenseRuleResponse
     */
    public function deleteContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a defense rule against container escapes.
     *  *
     * @param DeleteContainerPluginRuleRequest $request DeleteContainerPluginRuleRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteContainerPluginRuleResponse DeleteContainerPluginRuleResponse
     */
    public function deleteContainerPluginRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteContainerPluginRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a defense rule against container escapes.
     *  *
     * @param DeleteContainerPluginRuleRequest $request DeleteContainerPluginRuleRequest
     *
     * @return DeleteContainerPluginRuleResponse DeleteContainerPluginRuleResponse
     */
    public function deleteContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified IP address blocking policy from one or more servers.
     *  *
     * @param DeleteCustomBlockRecordRequest $request DeleteCustomBlockRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCustomBlockRecordResponse DeleteCustomBlockRecordResponse
     */
    public function deleteCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified IP address blocking policy from one or more servers.
     *  *
     * @param DeleteCustomBlockRecordRequest $request DeleteCustomBlockRecordRequest
     *
     * @return DeleteCustomBlockRecordResponse DeleteCustomBlockRecordResponse
     */
    public function deleteCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *  *
     * @param DeleteCycleTaskRequest $request DeleteCycleTaskRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteCycleTaskResponse DeleteCycleTaskResponse
     */
    public function deleteCycleTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteCycleTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteCycleTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
     *  *
     * @param DeleteCycleTaskRequest $request DeleteCycleTaskRequest
     *
     * @return DeleteCycleTaskResponse DeleteCycleTaskResponse
     */
    public function deleteCycleTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCycleTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes core file monitoring rules.
     *  *
     * @param DeleteFileProtectRuleRequest $request DeleteFileProtectRuleRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFileProtectRuleResponse DeleteFileProtectRuleResponse
     */
    public function deleteFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes core file monitoring rules.
     *  *
     * @param DeleteFileProtectRuleRequest $request DeleteFileProtectRuleRequest
     *
     * @return DeleteFileProtectRuleResponse DeleteFileProtectRuleResponse
     */
    public function deleteFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a server group.
     *  *
     * @description The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
     *  *
     * @param DeleteGroupRequest $request DeleteGroupRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteGroupResponse DeleteGroupResponse
     */
    public function deleteGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteGroup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a server group.
     *  *
     * @description The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
     *  *
     * @param DeleteGroupRequest $request DeleteGroupRequest
     *
     * @return DeleteGroupResponse DeleteGroupResponse
     */
    public function deleteGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified honeypot.
     *  *
     * @param DeleteHoneypotRequest $request DeleteHoneypotRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotResponse DeleteHoneypotResponse
     */
    public function deleteHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified honeypot.
     *  *
     * @param DeleteHoneypotRequest $request DeleteHoneypotRequest
     *
     * @return DeleteHoneypotResponse DeleteHoneypotResponse
     */
    public function deleteHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified management node.
     *  *
     * @param DeleteHoneypotNodeRequest $request DeleteHoneypotNodeRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotNodeResponse DeleteHoneypotNodeResponse
     */
    public function deleteHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified management node.
     *  *
     * @param DeleteHoneypotNodeRequest $request DeleteHoneypotNodeRequest
     *
     * @return DeleteHoneypotNodeResponse DeleteHoneypotNodeResponse
     */
    public function deleteHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified honeypot template.
     *  *
     * @param DeleteHoneypotPresetRequest $request DeleteHoneypotPresetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotPresetResponse DeleteHoneypotPresetResponse
     */
    public function deleteHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotPresetId)) {
            $query['HoneypotPresetId'] = $request->honeypotPresetId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified honeypot template.
     *  *
     * @param DeleteHoneypotPresetRequest $request DeleteHoneypotPresetRequest
     *
     * @return DeleteHoneypotPresetResponse DeleteHoneypotPresetResponse
     */
    public function deleteHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified probe.
     *  *
     * @param DeleteHoneypotProbeRequest $request DeleteHoneypotProbeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotProbeResponse DeleteHoneypotProbeResponse
     */
    public function deleteHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified probe.
     *  *
     * @param DeleteHoneypotProbeRequest $request DeleteHoneypotProbeRequest
     *
     * @return DeleteHoneypotProbeResponse DeleteHoneypotProbeResponse
     */
    public function deleteHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary Delete the probe service.
     *  *
     * @param DeleteHoneypotProbeBindRequest $request DeleteHoneypotProbeBindRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteHoneypotProbeBindResponse DeleteHoneypotProbeBindResponse
     */
    public function deleteHoneypotProbeBindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bindId)) {
            $query['BindId'] = $request->bindId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteHoneypotProbeBind',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteHoneypotProbeBindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Delete the probe service.
     *  *
     * @param DeleteHoneypotProbeBindRequest $request DeleteHoneypotProbeBindRequest
     *
     * @return DeleteHoneypotProbeBindResponse DeleteHoneypotProbeBindResponse
     */
    public function deleteHoneypotProbeBind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteHoneypotProbeBindWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an alert handling rule.
     *  *
     * @param DeleteImageEventOperationRequest $request DeleteImageEventOperationRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteImageEventOperationResponse DeleteImageEventOperationResponse
     */
    public function deleteImageEventOperationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteImageEventOperation',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an alert handling rule.
     *  *
     * @param DeleteImageEventOperationRequest $request DeleteImageEventOperationRequest
     *
     * @return DeleteImageEventOperationResponse DeleteImageEventOperationResponse
     */
    public function deleteImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an image vulnerability whitelist.
     *  *
     * @param DeleteImageVulWhitelistRequest $request DeleteImageVulWhitelistRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteImageVulWhitelistResponse DeleteImageVulWhitelistResponse
     */
    public function deleteImageVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteImageVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteImageVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an image vulnerability whitelist.
     *  *
     * @param DeleteImageVulWhitelistRequest $request DeleteImageVulWhitelistRequest
     *
     * @return DeleteImageVulWhitelistResponse DeleteImageVulWhitelistResponse
     */
    public function deleteImageVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteImageVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the command that is used to install the Security Center agent.
     *  *
     * @param DeleteInstallCodeRequest $request DeleteInstallCodeRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteInstallCodeResponse DeleteInstallCodeResponse
     */
    public function deleteInstallCodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->captchaCode)) {
            $query['CaptchaCode'] = $request->captchaCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteInstallCode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the command that is used to install the Security Center agent.
     *  *
     * @param DeleteInstallCodeRequest $request DeleteInstallCodeRequest
     *
     * @return DeleteInstallCodeResponse DeleteInstallCodeResponse
     */
    public function deleteInstallCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteInstallCodeWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a defense rule in the container firewall module.
     *  *
     * @param DeleteInterceptionRuleRequest $request DeleteInterceptionRuleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteInterceptionRuleResponse DeleteInterceptionRuleResponse
     */
    public function deleteInterceptionRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->ruleIds)) {
            $query['RuleIds'] = $request->ruleIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteInterceptionRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteInterceptionRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a defense rule in the container firewall module.
     *  *
     * @param DeleteInterceptionRuleRequest $request DeleteInterceptionRuleRequest
     *
     * @return DeleteInterceptionRuleResponse DeleteInterceptionRuleResponse
     */
    public function deleteInterceptionRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteInterceptionRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Removes the network objects that are in effect in the container firewall.
     *  *
     * @param DeleteInterceptionTargetRequest $request DeleteInterceptionTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteInterceptionTargetResponse DeleteInterceptionTargetResponse
     */
    public function deleteInterceptionTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->targetIds)) {
            $query['TargetIds'] = $request->targetIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteInterceptionTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteInterceptionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes the network objects that are in effect in the container firewall.
     *  *
     * @param DeleteInterceptionTargetRequest $request DeleteInterceptionTargetRequest
     *
     * @return DeleteInterceptionTargetResponse DeleteInterceptionTargetResponse
     */
    public function deleteInterceptionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteInterceptionTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the Kubernetes access information.
     *  *
     * @param DeleteK8sAccessInfoRequest $request DeleteK8sAccessInfoRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteK8sAccessInfoResponse DeleteK8sAccessInfoResponse
     */
    public function deleteK8sAccessInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliyunYundunGatewayApiName)) {
            $query['AliyunYundunGatewayApiName'] = $request->aliyunYundunGatewayApiName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayPopName)) {
            $query['AliyunYundunGatewayPopName'] = $request->aliyunYundunGatewayPopName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayProjectName)) {
            $query['AliyunYundunGatewayProjectName'] = $request->aliyunYundunGatewayProjectName;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteK8sAccessInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteK8sAccessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the Kubernetes access information.
     *  *
     * @param DeleteK8sAccessInfoRequest $request DeleteK8sAccessInfoRequest
     *
     * @return DeleteK8sAccessInfoResponse DeleteK8sAccessInfoResponse
     */
    public function deleteK8sAccessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteK8sAccessInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the basic configuration information from the logon security configurations for a specific asset.
     *  *
     * @param DeleteLoginBaseConfigRequest $request DeleteLoginBaseConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLoginBaseConfigResponse DeleteLoginBaseConfigResponse
     */
    public function deleteLoginBaseConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteLoginBaseConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteLoginBaseConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the basic configuration information from the logon security configurations for a specific asset.
     *  *
     * @param DeleteLoginBaseConfigRequest $request DeleteLoginBaseConfigRequest
     *
     * @return DeleteLoginBaseConfigResponse DeleteLoginBaseConfigResponse
     */
    public function deleteLoginBaseConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLoginBaseConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param DeleteMaliciousFileWhitelistConfigRequest $request DeleteMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMaliciousFileWhitelistConfigResponse DeleteMaliciousFileWhitelistConfigResponse
     */
    public function deleteMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param DeleteMaliciousFileWhitelistConfigRequest $request DeleteMaliciousFileWhitelistConfigRequest
     *
     * @return DeleteMaliciousFileWhitelistConfigResponse DeleteMaliciousFileWhitelistConfigResponse
     */
    public function deleteMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Removes the remarks added to alert events that are generated by the agentless detection feature.
     *  *
     * @param DeleteMaliciousNoteRequest $request DeleteMaliciousNoteRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMaliciousNoteResponse DeleteMaliciousNoteResponse
     */
    public function deleteMaliciousNoteWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->noteId)) {
            $query['NoteId'] = $request->noteId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMaliciousNote',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMaliciousNoteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes the remarks added to alert events that are generated by the agentless detection feature.
     *  *
     * @param DeleteMaliciousNoteRequest $request DeleteMaliciousNoteRequest
     *
     * @return DeleteMaliciousNoteResponse DeleteMaliciousNoteResponse
     */
    public function deleteMaliciousNote($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMaliciousNoteWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes rules of the at-risk image blocking type.
     *  *
     * @param DeleteOpaStrategyNewRequest $request DeleteOpaStrategyNewRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteOpaStrategyNewResponse DeleteOpaStrategyNewResponse
     */
    public function deleteOpaStrategyNewWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyIds)) {
            $query['StrategyIds'] = $request->strategyIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteOpaStrategyNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteOpaStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes rules of the at-risk image blocking type.
     *  *
     * @param DeleteOpaStrategyNewRequest $request DeleteOpaStrategyNewRequest
     *
     * @return DeleteOpaStrategyNewResponse DeleteOpaStrategyNewResponse
     */
    public function deleteOpaStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteOpaStrategyNewWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the configuration of an Object Storage Service (OSS) file detection policy.
     *  *
     * @param DeleteOssScanConfigRequest $request DeleteOssScanConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteOssScanConfigResponse DeleteOssScanConfigResponse
     */
    public function deleteOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the configuration of an Object Storage Service (OSS) file detection policy.
     *  *
     * @param DeleteOssScanConfigRequest $request DeleteOssScanConfigRequest
     *
     * @return DeleteOssScanConfigResponse DeleteOssScanConfigResponse
     */
    public function deleteOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a private image repository by using the ID of the image repository.
     *  *
     * @param DeletePrivateRegistryRequest $request DeletePrivateRegistryRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeletePrivateRegistryResponse DeletePrivateRegistryResponse
     */
    public function deletePrivateRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->registryId)) {
            $query['RegistryId'] = $request->registryId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeletePrivateRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeletePrivateRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a private image repository by using the ID of the image repository.
     *  *
     * @param DeletePrivateRegistryRequest $request DeletePrivateRegistryRequest
     *
     * @return DeletePrivateRegistryResponse DeletePrivateRegistryResponse
     */
    public function deletePrivateRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePrivateRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a rule for container tamper-proofing.
     *  *
     * @param DeleteSasContainerWebDefenseRuleRequest $request DeleteSasContainerWebDefenseRuleRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSasContainerWebDefenseRuleResponse DeleteSasContainerWebDefenseRuleResponse
     */
    public function deleteSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSasContainerWebDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a rule for container tamper-proofing.
     *  *
     * @param DeleteSasContainerWebDefenseRuleRequest $request DeleteSasContainerWebDefenseRuleRequest
     *
     * @return DeleteSasContainerWebDefenseRuleResponse DeleteSasContainerWebDefenseRuleResponse
     */
    public function deleteSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
     *  *
     * @param DeleteSecurityEventMarkMissListRequest $request DeleteSecurityEventMarkMissListRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSecurityEventMarkMissListResponse DeleteSecurityEventMarkMissListResponse
     */
    public function deleteSecurityEventMarkMissListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSecurityEventMarkMissList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSecurityEventMarkMissListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
     *  *
     * @param DeleteSecurityEventMarkMissListRequest $request DeleteSecurityEventMarkMissListRequest
     *
     * @return DeleteSecurityEventMarkMissListResponse DeleteSecurityEventMarkMissListResponse
     */
    public function deleteSecurityEventMarkMissList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSecurityEventMarkMissListWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a service trail.
     *  *
     * @param DeleteServiceTrailRequest $request DeleteServiceTrailRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteServiceTrailResponse DeleteServiceTrailResponse
     */
    public function deleteServiceTrailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteServiceTrail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteServiceTrailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a service trail.
     *  *
     * @param DeleteServiceTrailRequest $request DeleteServiceTrailRequest
     *
     * @return DeleteServiceTrailResponse DeleteServiceTrailResponse
     */
    public function deleteServiceTrail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteServiceTrailWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a baseline check policy.
     *  *
     * @param DeleteStrategyRequest $request DeleteStrategyRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteStrategyResponse DeleteStrategyResponse
     */
    public function deleteStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a baseline check policy.
     *  *
     * @param DeleteStrategyRequest $request DeleteStrategyRequest
     *
     * @return DeleteStrategyResponse DeleteStrategyResponse
     */
    public function deleteStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the description of an alert.
     *  *
     * @param DeleteSuspEventNodeRequest $request DeleteSuspEventNodeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteSuspEventNodeResponse DeleteSuspEventNodeResponse
     */
    public function deleteSuspEventNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->noteId)) {
            $query['NoteId'] = $request->noteId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteSuspEventNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteSuspEventNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the description of an alert.
     *  *
     * @param DeleteSuspEventNodeRequest $request DeleteSuspEventNodeRequest
     *
     * @return DeleteSuspEventNodeResponse DeleteSuspEventNodeResponse
     */
    public function deleteSuspEventNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSuspEventNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Removes custom tags from assets.
     *  *
     * @description Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
     *  *
     * @param DeleteTagWithUuidRequest $request DeleteTagWithUuidRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTagWithUuidResponse DeleteTagWithUuidResponse
     */
    public function deleteTagWithUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tagName)) {
            $query['TagName'] = $request->tagName;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTagWithUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTagWithUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes custom tags from assets.
     *  *
     * @description Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
     *  *
     * @param DeleteTagWithUuidRequest $request DeleteTagWithUuidRequest
     *
     * @return DeleteTagWithUuidResponse DeleteTagWithUuidResponse
     */
    public function deleteTagWithUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTagWithUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes anti-ransomware policies that are created for databases.
     *  *
     * @param DeleteUniBackupPolicyRequest $request DeleteUniBackupPolicyRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteUniBackupPolicyResponse DeleteUniBackupPolicyResponse
     */
    public function deleteUniBackupPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->policyIds)) {
            $query['PolicyIds'] = $request->policyIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteUniBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteUniBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes anti-ransomware policies that are created for databases.
     *  *
     * @param DeleteUniBackupPolicyRequest $request DeleteUniBackupPolicyRequest
     *
     * @return DeleteUniBackupPolicyResponse DeleteUniBackupPolicyResponse
     */
    public function deleteUniBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteUniBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a honeypot.
     *  *
     * @param DeleteVpcHoneyPotRequest $request DeleteVpcHoneyPotRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVpcHoneyPotResponse DeleteVpcHoneyPotResponse
     */
    public function deleteVpcHoneyPotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVpcHoneyPot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVpcHoneyPotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a honeypot.
     *  *
     * @param DeleteVpcHoneyPotRequest $request DeleteVpcHoneyPotRequest
     *
     * @return DeleteVpcHoneyPotResponse DeleteVpcHoneyPotResponse
     */
    public function deleteVpcHoneyPot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVpcHoneyPotWithOptions($request, $runtime);
    }

    /**
     * @summary Delete a list of vulnerabilities that can be automatically fixed. After the list is deleted, you can not select the list when you create a vulnerability fixing task on the Playbook page.
     *  *
     * @param DeleteVulAutoRepairConfigRequest $request DeleteVulAutoRepairConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVulAutoRepairConfigResponse DeleteVulAutoRepairConfigResponse
     */
    public function deleteVulAutoRepairConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->configIdList)) {
            $query['ConfigIdList'] = $request->configIdList;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVulAutoRepairConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVulAutoRepairConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Delete a list of vulnerabilities that can be automatically fixed. After the list is deleted, you can not select the list when you create a vulnerability fixing task on the Playbook page.
     *  *
     * @param DeleteVulAutoRepairConfigRequest $request DeleteVulAutoRepairConfigRequest
     *
     * @return DeleteVulAutoRepairConfigResponse DeleteVulAutoRepairConfigResponse
     */
    public function deleteVulAutoRepairConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVulAutoRepairConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a specified vulnerability whitelist.
     *  *
     * @param DeleteVulWhitelistRequest $request DeleteVulWhitelistRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteVulWhitelistResponse DeleteVulWhitelistResponse
     */
    public function deleteVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->whitelist)) {
            $query['Whitelist'] = $request->whitelist;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a specified vulnerability whitelist.
     *  *
     * @param DeleteVulWhitelistRequest $request DeleteVulWhitelistRequest
     *
     * @return DeleteVulWhitelistResponse DeleteVulWhitelistResponse
     */
    public function deleteVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of AccessKey pair leaks.
     *  *
     * @param DescribeAccessKeyLeakDetailRequest $request DescribeAccessKeyLeakDetailRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAccessKeyLeakDetailResponse DescribeAccessKeyLeakDetailResponse
     */
    public function describeAccessKeyLeakDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAccessKeyLeakDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAccessKeyLeakDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of AccessKey pair leaks.
     *  *
     * @param DescribeAccessKeyLeakDetailRequest $request DescribeAccessKeyLeakDetailRequest
     *
     * @return DescribeAccessKeyLeakDetailResponse DescribeAccessKeyLeakDetailResponse
     */
    public function describeAccessKeyLeakDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccessKeyLeakDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the AccessKey pair leaks that are detected on your assets.
     *  *
     * @param DescribeAccesskeyLeakListRequest $request DescribeAccesskeyLeakListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAccesskeyLeakListResponse DescribeAccesskeyLeakListResponse
     */
    public function describeAccesskeyLeakListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->query)) {
            $query['Query'] = $request->query;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->startTs)) {
            $query['StartTs'] = $request->startTs;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAccesskeyLeakList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAccesskeyLeakListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the AccessKey pair leaks that are detected on your assets.
     *  *
     * @param DescribeAccesskeyLeakListRequest $request DescribeAccesskeyLeakListRequest
     *
     * @return DescribeAccesskeyLeakListResponse DescribeAccesskeyLeakListResponse
     */
    public function describeAccesskeyLeakList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccesskeyLeakListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the affected servers in the result of a virus scan task.
     *  *
     * @param DescribeAffectedAssetsRequest $request DescribeAffectedAssetsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAffectedAssetsResponse DescribeAffectedAssetsResponse
     */
    public function describeAffectedAssetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->current)) {
            $query['Current'] = $request->current;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAffectedAssets',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAffectedAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the affected servers in the result of a virus scan task.
     *  *
     * @param DescribeAffectedAssetsRequest $request DescribeAffectedAssetsRequest
     *
     * @return DescribeAffectedAssetsResponse DescribeAffectedAssetsResponse
     */
    public function describeAffectedAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAffectedAssetsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of malicious image samples.
     *  *
     * @param DescribeAffectedMaliciousFileImagesRequest $request DescribeAffectedMaliciousFileImagesRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAffectedMaliciousFileImagesResponse DescribeAffectedMaliciousFileImagesResponse
     */
    public function describeAffectedMaliciousFileImagesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->containerId)) {
            $query['ContainerId'] = $request->containerId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->image)) {
            $query['Image'] = $request->image;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->imageLayer)) {
            $query['ImageLayer'] = $request->imageLayer;
        }
        if (!Utils::isUnset($request->imageTag)) {
            $query['ImageTag'] = $request->imageTag;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->maliciousMd5)) {
            $query['MaliciousMd5'] = $request->maliciousMd5;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pod)) {
            $query['Pod'] = $request->pod;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAffectedMaliciousFileImages',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAffectedMaliciousFileImagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of malicious image samples.
     *  *
     * @param DescribeAffectedMaliciousFileImagesRequest $request DescribeAffectedMaliciousFileImagesRequest
     *
     * @return DescribeAffectedMaliciousFileImagesResponse DescribeAffectedMaliciousFileImagesResponse
     */
    public function describeAffectedMaliciousFileImages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAffectedMaliciousFileImagesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
     *  *
     * @param DescribeAgentInstallStatusRequest $request DescribeAgentInstallStatusRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAgentInstallStatusResponse DescribeAgentInstallStatusResponse
     */
    public function describeAgentInstallStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAgentInstallStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAgentInstallStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
     *  *
     * @param DescribeAgentInstallStatusRequest $request DescribeAgentInstallStatusRequest
     *
     * @return DescribeAgentInstallStatusResponse DescribeAgentInstallStatusResponse
     */
    public function describeAgentInstallStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAgentInstallStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
     *  *
     * @param DescribeAlarmEventDetailRequest $request DescribeAlarmEventDetailRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAlarmEventDetailResponse DescribeAlarmEventDetailResponse
     */
    public function describeAlarmEventDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alarmUniqueInfo)) {
            $query['AlarmUniqueInfo'] = $request->alarmUniqueInfo;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAlarmEventDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAlarmEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
     *  *
     * @param DescribeAlarmEventDetailRequest $request DescribeAlarmEventDetailRequest
     *
     * @return DescribeAlarmEventDetailResponse DescribeAlarmEventDetailResponse
     */
    public function describeAlarmEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAlarmEventDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the stack information about an alert event.
     *  *
     * @param DescribeAlarmEventStackInfoRequest $request DescribeAlarmEventStackInfoRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAlarmEventStackInfoResponse DescribeAlarmEventStackInfoResponse
     */
    public function describeAlarmEventStackInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uniqueInfo)) {
            $query['UniqueInfo'] = $request->uniqueInfo;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAlarmEventStackInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAlarmEventStackInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the stack information about an alert event.
     *  *
     * @param DescribeAlarmEventStackInfoRequest $request DescribeAlarmEventStackInfoRequest
     *
     * @return DescribeAlarmEventStackInfoResponse DescribeAlarmEventStackInfoResponse
     */
    public function describeAlarmEventStackInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAlarmEventStackInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about all server assets, including the asset group IDs and asset names.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAllEntityResponse DescribeAllEntityResponse
     */
    public function describeAllEntityWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeAllEntity',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAllEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about all server assets, including the asset group IDs and asset names.
     *  *
     * @return DescribeAllEntityResponse DescribeAllEntityResponse
     */
    public function describeAllEntity()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllEntityWithOptions($runtime);
    }

    /**
     * @summary Queries the information about all server groups.
     *  *
     * @param DescribeAllGroupsRequest $request DescribeAllGroupsRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAllGroupsResponse DescribeAllGroupsResponse
     */
    public function describeAllGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAllGroups',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAllGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about all server groups.
     *  *
     * @param DescribeAllGroupsRequest $request DescribeAllGroupsRequest
     *
     * @return DescribeAllGroupsResponse DescribeAllGroupsResponse
     */
    public function describeAllGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries baselines that are used in image baseline checks.
     *  *
     * @param DescribeAllImageBaselineRequest $request DescribeAllImageBaselineRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAllImageBaselineResponse DescribeAllImageBaselineResponse
     */
    public function describeAllImageBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAllImageBaseline',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAllImageBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries baselines that are used in image baseline checks.
     *  *
     * @param DescribeAllImageBaselineRequest $request DescribeAllImageBaselineRequest
     *
     * @return DescribeAllImageBaselineResponse DescribeAllImageBaselineResponse
     */
    public function describeAllImageBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllImageBaselineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries created defense rules against brute-force attacks.
     *  *
     * @param DescribeAntiBruteForceRulesRequest $request DescribeAntiBruteForceRulesRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAntiBruteForceRulesResponse DescribeAntiBruteForceRulesResponse
     */
    public function describeAntiBruteForceRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAntiBruteForceRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAntiBruteForceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries created defense rules against brute-force attacks.
     *  *
     * @param DescribeAntiBruteForceRulesRequest $request DescribeAntiBruteForceRulesRequest
     *
     * @return DescribeAntiBruteForceRulesResponse DescribeAntiBruteForceRulesResponse
     */
    public function describeAntiBruteForceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAntiBruteForceRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the scan cycle for application vulnerabilities.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAppVulScanCycleResponse DescribeAppVulScanCycleResponse
     */
    public function describeAppVulScanCycleWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeAppVulScanCycle',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAppVulScanCycleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the scan cycle for application vulnerabilities.
     *  *
     * @return DescribeAppVulScanCycleResponse DescribeAppVulScanCycleResponse
     */
    public function describeAppVulScanCycle()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAppVulScanCycleWithOptions($runtime);
    }

    /**
     * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
     *  *
     * @param DescribeAssetDetailByUuidRequest $request DescribeAssetDetailByUuidRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAssetDetailByUuidResponse DescribeAssetDetailByUuidResponse
     */
    public function describeAssetDetailByUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAssetDetailByUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAssetDetailByUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
     *  *
     * @param DescribeAssetDetailByUuidRequest $request DescribeAssetDetailByUuidRequest
     *
     * @return DescribeAssetDetailByUuidResponse DescribeAssetDetailByUuidResponse
     */
    public function describeAssetDetailByUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetDetailByUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of Elastic Compute Service (ECS) instances.
     *  *
     * @param DescribeAssetDetailByUuidsRequest $request DescribeAssetDetailByUuidsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAssetDetailByUuidsResponse DescribeAssetDetailByUuidsResponse
     */
    public function describeAssetDetailByUuidsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAssetDetailByUuids',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAssetDetailByUuidsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of Elastic Compute Service (ECS) instances.
     *  *
     * @param DescribeAssetDetailByUuidsRequest $request DescribeAssetDetailByUuidsRequest
     *
     * @return DescribeAssetDetailByUuidsResponse DescribeAssetDetailByUuidsResponse
     */
    public function describeAssetDetailByUuids($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetDetailByUuidsWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the request, which is used to locate and troubleshoot issues.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAssetSummaryResponse DescribeAssetSummaryResponse
     */
    public function describeAssetSummaryWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeAssetSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAssetSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the request, which is used to locate and troubleshoot issues.
     *  *
     * @return DescribeAssetSummaryResponse DescribeAssetSummaryResponse
     */
    public function describeAssetSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetSummaryWithOptions($runtime);
    }

    /**
     * @summary Queries the risk information about containers.
     *  *
     * @param DescribeAssetsSecurityEventSummaryRequest $request DescribeAssetsSecurityEventSummaryRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAssetsSecurityEventSummaryResponse DescribeAssetsSecurityEventSummaryResponse
     */
    public function describeAssetsSecurityEventSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAssetsSecurityEventSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAssetsSecurityEventSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk information about containers.
     *  *
     * @param DescribeAssetsSecurityEventSummaryRequest $request DescribeAssetsSecurityEventSummaryRequest
     *
     * @return DescribeAssetsSecurityEventSummaryResponse DescribeAssetsSecurityEventSummaryResponse
     */
    public function describeAssetsSecurityEventSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAssetsSecurityEventSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the results of automatically connecting applications on Elastic Compute Service (ECS) instances to the application protection feature after the Runtime Application Self-Protection (RASP) agent is installed on the ECS instances.
     *  *
     * @param DescribeAttachRecordsRequest $request DescribeAttachRecordsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAttachRecordsResponse DescribeAttachRecordsResponse
     */
    public function describeAttachRecordsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->applicationId)) {
            $query['ApplicationId'] = $request->applicationId;
        }
        if (!Utils::isUnset($request->ecsUUIDList)) {
            $query['EcsUUIDList'] = $request->ecsUUIDList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAttachRecords',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAttachRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the results of automatically connecting applications on Elastic Compute Service (ECS) instances to the application protection feature after the Runtime Application Self-Protection (RASP) agent is installed on the ECS instances.
     *  *
     * @param DescribeAttachRecordsRequest $request DescribeAttachRecordsRequest
     *
     * @return DescribeAttachRecordsResponse DescribeAttachRecordsResponse
     */
    public function describeAttachRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAttachRecordsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of attack analysis.
     *  *
     * @param DescribeAttackAnalysisDataRequest $request DescribeAttackAnalysisDataRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAttackAnalysisDataResponse DescribeAttackAnalysisDataResponse
     */
    public function describeAttackAnalysisDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->base64)) {
            $query['Base64'] = $request->base64;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->data)) {
            $query['Data'] = $request->data;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeAttackAnalysisData',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAttackAnalysisDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of attack analysis.
     *  *
     * @param DescribeAttackAnalysisDataRequest $request DescribeAttackAnalysisDataRequest
     *
     * @return DescribeAttackAnalysisDataResponse DescribeAttackAnalysisDataResponse
     */
    public function describeAttackAnalysisData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAttackAnalysisDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeAutoDelConfigResponse DescribeAutoDelConfigResponse
     */
    public function describeAutoDelConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeAutoDelConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeAutoDelConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
     *  *
     * @return DescribeAutoDelConfigResponse DescribeAutoDelConfigResponse
     */
    public function describeAutoDelConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAutoDelConfigWithOptions($runtime);
    }

    /**
     * @summary Queries the information about a file to which archived alert events are exported.
     *  *
     * @param DescribeBackUpExportInfoRequest $request DescribeBackUpExportInfoRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackUpExportInfoResponse DescribeBackUpExportInfoResponse
     */
    public function describeBackUpExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->exportType)) {
            $query['ExportType'] = $request->exportType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackUpExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackUpExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a file to which archived alert events are exported.
     *  *
     * @param DescribeBackUpExportInfoRequest $request DescribeBackUpExportInfoRequest
     *
     * @return DescribeBackUpExportInfoResponse DescribeBackUpExportInfoResponse
     */
    public function describeBackUpExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackUpExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers on which the anti-ransomware agent is installed in a specified region.
     *  *
     * @description You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
     *  *
     * @param DescribeBackupClientsRequest $request DescribeBackupClientsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupClientsResponse DescribeBackupClientsResponse
     */
    public function describeBackupClientsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->supportRegionId)) {
            $query['SupportRegionId'] = $request->supportRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupClients',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupClientsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers on which the anti-ransomware agent is installed in a specified region.
     *  *
     * @description You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
     *  *
     * @param DescribeBackupClientsRequest $request DescribeBackupClientsRequest
     *
     * @return DescribeBackupClientsResponse DescribeBackupClientsResponse
     */
    public function describeBackupClients($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupClientsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries backup files.
     *  *
     * @param DescribeBackupFilesRequest $request DescribeBackupFilesRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupFilesResponse DescribeBackupFilesResponse
     */
    public function describeBackupFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->path)) {
            $query['Path'] = $request->path;
        }
        if (!Utils::isUnset($request->snapshotHash)) {
            $query['SnapshotHash'] = $request->snapshotHash;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupFiles',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries backup files.
     *  *
     * @param DescribeBackupFilesRequest $request DescribeBackupFilesRequest
     *
     * @return DescribeBackupFilesResponse DescribeBackupFilesResponse
     */
    public function describeBackupFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the backup status of a sever to which an anti-ransomware policy is applied.
     *  *
     * @param DescribeBackupMachineStatusRequest $request DescribeBackupMachineStatusRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupMachineStatusResponse DescribeBackupMachineStatusResponse
     */
    public function describeBackupMachineStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupMachineStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupMachineStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the backup status of a sever to which an anti-ransomware policy is applied.
     *  *
     * @param DescribeBackupMachineStatusRequest $request DescribeBackupMachineStatusRequest
     *
     * @return DescribeBackupMachineStatusResponse DescribeBackupMachineStatusResponse
     */
    public function describeBackupMachineStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupMachineStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries anti-ransomware policies.
     *  *
     * @param DescribeBackupPoliciesRequest $request DescribeBackupPoliciesRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupPoliciesResponse DescribeBackupPoliciesResponse
     */
    public function describeBackupPoliciesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->machineRemark)) {
            $query['MachineRemark'] = $request->machineRemark;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupPolicies',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries anti-ransomware policies.
     *  *
     * @param DescribeBackupPoliciesRequest $request DescribeBackupPoliciesRequest
     *
     * @return DescribeBackupPoliciesResponse DescribeBackupPoliciesResponse
     */
    public function describeBackupPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupPoliciesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an anti-ransomware policy for servers.
     *  *
     * @param DescribeBackupPolicyRequest $request DescribeBackupPolicyRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupPolicyResponse DescribeBackupPolicyResponse
     */
    public function describeBackupPolicyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an anti-ransomware policy for servers.
     *  *
     * @param DescribeBackupPolicyRequest $request DescribeBackupPolicyRequest
     *
     * @return DescribeBackupPolicyResponse DescribeBackupPolicyResponse
     */
    public function describeBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of restoration tasks.
     *  *
     * @description If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBackupRestoreCountResponse DescribeBackupRestoreCountResponse
     */
    public function describeBackupRestoreCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeBackupRestoreCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBackupRestoreCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of restoration tasks.
     *  *
     * @description If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
     *  *
     * @return DescribeBackupRestoreCountResponse DescribeBackupRestoreCountResponse
     */
    public function describeBackupRestoreCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupRestoreCountWithOptions($runtime);
    }

    /**
     * @summary Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
     *  *
     * @param DescribeBruteForceRecordsRequest $request DescribeBruteForceRecordsRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBruteForceRecordsResponse DescribeBruteForceRecordsResponse
     */
    public function describeBruteForceRecordsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBruteForceRecords',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBruteForceRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
     *  *
     * @param DescribeBruteForceRecordsRequest $request DescribeBruteForceRecordsRequest
     *
     * @return DescribeBruteForceRecordsResponse DescribeBruteForceRecordsResponse
     */
    public function describeBruteForceRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBruteForceRecordsWithOptions($request, $runtime);
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param DescribeBruteForceSummaryRequest $request DescribeBruteForceSummaryRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeBruteForceSummaryResponse DescribeBruteForceSummaryResponse
     */
    public function describeBruteForceSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeBruteForceSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeBruteForceSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param DescribeBruteForceSummaryRequest $request DescribeBruteForceSummaryRequest
     *
     * @return DescribeBruteForceSummaryResponse DescribeBruteForceSummaryResponse
     */
    public function describeBruteForceSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBruteForceSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of fixable vulnerabilities.
     *  *
     * @param DescribeCanFixVulListRequest $request DescribeCanFixVulListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCanFixVulListResponse DescribeCanFixVulListResponse
     */
    public function describeCanFixVulListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->containerId)) {
            $query['ContainerId'] = $request->containerId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->digest)) {
            $query['Digest'] = $request->digest;
        }
        if (!Utils::isUnset($request->image)) {
            $query['Image'] = $request->image;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pod)) {
            $query['Pod'] = $request->pod;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCanFixVulList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCanFixVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of fixable vulnerabilities.
     *  *
     * @param DescribeCanFixVulListRequest $request DescribeCanFixVulListRequest
     *
     * @return DescribeCanFixVulListResponse DescribeCanFixVulListResponse
     */
    public function describeCanFixVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCanFixVulListWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DescribeCheckEcsWarningsRequest $request DescribeCheckEcsWarningsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckEcsWarningsResponse DescribeCheckEcsWarningsResponse
     */
    public function describeCheckEcsWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckEcsWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckEcsWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DescribeCheckEcsWarningsRequest $request DescribeCheckEcsWarningsRequest
     *
     * @return DescribeCheckEcsWarningsResponse DescribeCheckEcsWarningsResponse
     */
    public function describeCheckEcsWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckEcsWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the parameters that you can configure to fix specified risk items.
     *  *
     * @param DescribeCheckFixDetailsRequest $request DescribeCheckFixDetailsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckFixDetailsResponse DescribeCheckFixDetailsResponse
     */
    public function describeCheckFixDetailsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckFixDetails',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckFixDetailsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the parameters that you can configure to fix specified risk items.
     *  *
     * @param DescribeCheckFixDetailsRequest $request DescribeCheckFixDetailsRequest
     *
     * @return DescribeCheckFixDetailsResponse DescribeCheckFixDetailsResponse
     */
    public function describeCheckFixDetails($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckFixDetailsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a specified check item.
     *  *
     * @param DescribeCheckWarningDetailRequest $request DescribeCheckWarningDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckWarningDetailResponse DescribeCheckWarningDetailResponse
     */
    public function describeCheckWarningDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->checkWarningId)) {
            $query['CheckWarningId'] = $request->checkWarningId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckWarningDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckWarningDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a specified check item.
     *  *
     * @param DescribeCheckWarningDetailRequest $request DescribeCheckWarningDetailRequest
     *
     * @return DescribeCheckWarningDetailResponse DescribeCheckWarningDetailResponse
     */
    public function describeCheckWarningDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
     *  *
     * @param DescribeCheckWarningMachinesRequest $request DescribeCheckWarningMachinesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckWarningMachinesResponse DescribeCheckWarningMachinesResponse
     */
    public function describeCheckWarningMachinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckWarningMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckWarningMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
     *  *
     * @param DescribeCheckWarningMachinesRequest $request DescribeCheckWarningMachinesRequest
     *
     * @return DescribeCheckWarningMachinesResponse DescribeCheckWarningMachinesResponse
     */
    public function describeCheckWarningMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningMachinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
     *  *
     * @param DescribeCheckWarningSummaryRequest $request DescribeCheckWarningSummaryRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckWarningSummaryResponse DescribeCheckWarningSummaryResponse
     */
    public function describeCheckWarningSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskName)) {
            $query['RiskName'] = $request->riskName;
        }
        if (!Utils::isUnset($request->riskStatus)) {
            $query['RiskStatus'] = $request->riskStatus;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->typeName)) {
            $query['TypeName'] = $request->typeName;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckWarningSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckWarningSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
     *  *
     * @param DescribeCheckWarningSummaryRequest $request DescribeCheckWarningSummaryRequest
     *
     * @return DescribeCheckWarningSummaryResponse DescribeCheckWarningSummaryResponse
     */
    public function describeCheckWarningSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about specified risk items and the check items of a specified server.
     *  *
     * @param DescribeCheckWarningsRequest $request DescribeCheckWarningsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCheckWarningsResponse DescribeCheckWarningsResponse
     */
    public function describeCheckWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->checkType)) {
            $query['CheckType'] = $request->checkType;
        }
        if (!Utils::isUnset($request->containerName)) {
            $query['ContainerName'] = $request->containerName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->riskStatus)) {
            $query['RiskStatus'] = $request->riskStatus;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCheckWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCheckWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about specified risk items and the check items of a specified server.
     *  *
     * @param DescribeCheckWarningsRequest $request DescribeCheckWarningsRequest
     *
     * @return DescribeCheckWarningsResponse DescribeCheckWarningsResponse
     */
    public function describeCheckWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCheckWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the Security Center agent.
     *  *
     * @param DescribeClientConfSetupRequest $request DescribeClientConfSetupRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClientConfSetupResponse DescribeClientConfSetupResponse
     */
    public function describeClientConfSetupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyTag)) {
            $query['StrategyTag'] = $request->strategyTag;
        }
        if (!Utils::isUnset($request->strategyTagValue)) {
            $query['StrategyTagValue'] = $request->strategyTagValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClientConfSetup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClientConfSetupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the Security Center agent.
     *  *
     * @param DescribeClientConfSetupRequest $request DescribeClientConfSetupRequest
     *
     * @return DescribeClientConfSetupResponse DescribeClientConfSetupResponse
     */
    public function describeClientConfSetup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClientConfSetupWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of servers to which different tags are added.
     *  *
     * @param DescribeClientConfStrategyRequest $request DescribeClientConfStrategyRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClientConfStrategyResponse DescribeClientConfStrategyResponse
     */
    public function describeClientConfStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->tagValue)) {
            $query['TagValue'] = $request->tagValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClientConfStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClientConfStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of servers to which different tags are added.
     *  *
     * @param DescribeClientConfStrategyRequest $request DescribeClientConfStrategyRequest
     *
     * @return DescribeClientConfStrategyResponse DescribeClientConfStrategyResponse
     */
    public function describeClientConfStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClientConfStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
     *  *
     * @description You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
     *  *
     * @param DescribeCloudCenterInstancesRequest $request DescribeCloudCenterInstancesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCloudCenterInstancesResponse DescribeCloudCenterInstancesResponse
     */
    public function describeCloudCenterInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->importance)) {
            $query['Importance'] = $request->importance;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->noGroupTrace)) {
            $query['NoGroupTrace'] = $request->noGroupTrace;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->useNextToken)) {
            $query['UseNextToken'] = $request->useNextToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCloudCenterInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCloudCenterInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
     *  *
     * @description You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
     *  *
     * @param DescribeCloudCenterInstancesRequest $request DescribeCloudCenterInstancesRequest
     *
     * @return DescribeCloudCenterInstancesResponse DescribeCloudCenterInstancesResponse
     */
    public function describeCloudCenterInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudCenterInstancesWithOptions($request, $runtime);
    }

    /**
     * @deprecated openAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead
     *  *
     * @summary Queries the statistics of cloud services.
     *  *
     * Deprecated
     *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCloudProductFieldStatisticsResponse DescribeCloudProductFieldStatisticsResponse
     */
    public function describeCloudProductFieldStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeCloudProductFieldStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCloudProductFieldStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated openAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead
     *  *
     * @summary Queries the statistics of cloud services.
     *  *
     * Deprecated
     *
     * @return DescribeCloudProductFieldStatisticsResponse DescribeCloudProductFieldStatisticsResponse
     */
    public function describeCloudProductFieldStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudProductFieldStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries the information about an cluster based on the cluster ID.
     *  *
     * @param DescribeClusterBasicInfoRequest $request DescribeClusterBasicInfoRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterBasicInfoResponse DescribeClusterBasicInfoResponse
     */
    public function describeClusterBasicInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterBasicInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterBasicInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an cluster based on the cluster ID.
     *  *
     * @param DescribeClusterBasicInfoRequest $request DescribeClusterBasicInfoRequest
     *
     * @return DescribeClusterBasicInfoResponse DescribeClusterBasicInfoResponse
     */
    public function describeClusterBasicInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterBasicInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a cluster.
     *  *
     * @param DescribeClusterInfoListRequest $request DescribeClusterInfoListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterInfoListResponse DescribeClusterInfoListResponse
     */
    public function describeClusterInfoListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterInfoList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterInfoListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a cluster.
     *  *
     * @param DescribeClusterInfoListRequest $request DescribeClusterInfoListRequest
     *
     * @return DescribeClusterInfoListResponse DescribeClusterInfoListResponse
     */
    public function describeClusterInfoList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterInfoListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the network topology edge by cluster.
     *  *
     * @param DescribeClusterNetworkRequest $request DescribeClusterNetworkRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterNetworkResponse DescribeClusterNetworkResponse
     */
    public function describeClusterNetworkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterNetwork',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the network topology edge by cluster.
     *  *
     * @param DescribeClusterNetworkRequest $request DescribeClusterNetworkRequest
     *
     * @return DescribeClusterNetworkResponse DescribeClusterNetworkResponse
     */
    public function describeClusterNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterNetworkWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
     *  *
     * @param DescribeClusterVulStatisticsRequest $request DescribeClusterVulStatisticsRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeClusterVulStatisticsResponse DescribeClusterVulStatisticsResponse
     */
    public function describeClusterVulStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeClusterVulStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeClusterVulStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
     *  *
     * @param DescribeClusterVulStatisticsRequest $request DescribeClusterVulStatisticsRequest
     *
     * @return DescribeClusterVulStatisticsResponse DescribeClusterVulStatisticsResponse
     */
    public function describeClusterVulStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClusterVulStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a specified feature.
     *  *
     * @param DescribeCommonOverallConfigRequest $request DescribeCommonOverallConfigRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCommonOverallConfigResponse DescribeCommonOverallConfigResponse
     */
    public function describeCommonOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCommonOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCommonOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a specified feature.
     *  *
     * @param DescribeCommonOverallConfigRequest $request DescribeCommonOverallConfigRequest
     *
     * @return DescribeCommonOverallConfigResponse DescribeCommonOverallConfigResponse
     */
    public function describeCommonOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of features in proactive defense.
     *  *
     * @param DescribeCommonOverallConfigListRequest $request DescribeCommonOverallConfigListRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCommonOverallConfigListResponse DescribeCommonOverallConfigListResponse
     */
    public function describeCommonOverallConfigListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->typeList)) {
            $query['TypeList'] = $request->typeList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCommonOverallConfigList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCommonOverallConfigListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of features in proactive defense.
     *  *
     * @param DescribeCommonOverallConfigListRequest $request DescribeCommonOverallConfigListRequest
     *
     * @return DescribeCommonOverallConfigListResponse DescribeCommonOverallConfigListResponse
     */
    public function describeCommonOverallConfigList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonOverallConfigListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the proactive defense feature.
     *  *
     * @param DescribeCommonTargetConfigRequest $request DescribeCommonTargetConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCommonTargetConfigResponse DescribeCommonTargetConfigResponse
     */
    public function describeCommonTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCommonTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCommonTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the proactive defense feature.
     *  *
     * @param DescribeCommonTargetConfigRequest $request DescribeCommonTargetConfigRequest
     *
     * @return DescribeCommonTargetConfigResponse DescribeCommonTargetConfigResponse
     */
    public function describeCommonTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers based on the specified configuration item.
     *  *
     * @param DescribeCommonTargetResultListRequest $request DescribeCommonTargetResultListRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCommonTargetResultListResponse DescribeCommonTargetResultListResponse
     */
    public function describeCommonTargetResultListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCommonTargetResultList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCommonTargetResultListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers based on the specified configuration item.
     *  *
     * @param DescribeCommonTargetResultListRequest $request DescribeCommonTargetResultListRequest
     *
     * @return DescribeCommonTargetResultListResponse DescribeCommonTargetResultListResponse
     */
    public function describeCommonTargetResultList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommonTargetResultListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the priorities to fix vulnerabilities.
     *  *
     * @param DescribeConcernNecessityRequest $request DescribeConcernNecessityRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeConcernNecessityResponse DescribeConcernNecessityResponse
     */
    public function describeConcernNecessityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeConcernNecessity',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeConcernNecessityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the priorities to fix vulnerabilities.
     *  *
     * @param DescribeConcernNecessityRequest $request DescribeConcernNecessityRequest
     *
     * @return DescribeConcernNecessityResponse DescribeConcernNecessityResponse
     */
    public function describeConcernNecessity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeConcernNecessityWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a containerized application.
     *  *
     * @param DescribeContainerAppsRequest $request DescribeContainerAppsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerAppsResponse DescribeContainerAppsResponse
     */
    public function describeContainerAppsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerApps',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerAppsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a containerized application.
     *  *
     * @param DescribeContainerAppsRequest $request DescribeContainerAppsRequest
     *
     * @return DescribeContainerAppsResponse DescribeContainerAppsResponse
     */
    public function describeContainerApps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerAppsWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the filter conditions that you can use to filter the containers.
     *  *
     * @param DescribeContainerCriteriaRequest $request DescribeContainerCriteriaRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerCriteriaResponse DescribeContainerCriteriaResponse
     */
    public function describeContainerCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupField)) {
            $query['GroupField'] = $request->groupField;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the filter conditions that you can use to filter the containers.
     *  *
     * @param DescribeContainerCriteriaRequest $request DescribeContainerCriteriaRequest
     *
     * @return DescribeContainerCriteriaResponse DescribeContainerCriteriaResponse
     */
    public function describeContainerCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about containers.
     *  *
     * @param DescribeContainerInstancesRequest $request DescribeContainerInstancesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerInstancesResponse DescribeContainerInstancesResponse
     */
    public function describeContainerInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about containers.
     *  *
     * @param DescribeContainerInstancesRequest $request DescribeContainerInstancesRequest
     *
     * @return DescribeContainerInstancesResponse DescribeContainerInstancesResponse
     */
    public function describeContainerInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the vulnerability scan of one or more running container applications.
     *  *
     * @param DescribeContainerScanConfigRequest $request DescribeContainerScanConfigRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerScanConfigResponse DescribeContainerScanConfigResponse
     */
    public function describeContainerScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the vulnerability scan of one or more running container applications.
     *  *
     * @param DescribeContainerScanConfigRequest $request DescribeContainerScanConfigRequest
     *
     * @return DescribeContainerScanConfigResponse DescribeContainerScanConfigResponse
     */
    public function describeContainerScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alert statistics on container assets.
     *  *
     * @description Only users who created a Container Registry Enterprise Edition instance can call this operation.
     *  *
     * @param DescribeContainerStatisticsRequest $request DescribeContainerStatisticsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerStatisticsResponse DescribeContainerStatisticsResponse
     */
    public function describeContainerStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert statistics on container assets.
     *  *
     * @description Only users who created a Container Registry Enterprise Edition instance can call this operation.
     *  *
     * @param DescribeContainerStatisticsRequest $request DescribeContainerStatisticsRequest
     *
     * @return DescribeContainerStatisticsResponse DescribeContainerStatisticsResponse
     */
    public function describeContainerStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of container assets by using an attribute.
     *  *
     * @param DescribeContainerTagsRequest $request DescribeContainerTagsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeContainerTagsResponse DescribeContainerTagsResponse
     */
    public function describeContainerTagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldName)) {
            $query['FieldName'] = $request->fieldName;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeContainerTags',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeContainerTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of container assets by using an attribute.
     *  *
     * @param DescribeContainerTagsRequest $request DescribeContainerTagsRequest
     *
     * @return DescribeContainerTagsResponse DescribeContainerTagsResponse
     */
    public function describeContainerTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeContainerTagsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of images that are not scanned.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCountNotScannedImageResponse DescribeCountNotScannedImageResponse
     */
    public function describeCountNotScannedImageWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeCountNotScannedImage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCountNotScannedImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of images that are not scanned.
     *  *
     * @return DescribeCountNotScannedImageResponse DescribeCountNotScannedImageResponse
     */
    public function describeCountNotScannedImage()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCountNotScannedImageWithOptions($runtime);
    }

    /**
     * @summary Queries the number of images that are scanned.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCountScannedImageResponse DescribeCountScannedImageResponse
     */
    public function describeCountScannedImageWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeCountScannedImage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCountScannedImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of images that are scanned.
     *  *
     * @return DescribeCountScannedImageResponse DescribeCountScannedImageResponse
     */
    public function describeCountScannedImage()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCountScannedImageWithOptions($runtime);
    }

    /**
     * @summary Queries the filter conditions that are used to search for assets in fuzzy match mode.
     *  *
     * @param DescribeCriteriaRequest $request DescribeCriteriaRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCriteriaResponse DescribeCriteriaResponse
     */
    public function describeCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->supportAutoTag)) {
            $query['SupportAutoTag'] = $request->supportAutoTag;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the filter conditions that are used to search for assets in fuzzy match mode.
     *  *
     * @param DescribeCriteriaRequest $request DescribeCriteriaRequest
     *
     * @return DescribeCriteriaResponse DescribeCriteriaResponse
     */
    public function describeCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
     *  *
     * @param DescribeCustomBlockInstancesRequest $request DescribeCustomBlockInstancesRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomBlockInstancesResponse DescribeCustomBlockInstancesResponse
     */
    public function describeCustomBlockInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomBlockInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomBlockInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
     *  *
     * @param DescribeCustomBlockInstancesRequest $request DescribeCustomBlockInstancesRequest
     *
     * @return DescribeCustomBlockInstancesResponse DescribeCustomBlockInstancesResponse
     */
    public function describeCustomBlockInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomBlockInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the defense rules against brute-force attacks that are applied to one or more servers.
     *  *
     * @param DescribeCustomBlockRecordsRequest $request DescribeCustomBlockRecordsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCustomBlockRecordsResponse DescribeCustomBlockRecordsResponse
     */
    public function describeCustomBlockRecordsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCustomBlockRecords',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCustomBlockRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the defense rules against brute-force attacks that are applied to one or more servers.
     *  *
     * @param DescribeCustomBlockRecordsRequest $request DescribeCustomBlockRecordsRequest
     *
     * @return DescribeCustomBlockRecordsResponse DescribeCustomBlockRecordsResponse
     */
    public function describeCustomBlockRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomBlockRecordsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
     *  *
     * @param DescribeCycleTaskListRequest $request DescribeCycleTaskListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeCycleTaskListResponse DescribeCycleTaskListResponse
     */
    public function describeCycleTaskListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeCycleTaskList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeCycleTaskListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
     *  *
     * @param DescribeCycleTaskListRequest $request DescribeCycleTaskListRequest
     *
     * @return DescribeCycleTaskListResponse DescribeCycleTaskListResponse
     */
    public function describeCycleTaskList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCycleTaskListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDefaultProxyInstallVersionResponse DescribeDefaultProxyInstallVersionResponse
     */
    public function describeDefaultProxyInstallVersionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeDefaultProxyInstallVersion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDefaultProxyInstallVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
     *  *
     * @return DescribeDefaultProxyInstallVersionResponse DescribeDefaultProxyInstallVersionResponse
     */
    public function describeDefaultProxyInstallVersion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDefaultProxyInstallVersionWithOptions($runtime);
    }

    /**
     * @summary Obtains DingTalk notifications.
     *  *
     * @param DescribeDingTalkRequest $request DescribeDingTalkRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDingTalkResponse DescribeDingTalkResponse
     */
    public function describeDingTalkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleActionName)) {
            $query['RuleActionName'] = $request->ruleActionName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDingTalk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDingTalkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains DingTalk notifications.
     *  *
     * @param DescribeDingTalkRequest $request DescribeDingTalkRequest
     *
     * @return DescribeDingTalkResponse DescribeDingTalkResponse
     */
    public function describeDingTalk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDingTalkWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainCountRequest $request DescribeDomainCountRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainCountResponse DescribeDomainCountResponse
     */
    public function describeDomainCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainCountRequest $request DescribeDomainCountRequest
     *
     * @return DescribeDomainCountResponse DescribeDomainCountResponse
     */
    public function describeDomainCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainDetailRequest $request DescribeDomainDetailRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainDetailResponse DescribeDomainDetailResponse
     */
    public function describeDomainDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->domainName)) {
            $query['DomainName'] = $request->domainName;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainDetailRequest $request DescribeDomainDetailRequest
     *
     * @return DescribeDomainDetailResponse DescribeDomainDetailResponse
     */
    public function describeDomainDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainListRequest $request DescribeDomainListRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeDomainListResponse DescribeDomainListResponse
     */
    public function describeDomainListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->domainType)) {
            $query['DomainType'] = $request->domainType;
        }
        if (!Utils::isUnset($request->fuzzyDomain)) {
            $query['FuzzyDomain'] = $request->fuzzyDomain;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeDomainList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeDomainListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the domain assets within your Alibaba Cloud account.
     *  *
     * @param DescribeDomainListRequest $request DescribeDomainListRequest
     *
     * @return DescribeDomainListResponse DescribeDomainListResponse
     */
    public function describeDomainList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDomainListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether Security Center is authorized to scan for urgent vulnerabilities.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEmgUserAgreementResponse DescribeEmgUserAgreementResponse
     */
    public function describeEmgUserAgreementWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeEmgUserAgreement',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEmgUserAgreementResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether Security Center is authorized to scan for urgent vulnerabilities.
     *  *
     * @return DescribeEmgUserAgreementResponse DescribeEmgUserAgreementResponse
     */
    public function describeEmgUserAgreement()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEmgUserAgreementWithOptions($runtime);
    }

    /**
     * @summary Queries the details of urgent vulnerabilities.
     *  *
     * @param DescribeEmgVulItemRequest $request DescribeEmgVulItemRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEmgVulItemResponse DescribeEmgVulItemResponse
     */
    public function describeEmgVulItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkType)) {
            $query['CheckType'] = $request->checkType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskStatus)) {
            $query['RiskStatus'] = $request->riskStatus;
        }
        if (!Utils::isUnset($request->scanType)) {
            $query['ScanType'] = $request->scanType;
        }
        if (!Utils::isUnset($request->vulName)) {
            $query['VulName'] = $request->vulName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEmgVulItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEmgVulItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of urgent vulnerabilities.
     *  *
     * @param DescribeEmgVulItemRequest $request DescribeEmgVulItemRequest
     *
     * @return DescribeEmgVulItemResponse DescribeEmgVulItemResponse
     */
    public function describeEmgVulItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEmgVulItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of alert events by risk level.
     *  *
     * @param DescribeEventLevelCountRequest $request DescribeEventLevelCountRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEventLevelCountResponse DescribeEventLevelCountResponse
     */
    public function describeEventLevelCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->containerIds)) {
            $query['ContainerIds'] = $request->containerIds;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEventLevelCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEventLevelCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of alert events by risk level.
     *  *
     * @param DescribeEventLevelCountRequest $request DescribeEventLevelCountRequest
     *
     * @return DescribeEventLevelCountResponse DescribeEventLevelCountResponse
     */
    public function describeEventLevelCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEventLevelCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the platforms that are supported by the feature of container threat detection.
     *  *
     * @param DescribeEventOnStageRequest $request DescribeEventOnStageRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeEventOnStageResponse DescribeEventOnStageResponse
     */
    public function describeEventOnStageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeEventOnStage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeEventOnStageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the platforms that are supported by the feature of container threat detection.
     *  *
     * @param DescribeEventOnStageRequest $request DescribeEventOnStageRequest
     *
     * @return DescribeEventOnStageResponse DescribeEventOnStageResponse
     */
    public function describeEventOnStage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEventOnStageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the directories that are excluded from anti-ransomware.
     *  *
     * @param DescribeExcludeSystemPathRequest $request DescribeExcludeSystemPathRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExcludeSystemPathResponse DescribeExcludeSystemPathResponse
     */
    public function describeExcludeSystemPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExcludeSystemPath',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExcludeSystemPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the directories that are excluded from anti-ransomware.
     *  *
     * @param DescribeExcludeSystemPathRequest $request DescribeExcludeSystemPathRequest
     *
     * @return DescribeExcludeSystemPathResponse DescribeExcludeSystemPathResponse
     */
    public function describeExcludeSystemPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExcludeSystemPathWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a task that exports your assets to an Excel file.
     *  *
     * @param DescribeExportInfoRequest $request DescribeExportInfoRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExportInfoResponse DescribeExportInfoResponse
     */
    public function describeExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a task that exports your assets to an Excel file.
     *  *
     * @param DescribeExportInfoRequest $request DescribeExportInfoRequest
     *
     * @return DescribeExportInfoResponse DescribeExportInfoResponse
     */
    public function describeExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the weak password-related risks of a specified server that is exposed on the Internet.
     *  *
     * @param DescribeExposedCheckWarningRequest $request DescribeExposedCheckWarningRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedCheckWarningResponse DescribeExposedCheckWarningResponse
     */
    public function describeExposedCheckWarningWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->typeName)) {
            $query['TypeName'] = $request->typeName;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedCheckWarning',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedCheckWarningResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the weak password-related risks of a specified server that is exposed on the Internet.
     *  *
     * @param DescribeExposedCheckWarningRequest $request DescribeExposedCheckWarningRequest
     *
     * @return DescribeExposedCheckWarningResponse DescribeExposedCheckWarningResponse
     */
    public function describeExposedCheckWarning($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedCheckWarningWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the search conditions that are used to search for exposed assets.
     *  *
     * @param DescribeExposedInstanceCriteriaRequest $request DescribeExposedInstanceCriteriaRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedInstanceCriteriaResponse DescribeExposedInstanceCriteriaResponse
     */
    public function describeExposedInstanceCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedInstanceCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedInstanceCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the search conditions that are used to search for exposed assets.
     *  *
     * @param DescribeExposedInstanceCriteriaRequest $request DescribeExposedInstanceCriteriaRequest
     *
     * @return DescribeExposedInstanceCriteriaResponse DescribeExposedInstanceCriteriaResponse
     */
    public function describeExposedInstanceCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedInstanceCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a specified server that is exposed on the Internet.
     *  *
     * @param DescribeExposedInstanceDetailRequest $request DescribeExposedInstanceDetailRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedInstanceDetailResponse DescribeExposedInstanceDetailResponse
     */
    public function describeExposedInstanceDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedInstanceDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedInstanceDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a specified server that is exposed on the Internet.
     *  *
     * @param DescribeExposedInstanceDetailRequest $request DescribeExposedInstanceDetailRequest
     *
     * @return DescribeExposedInstanceDetailResponse DescribeExposedInstanceDetailResponse
     */
    public function describeExposedInstanceDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedInstanceDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers that are exposed on the Internet.
     *  *
     * @param DescribeExposedInstanceListRequest $request DescribeExposedInstanceListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedInstanceListResponse DescribeExposedInstanceListResponse
     */
    public function describeExposedInstanceListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->exposureComponent)) {
            $query['ExposureComponent'] = $request->exposureComponent;
        }
        if (!Utils::isUnset($request->exposureIp)) {
            $query['ExposureIp'] = $request->exposureIp;
        }
        if (!Utils::isUnset($request->exposurePort)) {
            $query['ExposurePort'] = $request->exposurePort;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->healthStatus)) {
            $query['HealthStatus'] = $request->healthStatus;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceName)) {
            $query['InstanceName'] = $request->instanceName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->vulStatus)) {
            $query['VulStatus'] = $request->vulStatus;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedInstanceList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedInstanceListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers that are exposed on the Internet.
     *  *
     * @param DescribeExposedInstanceListRequest $request DescribeExposedInstanceListRequest
     *
     * @return DescribeExposedInstanceListResponse DescribeExposedInstanceListResponse
     */
    public function describeExposedInstanceList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedInstanceListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the exposure statistics of the assets on the Internet.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedStatisticsResponse DescribeExposedStatisticsResponse
     */
    public function describeExposedStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeExposedStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the exposure statistics of the assets on the Internet.
     *  *
     * @return DescribeExposedStatisticsResponse DescribeExposedStatisticsResponse
     */
    public function describeExposedStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
     *  *
     * @param DescribeExposedStatisticsDetailRequest $request DescribeExposedStatisticsDetailRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeExposedStatisticsDetailResponse DescribeExposedStatisticsDetailResponse
     */
    public function describeExposedStatisticsDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->statisticsType)) {
            $query['StatisticsType'] = $request->statisticsType;
        }
        if (!Utils::isUnset($request->statisticsTypeGatewayType)) {
            $query['StatisticsTypeGatewayType'] = $request->statisticsTypeGatewayType;
        }
        if (!Utils::isUnset($request->statisticsTypeInstanceValue)) {
            $query['StatisticsTypeInstanceValue'] = $request->statisticsTypeInstanceValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeExposedStatisticsDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeExposedStatisticsDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
     *  *
     * @param DescribeExposedStatisticsDetailRequest $request DescribeExposedStatisticsDetailRequest
     *
     * @return DescribeExposedStatisticsDetailResponse DescribeExposedStatisticsDetailResponse
     */
    public function describeExposedStatisticsDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeExposedStatisticsDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of servers.
     *  *
     * @param DescribeFieldStatisticsRequest $request DescribeFieldStatisticsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeFieldStatisticsResponse DescribeFieldStatisticsResponse
     */
    public function describeFieldStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeFieldStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeFieldStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of servers.
     *  *
     * @param DescribeFieldStatisticsRequest $request DescribeFieldStatisticsRequest
     *
     * @return DescribeFieldStatisticsResponse DescribeFieldStatisticsResponse
     */
    public function describeFieldStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFieldStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeFixUsedCountResponse DescribeFixUsedCountResponse
     */
    public function describeFixUsedCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeFixUsedCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeFixUsedCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
     *  *
     * @return DescribeFixUsedCountResponse DescribeFixUsedCountResponse
     */
    public function describeFixUsedCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFixUsedCountWithOptions($runtime);
    }

    /**
     * @summary Queries the pre-patches that are required to fix a specified Windows system vulnerability.
     *  *
     * @param DescribeFrontVulPatchListRequest $request DescribeFrontVulPatchListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeFrontVulPatchListResponse DescribeFrontVulPatchListResponse
     */
    public function describeFrontVulPatchListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->info)) {
            $query['Info'] = $request->info;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeFrontVulPatchList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeFrontVulPatchListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the pre-patches that are required to fix a specified Windows system vulnerability.
     *  *
     * @param DescribeFrontVulPatchListRequest $request DescribeFrontVulPatchListRequest
     *
     * @return DescribeFrontVulPatchListResponse DescribeFrontVulPatchListResponse
     */
    public function describeFrontVulPatchList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeFrontVulPatchListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the structure of a group.
     *  *
     * @param DescribeGroupStructRequest $request DescribeGroupStructRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupStructResponse DescribeGroupStructResponse
     */
    public function describeGroupStructWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupStruct',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupStructResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the structure of a group.
     *  *
     * @param DescribeGroupStructRequest $request DescribeGroupStructRequest
     *
     * @return DescribeGroupStructResponse DescribeGroupStructResponse
     */
    public function describeGroupStruct($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupStructWithOptions($request, $runtime);
    }

    /**
     * @summary Queries containers by group type.
     *  *
     * @param DescribeGroupedContainerInstancesRequest $request DescribeGroupedContainerInstancesRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedContainerInstancesResponse DescribeGroupedContainerInstancesResponse
     */
    public function describeGroupedContainerInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->groupField)) {
            $query['GroupField'] = $request->groupField;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedContainerInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedContainerInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries containers by group type.
     *  *
     * @param DescribeGroupedContainerInstancesRequest $request DescribeGroupedContainerInstancesRequest
     *
     * @return DescribeGroupedContainerInstancesResponse DescribeGroupedContainerInstancesResponse
     */
    public function describeGroupedContainerInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedContainerInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistical information about assets based on a specified filter condition.
     *  *
     * @param DescribeGroupedInstancesRequest $request DescribeGroupedInstancesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedInstancesResponse DescribeGroupedInstancesResponse
     */
    public function describeGroupedInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->groupField)) {
            $query['GroupField'] = $request->groupField;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->noPage)) {
            $query['NoPage'] = $request->noPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->saleVersionCheckCode)) {
            $query['SaleVersionCheckCode'] = $request->saleVersionCheckCode;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistical information about assets based on a specified filter condition.
     *  *
     * @param DescribeGroupedInstancesRequest $request DescribeGroupedInstancesRequest
     *
     * @return DescribeGroupedInstancesResponse DescribeGroupedInstancesResponse
     */
    public function describeGroupedInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of malicious image samples.
     *  *
     * @param DescribeGroupedMaliciousFilesRequest $request DescribeGroupedMaliciousFilesRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedMaliciousFilesResponse DescribeGroupedMaliciousFilesResponse
     */
    public function describeGroupedMaliciousFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fuzzyMaliciousName)) {
            $query['FuzzyMaliciousName'] = $request->fuzzyMaliciousName;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->imageLayer)) {
            $query['ImageLayer'] = $request->imageLayer;
        }
        if (!Utils::isUnset($request->imageTag)) {
            $query['ImageTag'] = $request->imageTag;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->maliciousMd5)) {
            $query['MaliciousMd5'] = $request->maliciousMd5;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedMaliciousFiles',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedMaliciousFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of malicious image samples.
     *  *
     * @param DescribeGroupedMaliciousFilesRequest $request DescribeGroupedMaliciousFilesRequest
     *
     * @return DescribeGroupedMaliciousFilesResponse DescribeGroupedMaliciousFilesResponse
     */
    public function describeGroupedMaliciousFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedMaliciousFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of asset tags.
     *  *
     * @param DescribeGroupedTagsRequest $request DescribeGroupedTagsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedTagsResponse DescribeGroupedTagsResponse
     */
    public function describeGroupedTagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedTags',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of asset tags.
     *  *
     * @param DescribeGroupedTagsRequest $request DescribeGroupedTagsRequest
     *
     * @return DescribeGroupedTagsResponse DescribeGroupedTagsResponse
     */
    public function describeGroupedTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedTagsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries vulnerabilities by group.
     *  *
     * @param DescribeGroupedVulRequest $request DescribeGroupedVulRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeGroupedVulResponse DescribeGroupedVulResponse
     */
    public function describeGroupedVulWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        if (!Utils::isUnset($request->attachTypes)) {
            $query['AttachTypes'] = $request->attachTypes;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->searchTags)) {
            $query['SearchTags'] = $request->searchTags;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeGroupedVul',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeGroupedVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries vulnerabilities by group.
     *  *
     * @param DescribeGroupedVulRequest $request DescribeGroupedVulRequest
     *
     * @return DescribeGroupedVulResponse DescribeGroupedVulResponse
     */
    public function describeGroupedVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGroupedVulWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
     *  *
     * @param DescribeHcExportInfoRequest $request DescribeHcExportInfoRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHcExportInfoResponse DescribeHcExportInfoResponse
     */
    public function describeHcExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHcExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHcExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
     *  *
     * @param DescribeHcExportInfoRequest $request DescribeHcExportInfoRequest
     *
     * @return DescribeHcExportInfoResponse DescribeHcExportInfoResponse
     */
    public function describeHcExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHcExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries statistics on the quota of honeypots.
     *  *
     * @param DescribeHoneyPotAuthRequest $request DescribeHoneyPotAuthRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHoneyPotAuthResponse DescribeHoneyPotAuthResponse
     */
    public function describeHoneyPotAuthWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHoneyPotAuth',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHoneyPotAuthResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries statistics on the quota of honeypots.
     *  *
     * @param DescribeHoneyPotAuthRequest $request DescribeHoneyPotAuthRequest
     *
     * @return DescribeHoneyPotAuthResponse DescribeHoneyPotAuthResponse
     */
    public function describeHoneyPotAuth($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHoneyPotAuthWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
     *  *
     * @param DescribeHoneyPotSuspStatisticsRequest $request DescribeHoneyPotSuspStatisticsRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeHoneyPotSuspStatisticsResponse DescribeHoneyPotSuspStatisticsResponse
     */
    public function describeHoneyPotSuspStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->statisticsDays)) {
            $query['StatisticsDays'] = $request->statisticsDays;
        }
        if (!Utils::isUnset($request->statisticsKeyType)) {
            $query['StatisticsKeyType'] = $request->statisticsKeyType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeHoneyPotSuspStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeHoneyPotSuspStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
     *  *
     * @param DescribeHoneyPotSuspStatisticsRequest $request DescribeHoneyPotSuspStatisticsRequest
     *
     * @return DescribeHoneyPotSuspStatisticsResponse DescribeHoneyPotSuspStatisticsResponse
     */
    public function describeHoneyPotSuspStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHoneyPotSuspStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries an image digest.
     *  *
     * @param DescribeImageRequest $request DescribeImageRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageResponse DescribeImageResponse
     */
    public function describeImageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->imageInstanceId)) {
            $query['ImageInstanceId'] = $request->imageInstanceId;
        }
        if (!Utils::isUnset($request->imageRegionId)) {
            $query['ImageRegionId'] = $request->imageRegionId;
        }
        if (!Utils::isUnset($request->imageRepoId)) {
            $query['ImageRepoId'] = $request->imageRepoId;
        }
        if (!Utils::isUnset($request->imageTag)) {
            $query['ImageTag'] = $request->imageTag;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries an image digest.
     *  *
     * @param DescribeImageRequest $request DescribeImageRequest
     *
     * @return DescribeImageResponse DescribeImageResponse
     */
    public function describeImage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the security scan results of images.
     *  *
     * @param DescribeImageBaselineCheckResultRequest $request DescribeImageBaselineCheckResultRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineCheckResultResponse DescribeImageBaselineCheckResultResponse
     */
    public function describeImageBaselineCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the security scan results of images.
     *  *
     * @param DescribeImageBaselineCheckResultRequest $request DescribeImageBaselineCheckResultRequest
     *
     * @return DescribeImageBaselineCheckResultResponse DescribeImageBaselineCheckResultResponse
     */
    public function describeImageBaselineCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineCheckResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the check results of image baselines that are included in an image scan task.
     *  *
     * @param DescribeImageBaselineCheckSummaryRequest $request DescribeImageBaselineCheckSummaryRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineCheckSummaryResponse DescribeImageBaselineCheckSummaryResponse
     */
    public function describeImageBaselineCheckSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineCheckSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineCheckSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the check results of image baselines that are included in an image scan task.
     *  *
     * @param DescribeImageBaselineCheckSummaryRequest $request DescribeImageBaselineCheckSummaryRequest
     *
     * @return DescribeImageBaselineCheckSummaryResponse DescribeImageBaselineCheckSummaryResponse
     */
    public function describeImageBaselineCheckSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineCheckSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about the baseline check result for an image.
     *  *
     * @param DescribeImageBaselineDetailRequest $request DescribeImageBaselineDetailRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineDetailResponse DescribeImageBaselineDetailResponse
     */
    public function describeImageBaselineDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineItemKey)) {
            $query['BaselineItemKey'] = $request->baselineItemKey;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about the baseline check result for an image.
     *  *
     * @param DescribeImageBaselineDetailRequest $request DescribeImageBaselineDetailRequest
     *
     * @return DescribeImageBaselineDetailResponse DescribeImageBaselineDetailResponse
     */
    public function describeImageBaselineDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries baseline check results based on images.
     *  *
     * @param DescribeImageBaselineItemListRequest $request DescribeImageBaselineItemListRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineItemListResponse DescribeImageBaselineItemListResponse
     */
    public function describeImageBaselineItemListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineClassKey)) {
            $query['BaselineClassKey'] = $request->baselineClassKey;
        }
        if (!Utils::isUnset($request->baselineNameKey)) {
            $query['BaselineNameKey'] = $request->baselineNameKey;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineItemList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineItemListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries baseline check results based on images.
     *  *
     * @param DescribeImageBaselineItemListRequest $request DescribeImageBaselineItemListRequest
     *
     * @return DescribeImageBaselineItemListResponse DescribeImageBaselineItemListResponse
     */
    public function describeImageBaselineItemList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineItemListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a baseline check policy for images.
     *  *
     * @param DescribeImageBaselineStrategyRequest $request DescribeImageBaselineStrategyRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageBaselineStrategyResponse DescribeImageBaselineStrategyResponse
     */
    public function describeImageBaselineStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageBaselineStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageBaselineStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a baseline check policy for images.
     *  *
     * @param DescribeImageBaselineStrategyRequest $request DescribeImageBaselineStrategyRequest
     *
     * @return DescribeImageBaselineStrategyResponse DescribeImageBaselineStrategyResponse
     */
    public function describeImageBaselineStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageBaselineStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the search conditions that are used to query images.
     *  *
     * @param DescribeImageCriteriaRequest $request DescribeImageCriteriaRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageCriteriaResponse DescribeImageCriteriaResponse
     */
    public function describeImageCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the search conditions that are used to query images.
     *  *
     * @param DescribeImageCriteriaRequest $request DescribeImageCriteriaRequest
     *
     * @return DescribeImageCriteriaResponse DescribeImageCriteriaResponse
     */
    public function describeImageCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the conditions for handling alert events in an image.
     *  *
     * @param DescribeImageEventOperationConditionRequest $request DescribeImageEventOperationConditionRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageEventOperationConditionResponse DescribeImageEventOperationConditionResponse
     */
    public function describeImageEventOperationConditionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventType)) {
            $query['EventType'] = $request->eventType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageEventOperationCondition',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageEventOperationConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the conditions for handling alert events in an image.
     *  *
     * @param DescribeImageEventOperationConditionRequest $request DescribeImageEventOperationConditionRequest
     *
     * @return DescribeImageEventOperationConditionResponse DescribeImageEventOperationConditionResponse
     */
    public function describeImageEventOperationCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageEventOperationConditionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries alert handling rules by page.
     *  *
     * @param DescribeImageEventOperationPageRequest $request DescribeImageEventOperationPageRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageEventOperationPageResponse DescribeImageEventOperationPageResponse
     */
    public function describeImageEventOperationPageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventKey)) {
            $query['EventKey'] = $request->eventKey;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->eventType)) {
            $query['EventType'] = $request->eventType;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageEventOperationPage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageEventOperationPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries alert handling rules by page.
     *  *
     * @param DescribeImageEventOperationPageRequest $request DescribeImageEventOperationPageRequest
     *
     * @return DescribeImageEventOperationPageResponse DescribeImageEventOperationPageResponse
     */
    public function describeImageEventOperationPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageEventOperationPageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the scheduled fix of image risks.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageFixCycleConfigResponse DescribeImageFixCycleConfigResponse
     */
    public function describeImageFixCycleConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeImageFixCycleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageFixCycleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the scheduled fix of image risks.
     *  *
     * @return DescribeImageFixCycleConfigResponse DescribeImageFixCycleConfigResponse
     */
    public function describeImageFixCycleConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageFixCycleConfigWithOptions($runtime);
    }

    /**
     * @summary Queries the tasks that you create to fix image risks.
     *  *
     * @param DescribeImageFixTaskRequest $request DescribeImageFixTaskRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageFixTaskResponse DescribeImageFixTaskResponse
     */
    public function describeImageFixTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageFixTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageFixTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the tasks that you create to fix image risks.
     *  *
     * @param DescribeImageFixTaskRequest $request DescribeImageFixTaskRequest
     *
     * @return DescribeImageFixTaskResponse DescribeImageFixTaskResponse
     */
    public function describeImageFixTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageFixTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries image vulnerabilities.
     *  *
     * @param DescribeImageGroupedVulListRequest $request DescribeImageGroupedVulListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageGroupedVulListResponse DescribeImageGroupedVulListResponse
     */
    public function describeImageGroupedVulListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->cveId)) {
            $query['CveId'] = $request->cveId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->imageLayer)) {
            $query['ImageLayer'] = $request->imageLayer;
        }
        if (!Utils::isUnset($request->imageTag)) {
            $query['ImageTag'] = $request->imageTag;
        }
        if (!Utils::isUnset($request->isLatest)) {
            $query['IsLatest'] = $request->isLatest;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->patchId)) {
            $query['PatchId'] = $request->patchId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageGroupedVulList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageGroupedVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries image vulnerabilities.
     *  *
     * @param DescribeImageGroupedVulListRequest $request DescribeImageGroupedVulListRequest
     *
     * @return DescribeImageGroupedVulListResponse DescribeImageGroupedVulListResponse
     */
    public function describeImageGroupedVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageGroupedVulListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries images.
     *  *
     * @param DescribeImageInfoListRequest $request DescribeImageInfoListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageInfoListResponse DescribeImageInfoListResponse
     */
    public function describeImageInfoListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageInfoList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageInfoListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries images.
     *  *
     * @param DescribeImageInfoListRequest $request DescribeImageInfoListRequest
     *
     * @return DescribeImageInfoListResponse DescribeImageInfoListResponse
     */
    public function describeImageInfoList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageInfoListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about images.
     *  *
     * @param DescribeImageInstancesRequest $request DescribeImageInstancesRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageInstancesResponse DescribeImageInstancesResponse
     */
    public function describeImageInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->scanned)) {
            $query['Scanned'] = $request->scanned;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about images.
     *  *
     * @param DescribeImageInstancesRequest $request DescribeImageInstancesRequest
     *
     * @return DescribeImageInstancesResponse DescribeImageInstancesResponse
     */
    public function describeImageInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the most recent scan task that is created for an image.
     *  *
     * @param DescribeImageLatestScanTaskRequest $request DescribeImageLatestScanTaskRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageLatestScanTaskResponse DescribeImageLatestScanTaskResponse
     */
    public function describeImageLatestScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->digest)) {
            $query['Digest'] = $request->digest;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageLatestScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageLatestScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the most recent scan task that is created for an image.
     *  *
     * @param DescribeImageLatestScanTaskRequest $request DescribeImageLatestScanTaskRequest
     *
     * @return DescribeImageLatestScanTaskResponse DescribeImageLatestScanTaskResponse
     */
    public function describeImageLatestScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageLatestScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about images that are affected by sensitive files.
     *  *
     * @param DescribeImageListBySensitiveFileRequest $tmpReq  DescribeImageListBySensitiveFileRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageListBySensitiveFileResponse DescribeImageListBySensitiveFileResponse
     */
    public function describeImageListBySensitiveFileWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeImageListBySensitiveFileShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->scanRange)) {
            $request->scanRangeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->scanRangeShrink)) {
            $query['ScanRange'] = $request->scanRangeShrink;
        }
        if (!Utils::isUnset($request->sensitiveFileKey)) {
            $query['SensitiveFileKey'] = $request->sensitiveFileKey;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageListBySensitiveFile',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageListBySensitiveFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about images that are affected by sensitive files.
     *  *
     * @param DescribeImageListBySensitiveFileRequest $request DescribeImageListBySensitiveFileRequest
     *
     * @return DescribeImageListBySensitiveFileResponse DescribeImageListBySensitiveFileResponse
     */
    public function describeImageListBySensitiveFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageListBySensitiveFileWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about images in the results of image baseline checks.
     *  *
     * @param DescribeImageListWithBaselineNameRequest $request DescribeImageListWithBaselineNameRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageListWithBaselineNameResponse DescribeImageListWithBaselineNameResponse
     */
    public function describeImageListWithBaselineNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineNameKey)) {
            $query['BaselineNameKey'] = $request->baselineNameKey;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->containerId)) {
            $query['ContainerId'] = $request->containerId;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->image)) {
            $query['Image'] = $request->image;
        }
        if (!Utils::isUnset($request->imageDigest)) {
            $query['ImageDigest'] = $request->imageDigest;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pod)) {
            $query['Pod'] = $request->pod;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageListWithBaselineName',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageListWithBaselineNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about images in the results of image baseline checks.
     *  *
     * @param DescribeImageListWithBaselineNameRequest $request DescribeImageListWithBaselineNameRequest
     *
     * @return DescribeImageListWithBaselineNameResponse DescribeImageListWithBaselineNameResponse
     */
    public function describeImageListWithBaselineName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageListWithBaselineNameWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the filter conditions that are supported by the image repository.
     *  *
     * @param DescribeImageRepoCriteriaRequest $request DescribeImageRepoCriteriaRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageRepoCriteriaResponse DescribeImageRepoCriteriaResponse
     */
    public function describeImageRepoCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageRepoCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageRepoCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the filter conditions that are supported by the image repository.
     *  *
     * @param DescribeImageRepoCriteriaRequest $request DescribeImageRepoCriteriaRequest
     *
     * @return DescribeImageRepoCriteriaResponse DescribeImageRepoCriteriaResponse
     */
    public function describeImageRepoCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRepoCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about image repositories.
     *  *
     * @param DescribeImageRepoDetailListRequest $request DescribeImageRepoDetailListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageRepoDetailListResponse DescribeImageRepoDetailListResponse
     */
    public function describeImageRepoDetailListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageRepoDetailList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageRepoDetailListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about image repositories.
     *  *
     * @param DescribeImageRepoDetailListRequest $request DescribeImageRepoDetailListRequest
     *
     * @return DescribeImageRepoDetailListResponse DescribeImageRepoDetailListResponse
     */
    public function describeImageRepoDetailList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRepoDetailListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics and configurations of the feature that protects images.
     *  *
     * @param DescribeImageRepoListRequest $request DescribeImageRepoListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageRepoListResponse DescribeImageRepoListResponse
     */
    public function describeImageRepoListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fieldName)) {
            $query['FieldName'] = $request->fieldName;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageRepoList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageRepoListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics and configurations of the feature that protects images.
     *  *
     * @param DescribeImageRepoListRequest $request DescribeImageRepoListRequest
     *
     * @return DescribeImageRepoListResponse DescribeImageRepoListResponse
     */
    public function describeImageRepoList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageRepoListWithOptions($request, $runtime);
    }

    /**
     * @summary The quota for container image scan.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageScanAuthCountResponse DescribeImageScanAuthCountResponse
     */
    public function describeImageScanAuthCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeImageScanAuthCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageScanAuthCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The quota for container image scan.
     *  *
     * @return DescribeImageScanAuthCountResponse DescribeImageScanAuthCountResponse
     */
    public function describeImageScanAuthCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageScanAuthCountWithOptions($runtime);
    }

    /**
     * @summary Queries whether Security Center is authorized to scan images.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageScanAuthorizationResponse DescribeImageScanAuthorizationResponse
     */
    public function describeImageScanAuthorizationWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeImageScanAuthorization',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageScanAuthorizationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether Security Center is authorized to scan images.
     *  *
     * @return DescribeImageScanAuthorizationResponse DescribeImageScanAuthorizationResponse
     */
    public function describeImageScanAuthorization()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageScanAuthorizationWithOptions($runtime);
    }

    /**
     * @summary Queries the sensitive files in an image.
     *  *
     * @param DescribeImageSensitiveFileByKeyRequest $tmpReq  DescribeImageSensitiveFileByKeyRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageSensitiveFileByKeyResponse DescribeImageSensitiveFileByKeyResponse
     */
    public function describeImageSensitiveFileByKeyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeImageSensitiveFileByKeyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->scanRange)) {
            $request->scanRangeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->scanRangeShrink)) {
            $query['ScanRange'] = $request->scanRangeShrink;
        }
        if (!Utils::isUnset($request->sensitiveFileKey)) {
            $query['SensitiveFileKey'] = $request->sensitiveFileKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageSensitiveFileByKey',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageSensitiveFileByKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the sensitive files in an image.
     *  *
     * @param DescribeImageSensitiveFileByKeyRequest $request DescribeImageSensitiveFileByKeyRequest
     *
     * @return DescribeImageSensitiveFileByKeyResponse DescribeImageSensitiveFileByKeyResponse
     */
    public function describeImageSensitiveFileByKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageSensitiveFileByKeyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about sensitive files.
     *  *
     * @param DescribeImageSensitiveFileListRequest $tmpReq  DescribeImageSensitiveFileListRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageSensitiveFileListResponse DescribeImageSensitiveFileListResponse
     */
    public function describeImageSensitiveFileListWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DescribeImageSensitiveFileListShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->scanRange)) {
            $request->scanRangeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->scanRange, 'ScanRange', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->scanRangeShrink)) {
            $query['ScanRange'] = $request->scanRangeShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageSensitiveFileList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageSensitiveFileListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about sensitive files.
     *  *
     * @param DescribeImageSensitiveFileListRequest $request DescribeImageSensitiveFileListRequest
     *
     * @return DescribeImageSensitiveFileListResponse DescribeImageSensitiveFileListResponse
     */
    public function describeImageSensitiveFileList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageSensitiveFileListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the risk statistics on container images.
     *  *
     * @description Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
     * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageStatisticsResponse DescribeImageStatisticsResponse
     */
    public function describeImageStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeImageStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk statistics on container images.
     *  *
     * @description Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
     * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
     *  *
     * @return DescribeImageStatisticsResponse DescribeImageStatisticsResponse
     */
    public function describeImageStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries information about the vulnerabilities that are detected by using container image scan and the affected images.
     *  *
     * @description To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](~~PublicCreateImageScanTask~~) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
     *  *
     * @param DescribeImageVulListRequest $request DescribeImageVulListRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageVulListResponse DescribeImageVulListResponse
     */
    public function describeImageVulListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->containerId)) {
            $query['ContainerId'] = $request->containerId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->digest)) {
            $query['Digest'] = $request->digest;
        }
        if (!Utils::isUnset($request->image)) {
            $query['Image'] = $request->image;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pod)) {
            $query['Pod'] = $request->pod;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoId)) {
            $query['RepoId'] = $request->repoId;
        }
        if (!Utils::isUnset($request->repoInstanceId)) {
            $query['RepoInstanceId'] = $request->repoInstanceId;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoName)) {
            $query['RepoName'] = $request->repoName;
        }
        if (!Utils::isUnset($request->repoNamespace)) {
            $query['RepoNamespace'] = $request->repoNamespace;
        }
        if (!Utils::isUnset($request->repoRegionId)) {
            $query['RepoRegionId'] = $request->repoRegionId;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageVulList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the vulnerabilities that are detected by using container image scan and the affected images.
     *  *
     * @description To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](~~PublicCreateImageScanTask~~) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
     *  *
     * @param DescribeImageVulListRequest $request DescribeImageVulListRequest
     *
     * @return DescribeImageVulListResponse DescribeImageVulListResponse
     */
    public function describeImageVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageVulListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the whitelist of image vulnerabilities.
     *  *
     * @param DescribeImageVulWhiteListRequest $request DescribeImageVulWhiteListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeImageVulWhiteListResponse DescribeImageVulWhiteListResponse
     */
    public function describeImageVulWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeImageVulWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeImageVulWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the whitelist of image vulnerabilities.
     *  *
     * @param DescribeImageVulWhiteListRequest $request DescribeImageVulWhiteListRequest
     *
     * @return DescribeImageVulWhiteListResponse DescribeImageVulWhiteListResponse
     */
    public function describeImageVulWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeImageVulWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the verification codes that are used to manually install the Security Center agent.
     *  *
     * @param DescribeInstallCaptchaRequest $request DescribeInstallCaptchaRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstallCaptchaResponse DescribeInstallCaptchaResponse
     */
    public function describeInstallCaptchaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->deadline)) {
            $query['Deadline'] = $request->deadline;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeInstallCaptcha',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstallCaptchaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the verification codes that are used to manually install the Security Center agent.
     *  *
     * @param DescribeInstallCaptchaRequest $request DescribeInstallCaptchaRequest
     *
     * @return DescribeInstallCaptchaResponse DescribeInstallCaptchaResponse
     */
    public function describeInstallCaptcha($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstallCaptchaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstallCodeResponse DescribeInstallCodeResponse
     */
    public function describeInstallCodeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeInstallCode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
     *  *
     * @return DescribeInstallCodeResponse DescribeInstallCodeResponse
     */
    public function describeInstallCode()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstallCodeWithOptions($runtime);
    }

    /**
     * @summary Queries the commands that are used to manually install the Security Center Agent.
     *  *
     * @description You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstallCodesResponse DescribeInstallCodesResponse
     */
    public function describeInstallCodesWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeInstallCodes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstallCodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the commands that are used to manually install the Security Center Agent.
     *  *
     * @description You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
     * ### QPS limit
     * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
     *  *
     * @return DescribeInstallCodesResponse DescribeInstallCodesResponse
     */
    public function describeInstallCodes()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstallCodesWithOptions($runtime);
    }

    /**
     * @summary Queries the information about servers to which a defense rule against brute-force attacks is applied.
     *  *
     * @param DescribeInstanceAntiBruteForceRulesRequest $request DescribeInstanceAntiBruteForceRulesRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstanceAntiBruteForceRulesResponse DescribeInstanceAntiBruteForceRulesResponse
     */
    public function describeInstanceAntiBruteForceRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeInstanceAntiBruteForceRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstanceAntiBruteForceRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about servers to which a defense rule against brute-force attacks is applied.
     *  *
     * @param DescribeInstanceAntiBruteForceRulesRequest $request DescribeInstanceAntiBruteForceRulesRequest
     *
     * @return DescribeInstanceAntiBruteForceRulesResponse DescribeInstanceAntiBruteForceRulesResponse
     */
    public function describeInstanceAntiBruteForceRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceAntiBruteForceRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of the instance that you restart.
     *  *
     * @param DescribeInstanceRebootStatusRequest $request DescribeInstanceRebootStatusRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstanceRebootStatusResponse DescribeInstanceRebootStatusResponse
     */
    public function describeInstanceRebootStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeInstanceRebootStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstanceRebootStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of the instance that you restart.
     *  *
     * @param DescribeInstanceRebootStatusRequest $request DescribeInstanceRebootStatusRequest
     *
     * @return DescribeInstanceRebootStatusResponse DescribeInstanceRebootStatusResponse
     */
    public function describeInstanceRebootStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceRebootStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of assets that are protected by Security Center.
     *  *
     * @param DescribeInstanceStatisticsRequest $request DescribeInstanceStatisticsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeInstanceStatisticsResponse DescribeInstanceStatisticsResponse
     */
    public function describeInstanceStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeInstanceStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeInstanceStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of assets that are protected by Security Center.
     *  *
     * @param DescribeInstanceStatisticsRequest $request DescribeInstanceStatisticsRequest
     *
     * @return DescribeInstanceStatisticsResponse DescribeInstanceStatisticsResponse
     */
    public function describeInstanceStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether an IP address is related to an alert event.
     *  *
     * @param DescribeIpTagsRequest $request DescribeIpTagsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeIpTagsResponse DescribeIpTagsResponse
     */
    public function describeIpTagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ip)) {
            $query['Ip'] = $request->ip;
        }
        if (!Utils::isUnset($request->securityEventId)) {
            $query['SecurityEventId'] = $request->securityEventId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeIpTags',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeIpTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether an IP address is related to an alert event.
     *  *
     * @param DescribeIpTagsRequest $request DescribeIpTagsRequest
     *
     * @return DescribeIpTagsResponse DescribeIpTagsResponse
     */
    public function describeIpTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpTagsWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLatestScanTaskResponse DescribeLatestScanTaskResponse
     */
    public function describeLatestScanTaskWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeLatestScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLatestScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @return DescribeLatestScanTaskResponse DescribeLatestScanTaskResponse
     */
    public function describeLatestScanTask()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLatestScanTaskWithOptions($runtime);
    }

    /**
     * @summary Queries the configurations of the log analysis feature provided by Security Center.
     *  *
     * @param DescribeLogMetaRequest $request DescribeLogMetaRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLogMetaResponse DescribeLogMetaResponse
     */
    public function describeLogMetaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeLogMeta',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLogMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the log analysis feature provided by Security Center.
     *  *
     * @param DescribeLogMetaRequest $request DescribeLogMetaRequest
     *
     * @return DescribeLogMetaResponse DescribeLogMetaResponse
     */
    public function describeLogMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogMetaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status information about the log analysis feature.
     *  *
     * @param DescribeLogShipperStatusRequest $request DescribeLogShipperStatusRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLogShipperStatusResponse DescribeLogShipperStatusResponse
     */
    public function describeLogShipperStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeLogShipperStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLogShipperStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status information about the log analysis feature.
     *  *
     * @param DescribeLogShipperStatusRequest $request DescribeLogShipperStatusRequest
     *
     * @return DescribeLogShipperStatusResponse DescribeLogShipperStatusResponse
     */
    public function describeLogShipperStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogShipperStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the configurations that are used to detect unusual logons to your servers.
     *  *
     * @param DescribeLoginBaseConfigsRequest $request DescribeLoginBaseConfigsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLoginBaseConfigsResponse DescribeLoginBaseConfigsResponse
     */
    public function describeLoginBaseConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeLoginBaseConfigs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLoginBaseConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the configurations that are used to detect unusual logons to your servers.
     *  *
     * @param DescribeLoginBaseConfigsRequest $request DescribeLoginBaseConfigsRequest
     *
     * @return DescribeLoginBaseConfigsResponse DescribeLoginBaseConfigsResponse
     */
    public function describeLoginBaseConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLoginBaseConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLoginSwitchConfigsResponse DescribeLoginSwitchConfigsResponse
     */
    public function describeLoginSwitchConfigsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeLoginSwitchConfigs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLoginSwitchConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
     *  *
     * @return DescribeLoginSwitchConfigsResponse DescribeLoginSwitchConfigsResponse
     */
    public function describeLoginSwitchConfigs()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLoginSwitchConfigsWithOptions($runtime);
    }

    /**
     * @summary Queries the purchased log storage capacity.
     *  *
     * @param DescribeLogstoreStorageRequest $request DescribeLogstoreStorageRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeLogstoreStorageResponse DescribeLogstoreStorageResponse
     */
    public function describeLogstoreStorageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeLogstoreStorage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeLogstoreStorageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the purchased log storage capacity.
     *  *
     * @param DescribeLogstoreStorageRequest $request DescribeLogstoreStorageRequest
     *
     * @return DescribeLogstoreStorageResponse DescribeLogstoreStorageResponse
     */
    public function describeLogstoreStorage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogstoreStorageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
     *  *
     * @param DescribeMachineCanRebootRequest $request DescribeMachineCanRebootRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeMachineCanRebootResponse DescribeMachineCanRebootResponse
     */
    public function describeMachineCanRebootWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeMachineCanReboot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeMachineCanRebootResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
     *  *
     * @param DescribeMachineCanRebootRequest $request DescribeMachineCanRebootRequest
     *
     * @return DescribeMachineCanRebootResponse DescribeMachineCanRebootResponse
     */
    public function describeMachineCanReboot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMachineCanRebootWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of malicious image sample types.
     *  *
     * @param DescribeMatchedMaliciousNamesRequest $request DescribeMatchedMaliciousNamesRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeMatchedMaliciousNamesResponse DescribeMatchedMaliciousNamesResponse
     */
    public function describeMatchedMaliciousNamesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeMatchedMaliciousNames',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeMatchedMaliciousNamesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of malicious image sample types.
     *  *
     * @param DescribeMatchedMaliciousNamesRequest $request DescribeMatchedMaliciousNamesRequest
     *
     * @return DescribeMatchedMaliciousNamesResponse DescribeMatchedMaliciousNamesResponse
     */
    public function describeMatchedMaliciousNames($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMatchedMaliciousNamesWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the server.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeModuleConfigResponse DescribeModuleConfigResponse
     */
    public function describeModuleConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeModuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeModuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the server.
     *  *
     * @return DescribeModuleConfigResponse DescribeModuleConfigResponse
     */
    public function describeModuleConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeModuleConfigWithOptions($runtime);
    }

    /**
     * @summary Queries the list of accounts that are added to the multi-account management feature as members.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeMonitorAccountsResponse DescribeMonitorAccountsResponse
     */
    public function describeMonitorAccountsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeMonitorAccounts',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeMonitorAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of accounts that are added to the multi-account management feature as members.
     *  *
     * @return DescribeMonitorAccountsResponse DescribeMonitorAccountsResponse
     */
    public function describeMonitorAccounts()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMonitorAccountsWithOptions($runtime);
    }

    /**
     * @summary Queries notification settings.
     *  *
     * @param DescribeNoticeConfigRequest $request DescribeNoticeConfigRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeNoticeConfigResponse DescribeNoticeConfigResponse
     */
    public function describeNoticeConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeNoticeConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeNoticeConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries notification settings.
     *  *
     * @param DescribeNoticeConfigRequest $request DescribeNoticeConfigRequest
     *
     * @return DescribeNoticeConfigResponse DescribeNoticeConfigResponse
     */
    public function describeNoticeConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNoticeConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an alert type.
     *  *
     * @param DescribeNsasSuspEventTypeRequest $request DescribeNsasSuspEventTypeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeNsasSuspEventTypeResponse DescribeNsasSuspEventTypeResponse
     */
    public function describeNsasSuspEventTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeNsasSuspEventType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeNsasSuspEventTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an alert type.
     *  *
     * @param DescribeNsasSuspEventTypeRequest $request DescribeNsasSuspEventTypeRequest
     *
     * @return DescribeNsasSuspEventTypeResponse DescribeNsasSuspEventTypeResponse
     */
    public function describeNsasSuspEventType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeNsasSuspEventTypeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers whose Security Center agent status is Offline.
     *  *
     * @param DescribeOfflineMachinesRequest $request DescribeOfflineMachinesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeOfflineMachinesResponse DescribeOfflineMachinesResponse
     */
    public function describeOfflineMachinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->os)) {
            $query['Os'] = $request->os;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionIdStr)) {
            $query['RegionIdStr'] = $request->regionIdStr;
        }
        if (!Utils::isUnset($request->regionNo)) {
            $query['RegionNo'] = $request->regionNo;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeOfflineMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeOfflineMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers whose Security Center agent status is Offline.
     *  *
     * @param DescribeOfflineMachinesRequest $request DescribeOfflineMachinesRequest
     *
     * @return DescribeOfflineMachinesResponse DescribeOfflineMachinesResponse
     */
    public function describeOfflineMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOfflineMachinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries troubleshooting tasks for the Security Center agent.
     *  *
     * @param DescribeOnceTaskRequest $request DescribeOnceTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeOnceTaskResponse DescribeOnceTaskResponse
     */
    public function describeOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTimeQuery)) {
            $query['EndTimeQuery'] = $request->endTimeQuery;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->rootTaskId)) {
            $query['RootTaskId'] = $request->rootTaskId;
        }
        if (!Utils::isUnset($request->startTimeQuery)) {
            $query['StartTimeQuery'] = $request->startTimeQuery;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries troubleshooting tasks for the Security Center agent.
     *  *
     * @param DescribeOnceTaskRequest $request DescribeOnceTaskRequest
     *
     * @return DescribeOnceTaskResponse DescribeOnceTaskResponse
     */
    public function describeOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
     *  *
     * @param DescribeOnceTaskLeafRecordPageRequest $request DescribeOnceTaskLeafRecordPageRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeOnceTaskLeafRecordPageResponse DescribeOnceTaskLeafRecordPageResponse
     */
    public function describeOnceTaskLeafRecordPageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->relateInfo)) {
            $query['RelateInfo'] = $request->relateInfo;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeOnceTaskLeafRecordPage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeOnceTaskLeafRecordPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
     *  *
     * @param DescribeOnceTaskLeafRecordPageRequest $request DescribeOnceTaskLeafRecordPageRequest
     *
     * @return DescribeOnceTaskLeafRecordPageResponse DescribeOnceTaskLeafRecordPageResponse
     */
    public function describeOnceTaskLeafRecordPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOnceTaskLeafRecordPageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
     *  *
     * @param DescribePropertyCountRequest $request DescribePropertyCountRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyCountResponse DescribePropertyCountResponse
     */
    public function describePropertyCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
     *  *
     * @param DescribePropertyCountRequest $request DescribePropertyCountRequest
     *
     * @return DescribePropertyCountResponse DescribePropertyCountResponse
     */
    public function describePropertyCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of scheduled tasks on the Host page.
     *  *
     * @param DescribePropertyCronDetailRequest $request DescribePropertyCronDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyCronDetailResponse DescribePropertyCronDetailResponse
     */
    public function describePropertyCronDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyCronDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyCronDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of scheduled tasks on the Host page.
     *  *
     * @param DescribePropertyCronDetailRequest $request DescribePropertyCronDetailRequest
     *
     * @return DescribePropertyCronDetailResponse DescribePropertyCronDetailResponse
     */
    public function describePropertyCronDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyCronDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the scheduled tasks of your assets.
     *  *
     * @param DescribePropertyCronItemRequest $request DescribePropertyCronItemRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyCronItemResponse DescribePropertyCronItemResponse
     */
    public function describePropertyCronItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyCronItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyCronItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the scheduled tasks of your assets.
     *  *
     * @param DescribePropertyCronItemRequest $request DescribePropertyCronItemRequest
     *
     * @return DescribePropertyCronItemResponse DescribePropertyCronItemResponse
     */
    public function describePropertyCronItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyCronItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the fingerprints of ports on a specified server.
     *  *
     * @param DescribePropertyPortDetailRequest $request DescribePropertyPortDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyPortDetailResponse DescribePropertyPortDetailResponse
     */
    public function describePropertyPortDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bindIp)) {
            $query['BindIp'] = $request->bindIp;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->procName)) {
            $query['ProcName'] = $request->procName;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyPortDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyPortDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the fingerprints of ports on a specified server.
     *  *
     * @param DescribePropertyPortDetailRequest $request DescribePropertyPortDetailRequest
     *
     * @return DescribePropertyPortDetailResponse DescribePropertyPortDetailResponse
     */
    public function describePropertyPortDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyPortDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about all ports.
     *  *
     * @param DescribePropertyPortItemRequest $request DescribePropertyPortItemRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyPortItemResponse DescribePropertyPortItemResponse
     */
    public function describePropertyPortItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyPortItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyPortItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about all ports.
     *  *
     * @param DescribePropertyPortItemRequest $request DescribePropertyPortItemRequest
     *
     * @return DescribePropertyPortItemResponse DescribePropertyPortItemResponse
     */
    public function describePropertyPortItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyPortItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the fingerprints of processes on a specified server.
     *  *
     * @param DescribePropertyProcDetailRequest $request DescribePropertyProcDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyProcDetailResponse DescribePropertyProcDetailResponse
     */
    public function describePropertyProcDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cmdline)) {
            $query['Cmdline'] = $request->cmdline;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->procTimeEnd)) {
            $query['ProcTimeEnd'] = $request->procTimeEnd;
        }
        if (!Utils::isUnset($request->procTimeStart)) {
            $query['ProcTimeStart'] = $request->procTimeStart;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyProcDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyProcDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the fingerprints of processes on a specified server.
     *  *
     * @param DescribePropertyProcDetailRequest $request DescribePropertyProcDetailRequest
     *
     * @return DescribePropertyProcDetailResponse DescribePropertyProcDetailResponse
     */
    public function describePropertyProcDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyProcDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about all processes.
     *  *
     * @param DescribePropertyProcItemRequest $request DescribePropertyProcItemRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyProcItemResponse DescribePropertyProcItemResponse
     */
    public function describePropertyProcItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyProcItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyProcItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about all processes.
     *  *
     * @param DescribePropertyProcItemRequest $request DescribePropertyProcItemRequest
     *
     * @return DescribePropertyProcItemResponse DescribePropertyProcItemResponse
     */
    public function describePropertyProcItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyProcItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries middleware fingerprints.
     *  *
     * @param DescribePropertyScaDetailRequest $request DescribePropertyScaDetailRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyScaDetailResponse DescribePropertyScaDetailResponse
     */
    public function describePropertyScaDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->biz)) {
            $query['Biz'] = $request->biz;
        }
        if (!Utils::isUnset($request->bizType)) {
            $query['BizType'] = $request->bizType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->pid)) {
            $query['Pid'] = $request->pid;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->processStartedEnd)) {
            $query['ProcessStartedEnd'] = $request->processStartedEnd;
        }
        if (!Utils::isUnset($request->processStartedStart)) {
            $query['ProcessStartedStart'] = $request->processStartedStart;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->scaName)) {
            $query['ScaName'] = $request->scaName;
        }
        if (!Utils::isUnset($request->scaNamePattern)) {
            $query['ScaNamePattern'] = $request->scaNamePattern;
        }
        if (!Utils::isUnset($request->scaVersion)) {
            $query['ScaVersion'] = $request->scaVersion;
        }
        if (!Utils::isUnset($request->searchInfo)) {
            $query['SearchInfo'] = $request->searchInfo;
        }
        if (!Utils::isUnset($request->searchInfoSub)) {
            $query['SearchInfoSub'] = $request->searchInfoSub;
        }
        if (!Utils::isUnset($request->searchItem)) {
            $query['SearchItem'] = $request->searchItem;
        }
        if (!Utils::isUnset($request->searchItemSub)) {
            $query['SearchItemSub'] = $request->searchItemSub;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyScaDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyScaDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries middleware fingerprints.
     *  *
     * @param DescribePropertyScaDetailRequest $request DescribePropertyScaDetailRequest
     *
     * @return DescribePropertyScaDetailResponse DescribePropertyScaDetailResponse
     */
    public function describePropertyScaDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScaDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries middleware fingerprints.
     *  *
     * @param DescribePropertyScaItemRequest $request DescribePropertyScaItemRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyScaItemResponse DescribePropertyScaItemResponse
     */
    public function describePropertyScaItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->biz)) {
            $query['Biz'] = $request->biz;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->searchInfo)) {
            $query['SearchInfo'] = $request->searchInfo;
        }
        if (!Utils::isUnset($request->searchItem)) {
            $query['SearchItem'] = $request->searchItem;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyScaItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyScaItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries middleware fingerprints.
     *  *
     * @param DescribePropertyScaItemRequest $request DescribePropertyScaItemRequest
     *
     * @return DescribePropertyScaItemResponse DescribePropertyScaItemResponse
     */
    public function describePropertyScaItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScaItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of scheduled tasks of asset fingerprint collection.
     *  *
     * @param DescribePropertyScheduleConfigRequest $request DescribePropertyScheduleConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyScheduleConfigResponse DescribePropertyScheduleConfigResponse
     */
    public function describePropertyScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of scheduled tasks of asset fingerprint collection.
     *  *
     * @param DescribePropertyScheduleConfigRequest $request DescribePropertyScheduleConfigRequest
     *
     * @return DescribePropertyScheduleConfigResponse DescribePropertyScheduleConfigResponse
     */
    public function describePropertyScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a software asset.
     *  *
     * @param DescribePropertySoftwareDetailRequest $request DescribePropertySoftwareDetailRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertySoftwareDetailResponse DescribePropertySoftwareDetailResponse
     */
    public function describePropertySoftwareDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->installTimeEnd)) {
            $query['InstallTimeEnd'] = $request->installTimeEnd;
        }
        if (!Utils::isUnset($request->installTimeStart)) {
            $query['InstallTimeStart'] = $request->installTimeStart;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->path)) {
            $query['Path'] = $request->path;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->softwareVersion)) {
            $query['SoftwareVersion'] = $request->softwareVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertySoftwareDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertySoftwareDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a software asset.
     *  *
     * @param DescribePropertySoftwareDetailRequest $request DescribePropertySoftwareDetailRequest
     *
     * @return DescribePropertySoftwareDetailResponse DescribePropertySoftwareDetailResponse
     */
    public function describePropertySoftwareDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertySoftwareDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about all software assets.
     *  *
     * @param DescribePropertySoftwareItemRequest $request DescribePropertySoftwareItemRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertySoftwareItemResponse DescribePropertySoftwareItemResponse
     */
    public function describePropertySoftwareItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertySoftwareItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertySoftwareItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about all software assets.
     *  *
     * @param DescribePropertySoftwareItemRequest $request DescribePropertySoftwareItemRequest
     *
     * @return DescribePropertySoftwareItemResponse DescribePropertySoftwareItemResponse
     */
    public function describePropertySoftwareItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertySoftwareItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries middleware types.
     *  *
     * @param DescribePropertyTypeScaItemRequest $request DescribePropertyTypeScaItemRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyTypeScaItemResponse DescribePropertyTypeScaItemResponse
     */
    public function describePropertyTypeScaItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyTypeScaItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyTypeScaItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries middleware types.
     *  *
     * @param DescribePropertyTypeScaItemRequest $request DescribePropertyTypeScaItemRequest
     *
     * @return DescribePropertyTypeScaItemResponse DescribePropertyTypeScaItemResponse
     */
    public function describePropertyTypeScaItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyTypeScaItemWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DescribePropertyUsageNewestRequest $request DescribePropertyUsageNewestRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyUsageNewestResponse DescribePropertyUsageNewestResponse
     */
    public function describePropertyUsageNewestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyUsageNewest',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyUsageNewestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DescribePropertyUsageNewestRequest $request DescribePropertyUsageNewestRequest
     *
     * @return DescribePropertyUsageNewestResponse DescribePropertyUsageNewestResponse
     */
    public function describePropertyUsageNewest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUsageNewestWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the asset fingerprints for an account to which a server belongs.
     *  *
     * @param DescribePropertyUserDetailRequest $request DescribePropertyUserDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyUserDetailResponse DescribePropertyUserDetailResponse
     */
    public function describePropertyUserDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->extend)) {
            $query['Extend'] = $request->extend;
        }
        if (!Utils::isUnset($request->isRoot)) {
            $query['IsRoot'] = $request->isRoot;
        }
        if (!Utils::isUnset($request->lastLoginTimeEnd)) {
            $query['LastLoginTimeEnd'] = $request->lastLoginTimeEnd;
        }
        if (!Utils::isUnset($request->lastLoginTimeStart)) {
            $query['LastLoginTimeStart'] = $request->lastLoginTimeStart;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyUserDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyUserDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the asset fingerprints for an account to which a server belongs.
     *  *
     * @param DescribePropertyUserDetailRequest $request DescribePropertyUserDetailRequest
     *
     * @return DescribePropertyUserDetailResponse DescribePropertyUserDetailResponse
     */
    public function describePropertyUserDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUserDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about an account.
     *  *
     * @param DescribePropertyUserItemRequest $request DescribePropertyUserItemRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribePropertyUserItemResponse DescribePropertyUserItemResponse
     */
    public function describePropertyUserItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->user)) {
            $query['User'] = $request->user;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribePropertyUserItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribePropertyUserItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about an account.
     *  *
     * @param DescribePropertyUserItemRequest $request DescribePropertyUserItemRequest
     *
     * @return DescribePropertyUserItemResponse DescribePropertyUserItemResponse
     */
    public function describePropertyUserItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePropertyUserItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the download information about a quarantined file.
     *  *
     * @param DescribeQuaraFileDownloadInfoRequest $request DescribeQuaraFileDownloadInfoRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeQuaraFileDownloadInfoResponse DescribeQuaraFileDownloadInfoResponse
     */
    public function describeQuaraFileDownloadInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->quaraFileId)) {
            $query['QuaraFileId'] = $request->quaraFileId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeQuaraFileDownloadInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeQuaraFileDownloadInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the download information about a quarantined file.
     *  *
     * @param DescribeQuaraFileDownloadInfoRequest $request DescribeQuaraFileDownloadInfoRequest
     *
     * @return DescribeQuaraFileDownloadInfoResponse DescribeQuaraFileDownloadInfoResponse
     */
    public function describeQuaraFileDownloadInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeQuaraFileDownloadInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about restoration tasks.
     *  *
     * @description If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
     * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
     *  *
     * @param DescribeRestoreJobsRequest $request DescribeRestoreJobsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRestoreJobsResponse DescribeRestoreJobsResponse
     */
    public function describeRestoreJobsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->machineRemark)) {
            $query['MachineRemark'] = $request->machineRemark;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRestoreJobs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRestoreJobsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about restoration tasks.
     *  *
     * @description If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
     * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
     *  *
     * @param DescribeRestoreJobsRequest $request DescribeRestoreJobsRequest
     *
     * @return DescribeRestoreJobsResponse DescribeRestoreJobsResponse
     */
    public function describeRestoreJobs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRestoreJobsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries restoration tasks.
     *  *
     * @param DescribeRestorePlansRequest $request DescribeRestorePlansRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRestorePlansResponse DescribeRestorePlansResponse
     */
    public function describeRestorePlansWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->instanceName)) {
            $query['InstanceName'] = $request->instanceName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRestorePlans',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRestorePlansResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries restoration tasks.
     *  *
     * @param DescribeRestorePlansRequest $request DescribeRestorePlansRequest
     *
     * @return DescribeRestorePlansResponse DescribeRestorePlansResponse
     */
    public function describeRestorePlans($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRestorePlansWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
     *  *
     * @summary Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
     *  *
     * @description This operation is phased out. You can use the ListCheckInstanceResult operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckItemResultRequest $request DescribeRiskCheckItemResultRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskCheckItemResultResponse DescribeRiskCheckItemResultResponse
     */
    public function describeRiskCheckItemResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->itemId)) {
            $query['ItemId'] = $request->itemId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskCheckItemResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskCheckItemResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
     *  *
     * @summary Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
     *  *
     * @description This operation is phased out. You can use the ListCheckInstanceResult operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckItemResultRequest $request DescribeRiskCheckItemResultRequest
     *
     * @return DescribeRiskCheckItemResultResponse DescribeRiskCheckItemResultResponse
     */
    public function describeRiskCheckItemResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskCheckItemResultWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
     *  *
     * @summary Queries the check results of cloud service configurations by check item type or name.
     *  *
     * @description This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckResultRequest $request DescribeRiskCheckResultRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskCheckResultResponse DescribeRiskCheckResultResponse
     */
    public function describeRiskCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->itemIds)) {
            $query['ItemIds'] = $request->itemIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->queryFlag)) {
            $query['QueryFlag'] = $request->queryFlag;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
     *  *
     * @summary Queries the check results of cloud service configurations by check item type or name.
     *  *
     * @description This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckResultRequest $request DescribeRiskCheckResultRequest
     *
     * @return DescribeRiskCheckResultResponse DescribeRiskCheckResultResponse
     */
    public function describeRiskCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskCheckResultWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
     *  *
     * @summary Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
     *  *
     * @description This operation is phased out. You can use the GetCheckSummary operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckSummaryRequest $request DescribeRiskCheckSummaryRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskCheckSummaryResponse DescribeRiskCheckSummaryResponse
     */
    public function describeRiskCheckSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskCheckSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskCheckSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
     *  *
     * @summary Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
     *  *
     * @description This operation is phased out. You can use the GetCheckSummary operation.
     *  *
     * Deprecated
     *
     * @param DescribeRiskCheckSummaryRequest $request DescribeRiskCheckSummaryRequest
     *
     * @return DescribeRiskCheckSummaryResponse DescribeRiskCheckSummaryResponse
     */
    public function describeRiskCheckSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskCheckSummaryWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskItemType is deprecated
     *  *
     * @summary Queries the types of check items in configuration assessment.
     *  *
     * @description This operation is phased out. You can use the ListCheckStandard operation instead.
     *  *
     * Deprecated
     *
     * @param DescribeRiskItemTypeRequest $request DescribeRiskItemTypeRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskItemTypeResponse DescribeRiskItemTypeResponse
     */
    public function describeRiskItemTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskItemType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskItemTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskItemType is deprecated
     *  *
     * @summary Queries the types of check items in configuration assessment.
     *  *
     * @description This operation is phased out. You can use the ListCheckStandard operation instead.
     *  *
     * Deprecated
     *
     * @param DescribeRiskItemTypeRequest $request DescribeRiskItemTypeRequest
     *
     * @return DescribeRiskItemTypeResponse DescribeRiskItemTypeResponse
     */
    public function describeRiskItemType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskItemTypeWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
     *  *
     * @summary Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
     *  *
     * @description This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
     *  *
     * Deprecated
     *
     * @param DescribeRiskListCheckResultRequest $request DescribeRiskListCheckResultRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskListCheckResultResponse DescribeRiskListCheckResultResponse
     */
    public function describeRiskListCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskListCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskListCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
     *  *
     * @summary Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
     *  *
     * @description This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
     *  *
     * Deprecated
     *
     * @param DescribeRiskListCheckResultRequest $request DescribeRiskListCheckResultRequest
     *
     * @return DescribeRiskListCheckResultResponse DescribeRiskListCheckResultResponse
     */
    public function describeRiskListCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskListCheckResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries baseline types.
     *  *
     * @param DescribeRiskTypeRequest $request DescribeRiskTypeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRiskTypeResponse DescribeRiskTypeResponse
     */
    public function describeRiskTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRiskType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRiskTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries baseline types.
     *  *
     * @param DescribeRiskTypeRequest $request DescribeRiskTypeRequest
     *
     * @return DescribeRiskTypeResponse DescribeRiskTypeResponse
     */
    public function describeRiskType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRiskTypeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about baselines based on baseline IDs or names.
     *  *
     * @param DescribeRisksRequest $request DescribeRisksRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeRisksResponse DescribeRisksResponse
     */
    public function describeRisksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->limit)) {
            $query['Limit'] = $request->limit;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->riskName)) {
            $query['RiskName'] = $request->riskName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeRisks',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeRisksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about baselines based on baseline IDs or names.
     *  *
     * @param DescribeRisksRequest $request DescribeRisksRequest
     *
     * @return DescribeRisksResponse DescribeRisksResponse
     */
    public function describeRisks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRisksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
     *  *
     * @param DescribeSasPmAgentListRequest $request DescribeSasPmAgentListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSasPmAgentListResponse DescribeSasPmAgentListResponse
     */
    public function describeSasPmAgentListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSasPmAgentList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSasPmAgentListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
     *  *
     * @param DescribeSasPmAgentListRequest $request DescribeSasPmAgentListRequest
     *
     * @return DescribeSasPmAgentListResponse DescribeSasPmAgentListResponse
     */
    public function describeSasPmAgentList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSasPmAgentListWithOptions($request, $runtime);
    }

    /**
     * @summary DescribeScanTaskProgress
     *  *
     * @param DescribeScanTaskProgressRequest $request DescribeScanTaskProgressRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeScanTaskProgressResponse DescribeScanTaskProgressResponse
     */
    public function describeScanTaskProgressWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeScanTaskProgress',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeScanTaskProgressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary DescribeScanTaskProgress
     *  *
     * @param DescribeScanTaskProgressRequest $request DescribeScanTaskProgressRequest
     *
     * @return DescribeScanTaskProgressResponse DescribeScanTaskProgressResponse
     */
    public function describeScanTaskProgress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeScanTaskProgressWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of virus detection tasks.
     *  *
     * @param DescribeScanTaskStatisticsRequest $request DescribeScanTaskStatisticsRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeScanTaskStatisticsResponse DescribeScanTaskStatisticsResponse
     */
    public function describeScanTaskStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeScanTaskStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeScanTaskStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of virus detection tasks.
     *  *
     * @param DescribeScanTaskStatisticsRequest $request DescribeScanTaskStatisticsRequest
     *
     * @return DescribeScanTaskStatisticsResponse DescribeScanTaskStatisticsResponse
     */
    public function describeScanTaskStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeScanTaskStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DescribeSearchConditionRequest $request DescribeSearchConditionRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSearchConditionResponse DescribeSearchConditionResponse
     */
    public function describeSearchConditionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSearchCondition',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSearchConditionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DescribeSearchConditionRequest $request DescribeSearchConditionRequest
     *
     * @return DescribeSearchConditionResponse DescribeSearchConditionResponse
     */
    public function describeSearchCondition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSearchConditionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries suggestions on how to handle the risks that affect the security score.
     *  *
     * @param DescribeSecureSuggestionRequest $request DescribeSecureSuggestionRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecureSuggestionResponse DescribeSecureSuggestionResponse
     */
    public function describeSecureSuggestionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecureSuggestion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecureSuggestionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries suggestions on how to handle the risks that affect the security score.
     *  *
     * @param DescribeSecureSuggestionRequest $request DescribeSecureSuggestionRequest
     *
     * @return DescribeSecureSuggestionResponse DescribeSecureSuggestionResponse
     */
    public function describeSecureSuggestion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecureSuggestionWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
     *  *
     * @summary Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
     *  *
     * @description This operation is phased out. You can use the GetCheckConfig operation.
     *  *
     * Deprecated
     *
     * @param DescribeSecurityCheckScheduleConfigRequest $request DescribeSecurityCheckScheduleConfigRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityCheckScheduleConfigResponse DescribeSecurityCheckScheduleConfigResponse
     */
    public function describeSecurityCheckScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityCheckScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityCheckScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
     *  *
     * @summary Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
     *  *
     * @description This operation is phased out. You can use the GetCheckConfig operation.
     *  *
     * Deprecated
     *
     * @param DescribeSecurityCheckScheduleConfigRequest $request DescribeSecurityCheckScheduleConfigRequest
     *
     * @return DescribeSecurityCheckScheduleConfigResponse DescribeSecurityCheckScheduleConfigResponse
     */
    public function describeSecurityCheckScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityCheckScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the list of whitelist rules.
     *  *
     * @param DescribeSecurityEventMarkMissListRequest $request DescribeSecurityEventMarkMissListRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityEventMarkMissListResponse DescribeSecurityEventMarkMissListResponse
     */
    public function describeSecurityEventMarkMissListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityEventMarkMissList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityEventMarkMissListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the list of whitelist rules.
     *  *
     * @param DescribeSecurityEventMarkMissListRequest $request DescribeSecurityEventMarkMissListRequest
     *
     * @return DescribeSecurityEventMarkMissListResponse DescribeSecurityEventMarkMissListResponse
     */
    public function describeSecurityEventMarkMissList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityEventMarkMissListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
     *  *
     * @param DescribeSecurityEventOperationStatusRequest $request DescribeSecurityEventOperationStatusRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityEventOperationStatusResponse DescribeSecurityEventOperationStatusResponse
     */
    public function describeSecurityEventOperationStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityEventIds)) {
            $query['SecurityEventIds'] = $request->securityEventIds;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityEventOperationStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityEventOperationStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
     *  *
     * @param DescribeSecurityEventOperationStatusRequest $request DescribeSecurityEventOperationStatusRequest
     *
     * @return DescribeSecurityEventOperationStatusResponse DescribeSecurityEventOperationStatusResponse
     */
    public function describeSecurityEventOperationStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityEventOperationStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the operations that you can perform to handle an alert event.
     *  *
     * @param DescribeSecurityEventOperationsRequest $request DescribeSecurityEventOperationsRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityEventOperationsResponse DescribeSecurityEventOperationsResponse
     */
    public function describeSecurityEventOperationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityEventId)) {
            $query['SecurityEventId'] = $request->securityEventId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityEventOperations',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityEventOperationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the operations that you can perform to handle an alert event.
     *  *
     * @param DescribeSecurityEventOperationsRequest $request DescribeSecurityEventOperationsRequest
     *
     * @return DescribeSecurityEventOperationsResponse DescribeSecurityEventOperationsResponse
     */
    public function describeSecurityEventOperations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityEventOperationsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
     *  *
     * @param DescribeSecurityStatInfoRequest $request DescribeSecurityStatInfoRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSecurityStatInfoResponse DescribeSecurityStatInfoResponse
     */
    public function describeSecurityStatInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSecurityStatInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSecurityStatInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
     *  *
     * @param DescribeSecurityStatInfoRequest $request DescribeSecurityStatInfoRequest
     *
     * @return DescribeSecurityStatInfoResponse DescribeSecurityStatInfoResponse
     */
    public function describeSecurityStatInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityStatInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether a service-linked role is created for Security Center.
     *  *
     * @param DescribeServiceLinkedRoleStatusRequest $request DescribeServiceLinkedRoleStatusRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeServiceLinkedRoleStatusResponse DescribeServiceLinkedRoleStatusResponse
     */
    public function describeServiceLinkedRoleStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->serviceLinkedRole)) {
            $query['ServiceLinkedRole'] = $request->serviceLinkedRole;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeServiceLinkedRoleStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeServiceLinkedRoleStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether a service-linked role is created for Security Center.
     *  *
     * @param DescribeServiceLinkedRoleStatusRequest $request DescribeServiceLinkedRoleStatusRequest
     *
     * @return DescribeServiceLinkedRoleStatusResponse DescribeServiceLinkedRoleStatusResponse
     */
    public function describeServiceLinkedRoleStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeServiceLinkedRoleStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Alibaba Cloud CLI is a tool used to manage and configure Alibaba Cloud resources. After simple installation and configuration, you can use Alibaba Cloud CLI to manage multiple Alibaba Cloud products and services and migrate your data and business to the cloud with ease.
     *  *
     * @param DescribeSimilarEventScenariosRequest $request DescribeSimilarEventScenariosRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSimilarEventScenariosResponse DescribeSimilarEventScenariosResponse
     */
    public function describeSimilarEventScenariosWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->securityEventId)) {
            $query['SecurityEventId'] = $request->securityEventId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSimilarEventScenarios',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSimilarEventScenariosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Alibaba Cloud CLI is a tool used to manage and configure Alibaba Cloud resources. After simple installation and configuration, you can use Alibaba Cloud CLI to manage multiple Alibaba Cloud products and services and migrate your data and business to the cloud with ease.
     *  *
     * @param DescribeSimilarEventScenariosRequest $request DescribeSimilarEventScenariosRequest
     *
     * @return DescribeSimilarEventScenariosResponse DescribeSimilarEventScenariosResponse
     */
    public function describeSimilarEventScenarios($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSimilarEventScenariosWithOptions($request, $runtime);
    }

    /**
     * @summary Queries alert events that are triggered by the same rule or of the same alert type.
     *  *
     * @param DescribeSimilarSecurityEventsRequest $request DescribeSimilarSecurityEventsRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSimilarSecurityEventsResponse DescribeSimilarSecurityEventsResponse
     */
    public function describeSimilarSecurityEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSimilarSecurityEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSimilarSecurityEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries alert events that are triggered by the same rule or of the same alert type.
     *  *
     * @param DescribeSimilarSecurityEventsRequest $request DescribeSimilarSecurityEventsRequest
     *
     * @return DescribeSimilarSecurityEventsResponse DescribeSimilarSecurityEventsResponse
     */
    public function describeSimilarSecurityEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSimilarSecurityEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the backup snapshots that are created for anti-ransomware.
     *  *
     * @param DescribeSnapshotsRequest $request DescribeSnapshotsRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSnapshotsResponse DescribeSnapshotsResponse
     */
    public function describeSnapshotsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->apiVersion)) {
            $query['ApiVersion'] = $request->apiVersion;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->isAliYunEcs)) {
            $query['IsAliYunEcs'] = $request->isAliYunEcs;
        }
        if (!Utils::isUnset($request->machineRegion)) {
            $query['MachineRegion'] = $request->machineRegion;
        }
        if (!Utils::isUnset($request->machineRemark)) {
            $query['MachineRemark'] = $request->machineRemark;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSnapshots',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSnapshotsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the backup snapshots that are created for anti-ransomware.
     *  *
     * @param DescribeSnapshotsRequest $request DescribeSnapshotsRequest
     *
     * @return DescribeSnapshotsResponse DescribeSnapshotsResponse
     */
    public function describeSnapshots($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSnapshotsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about baseline check policies.
     *  *
     * @param DescribeStrategyRequest $request DescribeStrategyRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStrategyResponse DescribeStrategyResponse
     */
    public function describeStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->customType)) {
            $query['CustomType'] = $request->customType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyIds)) {
            $query['StrategyIds'] = $request->strategyIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about baseline check policies.
     *  *
     * @param DescribeStrategyRequest $request DescribeStrategyRequest
     *
     * @return DescribeStrategyResponse DescribeStrategyResponse
     */
    public function describeStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a baseline check policy.
     *  *
     * @param DescribeStrategyDetailRequest $request DescribeStrategyDetailRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStrategyDetailResponse DescribeStrategyDetailResponse
     */
    public function describeStrategyDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeStrategyDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeStrategyDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a baseline check policy.
     *  *
     * @param DescribeStrategyDetailRequest $request DescribeStrategyDetailRequest
     *
     * @return DescribeStrategyDetailResponse DescribeStrategyDetailResponse
     */
    public function describeStrategyDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyDetailWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DescribeStrategyExecDetailRequest $request DescribeStrategyExecDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStrategyExecDetailResponse DescribeStrategyExecDetailResponse
     */
    public function describeStrategyExecDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeStrategyExecDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeStrategyExecDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DescribeStrategyExecDetailRequest $request DescribeStrategyExecDetailRequest
     *
     * @return DescribeStrategyExecDetailResponse DescribeStrategyExecDetailResponse
     */
    public function describeStrategyExecDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyExecDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the assets to which a baseline check policy is applied.
     *  *
     * @param DescribeStrategyTargetRequest $request DescribeStrategyTargetRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeStrategyTargetResponse DescribeStrategyTargetResponse
     */
    public function describeStrategyTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeStrategyTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeStrategyTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the assets to which a baseline check policy is applied.
     *  *
     * @param DescribeStrategyTargetRequest $request DescribeStrategyTargetRequest
     *
     * @return DescribeStrategyTargetResponse DescribeStrategyTargetResponse
     */
    public function describeStrategyTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeStrategyTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
     *  *
     * @param DescribeSummaryInfoRequest $request DescribeSummaryInfoRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSummaryInfoResponse DescribeSummaryInfoResponse
     */
    public function describeSummaryInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSummaryInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSummaryInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
     *  *
     * @param DescribeSummaryInfoRequest $request DescribeSummaryInfoRequest
     *
     * @return DescribeSummaryInfoResponse DescribeSummaryInfoResponse
     */
    public function describeSummaryInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSummaryInfoWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSupportRegionResponse DescribeSupportRegionResponse
     */
    public function describeSupportRegionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeSupportRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSupportRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @return DescribeSupportRegionResponse DescribeSupportRegionResponse
     */
    public function describeSupportRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSupportRegionWithOptions($runtime);
    }

    /**
     * @summary Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
     *  *
     * @param DescribeSuspEventDetailRequest $request DescribeSuspEventDetailRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventDetailResponse DescribeSuspEventDetailResponse
     */
    public function describeSuspEventDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->suspiciousEventId)) {
            $query['SuspiciousEventId'] = $request->suspiciousEventId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEventDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
     *  *
     * @param DescribeSuspEventDetailRequest $request DescribeSuspEventDetailRequest
     *
     * @return DescribeSuspEventDetailResponse DescribeSuspEventDetailResponse
     */
    public function describeSuspEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an export task of exceptions.
     *  *
     * @param DescribeSuspEventExportInfoRequest $request DescribeSuspEventExportInfoRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventExportInfoResponse DescribeSuspEventExportInfoResponse
     */
    public function describeSuspEventExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEventExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an export task of exceptions.
     *  *
     * @param DescribeSuspEventExportInfoRequest $request DescribeSuspEventExportInfoRequest
     *
     * @return DescribeSuspEventExportInfoResponse DescribeSuspEventExportInfoResponse
     */
    public function describeSuspEventExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries quarantined files by page.
     *  *
     * @param DescribeSuspEventQuaraFilesRequest $request DescribeSuspEventQuaraFilesRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventQuaraFilesResponse DescribeSuspEventQuaraFilesResponse
     */
    public function describeSuspEventQuaraFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->groupingId)) {
            $query['GroupingId'] = $request->groupingId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->quaraTag)) {
            $query['QuaraTag'] = $request->quaraTag;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEventQuaraFiles',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventQuaraFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries quarantined files by page.
     *  *
     * @param DescribeSuspEventQuaraFilesRequest $request DescribeSuspEventQuaraFilesRequest
     *
     * @return DescribeSuspEventQuaraFilesResponse DescribeSuspEventQuaraFilesResponse
     */
    public function describeSuspEventQuaraFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventQuaraFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the user settings for exceptions.
     *  *
     * @param DescribeSuspEventUserSettingRequest $request DescribeSuspEventUserSettingRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventUserSettingResponse DescribeSuspEventUserSettingResponse
     */
    public function describeSuspEventUserSettingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEventUserSetting',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the user settings for exceptions.
     *  *
     * @param DescribeSuspEventUserSettingRequest $request DescribeSuspEventUserSettingRequest
     *
     * @return DescribeSuspEventUserSettingResponse DescribeSuspEventUserSettingResponse
     */
    public function describeSuspEventUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventUserSettingWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of alert events that are generated without aggregation.
     *  *
     * @param DescribeSuspEventsRequest $request DescribeSuspEventsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspEventsResponse DescribeSuspEventsResponse
     */
    public function describeSuspEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alarmUniqueInfo)) {
            $query['AlarmUniqueInfo'] = $request->alarmUniqueInfo;
        }
        if (!Utils::isUnset($request->assetsTypeList)) {
            $query['AssetsTypeList'] = $request->assetsTypeList;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->eventNames)) {
            $query['EventNames'] = $request->eventNames;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->operateErrorCodeList)) {
            $query['OperateErrorCodeList'] = $request->operateErrorCodeList;
        }
        if (!Utils::isUnset($request->operateTimeEnd)) {
            $query['OperateTimeEnd'] = $request->operateTimeEnd;
        }
        if (!Utils::isUnset($request->operateTimeStart)) {
            $query['OperateTimeStart'] = $request->operateTimeStart;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentEventTypes)) {
            $query['ParentEventTypes'] = $request->parentEventTypes;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sortColumn)) {
            $query['SortColumn'] = $request->sortColumn;
        }
        if (!Utils::isUnset($request->sortType)) {
            $query['SortType'] = $request->sortType;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->strictMode)) {
            $query['StrictMode'] = $request->strictMode;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        if (!Utils::isUnset($request->uniqueInfo)) {
            $query['UniqueInfo'] = $request->uniqueInfo;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $body = [];
        if (!Utils::isUnset($request->tacticId)) {
            $body['TacticId'] = $request->tacticId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of alert events that are generated without aggregation.
     *  *
     * @param DescribeSuspEventsRequest $request DescribeSuspEventsRequest
     *
     * @return DescribeSuspEventsResponse DescribeSuspEventsResponse
     */
    public function describeSuspEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of a specified feature.
     *  *
     * @param DescribeSuspiciousOverallConfigRequest $request DescribeSuspiciousOverallConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspiciousOverallConfigResponse DescribeSuspiciousOverallConfigResponse
     */
    public function describeSuspiciousOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspiciousOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspiciousOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of a specified feature.
     *  *
     * @param DescribeSuspiciousOverallConfigRequest $request DescribeSuspiciousOverallConfigRequest
     *
     * @return DescribeSuspiciousOverallConfigResponse DescribeSuspiciousOverallConfigResponse
     */
    public function describeSuspiciousOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspiciousOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
     *  *
     * @param DescribeSuspiciousUUIDConfigRequest $request DescribeSuspiciousUUIDConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeSuspiciousUUIDConfigResponse DescribeSuspiciousUUIDConfigResponse
     */
    public function describeSuspiciousUUIDConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeSuspiciousUUIDConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeSuspiciousUUIDConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
     *  *
     * @param DescribeSuspiciousUUIDConfigRequest $request DescribeSuspiciousUUIDConfigRequest
     *
     * @return DescribeSuspiciousUUIDConfigResponse DescribeSuspiciousUUIDConfigResponse
     */
    public function describeSuspiciousUUIDConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSuspiciousUUIDConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers on which vulnerability scan is enabled.
     *  *
     * @param DescribeTargetRequest $request DescribeTargetRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTargetResponse DescribeTargetResponse
     */
    public function describeTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers on which vulnerability scan is enabled.
     *  *
     * @param DescribeTargetRequest $request DescribeTargetRequest
     *
     * @return DescribeTargetResponse DescribeTargetResponse
     */
    public function describeTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the error logs on a task that failed to fix image vulnerabilities.
     *  *
     * @param DescribeTaskErrorLogRequest $request DescribeTaskErrorLogRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTaskErrorLogResponse DescribeTaskErrorLogResponse
     */
    public function describeTaskErrorLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->buildTaskId)) {
            $query['BuildTaskId'] = $request->buildTaskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTaskErrorLog',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTaskErrorLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the error logs on a task that failed to fix image vulnerabilities.
     *  *
     * @param DescribeTaskErrorLogRequest $request DescribeTaskErrorLogRequest
     *
     * @return DescribeTaskErrorLogResponse DescribeTaskErrorLogResponse
     */
    public function describeTaskErrorLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTaskErrorLogWithOptions($request, $runtime);
    }

    /**
     * @summary Queries event statistics.
     *  *
     * @param DescribeTotalStatisticsRequest $request DescribeTotalStatisticsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTotalStatisticsResponse DescribeTotalStatisticsResponse
     */
    public function describeTotalStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTotalStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTotalStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries event statistics.
     *  *
     * @param DescribeTotalStatisticsRequest $request DescribeTotalStatisticsRequest
     *
     * @return DescribeTotalStatisticsResponse DescribeTotalStatisticsResponse
     */
    public function describeTotalStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTotalStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the trace information about alerts.
     *  *
     * @param DescribeTraceInfoDetailRequest $request DescribeTraceInfoDetailRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTraceInfoDetailResponse DescribeTraceInfoDetailResponse
     */
    public function describeTraceInfoDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->incidentTime)) {
            $query['IncidentTime'] = $request->incidentTime;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->vertexId)) {
            $query['VertexId'] = $request->vertexId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTraceInfoDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTraceInfoDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the trace information about alerts.
     *  *
     * @param DescribeTraceInfoDetailRequest $request DescribeTraceInfoDetailRequest
     *
     * @return DescribeTraceInfoDetailResponse DescribeTraceInfoDetailResponse
     */
    public function describeTraceInfoDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTraceInfoDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a trace node.
     *  *
     * @param DescribeTraceInfoNodeRequest $request DescribeTraceInfoNodeRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeTraceInfoNodeResponse DescribeTraceInfoNodeResponse
     */
    public function describeTraceInfoNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->incidentTime)) {
            $query['IncidentTime'] = $request->incidentTime;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->vertexId)) {
            $query['VertexId'] = $request->vertexId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeTraceInfoNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeTraceInfoNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a trace node.
     *  *
     * @param DescribeTraceInfoNodeRequest $request DescribeTraceInfoNodeRequest
     *
     * @return DescribeTraceInfoNodeResponse DescribeTraceInfoNodeResponse
     */
    public function describeTraceInfoNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTraceInfoNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about databases for which anti-ransomware policies are created.
     *  *
     * @param DescribeUniBackupDatabaseRequest $request DescribeUniBackupDatabaseRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniBackupDatabaseResponse DescribeUniBackupDatabaseResponse
     */
    public function describeUniBackupDatabaseWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->databaseType)) {
            $query['DatabaseType'] = $request->databaseType;
        }
        if (!Utils::isUnset($request->instanceName)) {
            $query['InstanceName'] = $request->instanceName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->queryType)) {
            $query['QueryType'] = $request->queryType;
        }
        if (!Utils::isUnset($request->uniRegionId)) {
            $query['UniRegionId'] = $request->uniRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUniBackupDatabase',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniBackupDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about databases for which anti-ransomware policies are created.
     *  *
     * @param DescribeUniBackupDatabaseRequest $request DescribeUniBackupDatabaseRequest
     *
     * @return DescribeUniBackupDatabaseResponse DescribeUniBackupDatabaseResponse
     */
    public function describeUniBackupDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupDatabaseWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the anti-ransomware policies that are created for databases.
     *  *
     * @param DescribeUniBackupPoliciesRequest $request DescribeUniBackupPoliciesRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniBackupPoliciesResponse DescribeUniBackupPoliciesResponse
     */
    public function describeUniBackupPoliciesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->policyName)) {
            $query['PolicyName'] = $request->policyName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUniBackupPolicies',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniBackupPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the anti-ransomware policies that are created for databases.
     *  *
     * @param DescribeUniBackupPoliciesRequest $request DescribeUniBackupPoliciesRequest
     *
     * @return DescribeUniBackupPoliciesResponse DescribeUniBackupPoliciesResponse
     */
    public function describeUniBackupPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupPoliciesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an anti-ransomware policy for databases.
     *  *
     * @param DescribeUniBackupPolicyDetailRequest $request DescribeUniBackupPolicyDetailRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniBackupPolicyDetailResponse DescribeUniBackupPolicyDetailResponse
     */
    public function describeUniBackupPolicyDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUniBackupPolicyDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniBackupPolicyDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an anti-ransomware policy for databases.
     *  *
     * @param DescribeUniBackupPolicyDetailRequest $request DescribeUniBackupPolicyDetailRequest
     *
     * @return DescribeUniBackupPolicyDetailResponse DescribeUniBackupPolicyDetailResponse
     */
    public function describeUniBackupPolicyDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniBackupPolicyDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the backup snapshots from which the data of a database can be restored.
     *  *
     * @param DescribeUniRecoverableListRequest $request DescribeUniRecoverableListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniRecoverableListResponse DescribeUniRecoverableListResponse
     */
    public function describeUniRecoverableListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->database)) {
            $query['Database'] = $request->database;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUniRecoverableList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniRecoverableListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the backup snapshots from which the data of a database can be restored.
     *  *
     * @param DescribeUniRecoverableListRequest $request DescribeUniRecoverableListRequest
     *
     * @return DescribeUniRecoverableListResponse DescribeUniRecoverableListResponse
     */
    public function describeUniRecoverableList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniRecoverableListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the region that is supported by anti-ransomware for databases.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUniSupportRegionResponse DescribeUniSupportRegionResponse
     */
    public function describeUniSupportRegionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeUniSupportRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUniSupportRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the region that is supported by anti-ransomware for databases.
     *  *
     * @return DescribeUniSupportRegionResponse DescribeUniSupportRegionResponse
     */
    public function describeUniSupportRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUniSupportRegionWithOptions($runtime);
    }

    /**
     * @summary Queries the information about the servers to which an anti-ransomware policy is applied.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUserBackupMachinesResponse DescribeUserBackupMachinesResponse
     */
    public function describeUserBackupMachinesWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeUserBackupMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUserBackupMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers to which an anti-ransomware policy is applied.
     *  *
     * @return DescribeUserBackupMachinesResponse DescribeUserBackupMachinesResponse
     */
    public function describeUserBackupMachines()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserBackupMachinesWithOptions($runtime);
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param DescribeUserBaselineAuthorizationRequest $request DescribeUserBaselineAuthorizationRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUserBaselineAuthorizationResponse DescribeUserBaselineAuthorizationResponse
     */
    public function describeUserBaselineAuthorizationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUserBaselineAuthorization',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUserBaselineAuthorizationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param DescribeUserBaselineAuthorizationRequest $request DescribeUserBaselineAuthorizationRequest
     *
     * @return DescribeUserBaselineAuthorizationResponse DescribeUserBaselineAuthorizationResponse
     */
    public function describeUserBaselineAuthorization($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserBaselineAuthorizationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether the brute-force attacks protection feature has been authorized. The brute-force attacks protection feature cannot be used without authorization.
     *  *
     * @param DescribeUserLayoutAuthorizationRequest $request DescribeUserLayoutAuthorizationRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUserLayoutAuthorizationResponse DescribeUserLayoutAuthorizationResponse
     */
    public function describeUserLayoutAuthorizationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUserLayoutAuthorization',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUserLayoutAuthorizationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether the brute-force attacks protection feature has been authorized. The brute-force attacks protection feature cannot be used without authorization.
     *  *
     * @param DescribeUserLayoutAuthorizationRequest $request DescribeUserLayoutAuthorizationRequest
     *
     * @return DescribeUserLayoutAuthorizationResponse DescribeUserLayoutAuthorizationResponse
     */
    public function describeUserLayoutAuthorization($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUserLayoutAuthorizationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of assets that support fixing based on vulnerability names.
     *  *
     * @param DescribeUuidsByVulNamesRequest $request DescribeUuidsByVulNamesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeUuidsByVulNamesResponse DescribeUuidsByVulNamesResponse
     */
    public function describeUuidsByVulNamesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->fieldName)) {
            $query['FieldName'] = $request->fieldName;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->level)) {
            $query['Level'] = $request->level;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->searchTags)) {
            $query['SearchTags'] = $request->searchTags;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->vpcInstanceIds)) {
            $query['VpcInstanceIds'] = $request->vpcInstanceIds;
        }
        if (!Utils::isUnset($request->vulNames)) {
            $query['VulNames'] = $request->vulNames;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeUuidsByVulNames',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeUuidsByVulNamesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of assets that support fixing based on vulnerability names.
     *  *
     * @param DescribeUuidsByVulNamesRequest $request DescribeUuidsByVulNamesRequest
     *
     * @return DescribeUuidsByVulNamesResponse DescribeUuidsByVulNamesResponse
     */
    public function describeUuidsByVulNames($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUuidsByVulNamesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the service providers whose assets can be added to Security Center.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVendorListResponse DescribeVendorListResponse
     */
    public function describeVendorListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeVendorList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVendorListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the service providers whose assets can be added to Security Center.
     *  *
     * @return DescribeVendorListResponse DescribeVendorListResponse
     */
    public function describeVendorList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVendorListWithOptions($runtime);
    }

    /**
     * @summary Queries the details about the edition of purchased Security Center.
     *  *
     * @param DescribeVersionConfigRequest $request DescribeVersionConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVersionConfigResponse DescribeVersionConfigResponse
     */
    public function describeVersionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVersionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVersionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about the edition of purchased Security Center.
     *  *
     * @param DescribeVersionConfigRequest $request DescribeVersionConfigRequest
     *
     * @return DescribeVersionConfigResponse DescribeVersionConfigResponse
     */
    public function describeVersionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVersionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the search conditions that can be used to query honeypots.
     *  *
     * @param DescribeVpcHoneyPotCriteriaRequest $request DescribeVpcHoneyPotCriteriaRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpcHoneyPotCriteriaResponse DescribeVpcHoneyPotCriteriaResponse
     */
    public function describeVpcHoneyPotCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpcHoneyPotCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpcHoneyPotCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the search conditions that can be used to query honeypots.
     *  *
     * @param DescribeVpcHoneyPotCriteriaRequest $request DescribeVpcHoneyPotCriteriaRequest
     *
     * @return DescribeVpcHoneyPotCriteriaResponse DescribeVpcHoneyPotCriteriaResponse
     */
    public function describeVpcHoneyPotCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcHoneyPotCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries virtual private clouds (VPCs) on which honeypots are deployed.
     *  *
     * @description If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
     *  *
     * @param DescribeVpcHoneyPotListRequest $request DescribeVpcHoneyPotListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpcHoneyPotListResponse DescribeVpcHoneyPotListResponse
     */
    public function describeVpcHoneyPotListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->honeyPotExistence)) {
            $query['HoneyPotExistence'] = $request->honeyPotExistence;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        if (!Utils::isUnset($request->vpcName)) {
            $query['VpcName'] = $request->vpcName;
        }
        if (!Utils::isUnset($request->vpcRegionId)) {
            $query['VpcRegionId'] = $request->vpcRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVpcHoneyPotList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpcHoneyPotListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries virtual private clouds (VPCs) on which honeypots are deployed.
     *  *
     * @description If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
     *  *
     * @param DescribeVpcHoneyPotListRequest $request DescribeVpcHoneyPotListRequest
     *
     * @return DescribeVpcHoneyPotListResponse DescribeVpcHoneyPotListResponse
     */
    public function describeVpcHoneyPotList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcHoneyPotListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about virtual private clouds (VPCs).
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVpcListResponse DescribeVpcListResponse
     */
    public function describeVpcListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeVpcList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVpcListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about virtual private clouds (VPCs).
     *  *
     * @return DescribeVpcListResponse DescribeVpcListResponse
     */
    public function describeVpcList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVpcListWithOptions($runtime);
    }

    /**
     * @summary Queries the status information about vulnerability scan tasks on a server.
     *  *
     * @param DescribeVulCheckTaskStatusDetailRequest $request DescribeVulCheckTaskStatusDetailRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulCheckTaskStatusDetailResponse DescribeVulCheckTaskStatusDetailResponse
     */
    public function describeVulCheckTaskStatusDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskIds)) {
            $query['TaskIds'] = $request->taskIds;
        }
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulCheckTaskStatusDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulCheckTaskStatusDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status information about vulnerability scan tasks on a server.
     *  *
     * @param DescribeVulCheckTaskStatusDetailRequest $request DescribeVulCheckTaskStatusDetailRequest
     *
     * @return DescribeVulCheckTaskStatusDetailResponse DescribeVulCheckTaskStatusDetailResponse
     */
    public function describeVulCheckTaskStatusDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulCheckTaskStatusDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of vulnerability management.
     *  *
     * @param DescribeVulConfigRequest $request DescribeVulConfigRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulConfigResponse DescribeVulConfigResponse
     */
    public function describeVulConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of vulnerability management.
     *  *
     * @param DescribeVulConfigRequest $request DescribeVulConfigRequest
     *
     * @return DescribeVulConfigResponse DescribeVulConfigResponse
     */
    public function describeVulConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a vulnerability.
     *  *
     * @param DescribeVulDetailsRequest $request DescribeVulDetailsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulDetailsResponse DescribeVulDetailsResponse
     */
    public function describeVulDetailsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulDetails',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulDetailsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a vulnerability.
     *  *
     * @param DescribeVulDetailsRequest $request DescribeVulDetailsRequest
     *
     * @return DescribeVulDetailsResponse DescribeVulDetailsResponse
     */
    public function describeVulDetails($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulDetailsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a task that exports vulnerabilities.
     *  *
     * @description If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
     *  *
     * @param DescribeVulExportInfoRequest $request DescribeVulExportInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulExportInfoResponse DescribeVulExportInfoResponse
     */
    public function describeVulExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a task that exports vulnerabilities.
     *  *
     * @description If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
     *  *
     * @param DescribeVulExportInfoRequest $request DescribeVulExportInfoRequest
     *
     * @return DescribeVulExportInfoResponse DescribeVulExportInfoResponse
     */
    public function describeVulExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of vulnerability fixes.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulFixStatisticsResponse DescribeVulFixStatisticsResponse
     */
    public function describeVulFixStatisticsWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeVulFixStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulFixStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of vulnerability fixes.
     *  *
     * @return DescribeVulFixStatisticsResponse DescribeVulFixStatisticsResponse
     */
    public function describeVulFixStatistics()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulFixStatisticsWithOptions($runtime);
    }

    /**
     * @summary Queries vulnerabilities by type.
     *  *
     * @param DescribeVulListRequest $request DescribeVulListRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulListResponse DescribeVulListResponse
     */
    public function describeVulListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->attachTypes)) {
            $query['AttachTypes'] = $request->attachTypes;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->useNextToken)) {
            $query['UseNextToken'] = $request->useNextToken;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->vpcInstanceIds)) {
            $query['VpcInstanceIds'] = $request->vpcInstanceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries vulnerabilities by type.
     *  *
     * @param DescribeVulListRequest $request DescribeVulListRequest
     *
     * @return DescribeVulListResponse DescribeVulListResponse
     */
    public function describeVulList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the vulnerabilities that can be detected.
     *  *
     * @param DescribeVulListPageRequest $request DescribeVulListPageRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulListPageResponse DescribeVulListPageResponse
     */
    public function describeVulListPageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->cveId)) {
            $query['CveId'] = $request->cveId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->vulNameLike)) {
            $query['VulNameLike'] = $request->vulNameLike;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulListPage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulListPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the vulnerabilities that can be detected.
     *  *
     * @param DescribeVulListPageRequest $request DescribeVulListPageRequest
     *
     * @return DescribeVulListPageResponse DescribeVulListPageResponse
     */
    public function describeVulListPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulListPageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of vulnerabilities.
     *  *
     * @param DescribeVulNumStatisticsRequest $request DescribeVulNumStatisticsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulNumStatisticsResponse DescribeVulNumStatisticsResponse
     */
    public function describeVulNumStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulNumStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulNumStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of vulnerabilities.
     *  *
     * @param DescribeVulNumStatisticsRequest $request DescribeVulNumStatisticsRequest
     *
     * @return DescribeVulNumStatisticsResponse DescribeVulNumStatisticsResponse
     */
    public function describeVulNumStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulNumStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the vulnerability scan feature for a server.
     *  *
     * @param DescribeVulTargetConfigRequest $request DescribeVulTargetConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulTargetConfigResponse DescribeVulTargetConfigResponse
     */
    public function describeVulTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the vulnerability scan feature for a server.
     *  *
     * @param DescribeVulTargetConfigRequest $request DescribeVulTargetConfigRequest
     *
     * @return DescribeVulTargetConfigResponse DescribeVulTargetConfigResponse
     */
    public function describeVulTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of the vulnerability scan feature.
     *  *
     * @param DescribeVulTargetStatisticsRequest $request DescribeVulTargetStatisticsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulTargetStatisticsResponse DescribeVulTargetStatisticsResponse
     */
    public function describeVulTargetStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulTargetStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulTargetStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of the vulnerability scan feature.
     *  *
     * @param DescribeVulTargetStatisticsRequest $request DescribeVulTargetStatisticsRequest
     *
     * @return DescribeVulTargetStatisticsResponse DescribeVulTargetStatisticsResponse
     */
    public function describeVulTargetStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulTargetStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the whitelist of vulnerabilities by page.
     *  *
     * @param DescribeVulWhitelistRequest $request DescribeVulWhitelistRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeVulWhitelistResponse DescribeVulWhitelistResponse
     */
    public function describeVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the whitelist of vulnerabilities by page.
     *  *
     * @param DescribeVulWhitelistRequest $request DescribeVulWhitelistRequest
     *
     * @return DescribeVulWhitelistResponse DescribeVulWhitelistResponse
     */
    public function describeVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a export task for a baseline check result.
     *  *
     * @param DescribeWarningExportInfoRequest $request DescribeWarningExportInfoRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWarningExportInfoResponse DescribeWarningExportInfoResponse
     */
    public function describeWarningExportInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportId)) {
            $query['ExportId'] = $request->exportId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWarningExportInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWarningExportInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a export task for a baseline check result.
     *  *
     * @param DescribeWarningExportInfoRequest $request DescribeWarningExportInfoRequest
     *
     * @return DescribeWarningExportInfoResponse DescribeWarningExportInfoResponse
     */
    public function describeWarningExportInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWarningExportInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
     *  *
     * @param DescribeWarningMachinesRequest $request DescribeWarningMachinesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWarningMachinesResponse DescribeWarningMachinesResponse
     */
    public function describeWarningMachinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->haveRisk)) {
            $query['HaveRisk'] = $request->haveRisk;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->machineName)) {
            $query['MachineName'] = $request->machineName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWarningMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWarningMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
     *  *
     * @param DescribeWarningMachinesRequest $request DescribeWarningMachinesRequest
     *
     * @return DescribeWarningMachinesResponse DescribeWarningMachinesResponse
     */
    public function describeWarningMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWarningMachinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers that have web tamper proofing enabled.
     *  *
     * @param DescribeWebLockBindListRequest $request DescribeWebLockBindListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockBindListResponse DescribeWebLockBindListResponse
     */
    public function describeWebLockBindListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockBindList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockBindListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers that have web tamper proofing enabled.
     *  *
     * @param DescribeWebLockBindListRequest $request DescribeWebLockBindListRequest
     *
     * @return DescribeWebLockBindListResponse DescribeWebLockBindListResponse
     */
    public function describeWebLockBindList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockBindListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of web tamper proofing for a specified server.
     *  *
     * @param DescribeWebLockConfigListRequest $request DescribeWebLockConfigListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockConfigListResponse DescribeWebLockConfigListResponse
     */
    public function describeWebLockConfigListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockConfigList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockConfigListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of web tamper proofing for a specified server.
     *  *
     * @param DescribeWebLockConfigListRequest $request DescribeWebLockConfigListRequest
     *
     * @return DescribeWebLockConfigListResponse DescribeWebLockConfigListResponse
     */
    public function describeWebLockConfigList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockConfigListWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockExclusiveFileTypeResponse DescribeWebLockExclusiveFileTypeResponse
     */
    public function describeWebLockExclusiveFileTypeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeWebLockExclusiveFileType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockExclusiveFileTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @return DescribeWebLockExclusiveFileTypeResponse DescribeWebLockExclusiveFileTypeResponse
     */
    public function describeWebLockExclusiveFileType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockExclusiveFileTypeWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics on changes to the files that are protected by web tamper proofing.
     *  *
     * @param DescribeWebLockFileChangeStatisticsRequest $request DescribeWebLockFileChangeStatisticsRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockFileChangeStatisticsResponse DescribeWebLockFileChangeStatisticsResponse
     */
    public function describeWebLockFileChangeStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockFileChangeStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockFileChangeStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on changes to the files that are protected by web tamper proofing.
     *  *
     * @param DescribeWebLockFileChangeStatisticsRequest $request DescribeWebLockFileChangeStatisticsRequest
     *
     * @return DescribeWebLockFileChangeStatisticsResponse DescribeWebLockFileChangeStatisticsResponse
     */
    public function describeWebLockFileChangeStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockFileChangeStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries events on web tamper proofing.
     *  *
     * @param DescribeWebLockFileEventsRequest $request DescribeWebLockFileEventsRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockFileEventsResponse DescribeWebLockFileEventsResponse
     */
    public function describeWebLockFileEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->processName)) {
            $query['ProcessName'] = $request->processName;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->tsBegin)) {
            $query['TsBegin'] = $request->tsBegin;
        }
        if (!Utils::isUnset($request->tsEnd)) {
            $query['TsEnd'] = $request->tsEnd;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockFileEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockFileEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries events on web tamper proofing.
     *  *
     * @param DescribeWebLockFileEventsRequest $request DescribeWebLockFileEventsRequest
     *
     * @return DescribeWebLockFileEventsResponse DescribeWebLockFileEventsResponse
     */
    public function describeWebLockFileEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockFileEventsWithOptions($request, $runtime);
    }

    /**
     * @summary The number of attempts.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockFileTypeSummaryResponse DescribeWebLockFileTypeSummaryResponse
     */
    public function describeWebLockFileTypeSummaryWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeWebLockFileTypeSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockFileTypeSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The number of attempts.
     *  *
     * @return DescribeWebLockFileTypeSummaryResponse DescribeWebLockFileTypeSummaryResponse
     */
    public function describeWebLockFileTypeSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockFileTypeSummaryWithOptions($runtime);
    }

    /**
     * @summary Queries the types of files that can be protected by web tamper proofing.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockInclusiveFileTypeResponse DescribeWebLockInclusiveFileTypeResponse
     */
    public function describeWebLockInclusiveFileTypeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeWebLockInclusiveFileType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockInclusiveFileTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the types of files that can be protected by web tamper proofing.
     *  *
     * @return DescribeWebLockInclusiveFileTypeResponse DescribeWebLockInclusiveFileTypeResponse
     */
    public function describeWebLockInclusiveFileType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockInclusiveFileTypeWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics on processes for web tamper proofing.
     *  *
     * @param DescribeWebLockProcessBlockStatisticsRequest $request DescribeWebLockProcessBlockStatisticsRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockProcessBlockStatisticsResponse DescribeWebLockProcessBlockStatisticsResponse
     */
    public function describeWebLockProcessBlockStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockProcessBlockStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockProcessBlockStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on processes for web tamper proofing.
     *  *
     * @param DescribeWebLockProcessBlockStatisticsRequest $request DescribeWebLockProcessBlockStatisticsRequest
     *
     * @return DescribeWebLockProcessBlockStatisticsResponse DescribeWebLockProcessBlockStatisticsResponse
     */
    public function describeWebLockProcessBlockStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockProcessBlockStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the processes for web tamper proofing.
     *  *
     * @param DescribeWebLockProcessListRequest $request DescribeWebLockProcessListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockProcessListResponse DescribeWebLockProcessListResponse
     */
    public function describeWebLockProcessListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->processName)) {
            $query['ProcessName'] = $request->processName;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockProcessList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockProcessListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the processes for web tamper proofing.
     *  *
     * @param DescribeWebLockProcessListRequest $request DescribeWebLockProcessListRequest
     *
     * @return DescribeWebLockProcessListResponse DescribeWebLockProcessListResponse
     */
    public function describeWebLockProcessList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockProcessListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of web tamper proofing.
     *  *
     * @param DescribeWebLockStatusRequest $request DescribeWebLockStatusRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockStatusResponse DescribeWebLockStatusResponse
     */
    public function describeWebLockStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebLockStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of web tamper proofing.
     *  *
     * @param DescribeWebLockStatusRequest $request DescribeWebLockStatusRequest
     *
     * @return DescribeWebLockStatusResponse DescribeWebLockStatusResponse
     */
    public function describeWebLockStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of times that the files protected by web tamper proofing are changed.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebLockTotalFileChangeCountResponse DescribeWebLockTotalFileChangeCountResponse
     */
    public function describeWebLockTotalFileChangeCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DescribeWebLockTotalFileChangeCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebLockTotalFileChangeCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of times that the files protected by web tamper proofing are changed.
     *  *
     * @return DescribeWebLockTotalFileChangeCountResponse DescribeWebLockTotalFileChangeCountResponse
     */
    public function describeWebLockTotalFileChangeCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebLockTotalFileChangeCountWithOptions($runtime);
    }

    /**
     * @summary Queries the custom web directories that are scanned based on the alerting feature.
     *  *
     * @param DescribeWebPathRequest $request DescribeWebPathRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DescribeWebPathResponse DescribeWebPathResponse
     */
    public function describeWebPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DescribeWebPath',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DescribeWebPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the custom web directories that are scanned based on the alerting feature.
     *  *
     * @param DescribeWebPathRequest $request DescribeWebPathRequest
     *
     * @return DescribeWebPathResponse DescribeWebPathResponse
     */
    public function describeWebPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWebPathWithOptions($request, $runtime);
    }

    /**
     * @summary Disables an IP address blocking policy that is in effect.
     *  *
     * @param DisableBruteForceRecordRequest $request DisableBruteForceRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DisableBruteForceRecordResponse DisableBruteForceRecordResponse
     */
    public function disableBruteForceRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DisableBruteForceRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DisableBruteForceRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables an IP address blocking policy that is in effect.
     *  *
     * @param DisableBruteForceRecordRequest $request DisableBruteForceRecordRequest
     *
     * @return DisableBruteForceRecordResponse DisableBruteForceRecordResponse
     */
    public function disableBruteForceRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableBruteForceRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Disables a custom IP address blocking policy for servers.
     *  *
     * @param DisableCustomBlockRecordRequest $request DisableCustomBlockRecordRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DisableCustomBlockRecordResponse DisableCustomBlockRecordResponse
     */
    public function disableCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DisableCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DisableCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables a custom IP address blocking policy for servers.
     *  *
     * @param DisableCustomBlockRecordRequest $request DisableCustomBlockRecordRequest
     *
     * @return DisableCustomBlockRecordResponse DisableCustomBlockRecordResponse
     */
    public function disableCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Enables an IP address blocking policy for a specified server.
     *  *
     * @param EnableBruteForceRecordRequest $request EnableBruteForceRecordRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableBruteForceRecordResponse EnableBruteForceRecordResponse
     */
    public function enableBruteForceRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnableBruteForceRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableBruteForceRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables an IP address blocking policy for a specified server.
     *  *
     * @param EnableBruteForceRecordRequest $request EnableBruteForceRecordRequest
     *
     * @return EnableBruteForceRecordResponse EnableBruteForceRecordResponse
     */
    public function enableBruteForceRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableBruteForceRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Enables a custom IP address blocking policy.
     *  *
     * @param EnableCustomBlockRecordRequest $request EnableCustomBlockRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableCustomBlockRecordResponse EnableCustomBlockRecordResponse
     */
    public function enableCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnableCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables a custom IP address blocking policy.
     *  *
     * @param EnableCustomBlockRecordRequest $request EnableCustomBlockRecordRequest
     *
     * @return EnableCustomBlockRecordResponse EnableCustomBlockRecordResponse
     */
    public function enableCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Enables a custom rule for an instance.
     *  *
     * @param EnableCustomInstanceBlockRecordRequest $request EnableCustomInstanceBlockRecordRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return EnableCustomInstanceBlockRecordResponse EnableCustomInstanceBlockRecordResponse
     */
    public function enableCustomInstanceBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'EnableCustomInstanceBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EnableCustomInstanceBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables a custom rule for an instance.
     *  *
     * @param EnableCustomInstanceBlockRecordRequest $request EnableCustomInstanceBlockRecordRequest
     *
     * @return EnableCustomInstanceBlockRecordResponse EnableCustomInstanceBlockRecordResponse
     */
    public function enableCustomInstanceBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableCustomInstanceBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Performs a baseline check on servers to which a specified baseline check policy is applied.
     *  *
     * @param ExecStrategyRequest $request ExecStrategyRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ExecStrategyResponse ExecStrategyResponse
     */
    public function execStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExecStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExecStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Performs a baseline check on servers to which a specified baseline check policy is applied.
     *  *
     * @param ExecStrategyRequest $request ExecStrategyRequest
     *
     * @return ExecStrategyResponse ExecStrategyResponse
     */
    public function execStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->execStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
     *  *
     * @description You can call the operation to export the following check result lists:
     * *   The list of servers on the Host page.
     * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
     * *   The list of attack analysis data on the Attack Awareness page.
     * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
     *  *
     * @param ExportRecordRequest $request ExportRecordRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportRecordResponse ExportRecordResponse
     */
    public function exportRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->exportFileType)) {
            $query['ExportFileType'] = $request->exportFileType;
        }
        if (!Utils::isUnset($request->exportType)) {
            $query['ExportType'] = $request->exportType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->params)) {
            $query['Params'] = $request->params;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
     *  *
     * @description You can call the operation to export the following check result lists:
     * *   The list of servers on the Host page.
     * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
     * *   The list of attack analysis data on the Attack Awareness page.
     * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
     *  *
     * @param ExportRecordRequest $request ExportRecordRequest
     *
     * @return ExportRecordResponse ExportRecordResponse
     */
    public function exportRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Exports the information about exceptions to a file.
     *  *
     * @param ExportSuspEventsRequest $request ExportSuspEventsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportSuspEventsResponse ExportSuspEventsResponse
     */
    public function exportSuspEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetsTypeList)) {
            $query['AssetsTypeList'] = $request->assetsTypeList;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->operateErrorCodeList)) {
            $query['OperateErrorCodeList'] = $request->operateErrorCodeList;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentEventTypes)) {
            $query['ParentEventTypes'] = $request->parentEventTypes;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        if (!Utils::isUnset($request->uniqueInfo)) {
            $query['UniqueInfo'] = $request->uniqueInfo;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportSuspEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportSuspEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports the information about exceptions to a file.
     *  *
     * @param ExportSuspEventsRequest $request ExportSuspEventsRequest
     *
     * @return ExportSuspEventsResponse ExportSuspEventsResponse
     */
    public function exportSuspEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportSuspEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Exports vulnerabilities.
     *  *
     * @description You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
     * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param ExportVulRequest $request ExportVulRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportVulResponse ExportVulResponse
     */
    public function exportVulWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->attachTypes)) {
            $query['AttachTypes'] = $request->attachTypes;
        }
        if (!Utils::isUnset($request->containerName)) {
            $query['ContainerName'] = $request->containerName;
        }
        if (!Utils::isUnset($request->createTsEnd)) {
            $query['CreateTsEnd'] = $request->createTsEnd;
        }
        if (!Utils::isUnset($request->createTsStart)) {
            $query['CreateTsStart'] = $request->createTsStart;
        }
        if (!Utils::isUnset($request->cveId)) {
            $query['CveId'] = $request->cveId;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->necessity)) {
            $query['Necessity'] = $request->necessity;
        }
        if (!Utils::isUnset($request->path)) {
            $query['Path'] = $request->path;
        }
        if (!Utils::isUnset($request->searchTags)) {
            $query['SearchTags'] = $request->searchTags;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->vpcInstanceIds)) {
            $query['VpcInstanceIds'] = $request->vpcInstanceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportVul',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports vulnerabilities.
     *  *
     * @description You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
     * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param ExportVulRequest $request ExportVulRequest
     *
     * @return ExportVulResponse ExportVulResponse
     */
    public function exportVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportVulWithOptions($request, $runtime);
    }

    /**
     * @summary Exports baseline check results.
     *  *
     * @param ExportWarningRequest $request ExportWarningRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportWarningResponse ExportWarningResponse
     */
    public function exportWarningWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->exportType)) {
            $query['ExportType'] = $request->exportType;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->isCleartextPwd)) {
            $query['IsCleartextPwd'] = $request->isCleartextPwd;
        }
        if (!Utils::isUnset($request->isSummaryExport)) {
            $query['IsSummaryExport'] = $request->isSummaryExport;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->riskIds)) {
            $query['RiskIds'] = $request->riskIds;
        }
        if (!Utils::isUnset($request->riskLevels)) {
            $query['RiskLevels'] = $request->riskLevels;
        }
        if (!Utils::isUnset($request->riskName)) {
            $query['RiskName'] = $request->riskName;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->subTypeNames)) {
            $query['SubTypeNames'] = $request->subTypeNames;
        }
        if (!Utils::isUnset($request->typeName)) {
            $query['TypeName'] = $request->typeName;
        }
        if (!Utils::isUnset($request->typeNames)) {
            $query['TypeNames'] = $request->typeNames;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportWarning',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportWarningResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports baseline check results.
     *  *
     * @param ExportWarningRequest $request ExportWarningRequest
     *
     * @return ExportWarningResponse ExportWarningResponse
     */
    public function exportWarning($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportWarningWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param FindContainerNetworkConnectRequest $tmpReq  FindContainerNetworkConnectRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return FindContainerNetworkConnectResponse FindContainerNetworkConnectResponse
     */
    public function findContainerNetworkConnectWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new FindContainerNetworkConnectShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->dstNode)) {
            $request->dstNodeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->dstNode, 'DstNode', 'json');
        }
        if (!Utils::isUnset($tmpReq->srcNode)) {
            $request->srcNodeShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->srcNode, 'SrcNode', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dstNodeShrink)) {
            $query['DstNode'] = $request->dstNodeShrink;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->srcNodeShrink)) {
            $query['SrcNode'] = $request->srcNodeShrink;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'FindContainerNetworkConnect',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return FindContainerNetworkConnectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param FindContainerNetworkConnectRequest $request FindContainerNetworkConnectRequest
     *
     * @return FindContainerNetworkConnectResponse FindContainerNetworkConnectResponse
     */
    public function findContainerNetworkConnect($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->findContainerNetworkConnectWithOptions($request, $runtime);
    }

    /**
     * @summary Fixes a baseline risk item.
     *  *
     * @param FixCheckWarningsRequest $request FixCheckWarningsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return FixCheckWarningsResponse FixCheckWarningsResponse
     */
    public function fixCheckWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkParams)) {
            $query['CheckParams'] = $request->checkParams;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'FixCheckWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return FixCheckWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Fixes a baseline risk item.
     *  *
     * @param FixCheckWarningsRequest $request FixCheckWarningsRequest
     *
     * @return FixCheckWarningsResponse FixCheckWarningsResponse
     */
    public function fixCheckWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->fixCheckWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary Generates a command that is used to add a self-managed Kubernetes cluster.
     *  *
     * @param GenerateK8sAccessInfoRequest $request GenerateK8sAccessInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GenerateK8sAccessInfoResponse GenerateK8sAccessInfoResponse
     */
    public function generateK8sAccessInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliyunYundunGatewayApiName)) {
            $query['AliyunYundunGatewayApiName'] = $request->aliyunYundunGatewayApiName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayPopName)) {
            $query['AliyunYundunGatewayPopName'] = $request->aliyunYundunGatewayPopName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayProjectName)) {
            $query['AliyunYundunGatewayProjectName'] = $request->aliyunYundunGatewayProjectName;
        }
        if (!Utils::isUnset($request->auditLogStore)) {
            $query['AuditLogStore'] = $request->auditLogStore;
        }
        if (!Utils::isUnset($request->auditProject)) {
            $query['AuditProject'] = $request->auditProject;
        }
        if (!Utils::isUnset($request->auditRegionId)) {
            $query['AuditRegionId'] = $request->auditRegionId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->expireDate)) {
            $query['ExpireDate'] = $request->expireDate;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GenerateK8sAccessInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GenerateK8sAccessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Generates a command that is used to add a self-managed Kubernetes cluster.
     *  *
     * @param GenerateK8sAccessInfoRequest $request GenerateK8sAccessInfoRequest
     *
     * @return GenerateK8sAccessInfoResponse GenerateK8sAccessInfoResponse
     */
    public function generateK8sAccessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateK8sAccessInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a one-time scan task.
     *  *
     * @param GenerateOnceTaskRequest $request GenerateOnceTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GenerateOnceTaskResponse GenerateOnceTaskResponse
     */
    public function generateOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->param)) {
            $query['Param'] = $request->param;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GenerateOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GenerateOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a one-time scan task.
     *  *
     * @param GenerateOnceTaskRequest $request GenerateOnceTaskRequest
     *
     * @return GenerateOnceTaskResponse GenerateOnceTaskResponse
     */
    public function generateOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries search conditions that can be used to search for container file protection rules.
     *  *
     * @param GetAegisContainerPluginRuleCriteriaRequest $request GetAegisContainerPluginRuleCriteriaRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAegisContainerPluginRuleCriteriaResponse GetAegisContainerPluginRuleCriteriaResponse
     */
    public function getAegisContainerPluginRuleCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAegisContainerPluginRuleCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAegisContainerPluginRuleCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries search conditions that can be used to search for container file protection rules.
     *  *
     * @param GetAegisContainerPluginRuleCriteriaRequest $request GetAegisContainerPluginRuleCriteriaRequest
     *
     * @return GetAegisContainerPluginRuleCriteriaResponse GetAegisContainerPluginRuleCriteriaResponse
     */
    public function getAegisContainerPluginRuleCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAegisContainerPluginRuleCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of agentless detection tasks.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAgentlessTaskCountResponse GetAgentlessTaskCountResponse
     */
    public function getAgentlessTaskCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetAgentlessTaskCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAgentlessTaskCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of agentless detection tasks.
     *  *
     * @return GetAgentlessTaskCountResponse GetAgentlessTaskCountResponse
     */
    public function getAgentlessTaskCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAgentlessTaskCountWithOptions($runtime);
    }

    /**
     * @summary Queries the number of servers on which alerts are generated.
     *  *
     * @param GetAlarmMachineCountRequest $request GetAlarmMachineCountRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAlarmMachineCountResponse GetAlarmMachineCountResponse
     */
    public function getAlarmMachineCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAlarmMachineCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAlarmMachineCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of servers on which alerts are generated.
     *  *
     * @param GetAlarmMachineCountRequest $request GetAlarmMachineCountRequest
     *
     * @return GetAlarmMachineCountResponse GetAlarmMachineCountResponse
     */
    public function getAlarmMachineCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAlarmMachineCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the network topology between containerized applications.
     *  *
     * @param GetAppNetworkRequest $request GetAppNetworkRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAppNetworkResponse GetAppNetworkResponse
     */
    public function getAppNetworkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAppNetwork',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAppNetworkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the network topology between containerized applications.
     *  *
     * @param GetAppNetworkRequest $request GetAppNetworkRequest
     *
     * @return GetAppNetworkResponse GetAppNetworkResponse
     */
    public function getAppNetwork($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAppNetworkWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
     *  *
     * @param GetAssetDetailByUuidRequest $request GetAssetDetailByUuidRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAssetDetailByUuidResponse GetAssetDetailByUuidResponse
     */
    public function getAssetDetailByUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAssetDetailByUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAssetDetailByUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
     *  *
     * @param GetAssetDetailByUuidRequest $request GetAssetDetailByUuidRequest
     *
     * @return GetAssetDetailByUuidResponse GetAssetDetailByUuidResponse
     */
    public function getAssetDetailByUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetDetailByUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries asset selection configurations.
     *  *
     * @param GetAssetSelectionConfigRequest $request GetAssetSelectionConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAssetSelectionConfigResponse GetAssetSelectionConfigResponse
     */
    public function getAssetSelectionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->businessType)) {
            $query['BusinessType'] = $request->businessType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAssetSelectionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAssetSelectionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries asset selection configurations.
     *  *
     * @param GetAssetSelectionConfigRequest $request GetAssetSelectionConfigRequest
     *
     * @return GetAssetSelectionConfigResponse GetAssetSelectionConfigResponse
     */
    public function getAssetSelectionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetSelectionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
     *  *
     * @param GetAssetsPropertyDetailRequest $request GetAssetsPropertyDetailRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAssetsPropertyDetailResponse GetAssetsPropertyDetailResponse
     */
    public function getAssetsPropertyDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->biz)) {
            $query['Biz'] = $request->biz;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->itemName)) {
            $query['ItemName'] = $request->itemName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->searchCriteriaList)) {
            $query['SearchCriteriaList'] = $request->searchCriteriaList;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAssetsPropertyDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAssetsPropertyDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
     *  *
     * @param GetAssetsPropertyDetailRequest $request GetAssetsPropertyDetailRequest
     *
     * @return GetAssetsPropertyDetailResponse GetAssetsPropertyDetailResponse
     */
    public function getAssetsPropertyDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetsPropertyDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
     *  *
     * @param GetAssetsPropertyItemRequest $request GetAssetsPropertyItemRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAssetsPropertyItemResponse GetAssetsPropertyItemResponse
     */
    public function getAssetsPropertyItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->biz)) {
            $query['Biz'] = $request->biz;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->forceFlush)) {
            $query['ForceFlush'] = $request->forceFlush;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->searchInfo)) {
            $query['SearchInfo'] = $request->searchInfo;
        }
        if (!Utils::isUnset($request->searchItem)) {
            $query['SearchItem'] = $request->searchItem;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetAssetsPropertyItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAssetsPropertyItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
     *  *
     * @param GetAssetsPropertyItemRequest $request GetAssetsPropertyItemRequest
     *
     * @return GetAssetsPropertyItemResponse GetAssetsPropertyItemResponse
     */
    public function getAssetsPropertyItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAssetsPropertyItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics about the numbers of assets protected by each edition of Security Center.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAuthVersionStatisticResponse GetAuthVersionStatisticResponse
     */
    public function getAuthVersionStatisticWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetAuthVersionStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAuthVersionStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics about the numbers of assets protected by each edition of Security Center.
     *  *
     * @return GetAuthVersionStatisticResponse GetAuthVersionStatisticResponse
     */
    public function getAuthVersionStatistic()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAuthVersionStatisticWithOptions($runtime);
    }

    /**
     * @summary 
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBackupStorageCountResponse GetBackupStorageCountResponse
     */
    public function getBackupStorageCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetBackupStorageCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBackupStorageCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @return GetBackupStorageCountResponse GetBackupStorageCountResponse
     */
    public function getBackupStorageCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBackupStorageCountWithOptions($runtime);
    }

    /**
     * @summary Queries the information about an automatic configuration check on cloud services.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckConfigResponse GetCheckConfigResponse
     */
    public function getCheckConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetCheckConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an automatic configuration check on cloud services.
     *  *
     * @return GetCheckConfigResponse GetCheckConfigResponse
     */
    public function getCheckConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckConfigWithOptions($runtime);
    }

    /**
     * @summary Queries the details about a check item that is used for configuration assessment.
     *  *
     * @param GetCheckDetailRequest $request GetCheckDetailRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckDetailResponse GetCheckDetailResponse
     */
    public function getCheckDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a check item that is used for configuration assessment.
     *  *
     * @param GetCheckDetailRequest $request GetCheckDetailRequest
     *
     * @return GetCheckDetailResponse GetCheckDetailResponse
     */
    public function getCheckDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a configuration check task on cloud services.
     *  *
     * @param GetCheckProcessRequest $request GetCheckProcessRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckProcessResponse GetCheckProcessResponse
     */
    public function getCheckProcessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckProcess',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckProcessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a configuration check task on cloud services.
     *  *
     * @param GetCheckProcessRequest $request GetCheckProcessRequest
     *
     * @return GetCheckProcessResponse GetCheckProcessResponse
     */
    public function getCheckProcess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckProcessWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
     *  *
     * @param GetCheckRiskStatisticsRequest $request GetCheckRiskStatisticsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckRiskStatisticsResponse GetCheckRiskStatisticsResponse
     */
    public function getCheckRiskStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckRiskStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckRiskStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
     *  *
     * @param GetCheckRiskStatisticsRequest $request GetCheckRiskStatisticsRequest
     *
     * @return GetCheckRiskStatisticsResponse GetCheckRiskStatisticsResponse
     */
    public function getCheckRiskStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckRiskStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
     *  *
     * @param GetCheckSaleRequest $request GetCheckSaleRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckSaleResponse GetCheckSaleResponse
     */
    public function getCheckSaleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckSale',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckSaleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
     *  *
     * @param GetCheckSaleRequest $request GetCheckSaleRequest
     *
     * @return GetCheckSaleResponse GetCheckSaleResponse
     */
    public function getCheckSale($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckSaleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the summary information about the configuration checks on cloud services.
     *  *
     * @param GetCheckSummaryRequest $request GetCheckSummaryRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCheckSummaryResponse GetCheckSummaryResponse
     */
    public function getCheckSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->isItemStatistic)) {
            $query['IsItemStatistic'] = $request->isItemStatistic;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCheckSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCheckSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the summary information about the configuration checks on cloud services.
     *  *
     * @param GetCheckSummaryRequest $request GetCheckSummaryRequest
     *
     * @return GetCheckSummaryResponse GetCheckSummaryResponse
     */
    public function getCheckSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCheckSummaryWithOptions($request, $runtime);
    }

    /**
     * @deprecated openAPI GetClientInstallationStatistic is deprecated, please use Sas::2018-12-03::GetClientRatioStatistic instead
     *  *
     * @summary Queries the installation rate of the client on cloud assets in the specified period of time.
     *  *
     * Deprecated
     *
     * @param GetClientInstallationStatisticRequest $request GetClientInstallationStatisticRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClientInstallationStatisticResponse GetClientInstallationStatisticResponse
     */
    public function getClientInstallationStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClientInstallationStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClientInstallationStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated openAPI GetClientInstallationStatistic is deprecated, please use Sas::2018-12-03::GetClientRatioStatistic instead
     *  *
     * @summary Queries the installation rate of the client on cloud assets in the specified period of time.
     *  *
     * Deprecated
     *
     * @param GetClientInstallationStatisticRequest $request GetClientInstallationStatisticRequest
     *
     * @return GetClientInstallationStatisticResponse GetClientInstallationStatisticResponse
     */
    public function getClientInstallationStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClientInstallationStatisticWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation rate and online rate of the agent.
     *  *
     * @param GetClientRatioStatisticRequest $request GetClientRatioStatisticRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClientRatioStatisticResponse GetClientRatioStatisticResponse
     */
    public function getClientRatioStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->statisticTypes)) {
            $query['StatisticTypes'] = $request->statisticTypes;
        }
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClientRatioStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClientRatioStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation rate and online rate of the agent.
     *  *
     * @param GetClientRatioStatisticRequest $request GetClientRatioStatisticRequest
     *
     * @return GetClientRatioStatisticResponse GetClientRatioStatisticResponse
     */
    public function getClientRatioStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClientRatioStatisticWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a custom defense rule.
     *  *
     * @param GetClientUserDefineRuleRequest $request GetClientUserDefineRuleRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClientUserDefineRuleResponse GetClientUserDefineRuleResponse
     */
    public function getClientUserDefineRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClientUserDefineRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a custom defense rule.
     *  *
     * @param GetClientUserDefineRuleRequest $request GetClientUserDefineRuleRequest
     *
     * @return GetClientUserDefineRuleResponse GetClientUserDefineRuleResponse
     */
    public function getClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the filter conditions that are used to search for cloud assets.
     *  *
     * @param GetCloudAssetCriteriaRequest $request GetCloudAssetCriteriaRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCloudAssetCriteriaResponse GetCloudAssetCriteriaResponse
     */
    public function getCloudAssetCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cloudAssetTypes)) {
            $query['CloudAssetTypes'] = $request->cloudAssetTypes;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCloudAssetCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCloudAssetCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the filter conditions that are used to search for cloud assets.
     *  *
     * @param GetCloudAssetCriteriaRequest $request GetCloudAssetCriteriaRequest
     *
     * @return GetCloudAssetCriteriaResponse GetCloudAssetCriteriaResponse
     */
    public function getCloudAssetCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCloudAssetCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the details of cloud assets.
     *  *
     * @param GetCloudAssetDetailRequest $request GetCloudAssetDetailRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCloudAssetDetailResponse GetCloudAssetDetailResponse
     */
    public function getCloudAssetDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetSubType)) {
            $query['AssetSubType'] = $request->assetSubType;
        }
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        if (!Utils::isUnset($request->cloudAssetInstances)) {
            $query['CloudAssetInstances'] = $request->cloudAssetInstances;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCloudAssetDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCloudAssetDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the details of cloud assets.
     *  *
     * @param GetCloudAssetDetailRequest $request GetCloudAssetDetailRequest
     *
     * @return GetCloudAssetDetailResponse GetCloudAssetDetailResponse
     */
    public function getCloudAssetDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCloudAssetDetailWithOptions($request, $runtime);
    }

    /**
     * @summary The total number of instances that are at risk.
     *  *
     * @param GetCloudAssetSummaryRequest $request GetCloudAssetSummaryRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCloudAssetSummaryResponse GetCloudAssetSummaryResponse
     */
    public function getCloudAssetSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCloudAssetSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCloudAssetSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The total number of instances that are at risk.
     *  *
     * @param GetCloudAssetSummaryRequest $request GetCloudAssetSummaryRequest
     *
     * @return GetCloudAssetSummaryResponse GetCloudAssetSummaryResponse
     */
    public function getCloudAssetSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCloudAssetSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics on baseline risk items of container clusters.
     *  *
     * @param GetClusterCheckItemWarningStatisticsRequest $request GetClusterCheckItemWarningStatisticsRequest
     * @param RuntimeOptions                              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClusterCheckItemWarningStatisticsResponse GetClusterCheckItemWarningStatisticsResponse
     */
    public function getClusterCheckItemWarningStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClusterCheckItemWarningStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClusterCheckItemWarningStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on baseline risk items of container clusters.
     *  *
     * @param GetClusterCheckItemWarningStatisticsRequest $request GetClusterCheckItemWarningStatisticsRequest
     *
     * @return GetClusterCheckItemWarningStatisticsResponse GetClusterCheckItemWarningStatisticsResponse
     */
    public function getClusterCheckItemWarningStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterCheckItemWarningStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the overall information about cluster defense rules that are configured for the container firewall feature.
     *  *
     * @param GetClusterRuleSummaryRequest $request GetClusterRuleSummaryRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClusterRuleSummaryResponse GetClusterRuleSummaryResponse
     */
    public function getClusterRuleSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClusterRuleSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClusterRuleSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the overall information about cluster defense rules that are configured for the container firewall feature.
     *  *
     * @param GetClusterRuleSummaryRequest $request GetClusterRuleSummaryRequest
     *
     * @return GetClusterRuleSummaryResponse GetClusterRuleSummaryResponse
     */
    public function getClusterRuleSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterRuleSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of policies in each cluster.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClusterStrategyCountResponse GetClusterStrategyCountResponse
     */
    public function getClusterStrategyCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetClusterStrategyCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClusterStrategyCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of policies in each cluster.
     *  *
     * @return GetClusterStrategyCountResponse GetClusterStrategyCountResponse
     */
    public function getClusterStrategyCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterStrategyCountWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics on alert events that are generated for containers.
     *  *
     * @param GetClusterSuspEventStatisticsRequest $request GetClusterSuspEventStatisticsRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetClusterSuspEventStatisticsResponse GetClusterSuspEventStatisticsResponse
     */
    public function getClusterSuspEventStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetClusterSuspEventStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetClusterSuspEventStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on alert events that are generated for containers.
     *  *
     * @param GetClusterSuspEventStatisticsRequest $request GetClusterSuspEventStatisticsRequest
     *
     * @return GetClusterSuspEventStatisticsResponse GetClusterSuspEventStatisticsResponse
     */
    public function getClusterSuspEventStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getClusterSuspEventStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of a common switch.
     *  *
     * @param GetCommonSwitchConfigRequest $request GetCommonSwitchConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetCommonSwitchConfigResponse GetCommonSwitchConfigResponse
     */
    public function getCommonSwitchConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetCommonSwitchConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetCommonSwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of a common switch.
     *  *
     * @param GetCommonSwitchConfigRequest $request GetCommonSwitchConfigRequest
     *
     * @return GetCommonSwitchConfigResponse GetCommonSwitchConfigResponse
     */
    public function getCommonSwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getCommonSwitchConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a rule for non-image program defense.
     *  *
     * @param GetContainerDefenseRuleDetailRequest $request GetContainerDefenseRuleDetailRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetContainerDefenseRuleDetailResponse GetContainerDefenseRuleDetailResponse
     */
    public function getContainerDefenseRuleDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetContainerDefenseRuleDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetContainerDefenseRuleDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a rule for non-image program defense.
     *  *
     * @param GetContainerDefenseRuleDetailRequest $request GetContainerDefenseRuleDetailRequest
     *
     * @return GetContainerDefenseRuleDetailResponse GetContainerDefenseRuleDetailResponse
     */
    public function getContainerDefenseRuleDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getContainerDefenseRuleDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains the usage information of the malicious file detection SDK.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileDetectApiInvokeInfoResponse GetFileDetectApiInvokeInfoResponse
     */
    public function getFileDetectApiInvokeInfoWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetFileDetectApiInvokeInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileDetectApiInvokeInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the usage information of the malicious file detection SDK.
     *  *
     * @return GetFileDetectApiInvokeInfoResponse GetFileDetectApiInvokeInfoResponse
     */
    public function getFileDetectApiInvokeInfo()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileDetectApiInvokeInfoWithOptions($runtime);
    }

    /**
     * @summary Queries the cloud sandbox check results of malicious files.
     *  *
     * @param GetFileDetectReportRequest $request GetFileDetectReportRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileDetectReportResponse GetFileDetectReportResponse
     */
    public function getFileDetectReportWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->field)) {
            $query['Field'] = $request->field;
        }
        if (!Utils::isUnset($request->fileHash)) {
            $query['FileHash'] = $request->fileHash;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceType)) {
            $query['SourceType'] = $request->sourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileDetectReport',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileDetectReportResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the cloud sandbox check results of malicious files.
     *  *
     * @param GetFileDetectReportRequest $request GetFileDetectReportRequest
     *
     * @return GetFileDetectReportResponse GetFileDetectReportResponse
     */
    public function getFileDetectReport($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileDetectReportWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains file detection results.
     *  *
     * @description The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param GetFileDetectResultRequest $request GetFileDetectResultRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileDetectResultResponse GetFileDetectResultResponse
     */
    public function getFileDetectResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->hashKeyList)) {
            $query['HashKeyList'] = $request->hashKeyList;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileDetectResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileDetectResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains file detection results.
     *  *
     * @description The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
     *  *
     * @param GetFileDetectResultRequest $request GetFileDetectResultRequest
     *
     * @return GetFileDetectResultResponse GetFileDetectResultResponse
     */
    public function getFileDetectResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileDetectResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileProtectDashboardResponse GetFileProtectDashboardResponse
     */
    public function getFileProtectDashboardWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetFileProtectDashboard',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileProtectDashboardResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
     *  *
     * @return GetFileProtectDashboardResponse GetFileProtectDashboardResponse
     */
    public function getFileProtectDashboard()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectDashboardWithOptions($runtime);
    }

    /**
     * @summary Queries information about core file monitoring events.
     *  *
     * @param GetFileProtectEventRequest $request GetFileProtectEventRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileProtectEventResponse GetFileProtectEventResponse
     */
    public function getFileProtectEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileProtectEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileProtectEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about core file monitoring events.
     *  *
     * @param GetFileProtectEventRequest $request GetFileProtectEventRequest
     *
     * @return GetFileProtectEventResponse GetFileProtectEventResponse
     */
    public function getFileProtectEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the total number of core file monitoring events by filter condition.
     *  *
     * @param GetFileProtectEventCountRequest $request GetFileProtectEventCountRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileProtectEventCountResponse GetFileProtectEventCountResponse
     */
    public function getFileProtectEventCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileProtectEventCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileProtectEventCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the total number of core file monitoring events by filter condition.
     *  *
     * @param GetFileProtectEventCountRequest $request GetFileProtectEventCountRequest
     *
     * @return GetFileProtectEventCountResponse GetFileProtectEventCountResponse
     */
    public function getFileProtectEventCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectEventCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a core file monitoring rule based on the ID of the rule.
     *  *
     * @param GetFileProtectRuleRequest $request GetFileProtectRuleRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileProtectRuleResponse GetFileProtectRuleResponse
     */
    public function getFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a core file monitoring rule based on the ID of the rule.
     *  *
     * @param GetFileProtectRuleRequest $request GetFileProtectRuleRequest
     *
     * @return GetFileProtectRuleResponse GetFileProtectRuleResponse
     */
    public function getFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileUploadLimitResponse GetFileUploadLimitResponse
     */
    public function getFileUploadLimitWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetFileUploadLimit',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileUploadLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @return GetFileUploadLimitResponse GetFileUploadLimitResponse
     */
    public function getFileUploadLimit()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileUploadLimitWithOptions($runtime);
    }

    /**
     * @summary Obtains the URL that is used to upload a file to a honeypot.
     *  *
     * @param GetHoneyPotUploadPolicyInfoRequest $request GetHoneyPotUploadPolicyInfoRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneyPotUploadPolicyInfoResponse GetHoneyPotUploadPolicyInfoResponse
     */
    public function getHoneyPotUploadPolicyInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneyPotUploadPolicyInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneyPotUploadPolicyInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the URL that is used to upload a file to a honeypot.
     *  *
     * @param GetHoneyPotUploadPolicyInfoRequest $request GetHoneyPotUploadPolicyInfoRequest
     *
     * @return GetHoneyPotUploadPolicyInfoResponse GetHoneyPotUploadPolicyInfoResponse
     */
    public function getHoneyPotUploadPolicyInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneyPotUploadPolicyInfoWithOptions($request, $runtime);
    }

    /**
     * @param GetHoneypotAttackStatisticsRequest $request GetHoneypotAttackStatisticsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotAttackStatisticsResponse GetHoneypotAttackStatisticsResponse
     */
    public function getHoneypotAttackStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTimeStamp)) {
            $query['EndTimeStamp'] = $request->endTimeStamp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevelList)) {
            $query['RiskLevelList'] = $request->riskLevelList;
        }
        if (!Utils::isUnset($request->srcIp)) {
            $query['SrcIp'] = $request->srcIp;
        }
        if (!Utils::isUnset($request->startTimeStamp)) {
            $query['StartTimeStamp'] = $request->startTimeStamp;
        }
        if (!Utils::isUnset($request->statisticsType)) {
            $query['StatisticsType'] = $request->statisticsType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotAttackStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotAttackStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetHoneypotAttackStatisticsRequest $request GetHoneypotAttackStatisticsRequest
     *
     * @return GetHoneypotAttackStatisticsResponse GetHoneypotAttackStatisticsResponse
     */
    public function getHoneypotAttackStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotAttackStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Obtain attack trend statistics for a single attack source.
     *  *
     * @param GetHoneypotEventTrendRequest $request GetHoneypotEventTrendRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotEventTrendResponse GetHoneypotEventTrendResponse
     */
    public function getHoneypotEventTrendWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTimeStamp)) {
            $query['EndTimeStamp'] = $request->endTimeStamp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->riskLevelList)) {
            $query['RiskLevelList'] = $request->riskLevelList;
        }
        if (!Utils::isUnset($request->srcIp)) {
            $query['SrcIp'] = $request->srcIp;
        }
        if (!Utils::isUnset($request->startTimeStamp)) {
            $query['StartTimeStamp'] = $request->startTimeStamp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotEventTrend',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotEventTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtain attack trend statistics for a single attack source.
     *  *
     * @param GetHoneypotEventTrendRequest $request GetHoneypotEventTrendRequest
     *
     * @return GetHoneypotEventTrendResponse GetHoneypotEventTrendResponse
     */
    public function getHoneypotEventTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotEventTrendWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a specified management node.
     *  *
     * @param GetHoneypotNodeRequest $request GetHoneypotNodeRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotNodeResponse GetHoneypotNodeResponse
     */
    public function getHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a specified management node.
     *  *
     * @param GetHoneypotNodeRequest $request GetHoneypotNodeRequest
     *
     * @return GetHoneypotNodeResponse GetHoneypotNodeResponse
     */
    public function getHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the monitoring data of management nodes to which the cloud honeypot belongs.
     *  *
     * @param GetHoneypotNodeMetricListRequest $request GetHoneypotNodeMetricListRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotNodeMetricListResponse GetHoneypotNodeMetricListResponse
     */
    public function getHoneypotNodeMetricListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->express)) {
            $query['Express'] = $request->express;
        }
        if (!Utils::isUnset($request->length)) {
            $query['Length'] = $request->length;
        }
        if (!Utils::isUnset($request->metricName)) {
            $query['MetricName'] = $request->metricName;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->period)) {
            $query['Period'] = $request->period;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotNodeMetricList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotNodeMetricListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the monitoring data of management nodes to which the cloud honeypot belongs.
     *  *
     * @param GetHoneypotNodeMetricListRequest $request GetHoneypotNodeMetricListRequest
     *
     * @return GetHoneypotNodeMetricListResponse GetHoneypotNodeMetricListResponse
     */
    public function getHoneypotNodeMetricList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotNodeMetricListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of a specified honeypot template.
     *  *
     * @param GetHoneypotPresetRequest $request GetHoneypotPresetRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotPresetResponse GetHoneypotPresetResponse
     */
    public function getHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotPresetId)) {
            $query['HoneypotPresetId'] = $request->honeypotPresetId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of a specified honeypot template.
     *  *
     * @param GetHoneypotPresetRequest $request GetHoneypotPresetRequest
     *
     * @return GetHoneypotPresetResponse GetHoneypotPresetResponse
     */
    public function getHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a specified probe.
     *  *
     * @param GetHoneypotProbeRequest $request GetHoneypotProbeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotProbeResponse GetHoneypotProbeResponse
     */
    public function getHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a specified probe.
     *  *
     * @param GetHoneypotProbeRequest $request GetHoneypotProbeRequest
     *
     * @return GetHoneypotProbeResponse GetHoneypotProbeResponse
     */
    public function getHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param GetHoneypotStatisticsRequest $request GetHoneypotStatisticsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetHoneypotStatisticsResponse GetHoneypotStatisticsResponse
     */
    public function getHoneypotStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetHoneypotStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetHoneypotStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param GetHoneypotStatisticsRequest $request GetHoneypotStatisticsRequest
     *
     * @return GetHoneypotStatisticsResponse GetHoneypotStatisticsResponse
     */
    public function getHoneypotStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHoneypotStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries alert handling rules.
     *  *
     * @param GetImageEventOperationRequest $request GetImageEventOperationRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetImageEventOperationResponse GetImageEventOperationResponse
     */
    public function getImageEventOperationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetImageEventOperation',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries alert handling rules.
     *  *
     * @param GetImageEventOperationRequest $request GetImageEventOperationRequest
     *
     * @return GetImageEventOperationResponse GetImageEventOperationResponse
     */
    public function getImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of image scans that are performed within the last several days.
     *  *
     * @param GetImageScanNumInPeriodRequest $request GetImageScanNumInPeriodRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetImageScanNumInPeriodResponse GetImageScanNumInPeriodResponse
     */
    public function getImageScanNumInPeriodWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pastDay)) {
            $query['PastDay'] = $request->pastDay;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetImageScanNumInPeriod',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetImageScanNumInPeriodResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of image scans that are performed within the last several days.
     *  *
     * @param GetImageScanNumInPeriodRequest $request GetImageScanNumInPeriodRequest
     *
     * @return GetImageScanNumInPeriodResponse GetImageScanNumInPeriodResponse
     */
    public function getImageScanNumInPeriod($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getImageScanNumInPeriodWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a microsegmentation defense rule.
     *  *
     * @param GetInterceptionRuleDetailRequest $request GetInterceptionRuleDetailRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInterceptionRuleDetailResponse GetInterceptionRuleDetailResponse
     */
    public function getInterceptionRuleDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetInterceptionRuleDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInterceptionRuleDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a microsegmentation defense rule.
     *  *
     * @param GetInterceptionRuleDetailRequest $request GetInterceptionRuleDetailRequest
     *
     * @return GetInterceptionRuleDetailResponse GetInterceptionRuleDetailResponse
     */
    public function getInterceptionRuleDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInterceptionRuleDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics of the container firewall feature.
     *  *
     * @param GetInterceptionSummaryRequest $request GetInterceptionSummaryRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInterceptionSummaryResponse GetInterceptionSummaryResponse
     */
    public function getInterceptionSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetInterceptionSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInterceptionSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics of the container firewall feature.
     *  *
     * @param GetInterceptionSummaryRequest $request GetInterceptionSummaryRequest
     *
     * @return GetInterceptionSummaryResponse GetInterceptionSummaryResponse
     */
    public function getInterceptionSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInterceptionSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a specified network object that is protected by the container firewall feature.
     *  *
     * @param GetInterceptionTargetDetailRequest $request GetInterceptionTargetDetailRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInterceptionTargetDetailResponse GetInterceptionTargetDetailResponse
     */
    public function getInterceptionTargetDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->targetId)) {
            $query['TargetId'] = $request->targetId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetInterceptionTargetDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInterceptionTargetDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a specified network object that is protected by the container firewall feature.
     *  *
     * @param GetInterceptionTargetDetailRequest $request GetInterceptionTargetDetailRequest
     *
     * @return GetInterceptionTargetDetailResponse GetInterceptionTargetDetailResponse
     */
    public function getInterceptionTargetDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInterceptionTargetDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the latest scan task to determine whether the task is complete.
     *  *
     * @param GetLastOnceTaskInfoRequest $request GetLastOnceTaskInfoRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetLastOnceTaskInfoResponse GetLastOnceTaskInfoResponse
     */
    public function getLastOnceTaskInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetLastOnceTaskInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetLastOnceTaskInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the latest scan task to determine whether the task is complete.
     *  *
     * @param GetLastOnceTaskInfoRequest $request GetLastOnceTaskInfoRequest
     *
     * @return GetLastOnceTaskInfoResponse GetLastOnceTaskInfoResponse
     */
    public function getLastOnceTaskInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getLastOnceTaskInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of a data shipping task of a log.
     *  *
     * @param GetLogMetaRequest $request GetLogMetaRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetLogMetaResponse GetLogMetaResponse
     */
    public function getLogMetaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->logStore)) {
            $query['LogStore'] = $request->logStore;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetLogMeta',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetLogMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of a data shipping task of a log.
     *  *
     * @param GetLogMetaRequest $request GetLogMetaRequest
     *
     * @return GetLogMetaResponse GetLogMetaResponse
     */
    public function getLogMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getLogMetaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param GetMaliciousFileWhitelistConfigRequest $request GetMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMaliciousFileWhitelistConfigResponse GetMaliciousFileWhitelistConfigResponse
     */
    public function getMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param GetMaliciousFileWhitelistConfigRequest $request GetMaliciousFileWhitelistConfigRequest
     *
     * @return GetMaliciousFileWhitelistConfigResponse GetMaliciousFileWhitelistConfigResponse
     */
    public function getMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of a module.
     *  *
     * @param GetModuleConfigRequest $request GetModuleConfigRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetModuleConfigResponse GetModuleConfigResponse
     */
    public function getModuleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetModuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetModuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of a module.
     *  *
     * @param GetModuleConfigRequest $request GetModuleConfigRequest
     *
     * @return GetModuleConfigResponse GetModuleConfigResponse
     */
    public function getModuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getModuleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis.
     *  *
     * @param GetModuleTrialAuthInfoRequest $request GetModuleTrialAuthInfoRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetModuleTrialAuthInfoResponse GetModuleTrialAuthInfoResponse
     */
    public function getModuleTrialAuthInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->moduleCode)) {
            $query['ModuleCode'] = $request->moduleCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetModuleTrialAuthInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetModuleTrialAuthInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis.
     *  *
     * @param GetModuleTrialAuthInfoRequest $request GetModuleTrialAuthInfoRequest
     *
     * @return GetModuleTrialAuthInfoResponse GetModuleTrialAuthInfoResponse
     */
    public function getModuleTrialAuthInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getModuleTrialAuthInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an alert event that is generated for a malicious object.
     *  *
     * @param GetObjectScanEventRequest $request GetObjectScanEventRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetObjectScanEventResponse GetObjectScanEventResponse
     */
    public function getObjectScanEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetObjectScanEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetObjectScanEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an alert event that is generated for a malicious object.
     *  *
     * @param GetObjectScanEventRequest $request GetObjectScanEventRequest
     *
     * @return GetObjectScanEventResponse GetObjectScanEventResponse
     */
    public function getObjectScanEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getObjectScanEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
     *  *
     * @param GetOnceTaskResultInfoRequest $request GetOnceTaskResultInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOnceTaskResultInfoResponse GetOnceTaskResultInfoResponse
     */
    public function getOnceTaskResultInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOnceTaskResultInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOnceTaskResultInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
     *  *
     * @param GetOnceTaskResultInfoRequest $request GetOnceTaskResultInfoRequest
     *
     * @return GetOnceTaskResultInfoResponse GetOnceTaskResultInfoResponse
     */
    public function getOnceTaskResultInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOnceTaskResultInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the baselines that are supported by at-risk image blocking.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaClusterBaseLineListResponse GetOpaClusterBaseLineListResponse
     */
    public function getOpaClusterBaseLineListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetOpaClusterBaseLineList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaClusterBaseLineListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the baselines that are supported by at-risk image blocking.
     *  *
     * @return GetOpaClusterBaseLineListResponse GetOpaClusterBaseLineListResponse
     */
    public function getOpaClusterBaseLineList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterBaseLineListWithOptions($runtime);
    }

    /**
     * @summary 
     *  *
     * @param GetOpaClusterImageListRequest $request GetOpaClusterImageListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaClusterImageListResponse GetOpaClusterImageListResponse
     */
    public function getOpaClusterImageListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaClusterImageList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaClusterImageListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param GetOpaClusterImageListRequest $request GetOpaClusterImageListRequest
     *
     * @return GetOpaClusterImageListResponse GetOpaClusterImageListResponse
     */
    public function getOpaClusterImageList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterImageListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
     *  *
     * @param GetOpaClusterLabelListRequest $request GetOpaClusterLabelListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaClusterLabelListResponse GetOpaClusterLabelListResponse
     */
    public function getOpaClusterLabelListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->tagName)) {
            $query['TagName'] = $request->tagName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaClusterLabelList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaClusterLabelListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
     *  *
     * @param GetOpaClusterLabelListRequest $request GetOpaClusterLabelListRequest
     *
     * @return GetOpaClusterLabelListResponse GetOpaClusterLabelListResponse
     */
    public function getOpaClusterLabelList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterLabelListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
     *  *
     * @param GetOpaClusterNamespaceListRequest $request GetOpaClusterNamespaceListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaClusterNamespaceListResponse GetOpaClusterNamespaceListResponse
     */
    public function getOpaClusterNamespaceListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->nameSpaceName)) {
            $query['NameSpaceName'] = $request->nameSpaceName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaClusterNamespaceList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaClusterNamespaceListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
     *  *
     * @param GetOpaClusterNamespaceListRequest $request GetOpaClusterNamespaceListRequest
     *
     * @return GetOpaClusterNamespaceListResponse GetOpaClusterNamespaceListResponse
     */
    public function getOpaClusterNamespaceList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaClusterNamespaceListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
     *  *
     * @param GetOpaPluginStatusRequest $request GetOpaPluginStatusRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaPluginStatusResponse GetOpaPluginStatusResponse
     */
    public function getOpaPluginStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaPluginStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaPluginStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
     *  *
     * @param GetOpaPluginStatusRequest $request GetOpaPluginStatusRequest
     *
     * @return GetOpaPluginStatusResponse GetOpaPluginStatusResponse
     */
    public function getOpaPluginStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaPluginStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of the rule that is used to block at-risk images.
     *  *
     * @param GetOpaStrategyDetailNewRequest $request GetOpaStrategyDetailNewRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaStrategyDetailNewResponse GetOpaStrategyDetailNewResponse
     */
    public function getOpaStrategyDetailNewWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpaStrategyDetailNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaStrategyDetailNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of the rule that is used to block at-risk images.
     *  *
     * @param GetOpaStrategyDetailNewRequest $request GetOpaStrategyDetailNewRequest
     *
     * @return GetOpaStrategyDetailNewResponse GetOpaStrategyDetailNewResponse
     */
    public function getOpaStrategyDetailNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaStrategyDetailNewWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpaStrategyTemplateSummaryResponse GetOpaStrategyTemplateSummaryResponse
     */
    public function getOpaStrategyTemplateSummaryWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetOpaStrategyTemplateSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpaStrategyTemplateSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
     *  *
     * @return GetOpaStrategyTemplateSummaryResponse GetOpaStrategyTemplateSummaryResponse
     */
    public function getOpaStrategyTemplateSummary()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpaStrategyTemplateSummaryWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics about an Object Storage Service (OSS) bucket check.
     *  *
     * @param GetOssBucketScanStatisticRequest $request GetOssBucketScanStatisticRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOssBucketScanStatisticResponse GetOssBucketScanStatisticResponse
     */
    public function getOssBucketScanStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketNameList)) {
            $query['BucketNameList'] = $request->bucketNameList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOssBucketScanStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOssBucketScanStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics about an Object Storage Service (OSS) bucket check.
     *  *
     * @param GetOssBucketScanStatisticRequest $request GetOssBucketScanStatisticRequest
     *
     * @return GetOssBucketScanStatisticResponse GetOssBucketScanStatisticResponse
     */
    public function getOssBucketScanStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOssBucketScanStatisticWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of an Object Storage Service (OSS) bucket check policy.
     *  *
     * @param GetOssScanConfigRequest $request GetOssScanConfigRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOssScanConfigResponse GetOssScanConfigResponse
     */
    public function getOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of an Object Storage Service (OSS) bucket check policy.
     *  *
     * @param GetOssScanConfigRequest $request GetOssScanConfigRequest
     *
     * @return GetOssScanConfigResponse GetOssScanConfigResponse
     */
    public function getOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations for the collection frequency of asset fingerprints.
     *  *
     * @param GetPropertyScheduleConfigRequest $request GetPropertyScheduleConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetPropertyScheduleConfigResponse GetPropertyScheduleConfigResponse
     */
    public function getPropertyScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetPropertyScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetPropertyScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations for the collection frequency of asset fingerprints.
     *  *
     * @param GetPropertyScheduleConfigRequest $request GetPropertyScheduleConfigRequest
     *
     * @return GetPropertyScheduleConfigResponse GetPropertyScheduleConfigResponse
     */
    public function getPropertyScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPropertyScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the numbers of system defense rules and custom defense rules.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetRulesCountResponse GetRulesCountResponse
     */
    public function getRulesCountWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetRulesCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetRulesCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the numbers of system defense rules and custom defense rules.
     *  *
     * @return GetRulesCountResponse GetRulesCountResponse
     */
    public function getRulesCount()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRulesCountWithOptions($runtime);
    }

    /**
     * @summary Queries the applications that are specified in a rule for container tamper-proofing.
     *  *
     * @param GetSasContainerWebDefenseRuleApplicationRequest $request GetSasContainerWebDefenseRuleApplicationRequest
     * @param RuntimeOptions                                  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSasContainerWebDefenseRuleApplicationResponse GetSasContainerWebDefenseRuleApplicationResponse
     */
    public function getSasContainerWebDefenseRuleApplicationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSasContainerWebDefenseRuleApplication',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSasContainerWebDefenseRuleApplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the applications that are specified in a rule for container tamper-proofing.
     *  *
     * @param GetSasContainerWebDefenseRuleApplicationRequest $request GetSasContainerWebDefenseRuleApplicationRequest
     *
     * @return GetSasContainerWebDefenseRuleApplicationResponse GetSasContainerWebDefenseRuleApplicationResponse
     */
    public function getSasContainerWebDefenseRuleApplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSasContainerWebDefenseRuleApplicationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries search conditions that can be used to search for container file protection rules.
     *  *
     * @param GetSasContainerWebDefenseRuleCriteriaRequest $request GetSasContainerWebDefenseRuleCriteriaRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSasContainerWebDefenseRuleCriteriaResponse GetSasContainerWebDefenseRuleCriteriaResponse
     */
    public function getSasContainerWebDefenseRuleCriteriaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSasContainerWebDefenseRuleCriteria',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSasContainerWebDefenseRuleCriteriaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries search conditions that can be used to search for container file protection rules.
     *  *
     * @param GetSasContainerWebDefenseRuleCriteriaRequest $request GetSasContainerWebDefenseRuleCriteriaRequest
     *
     * @return GetSasContainerWebDefenseRuleCriteriaResponse GetSasContainerWebDefenseRuleCriteriaResponse
     */
    public function getSasContainerWebDefenseRuleCriteria($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSasContainerWebDefenseRuleCriteriaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of the deduction modules of the security score feature, including custom settings.
     *  *
     * @param GetSecurityScoreRuleRequest $request GetSecurityScoreRuleRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSecurityScoreRuleResponse GetSecurityScoreRuleResponse
     */
    public function getSecurityScoreRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSecurityScoreRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSecurityScoreRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of the deduction modules of the security score feature, including custom settings.
     *  *
     * @param GetSecurityScoreRuleRequest $request GetSecurityScoreRuleRequest
     *
     * @return GetSecurityScoreRuleResponse GetSecurityScoreRuleResponse
     */
    public function getSecurityScoreRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSecurityScoreRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the check rules of sensitive files.
     *  *
     * @param GetSensitiveDefineRuleConfigRequest $request GetSensitiveDefineRuleConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSensitiveDefineRuleConfigResponse GetSensitiveDefineRuleConfigResponse
     */
    public function getSensitiveDefineRuleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSensitiveDefineRuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSensitiveDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the check rules of sensitive files.
     *  *
     * @param GetSensitiveDefineRuleConfigRequest $request GetSensitiveDefineRuleConfigRequest
     *
     * @return GetSensitiveDefineRuleConfigResponse GetSensitiveDefineRuleConfigResponse
     */
    public function getSensitiveDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSensitiveDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the service trail that was delivered to ActionTrail.
     *  *
     * @param GetServiceTrailRequest $request GetServiceTrailRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetServiceTrailResponse GetServiceTrailResponse
     */
    public function getServiceTrailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetServiceTrail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetServiceTrailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the service trail that was delivered to ActionTrail.
     *  *
     * @param GetServiceTrailRequest $request GetServiceTrailRequest
     *
     * @return GetServiceTrailResponse GetServiceTrailResponse
     */
    public function getServiceTrail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getServiceTrailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
     *  *
     * @param GetStrategyTemplateDetailRequest $request GetStrategyTemplateDetailRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetStrategyTemplateDetailResponse GetStrategyTemplateDetailResponse
     */
    public function getStrategyTemplateDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetStrategyTemplateDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetStrategyTemplateDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
     *  *
     * @param GetStrategyTemplateDetailRequest $request GetStrategyTemplateDetailRequest
     *
     * @return GetStrategyTemplateDetailResponse GetStrategyTemplateDetailResponse
     */
    public function getStrategyTemplateDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getStrategyTemplateDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics on alerts in one or more asset groups.
     *  *
     * @param GetSuspiciousStatisticsRequest $request GetSuspiciousStatisticsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSuspiciousStatisticsResponse GetSuspiciousStatisticsResponse
     */
    public function getSuspiciousStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupIdList)) {
            $query['GroupIdList'] = $request->groupIdList;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSuspiciousStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSuspiciousStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on alerts in one or more asset groups.
     *  *
     * @param GetSuspiciousStatisticsRequest $request GetSuspiciousStatisticsRequest
     *
     * @return GetSuspiciousStatisticsResponse GetSuspiciousStatisticsResponse
     */
    public function getSuspiciousStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSuspiciousStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status and progress of the task that is run to migrate a server from a region inside the Chinese mainland to the Singapore region.
     *  *
     * @param GetSwitchRegionDetailRequest $request GetSwitchRegionDetailRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSwitchRegionDetailResponse GetSwitchRegionDetailResponse
     */
    public function getSwitchRegionDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSwitchRegionDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSwitchRegionDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status and progress of the task that is run to migrate a server from a region inside the Chinese mainland to the Singapore region.
     *  *
     * @param GetSwitchRegionDetailRequest $request GetSwitchRegionDetailRequest
     *
     * @return GetSwitchRegionDetailResponse GetSwitchRegionDetailResponse
     */
    public function getSwitchRegionDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSwitchRegionDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the language settings of log analysis.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetUserLangResponse GetUserLangResponse
     */
    public function getUserLangWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetUserLang',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetUserLangResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the language settings of log analysis.
     *  *
     * @return GetUserLangResponse GetUserLangResponse
     */
    public function getUserLang()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getUserLangWithOptions($runtime);
    }

    /**
     * @summary Queries the configurations of a periodic virus scan task.
     *  *
     * @param GetVirusScanConfigRequest $request GetVirusScanConfigRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVirusScanConfigResponse GetVirusScanConfigResponse
     */
    public function getVirusScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVirusScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVirusScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of a periodic virus scan task.
     *  *
     * @param GetVirusScanConfigRequest $request GetVirusScanConfigRequest
     *
     * @return GetVirusScanConfigResponse GetVirusScanConfigResponse
     */
    public function getVirusScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVirusScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the latest virus scan task.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVirusScanLatestTaskStatisticResponse GetVirusScanLatestTaskStatisticResponse
     */
    public function getVirusScanLatestTaskStatisticWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'GetVirusScanLatestTaskStatistic',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVirusScanLatestTaskStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the latest virus scan task.
     *  *
     * @return GetVirusScanLatestTaskStatisticResponse GetVirusScanLatestTaskStatisticResponse
     */
    public function getVirusScanLatestTaskStatistic()
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVirusScanLatestTaskStatisticWithOptions($runtime);
    }

    /**
     * @summary Queries the statistics on vulnerabilities in asset groups.
     *  *
     * @param GetVulStatisticsRequest $request GetVulStatisticsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVulStatisticsResponse GetVulStatisticsResponse
     */
    public function getVulStatisticsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupIdList)) {
            $query['GroupIdList'] = $request->groupIdList;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->typeList)) {
            $query['TypeList'] = $request->typeList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVulStatistics',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVulStatisticsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics on vulnerabilities in asset groups.
     *  *
     * @param GetVulStatisticsRequest $request GetVulStatisticsRequest
     *
     * @return GetVulStatisticsResponse GetVulStatisticsResponse
     */
    public function getVulStatistics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVulStatisticsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about a vulnerability whitelist.
     *  *
     * @param GetVulWhitelistRequest $request GetVulWhitelistRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetVulWhitelistResponse GetVulWhitelistResponse
     */
    public function getVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->vulWhitelistId)) {
            $query['VulWhitelistId'] = $request->vulWhitelistId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about a vulnerability whitelist.
     *  *
     * @param GetVulWhitelistRequest $request GetVulWhitelistRequest
     *
     * @return GetVulWhitelistResponse GetVulWhitelistResponse
     */
    public function getVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Handles alert events.
     *  *
     * @param HandleSecurityEventsRequest $request HandleSecurityEventsRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return HandleSecurityEventsResponse HandleSecurityEventsResponse
     */
    public function handleSecurityEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->markBatch)) {
            $query['MarkBatch'] = $request->markBatch;
        }
        if (!Utils::isUnset($request->markMissParam)) {
            $query['MarkMissParam'] = $request->markMissParam;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->operationParams)) {
            $query['OperationParams'] = $request->operationParams;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->securityEventIds)) {
            $query['SecurityEventIds'] = $request->securityEventIds;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'HandleSecurityEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return HandleSecurityEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles alert events.
     *  *
     * @param HandleSecurityEventsRequest $request HandleSecurityEventsRequest
     *
     * @return HandleSecurityEventsResponse HandleSecurityEventsResponse
     */
    public function handleSecurityEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->handleSecurityEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
     *  *
     * @param HandleSimilarSecurityEventsRequest $request HandleSimilarSecurityEventsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return HandleSimilarSecurityEventsResponse HandleSimilarSecurityEventsResponse
     */
    public function handleSimilarSecurityEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->markMissParam)) {
            $query['MarkMissParam'] = $request->markMissParam;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->operationParams)) {
            $query['OperationParams'] = $request->operationParams;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'HandleSimilarSecurityEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return HandleSimilarSecurityEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
     *  *
     * @param HandleSimilarSecurityEventsRequest $request HandleSimilarSecurityEventsRequest
     *
     * @return HandleSimilarSecurityEventsResponse HandleSimilarSecurityEventsResponse
     */
    public function handleSimilarSecurityEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->handleSimilarSecurityEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
     *  *
     * @param IgnoreCheckItemsRequest $request IgnoreCheckItemsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return IgnoreCheckItemsResponse IgnoreCheckItemsResponse
     */
    public function ignoreCheckItemsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkAndRiskTypeList)) {
            $query['CheckAndRiskTypeList'] = $request->checkAndRiskTypeList;
        }
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'IgnoreCheckItems',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return IgnoreCheckItemsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
     *  *
     * @param IgnoreCheckItemsRequest $request IgnoreCheckItemsRequest
     *
     * @return IgnoreCheckItemsResponse IgnoreCheckItemsResponse
     */
    public function ignoreCheckItems($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->ignoreCheckItemsWithOptions($request, $runtime);
    }

    /**
     * @summary Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
     *  *
     * @param IgnoreHcCheckWarningsRequest $request IgnoreHcCheckWarningsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return IgnoreHcCheckWarningsResponse IgnoreHcCheckWarningsResponse
     */
    public function ignoreHcCheckWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->checkWarningIds)) {
            $query['CheckWarningIds'] = $request->checkWarningIds;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'IgnoreHcCheckWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return IgnoreHcCheckWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
     *  *
     * @param IgnoreHcCheckWarningsRequest $request IgnoreHcCheckWarningsRequest
     *
     * @return IgnoreHcCheckWarningsResponse IgnoreHcCheckWarningsResponse
     */
    public function ignoreHcCheckWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->ignoreHcCheckWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary The UUID of the server on which you want to install the anti-ransomware agent. You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
     * >  You must specify at least one of the UuidList and Uuid parameters.
     *  *
     * @param InstallBackupClientRequest $request InstallBackupClientRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallBackupClientResponse InstallBackupClientResponse
     */
    public function installBackupClientWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallBackupClient',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallBackupClientResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The UUID of the server on which you want to install the anti-ransomware agent. You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.
     * >  You must specify at least one of the UuidList and Uuid parameters.
     *  *
     * @param InstallBackupClientRequest $request InstallBackupClientRequest
     *
     * @return InstallBackupClientResponse InstallBackupClientResponse
     */
    public function installBackupClient($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installBackupClientWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the CloudMonitor agent on specified servers.
     *  *
     * @description > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
     *  *
     * @param InstallCloudMonitorRequest $request InstallCloudMonitorRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallCloudMonitorResponse InstallCloudMonitorResponse
     */
    public function installCloudMonitorWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->agentAccessKey)) {
            $query['AgentAccessKey'] = $request->agentAccessKey;
        }
        if (!Utils::isUnset($request->agentSecretKey)) {
            $query['AgentSecretKey'] = $request->agentSecretKey;
        }
        if (!Utils::isUnset($request->argusVersion)) {
            $query['ArgusVersion'] = $request->argusVersion;
        }
        if (!Utils::isUnset($request->instanceIdList)) {
            $query['InstanceIdList'] = $request->instanceIdList;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallCloudMonitor',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallCloudMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the CloudMonitor agent on specified servers.
     *  *
     * @description > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
     *  *
     * @param InstallCloudMonitorRequest $request InstallCloudMonitorRequest
     *
     * @return InstallCloudMonitorResponse InstallCloudMonitorResponse
     */
    public function installCloudMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installCloudMonitorWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the Security Center agent on a proxy server in a hybrid cloud.
     *  *
     * @param InstallHybridProxyRequest $request InstallHybridProxyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallHybridProxyResponse InstallHybridProxyResponse
     */
    public function installHybridProxyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->installCode)) {
            $query['InstallCode'] = $request->installCode;
        }
        if (!Utils::isUnset($request->yundunUuids)) {
            $query['YundunUuids'] = $request->yundunUuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallHybridProxy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallHybridProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the Security Center agent on a proxy server in a hybrid cloud.
     *  *
     * @param InstallHybridProxyRequest $request InstallHybridProxyRequest
     *
     * @return InstallHybridProxyResponse InstallHybridProxyResponse
     */
    public function installHybridProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installHybridProxyWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
     *  *
     * @param InstallPmAgentRequest $request InstallPmAgentRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallPmAgentResponse InstallPmAgentResponse
     */
    public function installPmAgentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallPmAgent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallPmAgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
     *  *
     * @param InstallPmAgentRequest $request InstallPmAgentRequest
     *
     * @return InstallPmAgentResponse InstallPmAgentResponse
     */
    public function installPmAgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installPmAgentWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the Runtime Application Self-Protection (RASP) agent on Elastic Compute Service (ECS) instances to enable automatic application protection.
     *  *
     * @param InstallRaspAttachRequest $request InstallRaspAttachRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallRaspAttachResponse InstallRaspAttachResponse
     */
    public function installRaspAttachWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->applicationId)) {
            $query['ApplicationId'] = $request->applicationId;
        }
        if (!Utils::isUnset($request->ecsUUIDList)) {
            $query['EcsUUIDList'] = $request->ecsUUIDList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallRaspAttach',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallRaspAttachResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the Runtime Application Self-Protection (RASP) agent on Elastic Compute Service (ECS) instances to enable automatic application protection.
     *  *
     * @param InstallRaspAttachRequest $request InstallRaspAttachRequest
     *
     * @return InstallRaspAttachResponse InstallRaspAttachResponse
     */
    public function installRaspAttach($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installRaspAttachWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the anti-ransomware agent for databases.
     *  *
     * @param InstallUniBackupAgentRequest $request InstallUniBackupAgentRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return InstallUniBackupAgentResponse InstallUniBackupAgentResponse
     */
    public function installUniBackupAgentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'InstallUniBackupAgent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return InstallUniBackupAgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the anti-ransomware agent for databases.
     *  *
     * @param InstallUniBackupAgentRequest $request InstallUniBackupAgentRequest
     *
     * @return InstallUniBackupAgentResponse InstallUniBackupAgentResponse
     */
    public function installUniBackupAgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->installUniBackupAgentWithOptions($request, $runtime);
    }

    /**
     * @summary Adds processes to the process whitelist of web tamper proofing.
     *  *
     * @param JoinWebLockProcessWhiteListRequest $request JoinWebLockProcessWhiteListRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return JoinWebLockProcessWhiteListResponse JoinWebLockProcessWhiteListResponse
     */
    public function joinWebLockProcessWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->processPaths)) {
            $query['ProcessPaths'] = $request->processPaths;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'JoinWebLockProcessWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return JoinWebLockProcessWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds processes to the process whitelist of web tamper proofing.
     *  *
     * @param JoinWebLockProcessWhiteListRequest $request JoinWebLockProcessWhiteListRequest
     *
     * @return JoinWebLockProcessWhiteListResponse JoinWebLockProcessWhiteListResponse
     */
    public function joinWebLockProcessWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->joinWebLockProcessWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries defense rules against container escapes.
     *  *
     * @param ListAegisContainerPluginRuleRequest $request ListAegisContainerPluginRuleRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAegisContainerPluginRuleResponse ListAegisContainerPluginRuleResponse
     */
    public function listAegisContainerPluginRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAegisContainerPluginRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAegisContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries defense rules against container escapes.
     *  *
     * @param ListAegisContainerPluginRuleRequest $request ListAegisContainerPluginRuleRequest
     *
     * @return ListAegisContainerPluginRuleResponse ListAegisContainerPluginRuleResponse
     */
    public function listAegisContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAegisContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries malicious files that are detected by agentless detection tasks.
     *  *
     * @param ListAgentlessMaliciousFilesRequest $request ListAgentlessMaliciousFilesRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessMaliciousFilesResponse ListAgentlessMaliciousFilesResponse
     */
    public function listAgentlessMaliciousFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->dealed)) {
            $query['Dealed'] = $request->dealed;
        }
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->fuzzyMaliciousName)) {
            $query['FuzzyMaliciousName'] = $request->fuzzyMaliciousName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->levels)) {
            $query['Levels'] = $request->levels;
        }
        if (!Utils::isUnset($request->maliciousMd5)) {
            $query['MaliciousMd5'] = $request->maliciousMd5;
        }
        if (!Utils::isUnset($request->maliciousType)) {
            $query['MaliciousType'] = $request->maliciousType;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAgentlessMaliciousFiles',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessMaliciousFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries malicious files that are detected by agentless detection tasks.
     *  *
     * @param ListAgentlessMaliciousFilesRequest $request ListAgentlessMaliciousFilesRequest
     *
     * @return ListAgentlessMaliciousFilesResponse ListAgentlessMaliciousFilesResponse
     */
    public function listAgentlessMaliciousFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessMaliciousFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the regions that are supported by the agentless detection feature.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessRegionResponse ListAgentlessRegionResponse
     */
    public function listAgentlessRegionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListAgentlessRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the regions that are supported by the agentless detection feature.
     *  *
     * @return ListAgentlessRegionResponse ListAgentlessRegionResponse
     */
    public function listAgentlessRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessRegionWithOptions($runtime);
    }

    /**
     * @summary Obtains the risks associated with an agentless detection event.
     *  *
     * @param ListAgentlessRelateMaliciousRequest $request ListAgentlessRelateMaliciousRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessRelateMaliciousResponse ListAgentlessRelateMaliciousResponse
     */
    public function listAgentlessRelateMaliciousWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventId)) {
            $query['EventId'] = $request->eventId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAgentlessRelateMalicious',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessRelateMaliciousResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains the risks associated with an agentless detection event.
     *  *
     * @param ListAgentlessRelateMaliciousRequest $request ListAgentlessRelateMaliciousRequest
     *
     * @return ListAgentlessRelateMaliciousResponse ListAgentlessRelateMaliciousResponse
     */
    public function listAgentlessRelateMalicious($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessRelateMaliciousWithOptions($request, $runtime);
    }

    /**
     * @summary Queries at-risk hosts that are detected by the agentless detection feature.
     *  *
     * @param ListAgentlessRiskUuidRequest $request ListAgentlessRiskUuidRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessRiskUuidResponse ListAgentlessRiskUuidResponse
     */
    public function listAgentlessRiskUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->internetIp)) {
            $query['InternetIp'] = $request->internetIp;
        }
        if (!Utils::isUnset($request->intranetIp)) {
            $query['IntranetIp'] = $request->intranetIp;
        }
        if (!Utils::isUnset($request->machineName)) {
            $query['MachineName'] = $request->machineName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->risk)) {
            $query['Risk'] = $request->risk;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAgentlessRiskUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessRiskUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries at-risk hosts that are detected by the agentless detection feature.
     *  *
     * @param ListAgentlessRiskUuidRequest $request ListAgentlessRiskUuidRequest
     *
     * @return ListAgentlessRiskUuidResponse ListAgentlessRiskUuidResponse
     */
    public function listAgentlessRiskUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessRiskUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries agentless detection tasks.
     *  *
     * @param ListAgentlessTaskRequest $request ListAgentlessTaskRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAgentlessTaskResponse ListAgentlessTaskResponse
     */
    public function listAgentlessTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->internetIp)) {
            $query['InternetIp'] = $request->internetIp;
        }
        if (!Utils::isUnset($request->intranetIp)) {
            $query['IntranetIp'] = $request->intranetIp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->machineName)) {
            $query['MachineName'] = $request->machineName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->rootTask)) {
            $query['RootTask'] = $request->rootTask;
        }
        if (!Utils::isUnset($request->rootTaskId)) {
            $query['RootTaskId'] = $request->rootTaskId;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAgentlessTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAgentlessTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries agentless detection tasks.
     *  *
     * @param ListAgentlessTaskRequest $request ListAgentlessTaskRequest
     *
     * @return ListAgentlessTaskResponse ListAgentlessTaskResponse
     */
    public function listAgentlessTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAgentlessTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations for cleaning offline hosts whose provider cannot be identified.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAssetCleanConfigResponse ListAssetCleanConfigResponse
     */
    public function listAssetCleanConfigWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListAssetCleanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAssetCleanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations for cleaning offline hosts whose provider cannot be identified.
     *  *
     * @return ListAssetCleanConfigResponse ListAssetCleanConfigResponse
     */
    public function listAssetCleanConfig()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetCleanConfigWithOptions($runtime);
    }

    /**
     * @summary Queries the configurations of asset synchronization.
     *  *
     * @param ListAssetRefreshTaskConfigRequest $request ListAssetRefreshTaskConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAssetRefreshTaskConfigResponse ListAssetRefreshTaskConfigResponse
     */
    public function listAssetRefreshTaskConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->refreshConfigType)) {
            $query['RefreshConfigType'] = $request->refreshConfigType;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->targetId)) {
            $query['TargetId'] = $request->targetId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAssetRefreshTaskConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAssetRefreshTaskConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of asset synchronization.
     *  *
     * @param ListAssetRefreshTaskConfigRequest $request ListAssetRefreshTaskConfigRequest
     *
     * @return ListAssetRefreshTaskConfigResponse ListAssetRefreshTaskConfigResponse
     */
    public function listAssetRefreshTaskConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetRefreshTaskConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the selected assets.
     *  *
     * @param ListAssetSelectionSelectedTargetRequest $request ListAssetSelectionSelectedTargetRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAssetSelectionSelectedTargetResponse ListAssetSelectionSelectedTargetResponse
     */
    public function listAssetSelectionSelectedTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        if (!Utils::isUnset($request->targetList)) {
            $query['TargetList'] = $request->targetList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAssetSelectionSelectedTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAssetSelectionSelectedTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the selected assets.
     *  *
     * @param ListAssetSelectionSelectedTargetRequest $request ListAssetSelectionSelectedTargetRequest
     *
     * @return ListAssetSelectionSelectedTargetResponse ListAssetSelectionSelectedTargetResponse
     */
    public function listAssetSelectionSelectedTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetSelectionSelectedTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the required asset.
     *  *
     * @param ListAssetSelectionTargetRequest $request ListAssetSelectionTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAssetSelectionTargetResponse ListAssetSelectionTargetResponse
     */
    public function listAssetSelectionTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAssetSelectionTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAssetSelectionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the required asset.
     *  *
     * @param ListAssetSelectionTargetRequest $request ListAssetSelectionTargetRequest
     *
     * @return ListAssetSelectionTargetResponse ListAssetSelectionTargetResponse
     */
    public function listAssetSelectionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAssetSelectionTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about available honeypot templates.
     *  *
     * @param ListAvailableHoneypotRequest $request ListAvailableHoneypotRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAvailableHoneypotResponse ListAvailableHoneypotResponse
     */
    public function listAvailableHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListAvailableHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAvailableHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about available honeypot templates.
     *  *
     * @param ListAvailableHoneypotRequest $request ListAvailableHoneypotRequest
     *
     * @return ListAvailableHoneypotResponse ListAvailableHoneypotResponse
     */
    public function listAvailableHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAvailableHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Queries backup records.
     *  *
     * @param ListBackupRecordRequest $request ListBackupRecordRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBackupRecordResponse ListBackupRecordResponse
     */
    public function listBackupRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->backupEndTime)) {
            $query['BackupEndTime'] = $request->backupEndTime;
        }
        if (!Utils::isUnset($request->backupStartTime)) {
            $query['BackupStartTime'] = $request->backupStartTime;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->machineRemark)) {
            $query['MachineRemark'] = $request->machineRemark;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListBackupRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBackupRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries backup records.
     *  *
     * @param ListBackupRecordRequest $request ListBackupRecordRequest
     *
     * @return ListBackupRecordResponse ListBackupRecordResponse
     */
    public function listBackupRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBackupRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the instances that failed a specified check item of configuration assessment.
     *  *
     * @param ListCheckInstanceResultRequest $request ListCheckInstanceResultRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckInstanceResultResponse ListCheckInstanceResultResponse
     */
    public function listCheckInstanceResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->instanceIdKey)) {
            $query['InstanceIdKey'] = $request->instanceIdKey;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->instanceNameKey)) {
            $query['InstanceNameKey'] = $request->instanceNameKey;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionIdKey)) {
            $query['RegionIdKey'] = $request->regionIdKey;
        }
        if (!Utils::isUnset($request->sortTypes)) {
            $query['SortTypes'] = $request->sortTypes;
        }
        if (!Utils::isUnset($request->statuses)) {
            $query['Statuses'] = $request->statuses;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckInstanceResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckInstanceResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the instances that failed a specified check item of configuration assessment.
     *  *
     * @param ListCheckInstanceResultRequest $request ListCheckInstanceResultRequest
     *
     * @return ListCheckInstanceResultResponse ListCheckInstanceResultResponse
     */
    public function listCheckInstanceResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckInstanceResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the check items that can be customized.
     *  *
     * @param ListCheckItemRequest $request ListCheckItemRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckItemResponse ListCheckItemResponse
     */
    public function listCheckItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the check items that can be customized.
     *  *
     * @param ListCheckItemRequest $request ListCheckItemRequest
     *
     * @return ListCheckItemResponse ListCheckItemResponse
     */
    public function listCheckItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the servers that are affected by baseline risks.
     *  *
     * @param ListCheckItemWarningMachineRequest $request ListCheckItemWarningMachineRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckItemWarningMachineResponse ListCheckItemWarningMachineResponse
     */
    public function listCheckItemWarningMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->riskType)) {
            $query['RiskType'] = $request->riskType;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckItemWarningMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckItemWarningMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the servers that are affected by baseline risks.
     *  *
     * @param ListCheckItemWarningMachineRequest $request ListCheckItemWarningMachineRequest
     *
     * @return ListCheckItemWarningMachineResponse ListCheckItemWarningMachineResponse
     */
    public function listCheckItemWarningMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemWarningMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the risk statistics of check items by page.
     *  *
     * @param ListCheckItemWarningSummaryRequest $request ListCheckItemWarningSummaryRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckItemWarningSummaryResponse ListCheckItemWarningSummaryResponse
     */
    public function listCheckItemWarningSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkItemFuzzy)) {
            $query['CheckItemFuzzy'] = $request->checkItemFuzzy;
        }
        if (!Utils::isUnset($request->checkLevel)) {
            $query['CheckLevel'] = $request->checkLevel;
        }
        if (!Utils::isUnset($request->checkType)) {
            $query['CheckType'] = $request->checkType;
        }
        if (!Utils::isUnset($request->checkWarningStatus)) {
            $query['CheckWarningStatus'] = $request->checkWarningStatus;
        }
        if (!Utils::isUnset($request->containerFieldName)) {
            $query['ContainerFieldName'] = $request->containerFieldName;
        }
        if (!Utils::isUnset($request->containerFieldValue)) {
            $query['ContainerFieldValue'] = $request->containerFieldValue;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskType)) {
            $query['RiskType'] = $request->riskType;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckItemWarningSummary',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckItemWarningSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk statistics of check items by page.
     *  *
     * @param ListCheckItemWarningSummaryRequest $request ListCheckItemWarningSummaryRequest
     *
     * @return ListCheckItemWarningSummaryResponse ListCheckItemWarningSummaryResponse
     */
    public function listCheckItemWarningSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckItemWarningSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of the risk items that are detected in the configuration checks on cloud services.
     *  *
     * @param ListCheckResultRequest $request ListCheckResultRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckResultResponse ListCheckResultResponse
     */
    public function listCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkKey)) {
            $query['CheckKey'] = $request->checkKey;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->customParam)) {
            $query['CustomParam'] = $request->customParam;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->instanceTypes)) {
            $query['InstanceTypes'] = $request->instanceTypes;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->requirementIds)) {
            $query['RequirementIds'] = $request->requirementIds;
        }
        if (!Utils::isUnset($request->riskLevels)) {
            $query['RiskLevels'] = $request->riskLevels;
        }
        if (!Utils::isUnset($request->sortTypes)) {
            $query['SortTypes'] = $request->sortTypes;
        }
        if (!Utils::isUnset($request->standardIds)) {
            $query['StandardIds'] = $request->standardIds;
        }
        if (!Utils::isUnset($request->statuses)) {
            $query['Statuses'] = $request->statuses;
        }
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of the risk items that are detected in the configuration checks on cloud services.
     *  *
     * @param ListCheckResultRequest $request ListCheckResultRequest
     *
     * @return ListCheckResultResponse ListCheckResultResponse
     */
    public function listCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the standards of configuration checks.
     *  *
     * @param ListCheckStandardRequest $request ListCheckStandardRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckStandardResponse ListCheckStandardResponse
     */
    public function listCheckStandardWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->instanceSubTypes)) {
            $query['InstanceSubTypes'] = $request->instanceSubTypes;
        }
        if (!Utils::isUnset($request->instanceTypes)) {
            $query['InstanceTypes'] = $request->instanceTypes;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->vendors)) {
            $query['Vendors'] = $request->vendors;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckStandard',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckStandardResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the standards of configuration checks.
     *  *
     * @param ListCheckStandardRequest $request ListCheckStandardRequest
     *
     * @return ListCheckStandardResponse ListCheckStandardResponse
     */
    public function listCheckStandard($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckStandardWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the types of check items that meet the specified conditions based on the ID of a baseline.
     *  *
     * @param ListCheckTypesRequest $request ListCheckTypesRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCheckTypesResponse ListCheckTypesResponse
     */
    public function listCheckTypesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskId)) {
            $query['RiskId'] = $request->riskId;
        }
        if (!Utils::isUnset($request->showChecks)) {
            $query['ShowChecks'] = $request->showChecks;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCheckTypes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCheckTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the types of check items that meet the specified conditions based on the ID of a baseline.
     *  *
     * @param ListCheckTypesRequest $request ListCheckTypesRequest
     *
     * @return ListCheckTypesResponse ListCheckTypesResponse
     */
    public function listCheckTypes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckTypesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
     *  *
     * @param ListClientAlertModeRequest $request ListClientAlertModeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClientAlertModeResponse ListClientAlertModeResponse
     */
    public function listClientAlertModeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClientAlertMode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClientAlertModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
     *  *
     * @param ListClientAlertModeRequest $request ListClientAlertModeRequest
     *
     * @return ListClientAlertModeResponse ListClientAlertModeResponse
     */
    public function listClientAlertMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClientAlertModeWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClientUserDefineRuleTypesResponse ListClientUserDefineRuleTypesResponse
     */
    public function listClientUserDefineRuleTypesWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListClientUserDefineRuleTypes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClientUserDefineRuleTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @return ListClientUserDefineRuleTypesResponse ListClientUserDefineRuleTypesResponse
     */
    public function listClientUserDefineRuleTypes()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClientUserDefineRuleTypesWithOptions($runtime);
    }

    /**
     * @summary Queries custom defense rules.
     *  *
     * @param ListClientUserDefineRulesRequest $request ListClientUserDefineRulesRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClientUserDefineRulesResponse ListClientUserDefineRulesResponse
     */
    public function listClientUserDefineRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClientUserDefineRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClientUserDefineRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries custom defense rules.
     *  *
     * @param ListClientUserDefineRulesRequest $request ListClientUserDefineRulesRequest
     *
     * @return ListClientUserDefineRulesResponse ListClientUserDefineRulesResponse
     */
    public function listClientUserDefineRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClientUserDefineRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries cloud service assets.
     *  *
     * @param ListCloudAssetInstancesRequest $request ListCloudAssetInstancesRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCloudAssetInstancesResponse ListCloudAssetInstancesResponse
     */
    public function listCloudAssetInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cloudAssetTypes)) {
            $query['CloudAssetTypes'] = $request->cloudAssetTypes;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCloudAssetInstances',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCloudAssetInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries cloud service assets.
     *  *
     * @param ListCloudAssetInstancesRequest $request ListCloudAssetInstancesRequest
     *
     * @return ListCloudAssetInstancesResponse ListCloudAssetInstancesResponse
     */
    public function listCloudAssetInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCloudAssetInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the synchronization region configurations of other clouds on a site.
     *  *
     * @param ListCloudVendorRegionsRequest $request ListCloudVendorRegionsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCloudVendorRegionsResponse ListCloudVendorRegionsResponse
     */
    public function listCloudVendorRegionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCloudVendorRegions',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCloudVendorRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the synchronization region configurations of other clouds on a site.
     *  *
     * @param ListCloudVendorRegionsRequest $request ListCloudVendorRegionsRequest
     *
     * @return ListCloudVendorRegionsResponse ListCloudVendorRegionsResponse
     */
    public function listCloudVendorRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCloudVendorRegionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the protection status of the container firewall.
     *  *
     * @param ListClusterCnnfStatusDetailRequest $request ListClusterCnnfStatusDetailRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClusterCnnfStatusDetailResponse ListClusterCnnfStatusDetailResponse
     */
    public function listClusterCnnfStatusDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClusterCnnfStatusDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClusterCnnfStatusDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the protection status of the container firewall.
     *  *
     * @param ListClusterCnnfStatusDetailRequest $request ListClusterCnnfStatusDetailRequest
     *
     * @return ListClusterCnnfStatusDetailResponse ListClusterCnnfStatusDetailResponse
     */
    public function listClusterCnnfStatusDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterCnnfStatusDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the defense rules that are created for a cluster.
     *  *
     * @param ListClusterInterceptionConfigRequest $request ListClusterInterceptionConfigRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClusterInterceptionConfigResponse ListClusterInterceptionConfigResponse
     */
    public function listClusterInterceptionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterCNNFStatus)) {
            $query['ClusterCNNFStatus'] = $request->clusterCNNFStatus;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClusterInterceptionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClusterInterceptionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the defense rules that are created for a cluster.
     *  *
     * @param ListClusterInterceptionConfigRequest $request ListClusterInterceptionConfigRequest
     *
     * @return ListClusterInterceptionConfigResponse ListClusterInterceptionConfigResponse
     */
    public function listClusterInterceptionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterInterceptionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of plug-ins on clusters.
     *  *
     * @param ListClusterPluginInfoRequest $request ListClusterPluginInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClusterPluginInfoResponse ListClusterPluginInfoResponse
     */
    public function listClusterPluginInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pluginName)) {
            $query['PluginName'] = $request->pluginName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClusterPluginInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClusterPluginInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of plug-ins on clusters.
     *  *
     * @param ListClusterPluginInfoRequest $request ListClusterPluginInfoRequest
     *
     * @return ListClusterPluginInfoResponse ListClusterPluginInfoResponse
     */
    public function listClusterPluginInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterPluginInfoWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ListCompressFileDetectResultRequest $request ListCompressFileDetectResultRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCompressFileDetectResultResponse ListCompressFileDetectResultResponse
     */
    public function listCompressFileDetectResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->hashKey)) {
            $query['HashKey'] = $request->hashKey;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCompressFileDetectResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCompressFileDetectResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ListCompressFileDetectResultRequest $request ListCompressFileDetectResultRequest
     *
     * @return ListCompressFileDetectResultResponse ListCompressFileDetectResultResponse
     */
    public function listCompressFileDetectResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCompressFileDetectResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of rules for non-image program defense.
     *  *
     * @param ListContainerDefenseRuleRequest $request ListContainerDefenseRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListContainerDefenseRuleResponse ListContainerDefenseRuleResponse
     */
    public function listContainerDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->conditions)) {
            $query['Conditions'] = $request->conditions;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->isDefaultRule)) {
            $query['IsDefaultRule'] = $request->isDefaultRule;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListContainerDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of rules for non-image program defense.
     *  *
     * @param ListContainerDefenseRuleRequest $request ListContainerDefenseRuleRequest
     *
     * @return ListContainerDefenseRuleResponse ListContainerDefenseRuleResponse
     */
    public function listContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of clusters that are included in a rule for non-image program defense.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListContainerDefenseRuleClustersResponse ListContainerDefenseRuleClustersResponse
     */
    public function listContainerDefenseRuleClustersWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListContainerDefenseRuleClusters',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListContainerDefenseRuleClustersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of clusters that are included in a rule for non-image program defense.
     *  *
     * @return ListContainerDefenseRuleClustersResponse ListContainerDefenseRuleClustersResponse
     */
    public function listContainerDefenseRuleClusters()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listContainerDefenseRuleClustersWithOptions($runtime);
    }

    /**
     * @summary Queries the IDs and names of rules configured for proactive defense for containers.
     *  *
     * @param ListCriteriaStrategyRequest $request ListCriteriaStrategyRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCriteriaStrategyResponse ListCriteriaStrategyResponse
     */
    public function listCriteriaStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->label)) {
            $query['Label'] = $request->label;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCriteriaStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCriteriaStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the IDs and names of rules configured for proactive defense for containers.
     *  *
     * @param ListCriteriaStrategyRequest $request ListCriteriaStrategyRequest
     *
     * @return ListCriteriaStrategyResponse ListCriteriaStrategyResponse
     */
    public function listCriteriaStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCriteriaStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Queries core file monitoring rules that meet the specified filter condition.
     *  *
     * @param ListFileProtectEventRequest $request ListFileProtectEventRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileProtectEventResponse ListFileProtectEventResponse
     */
    public function listFileProtectEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alertLevels)) {
            $query['AlertLevels'] = $request->alertLevels;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->instanceName)) {
            $query['InstanceName'] = $request->instanceName;
        }
        if (!Utils::isUnset($request->internetIp)) {
            $query['InternetIp'] = $request->internetIp;
        }
        if (!Utils::isUnset($request->intranetIp)) {
            $query['IntranetIp'] = $request->intranetIp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListFileProtectEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileProtectEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries core file monitoring rules that meet the specified filter condition.
     *  *
     * @param ListFileProtectEventRequest $request ListFileProtectEventRequest
     *
     * @return ListFileProtectEventResponse ListFileProtectEventResponse
     */
    public function listFileProtectEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileProtectEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
     *  *
     * @param ListFileProtectPluginStatusRequest $request ListFileProtectPluginStatusRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileProtectPluginStatusResponse ListFileProtectPluginStatusResponse
     */
    public function listFileProtectPluginStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->switchId)) {
            $query['SwitchId'] = $request->switchId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListFileProtectPluginStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileProtectPluginStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
     *  *
     * @param ListFileProtectPluginStatusRequest $request ListFileProtectPluginStatusRequest
     *
     * @return ListFileProtectPluginStatusResponse ListFileProtectPluginStatusResponse
     */
    public function listFileProtectPluginStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileProtectPluginStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries core file monitoring rules.
     *  *
     * @param ListFileProtectRuleRequest $request ListFileProtectRuleRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileProtectRuleResponse ListFileProtectRuleResponse
     */
    public function listFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alertLevel)) {
            $query['AlertLevel'] = $request->alertLevel;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries core file monitoring rules.
     *  *
     * @param ListFileProtectRuleRequest $request ListFileProtectRuleRequest
     *
     * @return ListFileProtectRuleResponse ListFileProtectRuleResponse
     */
    public function listFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the server groups.
     *  *
     * @param ListGroupsRequest $request ListGroupsRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListGroupsResponse ListGroupsResponse
     */
    public function listGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->useNextToken)) {
            $query['UseNextToken'] = $request->useNextToken;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListGroups',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the server groups.
     *  *
     * @param ListGroupsRequest $request ListGroupsRequest
     *
     * @return ListGroupsResponse ListGroupsResponse
     */
    public function listGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about honeypots.
     *  *
     * @param ListHoneypotRequest $request ListHoneypotRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotResponse ListHoneypotResponse
     */
    public function listHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->honeypotIds)) {
            $query['HoneypotIds'] = $request->honeypotIds;
        }
        if (!Utils::isUnset($request->honeypotName)) {
            $query['HoneypotName'] = $request->honeypotName;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about honeypots.
     *  *
     * @param ListHoneypotRequest $request ListHoneypotRequest
     *
     * @return ListHoneypotResponse ListHoneypotResponse
     */
    public function listHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about alert events that are generated.
     *  *
     * @param ListHoneypotAlarmEventsRequest $request ListHoneypotAlarmEventsRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotAlarmEventsResponse ListHoneypotAlarmEventsResponse
     */
    public function listHoneypotAlarmEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotAlarmEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotAlarmEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about alert events that are generated.
     *  *
     * @param ListHoneypotAlarmEventsRequest $request ListHoneypotAlarmEventsRequest
     *
     * @return ListHoneypotAlarmEventsResponse ListHoneypotAlarmEventsResponse
     */
    public function listHoneypotAlarmEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotAlarmEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the attacker profile based on the source IP address of the attack.
     *  *
     * @param ListHoneypotAttackerPortraitRequest $request ListHoneypotAttackerPortraitRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotAttackerPortraitResponse ListHoneypotAttackerPortraitResponse
     */
    public function listHoneypotAttackerPortraitWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTimeStamp)) {
            $query['EndTimeStamp'] = $request->endTimeStamp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->srcIp)) {
            $query['SrcIp'] = $request->srcIp;
        }
        if (!Utils::isUnset($request->startTimeStamp)) {
            $query['StartTimeStamp'] = $request->startTimeStamp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotAttackerPortrait',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotAttackerPortraitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the attacker profile based on the source IP address of the attack.
     *  *
     * @param ListHoneypotAttackerPortraitRequest $request ListHoneypotAttackerPortraitRequest
     *
     * @return ListHoneypotAttackerPortraitResponse ListHoneypotAttackerPortraitResponse
     */
    public function listHoneypotAttackerPortrait($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotAttackerPortraitWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the attack source IP addresses that are used to attack a honeypot.
     *  *
     * @param ListHoneypotAttackerSourceRequest $request ListHoneypotAttackerSourceRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotAttackerSourceResponse ListHoneypotAttackerSourceResponse
     */
    public function listHoneypotAttackerSourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTimeStamp)) {
            $query['EndTimeStamp'] = $request->endTimeStamp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->riskLevelList)) {
            $query['RiskLevelList'] = $request->riskLevelList;
        }
        if (!Utils::isUnset($request->srcIp)) {
            $query['SrcIp'] = $request->srcIp;
        }
        if (!Utils::isUnset($request->startTimeStamp)) {
            $query['StartTimeStamp'] = $request->startTimeStamp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotAttackerSource',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotAttackerSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the attack source IP addresses that are used to attack a honeypot.
     *  *
     * @param ListHoneypotAttackerSourceRequest $request ListHoneypotAttackerSourceRequest
     *
     * @return ListHoneypotAttackerSourceResponse ListHoneypotAttackerSourceResponse
     */
    public function listHoneypotAttackerSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotAttackerSourceWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an intrusion event in a honeypot.
     *  *
     * @param ListHoneypotEventFlowsRequest $request ListHoneypotEventFlowsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotEventFlowsResponse ListHoneypotEventFlowsResponse
     */
    public function listHoneypotEventFlowsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotEventFlows',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotEventFlowsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an intrusion event in a honeypot.
     *  *
     * @param ListHoneypotEventFlowsRequest $request ListHoneypotEventFlowsRequest
     *
     * @return ListHoneypotEventFlowsResponse ListHoneypotEventFlowsResponse
     */
    public function listHoneypotEventFlows($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotEventFlowsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the intrusion events detected by honeypots.
     *  *
     * @param ListHoneypotEventsRequest $request ListHoneypotEventsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotEventsResponse ListHoneypotEventsResponse
     */
    public function listHoneypotEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the intrusion events detected by honeypots.
     *  *
     * @param ListHoneypotEventsRequest $request ListHoneypotEventsRequest
     *
     * @return ListHoneypotEventsResponse ListHoneypotEventsResponse
     */
    public function listHoneypotEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about management nodes.
     *  *
     * @param ListHoneypotNodeRequest $request ListHoneypotNodeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotNodeResponse ListHoneypotNodeResponse
     */
    public function listHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about management nodes.
     *  *
     * @param ListHoneypotNodeRequest $request ListHoneypotNodeRequest
     *
     * @return ListHoneypotNodeResponse ListHoneypotNodeResponse
     */
    public function listHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries honeypot templates.
     *  *
     * @param ListHoneypotPresetRequest $request ListHoneypotPresetRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotPresetResponse ListHoneypotPresetResponse
     */
    public function listHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->presetName)) {
            $query['PresetName'] = $request->presetName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries honeypot templates.
     *  *
     * @param ListHoneypotPresetRequest $request ListHoneypotPresetRequest
     *
     * @return ListHoneypotPresetResponse ListHoneypotPresetResponse
     */
    public function listHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Queries probes.
     *  *
     * @param ListHoneypotProbeRequest $request ListHoneypotProbeRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotProbeResponse ListHoneypotProbeResponse
     */
    public function listHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->displayName)) {
            $query['DisplayName'] = $request->displayName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->probeStatus)) {
            $query['ProbeStatus'] = $request->probeStatus;
        }
        if (!Utils::isUnset($request->probeType)) {
            $query['ProbeType'] = $request->probeType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries probes.
     *  *
     * @param ListHoneypotProbeRequest $request ListHoneypotProbeRequest
     *
     * @return ListHoneypotProbeResponse ListHoneypotProbeResponse
     */
    public function listHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ListHoneypotProbeUuidRequest $request ListHoneypotProbeUuidRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListHoneypotProbeUuidResponse ListHoneypotProbeUuidResponse
     */
    public function listHoneypotProbeUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->controlNodeId)) {
            $query['ControlNodeId'] = $request->controlNodeId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->probeType)) {
            $query['ProbeType'] = $request->probeType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListHoneypotProbeUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListHoneypotProbeUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ListHoneypotProbeUuidRequest $request ListHoneypotProbeUuidRequest
     *
     * @return ListHoneypotProbeUuidResponse ListHoneypotProbeUuidResponse
     */
    public function listHoneypotProbeUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listHoneypotProbeUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the types of risky image build commands.
     *  *
     * @param ListImageBuildRiskItemRequest $request ListImageBuildRiskItemRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListImageBuildRiskItemResponse ListImageBuildRiskItemResponse
     */
    public function listImageBuildRiskItemWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListImageBuildRiskItem',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListImageBuildRiskItemResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the types of risky image build commands.
     *  *
     * @param ListImageBuildRiskItemRequest $request ListImageBuildRiskItemRequest
     *
     * @return ListImageBuildRiskItemResponse ListImageBuildRiskItemResponse
     */
    public function listImageBuildRiskItem($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageBuildRiskItemWithOptions($request, $runtime);
    }

    /**
     * @summary The region ID of the image.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListImageRegistryRegionResponse ListImageRegistryRegionResponse
     */
    public function listImageRegistryRegionWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListImageRegistryRegion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListImageRegistryRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The region ID of the image.
     *  *
     * @return ListImageRegistryRegionResponse ListImageRegistryRegionResponse
     */
    public function listImageRegistryRegion()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageRegistryRegionWithOptions($runtime);
    }

    /**
     * @summary Queries security information about a container image.
     *  *
     * @param ListImageRiskRequest $request ListImageRiskRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListImageRiskResponse ListImageRiskResponse
     */
    public function listImageRiskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListImageRisk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListImageRiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries security information about a container image.
     *  *
     * @param ListImageRiskRequest $request ListImageRiskRequest
     *
     * @return ListImageRiskResponse ListImageRiskResponse
     */
    public function listImageRisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listImageRiskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the asset types and asset subtypes for configuration assessment.
     *  *
     * @param ListInstanceCatalogRequest $request ListInstanceCatalogRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceCatalogResponse ListInstanceCatalogResponse
     */
    public function listInstanceCatalogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->regionId)) {
            $query['RegionId'] = $request->regionId;
        }
        if (!Utils::isUnset($request->requirementIds)) {
            $query['RequirementIds'] = $request->requirementIds;
        }
        if (!Utils::isUnset($request->standardIds)) {
            $query['StandardIds'] = $request->standardIds;
        }
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceCatalog',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceCatalogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the asset types and asset subtypes for configuration assessment.
     *  *
     * @param ListInstanceCatalogRequest $request ListInstanceCatalogRequest
     *
     * @return ListInstanceCatalogResponse ListInstanceCatalogResponse
     */
    public function listInstanceCatalog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceCatalogWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the risk levels of instances.
     *  *
     * @param ListInstanceRiskLevelsRequest $request ListInstanceRiskLevelsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceRiskLevelsResponse ListInstanceRiskLevelsResponse
     */
    public function listInstanceRiskLevelsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceList)) {
            $query['InstanceList'] = $request->instanceList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceRiskLevels',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceRiskLevelsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk levels of instances.
     *  *
     * @param ListInstanceRiskLevelsRequest $request ListInstanceRiskLevelsRequest
     *
     * @return ListInstanceRiskLevelsResponse ListInstanceRiskLevelsResponse
     */
    public function listInstanceRiskLevels($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceRiskLevelsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the statistics about risks in instances.
     *  *
     * @param ListInstanceRiskNumRequest $request ListInstanceRiskNumRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceRiskNumResponse ListInstanceRiskNumResponse
     */
    public function listInstanceRiskNumWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceList)) {
            $query['InstanceList'] = $request->instanceList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceRiskNum',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceRiskNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the statistics about risks in instances.
     *  *
     * @param ListInstanceRiskNumRequest $request ListInstanceRiskNumRequest
     *
     * @return ListInstanceRiskNumResponse ListInstanceRiskNumResponse
     */
    public function listInstanceRiskNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceRiskNumWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alerts generated by defense rules.
     *  *
     * @param ListInterceptionHistoryRequest $request ListInterceptionHistoryRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInterceptionHistoryResponse ListInterceptionHistoryResponse
     */
    public function listInterceptionHistoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->historyName)) {
            $query['HistoryName'] = $request->historyName;
        }
        if (!Utils::isUnset($request->interceptionTypes)) {
            $query['InterceptionTypes'] = $request->interceptionTypes;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInterceptionHistory',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInterceptionHistoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alerts generated by defense rules.
     *  *
     * @param ListInterceptionHistoryRequest $request ListInterceptionHistoryRequest
     *
     * @return ListInterceptionHistoryResponse ListInterceptionHistoryResponse
     */
    public function listInterceptionHistory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInterceptionHistoryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries defense rules that are configured for the container firewall feature.
     *  *
     * @param ListInterceptionRulePageRequest $request ListInterceptionRulePageRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInterceptionRulePageResponse ListInterceptionRulePageResponse
     */
    public function listInterceptionRulePageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->criteriaType)) {
            $query['CriteriaType'] = $request->criteriaType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInterceptionRulePage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInterceptionRulePageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries defense rules that are configured for the container firewall feature.
     *  *
     * @param ListInterceptionRulePageRequest $request ListInterceptionRulePageRequest
     *
     * @return ListInterceptionRulePageResponse ListInterceptionRulePageResponse
     */
    public function listInterceptionRulePage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInterceptionRulePageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the network objects that are protected by the container firewall feature.
     *  *
     * @param ListInterceptionTargetPageRequest $request ListInterceptionTargetPageRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInterceptionTargetPageResponse ListInterceptionTargetPageResponse
     */
    public function listInterceptionTargetPageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageList)) {
            $query['ImageList'] = $request->imageList;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->tagList)) {
            $query['TagList'] = $request->tagList;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListInterceptionTargetPage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInterceptionTargetPageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the network objects that are protected by the container firewall feature.
     *  *
     * @param ListInterceptionTargetPageRequest $request ListInterceptionTargetPageRequest
     *
     * @return ListInterceptionTargetPageResponse ListInterceptionTargetPageResponse
     */
    public function listInterceptionTargetPage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInterceptionTargetPageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about Kubernetes clusters that are added to Security Center.
     *  *
     * @description You can use this operation to query the access information about Kubernetes clusters.
     *  *
     * @param ListK8sAccessInfoRequest $request ListK8sAccessInfoRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListK8sAccessInfoResponse ListK8sAccessInfoResponse
     */
    public function listK8sAccessInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliyunYundunGatewayApiName)) {
            $query['AliyunYundunGatewayApiName'] = $request->aliyunYundunGatewayApiName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayPopName)) {
            $query['AliyunYundunGatewayPopName'] = $request->aliyunYundunGatewayPopName;
        }
        if (!Utils::isUnset($request->aliyunYundunGatewayProjectName)) {
            $query['AliyunYundunGatewayProjectName'] = $request->aliyunYundunGatewayProjectName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListK8sAccessInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListK8sAccessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about Kubernetes clusters that are added to Security Center.
     *  *
     * @description You can use this operation to query the access information about Kubernetes clusters.
     *  *
     * @param ListK8sAccessInfoRequest $request ListK8sAccessInfoRequest
     *
     * @return ListK8sAccessInfoResponse ListK8sAccessInfoResponse
     */
    public function listK8sAccessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listK8sAccessInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param ListMaliciousFileWhitelistConfigsRequest $request ListMaliciousFileWhitelistConfigsRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMaliciousFileWhitelistConfigsResponse ListMaliciousFileWhitelistConfigsResponse
     */
    public function listMaliciousFileWhitelistConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListMaliciousFileWhitelistConfigs',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMaliciousFileWhitelistConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param ListMaliciousFileWhitelistConfigsRequest $request ListMaliciousFileWhitelistConfigsRequest
     *
     * @return ListMaliciousFileWhitelistConfigsResponse ListMaliciousFileWhitelistConfigsResponse
     */
    public function listMaliciousFileWhitelistConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMaliciousFileWhitelistConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries alerts that are generated for malicious files.
     *  *
     * @param ListObjectScanEventRequest $request ListObjectScanEventRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListObjectScanEventResponse ListObjectScanEventResponse
     */
    public function listObjectScanEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->md5)) {
            $query['Md5'] = $request->md5;
        }
        if (!Utils::isUnset($request->ossKey)) {
            $query['OssKey'] = $request->ossKey;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentEventId)) {
            $query['ParentEventId'] = $request->parentEventId;
        }
        if (!Utils::isUnset($request->riskLevel)) {
            $query['RiskLevel'] = $request->riskLevel;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->timeEnd)) {
            $query['TimeEnd'] = $request->timeEnd;
        }
        if (!Utils::isUnset($request->timeStart)) {
            $query['TimeStart'] = $request->timeStart;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListObjectScanEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListObjectScanEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries alerts that are generated for malicious files.
     *  *
     * @param ListObjectScanEventRequest $request ListObjectScanEventRequest
     *
     * @return ListObjectScanEventResponse ListObjectScanEventResponse
     */
    public function listObjectScanEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listObjectScanEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries at-risk image blocking rules.
     *  *
     * @param ListOpaClusterStrategyNewRequest $request ListOpaClusterStrategyNewRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListOpaClusterStrategyNewResponse ListOpaClusterStrategyNewResponse
     */
    public function listOpaClusterStrategyNewWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->label)) {
            $query['Label'] = $request->label;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListOpaClusterStrategyNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListOpaClusterStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries at-risk image blocking rules.
     *  *
     * @param ListOpaClusterStrategyNewRequest $request ListOpaClusterStrategyNewRequest
     *
     * @return ListOpaClusterStrategyNewResponse ListOpaClusterStrategyNewResponse
     */
    public function listOpaClusterStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOpaClusterStrategyNewWithOptions($request, $runtime);
    }

    /**
     * @summary Queries Object Storage Service (OSS) buckets.
     *  *
     * @param ListOssBucketRequest $request ListOssBucketRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListOssBucketResponse ListOssBucketResponse
     */
    public function listOssBucketWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListOssBucket',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListOssBucketResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries Object Storage Service (OSS) buckets.
     *  *
     * @param ListOssBucketRequest $request ListOssBucketRequest
     *
     * @return ListOssBucketResponse ListOssBucketResponse
     */
    public function listOssBucket($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOssBucketWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the risk information of an Object Storage Service (OSS) bucket.
     *  *
     * @param ListOssBucketScanInfoRequest $request ListOssBucketScanInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListOssBucketScanInfoResponse ListOssBucketScanInfoResponse
     */
    public function listOssBucketScanInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->fuzzBucketName)) {
            $query['FuzzBucketName'] = $request->fuzzBucketName;
        }
        if (!Utils::isUnset($request->hasRisk)) {
            $query['HasRisk'] = $request->hasRisk;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListOssBucketScanInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListOssBucketScanInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the risk information of an Object Storage Service (OSS) bucket.
     *  *
     * @param ListOssBucketScanInfoRequest $request ListOssBucketScanInfoRequest
     *
     * @return ListOssBucketScanInfoResponse ListOssBucketScanInfoResponse
     */
    public function listOssBucketScanInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOssBucketScanInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configuration of an Object Storage Service (OSS) file detection policy.
     *  *
     * @param ListOssScanConfigRequest $request ListOssScanConfigRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListOssScanConfigResponse ListOssScanConfigResponse
     */
    public function listOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configuration of an Object Storage Service (OSS) file detection policy.
     *  *
     * @param ListOssScanConfigRequest $request ListOssScanConfigRequest
     *
     * @return ListOssScanConfigResponse ListOssScanConfigResponse
     */
    public function listOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about plug-ins on a server.
     *  *
     * @param ListPluginForUuidRequest $tmpReq  ListPluginForUuidRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPluginForUuidResponse ListPluginForUuidResponse
     */
    public function listPluginForUuidWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListPluginForUuidShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->types)) {
            $request->typesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->types, 'Types', 'simple');
        }
        $query = [];
        if (!Utils::isUnset($request->typesShrink)) {
            $query['Types'] = $request->typesShrink;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPluginForUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPluginForUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about plug-ins on a server.
     *  *
     * @param ListPluginForUuidRequest $request ListPluginForUuidRequest
     *
     * @return ListPluginForUuidResponse ListPluginForUuidResponse
     */
    public function listPluginForUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPluginForUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the security risks of a pod.
     *  *
     * @param ListPodRiskRequest $request ListPodRiskRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPodRiskResponse ListPodRiskResponse
     */
    public function listPodRiskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->podName)) {
            $query['PodName'] = $request->podName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPodRisk',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPodRiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the security risks of a pod.
     *  *
     * @param ListPodRiskRequest $request ListPodRiskRequest
     *
     * @return ListPodRiskResponse ListPodRiskResponse
     */
    public function listPodRisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPodRiskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries image repositories.
     *  *
     * @param ListPrivateRegistryListRequest $request ListPrivateRegistryListRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPrivateRegistryListResponse ListPrivateRegistryListResponse
     */
    public function listPrivateRegistryListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->registryType)) {
            $query['RegistryType'] = $request->registryType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPrivateRegistryList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPrivateRegistryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries image repositories.
     *  *
     * @param ListPrivateRegistryListRequest $request ListPrivateRegistryListRequest
     *
     * @return ListPrivateRegistryListResponse ListPrivateRegistryListResponse
     */
    public function listPrivateRegistryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrivateRegistryListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of image repositories of each type.
     *  *
     * @param ListPrivateRegistryTypeRequest $request ListPrivateRegistryTypeRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPrivateRegistryTypeResponse ListPrivateRegistryTypeResponse
     */
    public function listPrivateRegistryTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPrivateRegistryType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPrivateRegistryTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of image repositories of each type.
     *  *
     * @param ListPrivateRegistryTypeRequest $request ListPrivateRegistryTypeRequest
     *
     * @return ListPrivateRegistryTypeResponse ListPrivateRegistryTypeResponse
     */
    public function listPrivateRegistryType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPrivateRegistryTypeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the installation information of one or more Runtime Application Self-protection-enabled (RASP-enabled) applications.
     *  *
     * @param ListQueryRaspAppInfoRequest $request ListQueryRaspAppInfoRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListQueryRaspAppInfoResponse ListQueryRaspAppInfoResponse
     */
    public function listQueryRaspAppInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListQueryRaspAppInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListQueryRaspAppInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the installation information of one or more Runtime Application Self-protection-enabled (RASP-enabled) applications.
     *  *
     * @param ListQueryRaspAppInfoRequest $request ListQueryRaspAppInfoRequest
     *
     * @return ListQueryRaspAppInfoResponse ListQueryRaspAppInfoResponse
     */
    public function listQueryRaspAppInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQueryRaspAppInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the network objects based on which a specified cluster is protected.
     *  *
     * @param ListRuleTargetAllRequest $request ListRuleTargetAllRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListRuleTargetAllResponse ListRuleTargetAllResponse
     */
    public function listRuleTargetAllWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListRuleTargetAll',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListRuleTargetAllResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the network objects based on which a specified cluster is protected.
     *  *
     * @param ListRuleTargetAllRequest $request ListRuleTargetAllRequest
     *
     * @return ListRuleTargetAllResponse ListRuleTargetAllResponse
     */
    public function listRuleTargetAll($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRuleTargetAllWithOptions($request, $runtime);
    }

    /**
     * @summary Queries rules for container tamper-proofing.
     *  *
     * @param ListSasContainerWebDefenseRuleRequest $request ListSasContainerWebDefenseRuleRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSasContainerWebDefenseRuleResponse ListSasContainerWebDefenseRuleResponse
     */
    public function listSasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->criteria)) {
            $query['Criteria'] = $request->criteria;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->logicalExp)) {
            $query['LogicalExp'] = $request->logicalExp;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListSasContainerWebDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries rules for container tamper-proofing.
     *  *
     * @param ListSasContainerWebDefenseRuleRequest $request ListSasContainerWebDefenseRuleRequest
     *
     * @return ListSasContainerWebDefenseRuleResponse ListSasContainerWebDefenseRuleResponse
     */
    public function listSasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries supported file suffixes.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSupportObjectSuffixResponse ListSupportObjectSuffixResponse
     */
    public function listSupportObjectSuffixWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListSupportObjectSuffix',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSupportObjectSuffixResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries supported file suffixes.
     *  *
     * @return ListSupportObjectSuffixResponse ListSupportObjectSuffixResponse
     */
    public function listSupportObjectSuffix()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSupportObjectSuffixWithOptions($runtime);
    }

    /**
     * @summary Queries the details about the aggregation types of system defense rules.
     *  *
     * @param ListSystemAggregationRulesRequest $request ListSystemAggregationRulesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSystemAggregationRulesResponse ListSystemAggregationRulesResponse
     */
    public function listSystemAggregationRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListSystemAggregationRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSystemAggregationRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about the aggregation types of system defense rules.
     *  *
     * @param ListSystemAggregationRulesRequest $request ListSystemAggregationRulesRequest
     *
     * @return ListSystemAggregationRulesResponse ListSystemAggregationRulesResponse
     */
    public function listSystemAggregationRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemAggregationRulesWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSystemClientRuleTypesResponse ListSystemClientRuleTypesResponse
     */
    public function listSystemClientRuleTypesWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'ListSystemClientRuleTypes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSystemClientRuleTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @return ListSystemClientRuleTypesResponse ListSystemClientRuleTypesResponse
     */
    public function listSystemClientRuleTypes()
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemClientRuleTypesWithOptions($runtime);
    }

    /**
     * @summary Queries system defense rules.
     *  *
     * @param ListSystemClientRulesRequest $request ListSystemClientRulesRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSystemClientRulesResponse ListSystemClientRulesResponse
     */
    public function listSystemClientRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aggregationIds)) {
            $query['AggregationIds'] = $request->aggregationIds;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->isContainer)) {
            $query['IsContainer'] = $request->isContainer;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleTypes)) {
            $query['RuleTypes'] = $request->ruleTypes;
        }
        if (!Utils::isUnset($request->systemType)) {
            $query['SystemType'] = $request->systemType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListSystemClientRules',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSystemClientRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries system defense rules.
     *  *
     * @param ListSystemClientRulesRequest $request ListSystemClientRulesRequest
     *
     * @return ListSystemClientRulesResponse ListSystemClientRulesResponse
     */
    public function listSystemClientRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemClientRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the aggregation types of system defense rules.
     *  *
     * @param ListSystemRuleAggregationTypesRequest $request ListSystemRuleAggregationTypesRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSystemRuleAggregationTypesResponse ListSystemRuleAggregationTypesResponse
     */
    public function listSystemRuleAggregationTypesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListSystemRuleAggregationTypes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSystemRuleAggregationTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the aggregation types of system defense rules.
     *  *
     * @param ListSystemRuleAggregationTypesRequest $request ListSystemRuleAggregationTypesRequest
     *
     * @return ListSystemRuleAggregationTypesResponse ListSystemRuleAggregationTypesResponse
     */
    public function listSystemRuleAggregationTypes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemRuleAggregationTypesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries tasks that are not complete by task type.
     *  *
     * @param ListUnfinishedOnceTaskRequest $request ListUnfinishedOnceTaskRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListUnfinishedOnceTaskResponse ListUnfinishedOnceTaskResponse
     */
    public function listUnfinishedOnceTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListUnfinishedOnceTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListUnfinishedOnceTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries tasks that are not complete by task type.
     *  *
     * @param ListUnfinishedOnceTaskRequest $request ListUnfinishedOnceTaskRequest
     *
     * @return ListUnfinishedOnceTaskResponse ListUnfinishedOnceTaskResponse
     */
    public function listUnfinishedOnceTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUnfinishedOnceTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the servers whose Security Center agent is not installed.
     *  *
     * @param ListUninstallAegisMachinesRequest $request ListUninstallAegisMachinesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListUninstallAegisMachinesResponse ListUninstallAegisMachinesResponse
     */
    public function listUninstallAegisMachinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->os)) {
            $query['Os'] = $request->os;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->regionIdStr)) {
            $query['RegionIdStr'] = $request->regionIdStr;
        }
        if (!Utils::isUnset($request->regionNo)) {
            $query['RegionNo'] = $request->regionNo;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListUninstallAegisMachines',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListUninstallAegisMachinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the servers whose Security Center agent is not installed.
     *  *
     * @param ListUninstallAegisMachinesRequest $request ListUninstallAegisMachinesRequest
     *
     * @return ListUninstallAegisMachinesResponse ListUninstallAegisMachinesResponse
     */
    public function listUninstallAegisMachines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUninstallAegisMachinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries protected assets by using the paths to specific web directories.
     *  *
     * @param ListUuidsByWebPathRequest $request ListUuidsByWebPathRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListUuidsByWebPathResponse ListUuidsByWebPathResponse
     */
    public function listUuidsByWebPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->webPath)) {
            $query['WebPath'] = $request->webPath;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListUuidsByWebPath',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListUuidsByWebPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries protected assets by using the paths to specific web directories.
     *  *
     * @param ListUuidsByWebPathRequest $request ListUuidsByWebPathRequest
     *
     * @return ListUuidsByWebPathResponse ListUuidsByWebPathResponse
     */
    public function listUuidsByWebPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUuidsByWebPathWithOptions($request, $runtime);
    }

    /**
     * @summary Queries servers on which virus detection and removal tasks are performed.
     *  *
     * @param ListVirusScanMachineRequest $request ListVirusScanMachineRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVirusScanMachineResponse ListVirusScanMachineResponse
     */
    public function listVirusScanMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVirusScanMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVirusScanMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries servers on which virus detection and removal tasks are performed.
     *  *
     * @param ListVirusScanMachineRequest $request ListVirusScanMachineRequest
     *
     * @return ListVirusScanMachineResponse ListVirusScanMachineResponse
     */
    public function listVirusScanMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirusScanMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the alert events that are generated for viruses detected on a server.
     *  *
     * @param ListVirusScanMachineEventRequest $request ListVirusScanMachineEventRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVirusScanMachineEventResponse ListVirusScanMachineEventResponse
     */
    public function listVirusScanMachineEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->operateTaskId)) {
            $query['OperateTaskId'] = $request->operateTaskId;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVirusScanMachineEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVirusScanMachineEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the alert events that are generated for viruses detected on a server.
     *  *
     * @param ListVirusScanMachineEventRequest $request ListVirusScanMachineEventRequest
     *
     * @return ListVirusScanMachineEventResponse ListVirusScanMachineEventResponse
     */
    public function listVirusScanMachineEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirusScanMachineEventWithOptions($request, $runtime);
    }

    /**
     * @summary Queries virus scan tasks based on conditions such as the task type, task status, and server information.
     *  *
     * @param ListVirusScanTaskRequest $request ListVirusScanTaskRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVirusScanTaskResponse ListVirusScanTaskResponse
     */
    public function listVirusScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->internetIp)) {
            $query['InternetIp'] = $request->internetIp;
        }
        if (!Utils::isUnset($request->intranetIp)) {
            $query['IntranetIp'] = $request->intranetIp;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->machineName)) {
            $query['MachineName'] = $request->machineName;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->rootTask)) {
            $query['RootTask'] = $request->rootTask;
        }
        if (!Utils::isUnset($request->rootTaskId)) {
            $query['RootTaskId'] = $request->rootTaskId;
        }
        if (!Utils::isUnset($request->scanType)) {
            $query['ScanType'] = $request->scanType;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->statusList)) {
            $query['StatusList'] = $request->statusList;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVirusScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVirusScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries virus scan tasks based on conditions such as the task type, task status, and server information.
     *  *
     * @param ListVirusScanTaskRequest $request ListVirusScanTaskRequest
     *
     * @return ListVirusScanTaskResponse ListVirusScanTaskResponse
     */
    public function listVirusScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVirusScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the existing configurations of vulnerabilities that can be automatically fixed.
     *  *
     * @param ListVulAutoRepairConfigRequest $request ListVulAutoRepairConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVulAutoRepairConfigResponse ListVulAutoRepairConfigResponse
     */
    public function listVulAutoRepairConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->aliasName)) {
            $query['AliasName'] = $request->aliasName;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVulAutoRepairConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVulAutoRepairConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the existing configurations of vulnerabilities that can be automatically fixed.
     *  *
     * @param ListVulAutoRepairConfigRequest $request ListVulAutoRepairConfigRequest
     *
     * @return ListVulAutoRepairConfigResponse ListVulAutoRepairConfigResponse
     */
    public function listVulAutoRepairConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVulAutoRepairConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the global configurations of vulnerability detection.
     *  *
     * @param ListVulGlobalConfigRequest $request ListVulGlobalConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListVulGlobalConfigResponse ListVulGlobalConfigResponse
     */
    public function listVulGlobalConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configKey)) {
            $query['ConfigKey'] = $request->configKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListVulGlobalConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListVulGlobalConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the global configurations of vulnerability detection.
     *  *
     * @param ListVulGlobalConfigRequest $request ListVulGlobalConfigRequest
     *
     * @return ListVulGlobalConfigResponse ListVulGlobalConfigResponse
     */
    public function listVulGlobalConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listVulGlobalConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
     *  *
     * @param MarkMonitorAccountsRequest $request MarkMonitorAccountsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return MarkMonitorAccountsResponse MarkMonitorAccountsResponse
     */
    public function markMonitorAccountsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accountIds)) {
            $query['AccountIds'] = $request->accountIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'MarkMonitorAccounts',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return MarkMonitorAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
     *  *
     * @param MarkMonitorAccountsRequest $request MarkMonitorAccountsRequest
     *
     * @return MarkMonitorAccountsResponse MarkMonitorAccountsResponse
     */
    public function markMonitorAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->markMonitorAccountsWithOptions($request, $runtime);
    }

    /**
     * @summary Handles AccessKey pair leaks.
     *  *
     * @param ModifyAccessKeyLeakDealRequest $request ModifyAccessKeyLeakDealRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAccessKeyLeakDealResponse ModifyAccessKeyLeakDealResponse
     */
    public function modifyAccessKeyLeakDealWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->idList)) {
            $query['IdList'] = $request->idList;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAccessKeyLeakDeal',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAccessKeyLeakDealResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles AccessKey pair leaks.
     *  *
     * @param ModifyAccessKeyLeakDealRequest $request ModifyAccessKeyLeakDealRequest
     *
     * @return ModifyAccessKeyLeakDealResponse ModifyAccessKeyLeakDealResponse
     */
    public function modifyAccessKeyLeakDeal($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAccessKeyLeakDealWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a defense rule against brute-force attacks.
     *  *
     * @param ModifyAntiBruteForceRuleRequest $request ModifyAntiBruteForceRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAntiBruteForceRuleResponse ModifyAntiBruteForceRuleResponse
     */
    public function modifyAntiBruteForceRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defaultRule)) {
            $query['DefaultRule'] = $request->defaultRule;
        }
        if (!Utils::isUnset($request->failCount)) {
            $query['FailCount'] = $request->failCount;
        }
        if (!Utils::isUnset($request->forbiddenTime)) {
            $query['ForbiddenTime'] = $request->forbiddenTime;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->span)) {
            $query['Span'] = $request->span;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAntiBruteForceRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a defense rule against brute-force attacks.
     *  *
     * @param ModifyAntiBruteForceRuleRequest $request ModifyAntiBruteForceRuleRequest
     *
     * @return ModifyAntiBruteForceRuleResponse ModifyAntiBruteForceRuleResponse
     */
    public function modifyAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Configures a scan cycle for application vulnerabilities.
     *  *
     * @param ModifyAppVulScanCycleRequest $request ModifyAppVulScanCycleRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAppVulScanCycleResponse ModifyAppVulScanCycleResponse
     */
    public function modifyAppVulScanCycleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->cycle)) {
            $query['Cycle'] = $request->cycle;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAppVulScanCycle',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAppVulScanCycleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures a scan cycle for application vulnerabilities.
     *  *
     * @param ModifyAppVulScanCycleRequest $request ModifyAppVulScanCycleRequest
     *
     * @return ModifyAppVulScanCycleResponse ModifyAppVulScanCycleResponse
     */
    public function modifyAppVulScanCycle($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAppVulScanCycleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
     *  *
     * @param ModifyAssetCleanConfigRequest $request ModifyAssetCleanConfigRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAssetCleanConfigResponse ModifyAssetCleanConfigResponse
     */
    public function modifyAssetCleanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetCleanConfigs)) {
            $query['AssetCleanConfigs'] = $request->assetCleanConfigs;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAssetCleanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAssetCleanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
     *  *
     * @param ModifyAssetCleanConfigRequest $request ModifyAssetCleanConfigRequest
     *
     * @return ModifyAssetCleanConfigResponse ModifyAssetCleanConfigResponse
     */
    public function modifyAssetCleanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAssetCleanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the server group to which specified servers belong.
     *  *
     * @description You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
     * ### Limits
     * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param ModifyAssetGroupRequest $request ModifyAssetGroupRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAssetGroupResponse ModifyAssetGroupResponse
     */
    public function modifyAssetGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupId)) {
            $query['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAssetGroup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAssetGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the server group to which specified servers belong.
     *  *
     * @description You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
     * ### Limits
     * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param ModifyAssetGroupRequest $request ModifyAssetGroupRequest
     *
     * @return ModifyAssetGroupResponse ModifyAssetGroupResponse
     */
    public function modifyAssetGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAssetGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the importance of an asset.
     *  *
     * @param ModifyAssetImportantRequest $request ModifyAssetImportantRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAssetImportantResponse ModifyAssetImportantResponse
     */
    public function modifyAssetImportantWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->importantCode)) {
            $query['ImportantCode'] = $request->importantCode;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAssetImportant',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAssetImportantResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the importance of an asset.
     *  *
     * @param ModifyAssetImportantRequest $request ModifyAssetImportantRequest
     *
     * @return ModifyAssetImportantResponse ModifyAssetImportantResponse
     */
    public function modifyAssetImportant($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAssetImportantWithOptions($request, $runtime);
    }

    /**
     * @summary Specifies the number of days after which a detected vulnerability is automatically deleted.
     *  *
     * @param ModifyAutoDelConfigRequest $request ModifyAutoDelConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyAutoDelConfigResponse ModifyAutoDelConfigResponse
     */
    public function modifyAutoDelConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->days)) {
            $query['Days'] = $request->days;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyAutoDelConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyAutoDelConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Specifies the number of days after which a detected vulnerability is automatically deleted.
     *  *
     * @param ModifyAutoDelConfigRequest $request ModifyAutoDelConfigRequest
     *
     * @return ModifyAutoDelConfigResponse ModifyAutoDelConfigResponse
     */
    public function modifyAutoDelConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAutoDelConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an anti-ransomware policy.
     *  *
     * @param ModifyBackupPolicyRequest $tmpReq  ModifyBackupPolicyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyBackupPolicyResponse ModifyBackupPolicyResponse
     */
    public function modifyBackupPolicyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyBackupPolicyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->policy)) {
            $request->policyShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->policy, 'Policy', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->policyShrink)) {
            $query['Policy'] = $request->policyShrink;
        }
        if (!Utils::isUnset($request->policyRegionId)) {
            $query['PolicyRegionId'] = $request->policyRegionId;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an anti-ransomware policy.
     *  *
     * @param ModifyBackupPolicyRequest $request ModifyBackupPolicyRequest
     *
     * @return ModifyBackupPolicyResponse ModifyBackupPolicyResponse
     */
    public function modifyBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables an anti-ransomware policy.
     *  *
     * @param ModifyBackupPolicyStatusRequest $request ModifyBackupPolicyStatusRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyBackupPolicyStatusResponse ModifyBackupPolicyStatusResponse
     */
    public function modifyBackupPolicyStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyBackupPolicyStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyBackupPolicyStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables an anti-ransomware policy.
     *  *
     * @param ModifyBackupPolicyStatusRequest $request ModifyBackupPolicyStatusRequest
     *
     * @return ModifyBackupPolicyStatusResponse ModifyBackupPolicyStatusResponse
     */
    public function modifyBackupPolicyStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBackupPolicyStatusWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ModifyClearLogstoreStorageRequest $request ModifyClearLogstoreStorageRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClearLogstoreStorageResponse ModifyClearLogstoreStorageResponse
     */
    public function modifyClearLogstoreStorageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->userLogStore)) {
            $query['UserLogStore'] = $request->userLogStore;
        }
        if (!Utils::isUnset($request->userProject)) {
            $query['UserProject'] = $request->userProject;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClearLogstoreStorage',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClearLogstoreStorageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ModifyClearLogstoreStorageRequest $request ModifyClearLogstoreStorageRequest
     *
     * @return ModifyClearLogstoreStorageResponse ModifyClearLogstoreStorageResponse
     */
    public function modifyClearLogstoreStorage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClearLogstoreStorageWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the resource configurations of the Security Center agent.
     *  *
     * @param ModifyClientConfSetupRequest $request ModifyClientConfSetupRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClientConfSetupResponse ModifyClientConfSetupResponse
     */
    public function modifyClientConfSetupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->strategyConfig)) {
            $query['StrategyConfig'] = $request->strategyConfig;
        }
        if (!Utils::isUnset($request->strategyTag)) {
            $query['StrategyTag'] = $request->strategyTag;
        }
        if (!Utils::isUnset($request->strategyTagValue)) {
            $query['StrategyTagValue'] = $request->strategyTagValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClientConfSetup',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClientConfSetupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the resource configurations of the Security Center agent.
     *  *
     * @param ModifyClientConfSetupRequest $request ModifyClientConfSetupRequest
     *
     * @return ModifyClientConfSetupResponse ModifyClientConfSetupResponse
     */
    public function modifyClientConfSetup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClientConfSetupWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an agent configuration policy.
     *  *
     * @param ModifyClientConfStrategyRequest $request ModifyClientConfStrategyRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClientConfStrategyResponse ModifyClientConfStrategyResponse
     */
    public function modifyClientConfStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tag)) {
            $query['Tag'] = $request->tag;
        }
        if (!Utils::isUnset($request->tagExt)) {
            $query['TagExt'] = $request->tagExt;
        }
        if (!Utils::isUnset($request->tagValue)) {
            $query['TagValue'] = $request->tagValue;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClientConfStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClientConfStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an agent configuration policy.
     *  *
     * @param ModifyClientConfStrategyRequest $request ModifyClientConfStrategyRequest
     *
     * @return ModifyClientConfStrategyResponse ModifyClientConfStrategyResponse
     */
    public function modifyClientConfStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClientConfStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a custom defense rule.
     *  *
     * @param ModifyClientUserDefineRuleRequest $request ModifyClientUserDefineRuleRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClientUserDefineRuleResponse ModifyClientUserDefineRuleResponse
     */
    public function modifyClientUserDefineRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->actionType)) {
            $query['ActionType'] = $request->actionType;
        }
        if (!Utils::isUnset($request->cmdline)) {
            $query['Cmdline'] = $request->cmdline;
        }
        if (!Utils::isUnset($request->domain)) {
            $query['Domain'] = $request->domain;
        }
        if (!Utils::isUnset($request->filePath)) {
            $query['FilePath'] = $request->filePath;
        }
        if (!Utils::isUnset($request->IP)) {
            $query['IP'] = $request->IP;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->md5List)) {
            $query['Md5List'] = $request->md5List;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->newFilePath)) {
            $query['NewFilePath'] = $request->newFilePath;
        }
        if (!Utils::isUnset($request->parentCmdline)) {
            $query['ParentCmdline'] = $request->parentCmdline;
        }
        if (!Utils::isUnset($request->parentProcPath)) {
            $query['ParentProcPath'] = $request->parentProcPath;
        }
        if (!Utils::isUnset($request->platform)) {
            $query['Platform'] = $request->platform;
        }
        if (!Utils::isUnset($request->port)) {
            $query['Port'] = $request->port;
        }
        if (!Utils::isUnset($request->portStr)) {
            $query['PortStr'] = $request->portStr;
        }
        if (!Utils::isUnset($request->procPath)) {
            $query['ProcPath'] = $request->procPath;
        }
        if (!Utils::isUnset($request->registryContent)) {
            $query['RegistryContent'] = $request->registryContent;
        }
        if (!Utils::isUnset($request->registryKey)) {
            $query['RegistryKey'] = $request->registryKey;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClientUserDefineRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClientUserDefineRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a custom defense rule.
     *  *
     * @param ModifyClientUserDefineRuleRequest $request ModifyClientUserDefineRuleRequest
     *
     * @return ModifyClientUserDefineRuleResponse ModifyClientUserDefineRuleResponse
     */
    public function modifyClientUserDefineRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClientUserDefineRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Fixes the blocking status of clusters whose status is Normal to be confirmed.
     *  *
     * @param ModifyClusterCnnfStatusUserConfirmRequest $request ModifyClusterCnnfStatusUserConfirmRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyClusterCnnfStatusUserConfirmResponse ModifyClusterCnnfStatusUserConfirmResponse
     */
    public function modifyClusterCnnfStatusUserConfirmWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        if (!Utils::isUnset($request->userConfirm)) {
            $query['UserConfirm'] = $request->userConfirm;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyClusterCnnfStatusUserConfirm',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyClusterCnnfStatusUserConfirmResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Fixes the blocking status of clusters whose status is Normal to be confirmed.
     *  *
     * @param ModifyClusterCnnfStatusUserConfirmRequest $request ModifyClusterCnnfStatusUserConfirmRequest
     *
     * @return ModifyClusterCnnfStatusUserConfirmResponse ModifyClusterCnnfStatusUserConfirmResponse
     */
    public function modifyClusterCnnfStatusUserConfirm($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyClusterCnnfStatusUserConfirmWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the priority to fix vulnerabilities.
     *  *
     * @param ModifyConcernNecessityRequest $request ModifyConcernNecessityRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyConcernNecessityResponse ModifyConcernNecessityResponse
     */
    public function modifyConcernNecessityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->concernNecessity)) {
            $query['ConcernNecessity'] = $request->concernNecessity;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyConcernNecessity',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyConcernNecessityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the priority to fix vulnerabilities.
     *  *
     * @param ModifyConcernNecessityRequest $request ModifyConcernNecessityRequest
     *
     * @return ModifyConcernNecessityResponse ModifyConcernNecessityResponse
     */
    public function modifyConcernNecessity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyConcernNecessityWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a rule for non-image program defense.
     *  *
     * @param ModifyContainerDefenseRuleRequest $tmpReq  ModifyContainerDefenseRuleRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyContainerDefenseRuleResponse ModifyContainerDefenseRuleResponse
     */
    public function modifyContainerDefenseRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyContainerDefenseRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->whitelist)) {
            $request->whitelistShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->whitelist, 'Whitelist', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->scope)) {
            $query['Scope'] = $request->scope;
        }
        if (!Utils::isUnset($request->whitelistShrink)) {
            $query['Whitelist'] = $request->whitelistShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyContainerDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyContainerDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a rule for non-image program defense.
     *  *
     * @param ModifyContainerDefenseRuleRequest $request ModifyContainerDefenseRuleRequest
     *
     * @return ModifyContainerDefenseRuleResponse ModifyContainerDefenseRuleResponse
     */
    public function modifyContainerDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the status of non-image program defense rules.
     *  *
     * @param ModifyContainerDefenseRuleSwitchRequest $request ModifyContainerDefenseRuleSwitchRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyContainerDefenseRuleSwitchResponse ModifyContainerDefenseRuleSwitchResponse
     */
    public function modifyContainerDefenseRuleSwitchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleIds)) {
            $query['RuleIds'] = $request->ruleIds;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyContainerDefenseRuleSwitch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyContainerDefenseRuleSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the status of non-image program defense rules.
     *  *
     * @param ModifyContainerDefenseRuleSwitchRequest $request ModifyContainerDefenseRuleSwitchRequest
     *
     * @return ModifyContainerDefenseRuleSwitchResponse ModifyContainerDefenseRuleSwitchResponse
     */
    public function modifyContainerDefenseRuleSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerDefenseRuleSwitchWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the defense rule against container escapes.
     *  *
     * @param ModifyContainerPluginRuleRequest $request ModifyContainerPluginRuleRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyContainerPluginRuleResponse ModifyContainerPluginRuleResponse
     */
    public function modifyContainerPluginRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $query['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->selectedPolicy)) {
            $query['SelectedPolicy'] = $request->selectedPolicy;
        }
        if (!Utils::isUnset($request->whiteImages)) {
            $query['WhiteImages'] = $request->whiteImages;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyContainerPluginRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyContainerPluginRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the defense rule against container escapes.
     *  *
     * @param ModifyContainerPluginRuleRequest $request ModifyContainerPluginRuleRequest
     *
     * @return ModifyContainerPluginRuleResponse ModifyContainerPluginRuleResponse
     */
    public function modifyContainerPluginRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerPluginRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of vulnerability scan for a running container.
     *  *
     * @param ModifyContainerScanConfigRequest $request ModifyContainerScanConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyContainerScanConfigResponse ModifyContainerScanConfigResponse
     */
    public function modifyContainerScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appNames)) {
            $query['AppNames'] = $request->appNames;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyContainerScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyContainerScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of vulnerability scan for a running container.
     *  *
     * @param ModifyContainerScanConfigRequest $request ModifyContainerScanConfigRequest
     *
     * @return ModifyContainerScanConfigResponse ModifyContainerScanConfigResponse
     */
    public function modifyContainerScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyContainerScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
     *  *
     * @param ModifyCreateVulWhitelistRequest $request ModifyCreateVulWhitelistRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCreateVulWhitelistResponse ModifyCreateVulWhitelistResponse
     */
    public function modifyCreateVulWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->targetInfo)) {
            $query['TargetInfo'] = $request->targetInfo;
        }
        if (!Utils::isUnset($request->whitelist)) {
            $query['Whitelist'] = $request->whitelist;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCreateVulWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCreateVulWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
     *  *
     * @param ModifyCreateVulWhitelistRequest $request ModifyCreateVulWhitelistRequest
     *
     * @return ModifyCreateVulWhitelistResponse ModifyCreateVulWhitelistResponse
     */
    public function modifyCreateVulWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCreateVulWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a custom IP address blocking policy.
     *  *
     * @param ModifyCustomBlockRecordRequest $request ModifyCustomBlockRecordRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCustomBlockRecordResponse ModifyCustomBlockRecordResponse
     */
    public function modifyCustomBlockRecordWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->blockIp)) {
            $query['BlockIp'] = $request->blockIp;
        }
        if (!Utils::isUnset($request->bound)) {
            $query['Bound'] = $request->bound;
        }
        if (!Utils::isUnset($request->expireTime)) {
            $query['ExpireTime'] = $request->expireTime;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCustomBlockRecord',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCustomBlockRecordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a custom IP address blocking policy.
     *  *
     * @param ModifyCustomBlockRecordRequest $request ModifyCustomBlockRecordRequest
     *
     * @return ModifyCustomBlockRecordResponse ModifyCustomBlockRecordResponse
     */
    public function modifyCustomBlockRecord($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCustomBlockRecordWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
     *  *
     * @param ModifyCycleTaskRequest $request ModifyCycleTaskRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyCycleTaskResponse ModifyCycleTaskResponse
     */
    public function modifyCycleTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        if (!Utils::isUnset($request->enable)) {
            $query['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->firstDateStr)) {
            $query['FirstDateStr'] = $request->firstDateStr;
        }
        if (!Utils::isUnset($request->intervalPeriod)) {
            $query['IntervalPeriod'] = $request->intervalPeriod;
        }
        if (!Utils::isUnset($request->param)) {
            $query['Param'] = $request->param;
        }
        if (!Utils::isUnset($request->periodUnit)) {
            $query['PeriodUnit'] = $request->periodUnit;
        }
        if (!Utils::isUnset($request->targetEndTime)) {
            $query['TargetEndTime'] = $request->targetEndTime;
        }
        if (!Utils::isUnset($request->targetStartTime)) {
            $query['TargetStartTime'] = $request->targetStartTime;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyCycleTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyCycleTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
     *  *
     * @param ModifyCycleTaskRequest $request ModifyCycleTaskRequest
     *
     * @return ModifyCycleTaskResponse ModifyCycleTaskResponse
     */
    public function modifyCycleTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCycleTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Runs a scan task for urgent vulnerabilities.
     *  *
     * @param ModifyEmgVulSubmitRequest $request ModifyEmgVulSubmitRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyEmgVulSubmitResponse ModifyEmgVulSubmitResponse
     */
    public function modifyEmgVulSubmitWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->userAgreement)) {
            $query['UserAgreement'] = $request->userAgreement;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyEmgVulSubmit',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyEmgVulSubmitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Runs a scan task for urgent vulnerabilities.
     *  *
     * @param ModifyEmgVulSubmitRequest $request ModifyEmgVulSubmitRequest
     *
     * @return ModifyEmgVulSubmitResponse ModifyEmgVulSubmitResponse
     */
    public function modifyEmgVulSubmit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyEmgVulSubmitWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the name of a server group.
     *  *
     * @param ModifyGroupPropertyRequest $request ModifyGroupPropertyRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyGroupPropertyResponse ModifyGroupPropertyResponse
     */
    public function modifyGroupPropertyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->data)) {
            $query['Data'] = $request->data;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyGroupProperty',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyGroupPropertyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the name of a server group.
     *  *
     * @param ModifyGroupPropertyRequest $request ModifyGroupPropertyRequest
     *
     * @return ModifyGroupPropertyResponse ModifyGroupPropertyResponse
     */
    public function modifyGroupProperty($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyGroupPropertyWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of a scheduled image fix.
     *  *
     * @param ModifyImageFixCycleConfigRequest $request ModifyImageFixCycleConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyImageFixCycleConfigResponse ModifyImageFixCycleConfigResponse
     */
    public function modifyImageFixCycleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->imageFixCycle)) {
            $body['ImageFixCycle'] = $request->imageFixCycle;
        }
        if (!Utils::isUnset($request->imageFixSwitch)) {
            $body['ImageFixSwitch'] = $request->imageFixSwitch;
        }
        if (!Utils::isUnset($request->imageFixTarget)) {
            $body['ImageFixTarget'] = $request->imageFixTarget;
        }
        if (!Utils::isUnset($request->imageTimeRange)) {
            $body['ImageTimeRange'] = $request->imageTimeRange;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ModifyImageFixCycleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyImageFixCycleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of a scheduled image fix.
     *  *
     * @param ModifyImageFixCycleConfigRequest $request ModifyImageFixCycleConfigRequest
     *
     * @return ModifyImageFixCycleConfigResponse ModifyImageFixCycleConfigResponse
     */
    public function modifyImageFixCycleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyImageFixCycleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the transfer time of an image repository.
     *  *
     * @param ModifyImageRegistryRequest $request ModifyImageRegistryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyImageRegistryResponse ModifyImageRegistryResponse
     */
    public function modifyImageRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->id)) {
            $body['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->password)) {
            $body['Password'] = $request->password;
        }
        if (!Utils::isUnset($request->transPerHour)) {
            $body['TransPerHour'] = $request->transPerHour;
        }
        if (!Utils::isUnset($request->userName)) {
            $body['UserName'] = $request->userName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ModifyImageRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyImageRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the transfer time of an image repository.
     *  *
     * @param ModifyImageRegistryRequest $request ModifyImageRegistryRequest
     *
     * @return ModifyImageRegistryResponse ModifyImageRegistryResponse
     */
    public function modifyImageRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyImageRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the defense rule against brute-force attacks that is applied to a specified server.
     *  *
     * @param ModifyInstanceAntiBruteForceRuleRequest $request ModifyInstanceAntiBruteForceRuleRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyInstanceAntiBruteForceRuleResponse ModifyInstanceAntiBruteForceRuleResponse
     */
    public function modifyInstanceAntiBruteForceRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->newRuleId)) {
            $query['NewRuleId'] = $request->newRuleId;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyInstanceAntiBruteForceRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyInstanceAntiBruteForceRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the defense rule against brute-force attacks that is applied to a specified server.
     *  *
     * @param ModifyInstanceAntiBruteForceRuleRequest $request ModifyInstanceAntiBruteForceRuleRequest
     *
     * @return ModifyInstanceAntiBruteForceRuleResponse ModifyInstanceAntiBruteForceRuleResponse
     */
    public function modifyInstanceAntiBruteForceRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInstanceAntiBruteForceRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a proactive defense rule for containers.
     *  *
     * @param ModifyInterceptionRuleRequest $tmpReq  ModifyInterceptionRuleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyInterceptionRuleResponse ModifyInterceptionRuleResponse
     */
    public function modifyInterceptionRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyInterceptionRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->dstTarget)) {
            $request->dstTargetShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->dstTarget, 'DstTarget', 'json');
        }
        if (!Utils::isUnset($tmpReq->srcTarget)) {
            $request->srcTargetShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->srcTarget, 'SrcTarget', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dstTargetShrink)) {
            $query['DstTarget'] = $request->dstTargetShrink;
        }
        if (!Utils::isUnset($request->interceptType)) {
            $query['InterceptType'] = $request->interceptType;
        }
        if (!Utils::isUnset($request->orderIndex)) {
            $query['OrderIndex'] = $request->orderIndex;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        if (!Utils::isUnset($request->srcTargetShrink)) {
            $query['SrcTarget'] = $request->srcTargetShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyInterceptionRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyInterceptionRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a proactive defense rule for containers.
     *  *
     * @param ModifyInterceptionRuleRequest $request ModifyInterceptionRuleRequest
     *
     * @return ModifyInterceptionRuleResponse ModifyInterceptionRuleResponse
     */
    public function modifyInterceptionRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInterceptionRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables a proactive defense rule for containers.
     *  *
     * @param ModifyInterceptionRuleSwitchRequest $request ModifyInterceptionRuleSwitchRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyInterceptionRuleSwitchResponse ModifyInterceptionRuleSwitchResponse
     */
    public function modifyInterceptionRuleSwitchWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->ruleIds)) {
            $query['RuleIds'] = $request->ruleIds;
        }
        if (!Utils::isUnset($request->ruleSwitch)) {
            $query['RuleSwitch'] = $request->ruleSwitch;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyInterceptionRuleSwitch',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyInterceptionRuleSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables a proactive defense rule for containers.
     *  *
     * @param ModifyInterceptionRuleSwitchRequest $request ModifyInterceptionRuleSwitchRequest
     *
     * @return ModifyInterceptionRuleSwitchResponse ModifyInterceptionRuleSwitchResponse
     */
    public function modifyInterceptionRuleSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInterceptionRuleSwitchWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the information about a network object of the container firewall feature.
     *  *
     * @param ModifyInterceptionTargetRequest $request ModifyInterceptionTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyInterceptionTargetResponse ModifyInterceptionTargetResponse
     */
    public function modifyInterceptionTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appName)) {
            $query['AppName'] = $request->appName;
        }
        if (!Utils::isUnset($request->imageList)) {
            $query['ImageList'] = $request->imageList;
        }
        if (!Utils::isUnset($request->namespace_)) {
            $query['Namespace'] = $request->namespace_;
        }
        if (!Utils::isUnset($request->tagList)) {
            $query['TagList'] = $request->tagList;
        }
        if (!Utils::isUnset($request->targetId)) {
            $query['TargetId'] = $request->targetId;
        }
        if (!Utils::isUnset($request->targetName)) {
            $query['TargetName'] = $request->targetName;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyInterceptionTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyInterceptionTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the information about a network object of the container firewall feature.
     *  *
     * @param ModifyInterceptionTargetRequest $request ModifyInterceptionTargetRequest
     *
     * @return ModifyInterceptionTargetResponse ModifyInterceptionTargetResponse
     */
    public function modifyInterceptionTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInterceptionTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables the log analysis feature.
     *  *
     * @param ModifyLogMetaStatusRequest $request ModifyLogMetaStatusRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLogMetaStatusResponse ModifyLogMetaStatusResponse
     */
    public function modifyLogMetaStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->logStore)) {
            $query['LogStore'] = $request->logStore;
        }
        if (!Utils::isUnset($request->project)) {
            $query['Project'] = $request->project;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyLogMetaStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyLogMetaStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables the log analysis feature.
     *  *
     * @param ModifyLogMetaStatusRequest $request ModifyLogMetaStatusRequest
     *
     * @return ModifyLogMetaStatusResponse ModifyLogMetaStatusResponse
     */
    public function modifyLogMetaStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLogMetaStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the logon configuration for a specified asset.
     *  *
     * @param ModifyLoginBaseConfigRequest $request ModifyLoginBaseConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLoginBaseConfigResponse ModifyLoginBaseConfigResponse
     */
    public function modifyLoginBaseConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyLoginBaseConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyLoginBaseConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the logon configuration for a specified asset.
     *  *
     * @param ModifyLoginBaseConfigRequest $request ModifyLoginBaseConfigRequest
     *
     * @return ModifyLoginBaseConfigResponse ModifyLoginBaseConfigResponse
     */
    public function modifyLoginBaseConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLoginBaseConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables the logon security settings for an asset.
     *  *
     * @param ModifyLoginSwitchConfigRequest $request ModifyLoginSwitchConfigRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyLoginSwitchConfigResponse ModifyLoginSwitchConfigResponse
     */
    public function modifyLoginSwitchConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->item)) {
            $query['Item'] = $request->item;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyLoginSwitchConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyLoginSwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables the logon security settings for an asset.
     *  *
     * @param ModifyLoginSwitchConfigRequest $request ModifyLoginSwitchConfigRequest
     *
     * @return ModifyLoginSwitchConfigResponse ModifyLoginSwitchConfigResponse
     */
    public function modifyLoginSwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyLoginSwitchConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies notification settings.
     *  *
     * @param ModifyNoticeConfigRequest $request ModifyNoticeConfigRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyNoticeConfigResponse ModifyNoticeConfigResponse
     */
    public function modifyNoticeConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->project)) {
            $query['Project'] = $request->project;
        }
        if (!Utils::isUnset($request->route)) {
            $query['Route'] = $request->route;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->timeLimit)) {
            $query['TimeLimit'] = $request->timeLimit;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyNoticeConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyNoticeConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies notification settings.
     *  *
     * @param ModifyNoticeConfigRequest $request ModifyNoticeConfigRequest
     *
     * @return ModifyNoticeConfigResponse ModifyNoticeConfigResponse
     */
    public function modifyNoticeConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyNoticeConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Activates Simple Log Service.
     *  *
     * @description **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
     *  *
     * @param ModifyOpenLogShipperRequest $request ModifyOpenLogShipperRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyOpenLogShipperResponse ModifyOpenLogShipperResponse
     */
    public function modifyOpenLogShipperWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->resourceDirectoryAccountId)) {
            $query['ResourceDirectoryAccountId'] = $request->resourceDirectoryAccountId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyOpenLogShipper',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyOpenLogShipperResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Activates Simple Log Service.
     *  *
     * @description **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
     *  *
     * @param ModifyOpenLogShipperRequest $request ModifyOpenLogShipperRequest
     *
     * @return ModifyOpenLogShipperResponse ModifyOpenLogShipperResponse
     */
    public function modifyOpenLogShipper($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyOpenLogShipperWithOptions($request, $runtime);
    }

    /**
     * @summary Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
     *  *
     * @param ModifyOperateVulRequest $request ModifyOperateVulRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyOperateVulResponse ModifyOperateVulResponse
     */
    public function modifyOperateVulWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->info)) {
            $query['Info'] = $request->info;
        }
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyOperateVul',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyOperateVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
     *  *
     * @param ModifyOperateVulRequest $request ModifyOperateVulRequest
     *
     * @return ModifyOperateVulResponse ModifyOperateVulResponse
     */
    public function modifyOperateVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyOperateVulWithOptions($request, $runtime);
    }

    /**
     * @summary The new collection frequency of asset fingerprints. Valid values:
     * *   **0**: disabled, which indicates that the asset fingerprints are not automatically or periodically collected.
     * *   **1**: collects asset fingerprints once an hour.
     * *   **3**: collects asset fingerprints once every 3 hours.
     * *   **12**: collects asset fingerprints once every 12 hours.
     * *   **24**: collects asset fingerprints once a day.
     * *   **168**: collects asset fingerprints once every 7 days.
     *  *
     * @param ModifyPropertyScheduleConfigRequest $request ModifyPropertyScheduleConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyPropertyScheduleConfigResponse ModifyPropertyScheduleConfigResponse
     */
    public function modifyPropertyScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->scheduleTime)) {
            $query['ScheduleTime'] = $request->scheduleTime;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyPropertyScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyPropertyScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The new collection frequency of asset fingerprints. Valid values:
     * *   **0**: disabled, which indicates that the asset fingerprints are not automatically or periodically collected.
     * *   **1**: collects asset fingerprints once an hour.
     * *   **3**: collects asset fingerprints once every 3 hours.
     * *   **12**: collects asset fingerprints once every 12 hours.
     * *   **24**: collects asset fingerprints once a day.
     * *   **168**: collects asset fingerprints once every 7 days.
     *  *
     * @param ModifyPropertyScheduleConfigRequest $request ModifyPropertyScheduleConfigRequest
     *
     * @return ModifyPropertyScheduleConfigResponse ModifyPropertyScheduleConfigResponse
     */
    public function modifyPropertyScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPropertyScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Performs security check tasks on servers with a few clicks.
     *  *
     * @param ModifyPushAllTaskRequest $request ModifyPushAllTaskRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyPushAllTaskResponse ModifyPushAllTaskResponse
     */
    public function modifyPushAllTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->tasks)) {
            $query['Tasks'] = $request->tasks;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyPushAllTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyPushAllTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Performs security check tasks on servers with a few clicks.
     *  *
     * @param ModifyPushAllTaskRequest $request ModifyPushAllTaskRequest
     *
     * @return ModifyPushAllTaskResponse ModifyPushAllTaskResponse
     */
    public function modifyPushAllTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPushAllTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Refreshes the list of processes that are associated with a Linux software vulnerability.
     *  *
     * @param ModifyRefreshProcessInfoRequest $request ModifyRefreshProcessInfoRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyRefreshProcessInfoResponse ModifyRefreshProcessInfoResponse
     */
    public function modifyRefreshProcessInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyRefreshProcessInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyRefreshProcessInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Refreshes the list of processes that are associated with a Linux software vulnerability.
     *  *
     * @param ModifyRefreshProcessInfoRequest $request ModifyRefreshProcessInfoRequest
     *
     * @return ModifyRefreshProcessInfoResponse ModifyRefreshProcessInfoResponse
     */
    public function modifyRefreshProcessInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRefreshProcessInfoWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ModifyRiskCheckStatus is deprecated
     *  *
     * @summary Changes the status of a check item in the results of a check task. You can ignore or cancel ignoring a check item.
     *  *
     * @description This operation is phased out. You can use the following operations:
     * \\-To **ignore a check item**, use the AddCheckResultWhiteList operation.
     * \\-To **cancel ignoring a check item**, use the RemoveCheckResultWhiteList operation.
     *  *
     * Deprecated
     *
     * @param ModifyRiskCheckStatusRequest $request ModifyRiskCheckStatusRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyRiskCheckStatusResponse ModifyRiskCheckStatusResponse
     */
    public function modifyRiskCheckStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->itemId)) {
            $query['ItemId'] = $request->itemId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyRiskCheckStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyRiskCheckStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ModifyRiskCheckStatus is deprecated
     *  *
     * @summary Changes the status of a check item in the results of a check task. You can ignore or cancel ignoring a check item.
     *  *
     * @description This operation is phased out. You can use the following operations:
     * \\-To **ignore a check item**, use the AddCheckResultWhiteList operation.
     * \\-To **cancel ignoring a check item**, use the RemoveCheckResultWhiteList operation.
     *  *
     * Deprecated
     *
     * @param ModifyRiskCheckStatusRequest $request ModifyRiskCheckStatusRequest
     *
     * @return ModifyRiskCheckStatusResponse ModifyRiskCheckStatusResponse
     */
    public function modifyRiskCheckStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRiskCheckStatusWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ModifyRiskSingleResultStatus is deprecated
     *  *
     * @summary Modifies the status of a risk item that affects your assets. You can ignore the risk item or cancel ignoring the risk item.
     *  *
     * @description This operation is phased out. You can use the following operations:
     * \\-To **ignore a risk item**, use the AddCheckInstanceResultWhiteList operation.
     * \\-To **cancel ignoring a risk item**, use the RemoveCheckInstanceResultWhiteList operation.
     *  *
     * Deprecated
     *
     * @param ModifyRiskSingleResultStatusRequest $request ModifyRiskSingleResultStatusRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyRiskSingleResultStatusResponse ModifyRiskSingleResultStatusResponse
     */
    public function modifyRiskSingleResultStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ids)) {
            $query['Ids'] = $request->ids;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyRiskSingleResultStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyRiskSingleResultStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ModifyRiskSingleResultStatus is deprecated
     *  *
     * @summary Modifies the status of a risk item that affects your assets. You can ignore the risk item or cancel ignoring the risk item.
     *  *
     * @description This operation is phased out. You can use the following operations:
     * \\-To **ignore a risk item**, use the AddCheckInstanceResultWhiteList operation.
     * \\-To **cancel ignoring a risk item**, use the RemoveCheckInstanceResultWhiteList operation.
     *  *
     * Deprecated
     *
     * @param ModifyRiskSingleResultStatusRequest $request ModifyRiskSingleResultStatusRequest
     *
     * @return ModifyRiskSingleResultStatusResponse ModifyRiskSingleResultStatusResponse
     */
    public function modifyRiskSingleResultStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRiskSingleResultStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a rule for container tamper-proofing.
     *  *
     * @param ModifySasContainerWebDefenseRuleRequest $request ModifySasContainerWebDefenseRuleRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySasContainerWebDefenseRuleResponse ModifySasContainerWebDefenseRuleResponse
     */
    public function modifySasContainerWebDefenseRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pathConfDTOList)) {
            $query['PathConfDTOList'] = $request->pathConfDTOList;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifySasContainerWebDefenseRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySasContainerWebDefenseRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a rule for container tamper-proofing.
     *  *
     * @param ModifySasContainerWebDefenseRuleRequest $request ModifySasContainerWebDefenseRuleRequest
     *
     * @return ModifySasContainerWebDefenseRuleResponse ModifySasContainerWebDefenseRuleResponse
     */
    public function modifySasContainerWebDefenseRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySasContainerWebDefenseRuleWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ModifySecurityCheckScheduleConfig is deprecated
     *  *
     * @summary Specifies the time when an automatic configuration check is performed on cloud services.
     *  *
     * @description This operation is phased out. You can use the ChangeCheckConfig operation.
     *  *
     * Deprecated
     *
     * @param ModifySecurityCheckScheduleConfigRequest $request ModifySecurityCheckScheduleConfigRequest
     * @param RuntimeOptions                           $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySecurityCheckScheduleConfigResponse ModifySecurityCheckScheduleConfigResponse
     */
    public function modifySecurityCheckScheduleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->daysOfWeek)) {
            $query['DaysOfWeek'] = $request->daysOfWeek;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifySecurityCheckScheduleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySecurityCheckScheduleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ModifySecurityCheckScheduleConfig is deprecated
     *  *
     * @summary Specifies the time when an automatic configuration check is performed on cloud services.
     *  *
     * @description This operation is phased out. You can use the ChangeCheckConfig operation.
     *  *
     * Deprecated
     *
     * @param ModifySecurityCheckScheduleConfigRequest $request ModifySecurityCheckScheduleConfigRequest
     *
     * @return ModifySecurityCheckScheduleConfigResponse ModifySecurityCheckScheduleConfigResponse
     */
    public function modifySecurityCheckScheduleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySecurityCheckScheduleConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the alert handling rule for alerts that are added to the whitelist by asset.
     *  *
     * @param ModifySecurityEventMarkMissIndividuallyRequest $request ModifySecurityEventMarkMissIndividuallyRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifySecurityEventMarkMissIndividuallyResponse ModifySecurityEventMarkMissIndividuallyResponse
     */
    public function modifySecurityEventMarkMissIndividuallyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->deleteMarkMissParam)) {
            $body['DeleteMarkMissParam'] = $request->deleteMarkMissParam;
        }
        if (!Utils::isUnset($request->from)) {
            $body['From'] = $request->from;
        }
        if (!Utils::isUnset($request->insertMarkMissParam)) {
            $body['InsertMarkMissParam'] = $request->insertMarkMissParam;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ModifySecurityEventMarkMissIndividually',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifySecurityEventMarkMissIndividuallyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the alert handling rule for alerts that are added to the whitelist by asset.
     *  *
     * @param ModifySecurityEventMarkMissIndividuallyRequest $request ModifySecurityEventMarkMissIndividuallyRequest
     *
     * @return ModifySecurityEventMarkMissIndividuallyResponse ModifySecurityEventMarkMissIndividuallyResponse
     */
    public function modifySecurityEventMarkMissIndividually($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySecurityEventMarkMissIndividuallyWithOptions($request, $runtime);
    }

    /**
     * @summary Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
     *  *
     * @param ModifyStartVulScanRequest $request ModifyStartVulScanRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyStartVulScanResponse ModifyStartVulScanResponse
     */
    public function modifyStartVulScanWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->types)) {
            $query['Types'] = $request->types;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyStartVulScan',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyStartVulScanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
     *  *
     * @param ModifyStartVulScanRequest $request ModifyStartVulScanRequest
     *
     * @return ModifyStartVulScanResponse ModifyStartVulScanResponse
     */
    public function modifyStartVulScan($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStartVulScanWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a baseline check policy.
     *  *
     * @param ModifyStrategyRequest $request ModifyStrategyRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyStrategyResponse ModifyStrategyResponse
     */
    public function modifyStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->customType)) {
            $query['CustomType'] = $request->customType;
        }
        if (!Utils::isUnset($request->cycleDays)) {
            $query['CycleDays'] = $request->cycleDays;
        }
        if (!Utils::isUnset($request->cycleStartTime)) {
            $query['CycleStartTime'] = $request->cycleStartTime;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->riskCustomParams)) {
            $query['RiskCustomParams'] = $request->riskCustomParams;
        }
        if (!Utils::isUnset($request->riskSubTypeName)) {
            $query['RiskSubTypeName'] = $request->riskSubTypeName;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a baseline check policy.
     *  *
     * @param ModifyStrategyRequest $request ModifyStrategyRequest
     *
     * @return ModifyStrategyResponse ModifyStrategyResponse
     */
    public function modifyStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param ModifyStrategyTargetRequest $request ModifyStrategyTargetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyStrategyTargetResponse ModifyStrategyTargetResponse
     */
    public function modifyStrategyTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyStrategyTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyStrategyTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The source IP address of the request.
     *  *
     * @param ModifyStrategyTargetRequest $request ModifyStrategyTargetRequest
     *
     * @return ModifyStrategyTargetResponse ModifyStrategyTargetResponse
     */
    public function modifyStrategyTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyStrategyTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the names of the tags that are added to assets, or modifies the tags for assets.
     *  *
     * @param ModifyTagWithUuidRequest $request ModifyTagWithUuidRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyTagWithUuidResponse ModifyTagWithUuidResponse
     */
    public function modifyTagWithUuidWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->machineTypes)) {
            $query['MachineTypes'] = $request->machineTypes;
        }
        if (!Utils::isUnset($request->tagId)) {
            $query['TagId'] = $request->tagId;
        }
        if (!Utils::isUnset($request->tagList)) {
            $query['TagList'] = $request->tagList;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyTagWithUuid',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyTagWithUuidResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the names of the tags that are added to assets, or modifies the tags for assets.
     *  *
     * @param ModifyTagWithUuidRequest $request ModifyTagWithUuidRequest
     *
     * @return ModifyTagWithUuidResponse ModifyTagWithUuidResponse
     */
    public function modifyTagWithUuid($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyTagWithUuidWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an anti-ransomware policy for databases.
     *  *
     * @param ModifyUniBackupPolicyRequest $tmpReq  ModifyUniBackupPolicyRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyUniBackupPolicyResponse ModifyUniBackupPolicyResponse
     */
    public function modifyUniBackupPolicyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ModifyUniBackupPolicyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->fullPlan)) {
            $request->fullPlanShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->fullPlan, 'FullPlan', 'json');
        }
        if (!Utils::isUnset($tmpReq->incPlan)) {
            $request->incPlanShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->incPlan, 'IncPlan', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->accountName)) {
            $query['AccountName'] = $request->accountName;
        }
        if (!Utils::isUnset($request->accountPassword)) {
            $query['AccountPassword'] = $request->accountPassword;
        }
        if (!Utils::isUnset($request->fullPlanShrink)) {
            $query['FullPlan'] = $request->fullPlanShrink;
        }
        if (!Utils::isUnset($request->incPlanShrink)) {
            $query['IncPlan'] = $request->incPlanShrink;
        }
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        if (!Utils::isUnset($request->policyName)) {
            $query['PolicyName'] = $request->policyName;
        }
        if (!Utils::isUnset($request->policyStatus)) {
            $query['PolicyStatus'] = $request->policyStatus;
        }
        if (!Utils::isUnset($request->retention)) {
            $query['Retention'] = $request->retention;
        }
        if (!Utils::isUnset($request->speedLimiter)) {
            $query['SpeedLimiter'] = $request->speedLimiter;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyUniBackupPolicy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyUniBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an anti-ransomware policy for databases.
     *  *
     * @param ModifyUniBackupPolicyRequest $request ModifyUniBackupPolicyRequest
     *
     * @return ModifyUniBackupPolicyResponse ModifyUniBackupPolicyResponse
     */
    public function modifyUniBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyUniBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables a honeypot.
     *  *
     * @param ModifyVpcHoneyPotRequest $request ModifyVpcHoneyPotRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVpcHoneyPotResponse ModifyVpcHoneyPotResponse
     */
    public function modifyVpcHoneyPotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeyPotAction)) {
            $query['HoneyPotAction'] = $request->honeyPotAction;
        }
        if (!Utils::isUnset($request->vpcId)) {
            $query['VpcId'] = $request->vpcId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVpcHoneyPot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVpcHoneyPotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables a honeypot.
     *  *
     * @param ModifyVpcHoneyPotRequest $request ModifyVpcHoneyPotRequest
     *
     * @return ModifyVpcHoneyPotResponse ModifyVpcHoneyPotResponse
     */
    public function modifyVpcHoneyPot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVpcHoneyPotWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of the vulnerability scan feature.
     *  *
     * @param ModifyVulConfigRequest $request ModifyVulConfigRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVulConfigResponse ModifyVulConfigResponse
     */
    public function modifyVulConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVulConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVulConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of the vulnerability scan feature.
     *  *
     * @param ModifyVulConfigRequest $request ModifyVulConfigRequest
     *
     * @return ModifyVulConfigResponse ModifyVulConfigResponse
     */
    public function modifyVulConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of the vulnerability scan feature for a server.
     *  *
     * @param ModifyVulTargetRequest $request ModifyVulTargetRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVulTargetResponse ModifyVulTargetResponse
     */
    public function modifyVulTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVulTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVulTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of the vulnerability scan feature for a server.
     *  *
     * @param ModifyVulTargetRequest $request ModifyVulTargetRequest
     *
     * @return ModifyVulTargetResponse ModifyVulTargetResponse
     */
    public function modifyVulTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Configures vulnerability scan for a server.
     *  *
     * @param ModifyVulTargetConfigRequest $request ModifyVulTargetConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVulTargetConfigResponse ModifyVulTargetConfigResponse
     */
    public function modifyVulTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVulTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVulTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures vulnerability scan for a server.
     *  *
     * @param ModifyVulTargetConfigRequest $request ModifyVulTargetConfigRequest
     *
     * @return ModifyVulTargetConfigResponse ModifyVulTargetConfigResponse
     */
    public function modifyVulTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the servers that are added to a vulnerability whitelist.
     *  *
     * @param ModifyVulWhitelistTargetRequest $request ModifyVulWhitelistTargetRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyVulWhitelistTargetResponse ModifyVulWhitelistTargetResponse
     */
    public function modifyVulWhitelistTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->targetInfo)) {
            $query['TargetInfo'] = $request->targetInfo;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyVulWhitelistTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyVulWhitelistTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the servers that are added to a vulnerability whitelist.
     *  *
     * @param ModifyVulWhitelistTargetRequest $request ModifyVulWhitelistTargetRequest
     *
     * @return ModifyVulWhitelistTargetResponse ModifyVulWhitelistTargetResponse
     */
    public function modifyVulWhitelistTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyVulWhitelistTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a directory to protect for a specified server.
     *  *
     * @param ModifyWebLockCreateConfigRequest $request ModifyWebLockCreateConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockCreateConfigResponse ModifyWebLockCreateConfigResponse
     */
    public function modifyWebLockCreateConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defenceMode)) {
            $query['DefenceMode'] = $request->defenceMode;
        }
        if (!Utils::isUnset($request->dir)) {
            $query['Dir'] = $request->dir;
        }
        if (!Utils::isUnset($request->exclusiveDir)) {
            $query['ExclusiveDir'] = $request->exclusiveDir;
        }
        if (!Utils::isUnset($request->exclusiveFile)) {
            $query['ExclusiveFile'] = $request->exclusiveFile;
        }
        if (!Utils::isUnset($request->exclusiveFileType)) {
            $query['ExclusiveFileType'] = $request->exclusiveFileType;
        }
        if (!Utils::isUnset($request->inclusiveFile)) {
            $query['InclusiveFile'] = $request->inclusiveFile;
        }
        if (!Utils::isUnset($request->inclusiveFileType)) {
            $query['InclusiveFileType'] = $request->inclusiveFileType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->localBackupDir)) {
            $query['LocalBackupDir'] = $request->localBackupDir;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockCreateConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockCreateConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a directory to protect for a specified server.
     *  *
     * @param ModifyWebLockCreateConfigRequest $request ModifyWebLockCreateConfigRequest
     *
     * @return ModifyWebLockCreateConfigResponse ModifyWebLockCreateConfigResponse
     */
    public function modifyWebLockCreateConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockCreateConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a directory on a specified server from the protected directories of web tamper proofing.
     *  *
     * @description After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
     *  *
     * @param ModifyWebLockDeleteConfigRequest $request ModifyWebLockDeleteConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockDeleteConfigResponse ModifyWebLockDeleteConfigResponse
     */
    public function modifyWebLockDeleteConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockDeleteConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockDeleteConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a directory on a specified server from the protected directories of web tamper proofing.
     *  *
     * @description After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
     *  *
     * @param ModifyWebLockDeleteConfigRequest $request ModifyWebLockDeleteConfigRequest
     *
     * @return ModifyWebLockDeleteConfigResponse ModifyWebLockDeleteConfigResponse
     */
    public function modifyWebLockDeleteConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockDeleteConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the status of processes for web tamper proofing.
     *  *
     * @param ModifyWebLockProcessStatusRequest $request ModifyWebLockProcessStatusRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockProcessStatusResponse ModifyWebLockProcessStatusResponse
     */
    public function modifyWebLockProcessStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dealAll)) {
            $query['DealAll'] = $request->dealAll;
        }
        if (!Utils::isUnset($request->operateInfo)) {
            $query['OperateInfo'] = $request->operateInfo;
        }
        if (!Utils::isUnset($request->processPath)) {
            $query['ProcessPath'] = $request->processPath;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockProcessStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockProcessStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the status of processes for web tamper proofing.
     *  *
     * @param ModifyWebLockProcessStatusRequest $request ModifyWebLockProcessStatusRequest
     *
     * @return ModifyWebLockProcessStatusResponse ModifyWebLockProcessStatusResponse
     */
    public function modifyWebLockProcessStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockProcessStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Enables web tamper proofing for a specified server.
     *  *
     * @param ModifyWebLockStartRequest $request ModifyWebLockStartRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockStartResponse ModifyWebLockStartResponse
     */
    public function modifyWebLockStartWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defenceMode)) {
            $query['DefenceMode'] = $request->defenceMode;
        }
        if (!Utils::isUnset($request->dir)) {
            $query['Dir'] = $request->dir;
        }
        if (!Utils::isUnset($request->exclusiveDir)) {
            $query['ExclusiveDir'] = $request->exclusiveDir;
        }
        if (!Utils::isUnset($request->exclusiveFile)) {
            $query['ExclusiveFile'] = $request->exclusiveFile;
        }
        if (!Utils::isUnset($request->exclusiveFileType)) {
            $query['ExclusiveFileType'] = $request->exclusiveFileType;
        }
        if (!Utils::isUnset($request->inclusiveFileType)) {
            $query['InclusiveFileType'] = $request->inclusiveFileType;
        }
        if (!Utils::isUnset($request->localBackupDir)) {
            $query['LocalBackupDir'] = $request->localBackupDir;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockStart',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockStartResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables web tamper proofing for a specified server.
     *  *
     * @param ModifyWebLockStartRequest $request ModifyWebLockStartRequest
     *
     * @return ModifyWebLockStartResponse ModifyWebLockStartResponse
     */
    public function modifyWebLockStart($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockStartWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables web tamper proofing for a server.
     *  *
     * @param ModifyWebLockStatusRequest $request ModifyWebLockStatusRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockStatusResponse ModifyWebLockStatusResponse
     */
    public function modifyWebLockStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables web tamper proofing for a server.
     *  *
     * @param ModifyWebLockStatusRequest $request ModifyWebLockStatusRequest
     *
     * @return ModifyWebLockStatusResponse ModifyWebLockStatusResponse
     */
    public function modifyWebLockStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Disables web tamper proofing for a specified server.
     *  *
     * @param ModifyWebLockUnbindRequest $request ModifyWebLockUnbindRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockUnbindResponse ModifyWebLockUnbindResponse
     */
    public function modifyWebLockUnbindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockUnbind',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockUnbindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Disables web tamper proofing for a specified server.
     *  *
     * @param ModifyWebLockUnbindRequest $request ModifyWebLockUnbindRequest
     *
     * @return ModifyWebLockUnbindResponse ModifyWebLockUnbindResponse
     */
    public function modifyWebLockUnbind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockUnbindWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the protection policy for a specified server.
     *  *
     * @param ModifyWebLockUpdateConfigRequest $request ModifyWebLockUpdateConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebLockUpdateConfigResponse ModifyWebLockUpdateConfigResponse
     */
    public function modifyWebLockUpdateConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->defenceMode)) {
            $query['DefenceMode'] = $request->defenceMode;
        }
        if (!Utils::isUnset($request->dir)) {
            $query['Dir'] = $request->dir;
        }
        if (!Utils::isUnset($request->exclusiveDir)) {
            $query['ExclusiveDir'] = $request->exclusiveDir;
        }
        if (!Utils::isUnset($request->exclusiveFile)) {
            $query['ExclusiveFile'] = $request->exclusiveFile;
        }
        if (!Utils::isUnset($request->exclusiveFileType)) {
            $query['ExclusiveFileType'] = $request->exclusiveFileType;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->inclusiveFile)) {
            $query['InclusiveFile'] = $request->inclusiveFile;
        }
        if (!Utils::isUnset($request->inclusiveFileType)) {
            $query['InclusiveFileType'] = $request->inclusiveFileType;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->localBackupDir)) {
            $query['LocalBackupDir'] = $request->localBackupDir;
        }
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebLockUpdateConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebLockUpdateConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the protection policy for a specified server.
     *  *
     * @param ModifyWebLockUpdateConfigRequest $request ModifyWebLockUpdateConfigRequest
     *
     * @return ModifyWebLockUpdateConfigResponse ModifyWebLockUpdateConfigResponse
     */
    public function modifyWebLockUpdateConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebLockUpdateConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a custom web directory.
     *  *
     * @param ModifyWebPathRequest $request ModifyWebPathRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ModifyWebPathResponse ModifyWebPathResponse
     */
    public function modifyWebPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ModifyWebPath',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ModifyWebPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a custom web directory.
     *  *
     * @param ModifyWebPathRequest $request ModifyWebPathRequest
     *
     * @return ModifyWebPathResponse ModifyWebPathResponse
     */
    public function modifyWebPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWebPathWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param OpenPartialBuyRequest $request OpenPartialBuyRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenPartialBuyResponse OpenPartialBuyResponse
     */
    public function openPartialBuyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceId)) {
            $query['InstanceId'] = $request->instanceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OpenPartialBuy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OpenPartialBuyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param OpenPartialBuyRequest $request OpenPartialBuyRequest
     *
     * @return OpenPartialBuyResponse OpenPartialBuyResponse
     */
    public function openPartialBuy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openPartialBuyWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables sensitive file scan.
     *  *
     * @param OpenSensitiveFileScanRequest $request OpenSensitiveFileScanRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return OpenSensitiveFileScanResponse OpenSensitiveFileScanResponse
     */
    public function openSensitiveFileScanWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->switchOn)) {
            $query['SwitchOn'] = $request->switchOn;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OpenSensitiveFileScan',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OpenSensitiveFileScanResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables sensitive file scan.
     *  *
     * @param OpenSensitiveFileScanRequest $request OpenSensitiveFileScanRequest
     *
     * @return OpenSensitiveFileScanResponse OpenSensitiveFileScanResponse
     */
    public function openSensitiveFileScan($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openSensitiveFileScanWithOptions($request, $runtime);
    }

    /**
     * @summary Installs the Security Center agent on servers.
     *  *
     * @param OperateAgentClientInstallRequest $request OperateAgentClientInstallRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateAgentClientInstallResponse OperateAgentClientInstallResponse
     */
    public function operateAgentClientInstallWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->os)) {
            $query['Os'] = $request->os;
        }
        if (!Utils::isUnset($request->region)) {
            $query['Region'] = $request->region;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateAgentClientInstall',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateAgentClientInstallResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Installs the Security Center agent on servers.
     *  *
     * @param OperateAgentClientInstallRequest $request OperateAgentClientInstallRequest
     *
     * @return OperateAgentClientInstallResponse OperateAgentClientInstallResponse
     */
    public function operateAgentClientInstall($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateAgentClientInstallWithOptions($request, $runtime);
    }

    /**
     * @summary Adds or deletes container applications for tamper proofing.
     *  *
     * @param OperateApplicationRequest $request OperateApplicationRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateApplicationResponse OperateApplicationResponse
     */
    public function operateApplicationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->containerWebDefenseApplicationDTOS)) {
            $query['ContainerWebDefenseApplicationDTOS'] = $request->containerWebDefenseApplicationDTOS;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateApplication',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateApplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds or deletes container applications for tamper proofing.
     *  *
     * @param OperateApplicationRequest $request OperateApplicationRequest
     *
     * @return OperateApplicationResponse OperateApplicationResponse
     */
    public function operateApplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateApplicationWithOptions($request, $runtime);
    }

    /**
     * @summary Manages an Object Storage Service (OSS) bucket check task.
     *  *
     * @param OperateBucketScanTaskRequest $request OperateBucketScanTaskRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateBucketScanTaskResponse OperateBucketScanTaskResponse
     */
    public function operateBucketScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bucketName)) {
            $query['BucketName'] = $request->bucketName;
        }
        if (!Utils::isUnset($request->operateCode)) {
            $query['OperateCode'] = $request->operateCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateBucketScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateBucketScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Manages an Object Storage Service (OSS) bucket check task.
     *  *
     * @param OperateBucketScanTaskRequest $request OperateBucketScanTaskRequest
     *
     * @return OperateBucketScanTaskResponse OperateBucketScanTaskResponse
     */
    public function operateBucketScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateBucketScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables a feature by type.
     *  *
     * @param OperateCommonOverallConfigRequest $request OperateCommonOverallConfigRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateCommonOverallConfigResponse OperateCommonOverallConfigResponse
     */
    public function operateCommonOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->noTargetAsOn)) {
            $query['NoTargetAsOn'] = $request->noTargetAsOn;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateCommonOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateCommonOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables a feature by type.
     *  *
     * @param OperateCommonOverallConfigRequest $request OperateCommonOverallConfigRequest
     *
     * @return OperateCommonOverallConfigResponse OperateCommonOverallConfigResponse
     */
    public function operateCommonOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateCommonOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
     *  *
     * @param OperateCommonTargetConfigRequest $request OperateCommonTargetConfigRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateCommonTargetConfigResponse OperateCommonTargetConfigResponse
     */
    public function operateCommonTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fieldName)) {
            $query['FieldName'] = $request->fieldName;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->targetOperations)) {
            $query['TargetOperations'] = $request->targetOperations;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateCommonTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateCommonTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
     *  *
     * @param OperateCommonTargetConfigRequest $request OperateCommonTargetConfigRequest
     *
     * @return OperateCommonTargetConfigResponse OperateCommonTargetConfigResponse
     */
    public function operateCommonTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateCommonTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
     *  *
     * @param OperateImageBaselineWhitelistRequest $request OperateImageBaselineWhitelistRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateImageBaselineWhitelistResponse OperateImageBaselineWhitelistResponse
     */
    public function operateImageBaselineWhitelistWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineItemKeyList)) {
            $query['BaselineItemKeyList'] = $request->baselineItemKeyList;
        }
        if (!Utils::isUnset($request->imageUuid)) {
            $query['ImageUuid'] = $request->imageUuid;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->operation)) {
            $query['Operation'] = $request->operation;
        }
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateImageBaselineWhitelist',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateImageBaselineWhitelistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
     *  *
     * @param OperateImageBaselineWhitelistRequest $request OperateImageBaselineWhitelistRequest
     *
     * @return OperateImageBaselineWhitelistResponse OperateImageBaselineWhitelistResponse
     */
    public function operateImageBaselineWhitelist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateImageBaselineWhitelistWithOptions($request, $runtime);
    }

    /**
     * @summary Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
     *  *
     * @param OperateImageVulRequest $request OperateImageVulRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateImageVulResponse OperateImageVulResponse
     */
    public function operateImageVulWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->info)) {
            $query['Info'] = $request->info;
        }
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateImageVul',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateImageVulResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
     *  *
     * @param OperateImageVulRequest $request OperateImageVulRequest
     *
     * @return OperateImageVulResponse OperateImageVulResponse
     */
    public function operateImageVul($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateImageVulWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables a feature that detects exceptions.
     *  *
     * @param OperateSuspiciousOverallConfigRequest $request OperateSuspiciousOverallConfigRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateSuspiciousOverallConfigResponse OperateSuspiciousOverallConfigResponse
     */
    public function operateSuspiciousOverallConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->noTargetAsOn)) {
            $query['NoTargetAsOn'] = $request->noTargetAsOn;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateSuspiciousOverallConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateSuspiciousOverallConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables a feature that detects exceptions.
     *  *
     * @param OperateSuspiciousOverallConfigRequest $request OperateSuspiciousOverallConfigRequest
     *
     * @return OperateSuspiciousOverallConfigResponse OperateSuspiciousOverallConfigResponse
     */
    public function operateSuspiciousOverallConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateSuspiciousOverallConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Configures the scope on which proactive defense takes effect.
     *  *
     * @param OperateSuspiciousTargetConfigRequest $request OperateSuspiciousTargetConfigRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateSuspiciousTargetConfigResponse OperateSuspiciousTargetConfigResponse
     */
    public function operateSuspiciousTargetConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->targetOperations)) {
            $query['TargetOperations'] = $request->targetOperations;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateSuspiciousTargetConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateSuspiciousTargetConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures the scope on which proactive defense takes effect.
     *  *
     * @param OperateSuspiciousTargetConfigRequest $request OperateSuspiciousTargetConfigRequest
     *
     * @return OperateSuspiciousTargetConfigResponse OperateSuspiciousTargetConfigResponse
     */
    public function operateSuspiciousTargetConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateSuspiciousTargetConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the status of a rule for container tamper-proofing.
     *  *
     * @param OperateSwitchStatusRequest $request OperateSwitchStatusRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateSwitchStatusResponse OperateSwitchStatusResponse
     */
    public function operateSwitchStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->ruleId)) {
            $query['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateSwitchStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateSwitchStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the status of a rule for container tamper-proofing.
     *  *
     * @param OperateSwitchStatusRequest $request OperateSwitchStatusRequest
     *
     * @return OperateSwitchStatusResponse OperateSwitchStatusResponse
     */
    public function operateSwitchStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateSwitchStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
     *  *
     * @param OperateVirusEventsRequest $request OperateVirusEventsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateVirusEventsResponse OperateVirusEventsResponse
     */
    public function operateVirusEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->operationAll)) {
            $query['OperationAll'] = $request->operationAll;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        if (!Utils::isUnset($request->operationRange)) {
            $query['OperationRange'] = $request->operationRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateVirusEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateVirusEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
     *  *
     * @param OperateVirusEventsRequest $request OperateVirusEventsRequest
     *
     * @return OperateVirusEventsResponse OperateVirusEventsResponse
     */
    public function operateVirusEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateVirusEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Fixes Linux software vulnerabilities.
     *  *
     * @param OperateVulsRequest $request OperateVulsRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateVulsResponse OperateVulsResponse
     */
    public function operateVulsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->operateType)) {
            $query['OperateType'] = $request->operateType;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->vulNames)) {
            $query['VulNames'] = $request->vulNames;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateVuls',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateVulsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Fixes Linux software vulnerabilities.
     *  *
     * @param OperateVulsRequest $request OperateVulsRequest
     *
     * @return OperateVulsResponse OperateVulsResponse
     */
    public function operateVuls($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateVulsWithOptions($request, $runtime);
    }

    /**
     * @summary Handles alert events that are generated for web tamper proofing.
     *  *
     * @param OperateWebLockFileEventsRequest $request OperateWebLockFileEventsRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return OperateWebLockFileEventsResponse OperateWebLockFileEventsResponse
     */
    public function operateWebLockFileEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dealAll)) {
            $query['DealAll'] = $request->dealAll;
        }
        if (!Utils::isUnset($request->eventIds)) {
            $query['EventIds'] = $request->eventIds;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $query['OperationCode'] = $request->operationCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperateWebLockFileEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperateWebLockFileEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles alert events that are generated for web tamper proofing.
     *  *
     * @param OperateWebLockFileEventsRequest $request OperateWebLockFileEventsRequest
     *
     * @return OperateWebLockFileEventsResponse OperateWebLockFileEventsResponse
     */
    public function operateWebLockFileEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operateWebLockFileEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Cancels ignoring alert events.
     *  *
     * @param OperationCancelIgnoreSuspEventRequest $request OperationCancelIgnoreSuspEventRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return OperationCancelIgnoreSuspEventResponse OperationCancelIgnoreSuspEventResponse
     */
    public function operationCancelIgnoreSuspEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        if (!Utils::isUnset($request->securityEventIds)) {
            $query['SecurityEventIds'] = $request->securityEventIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperationCancelIgnoreSuspEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperationCancelIgnoreSuspEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Cancels ignoring alert events.
     *  *
     * @param OperationCancelIgnoreSuspEventRequest $request OperationCancelIgnoreSuspEventRequest
     *
     * @return OperationCancelIgnoreSuspEventResponse OperationCancelIgnoreSuspEventResponse
     */
    public function operationCancelIgnoreSuspEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operationCancelIgnoreSuspEventWithOptions($request, $runtime);
    }

    /**
     * @summary Handles multiple exceptions at a time.
     *  *
     * @param OperationSuspEventsRequest $request OperationSuspEventsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return OperationSuspEventsResponse OperationSuspEventsResponse
     */
    public function operationSuspEventsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->operation)) {
            $query['Operation'] = $request->operation;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->subOperation)) {
            $query['SubOperation'] = $request->subOperation;
        }
        if (!Utils::isUnset($request->suspiciousEventIds)) {
            $query['SuspiciousEventIds'] = $request->suspiciousEventIds;
        }
        if (!Utils::isUnset($request->warnType)) {
            $query['WarnType'] = $request->warnType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'OperationSuspEvents',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OperationSuspEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Handles multiple exceptions at a time.
     *  *
     * @param OperationSuspEventsRequest $request OperationSuspEventsRequest
     *
     * @return OperationSuspEventsResponse OperationSuspEventsResponse
     */
    public function operationSuspEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->operationSuspEventsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries image repositories by page.
     *  *
     * @param PageImageRegistryRequest $request PageImageRegistryRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return PageImageRegistryResponse PageImageRegistryResponse
     */
    public function pageImageRegistryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->currentPage)) {
            $body['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->registryNameLike)) {
            $body['RegistryNameLike'] = $request->registryNameLike;
        }
        if (!Utils::isUnset($request->registryTypeInList)) {
            $body['RegistryTypeInList'] = $request->registryTypeInList;
        }
        if (!Utils::isUnset($request->registryTypeNotInList)) {
            $body['RegistryTypeNotInList'] = $request->registryTypeNotInList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'PageImageRegistry',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PageImageRegistryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries image repositories by page.
     *  *
     * @param PageImageRegistryRequest $request PageImageRegistryRequest
     *
     * @return PageImageRegistryResponse PageImageRegistryResponse
     */
    public function pageImageRegistry($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->pageImageRegistryWithOptions($request, $runtime);
    }

    /**
     * @summary Enables or disables the Security Center agent.
     *  *
     * @param PauseClientRequest $request PauseClientRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return PauseClientResponse PauseClientResponse
     */
    public function pauseClientWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        if (!Utils::isUnset($request->value)) {
            $query['Value'] = $request->value;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PauseClient',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PauseClientResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Enables or disables the Security Center agent.
     *  *
     * @param PauseClientRequest $request PauseClientRequest
     *
     * @return PauseClientResponse PauseClientResponse
     */
    public function pauseClient($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->pauseClientWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an image scan task.
     *  *
     * @description Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
     *  *
     * @param PublicCreateImageScanTaskRequest $request PublicCreateImageScanTaskRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return PublicCreateImageScanTaskResponse PublicCreateImageScanTaskResponse
     */
    public function publicCreateImageScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->digests)) {
            $query['Digests'] = $request->digests;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->regionIds)) {
            $query['RegionIds'] = $request->regionIds;
        }
        if (!Utils::isUnset($request->registryTypes)) {
            $query['RegistryTypes'] = $request->registryTypes;
        }
        if (!Utils::isUnset($request->repoIds)) {
            $query['RepoIds'] = $request->repoIds;
        }
        if (!Utils::isUnset($request->repoNames)) {
            $query['RepoNames'] = $request->repoNames;
        }
        if (!Utils::isUnset($request->repoNamespaces)) {
            $query['RepoNamespaces'] = $request->repoNamespaces;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PublicCreateImageScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublicCreateImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an image scan task.
     *  *
     * @description Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
     *  *
     * @param PublicCreateImageScanTaskRequest $request PublicCreateImageScanTaskRequest
     *
     * @return PublicCreateImageScanTaskResponse PublicCreateImageScanTaskResponse
     */
    public function publicCreateImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publicCreateImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param PublicPreCheckImageScanTaskRequest $request PublicPreCheckImageScanTaskRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return PublicPreCheckImageScanTaskResponse PublicPreCheckImageScanTaskResponse
     */
    public function publicPreCheckImageScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->digests)) {
            $query['Digests'] = $request->digests;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        if (!Utils::isUnset($request->regionIds)) {
            $query['RegionIds'] = $request->regionIds;
        }
        if (!Utils::isUnset($request->registryTypes)) {
            $query['RegistryTypes'] = $request->registryTypes;
        }
        if (!Utils::isUnset($request->repoIds)) {
            $query['RepoIds'] = $request->repoIds;
        }
        if (!Utils::isUnset($request->repoNames)) {
            $query['RepoNames'] = $request->repoNames;
        }
        if (!Utils::isUnset($request->repoNamespaces)) {
            $query['RepoNamespaces'] = $request->repoNamespaces;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->tags)) {
            $query['Tags'] = $request->tags;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PublicPreCheckImageScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublicPreCheckImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param PublicPreCheckImageScanTaskRequest $request PublicPreCheckImageScanTaskRequest
     *
     * @return PublicPreCheckImageScanTaskResponse PublicPreCheckImageScanTaskResponse
     */
    public function publicPreCheckImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publicPreCheckImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Adds images to Security Center and creates an image scan task to scan the images.
     *  *
     * @param PublicSyncAndCreateImageScanTaskRequest $request PublicSyncAndCreateImageScanTaskRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return PublicSyncAndCreateImageScanTaskResponse PublicSyncAndCreateImageScanTaskResponse
     */
    public function publicSyncAndCreateImageScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->images)) {
            $query['Images'] = $request->images;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'PublicSyncAndCreateImageScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublicSyncAndCreateImageScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds images to Security Center and creates an image scan task to scan the images.
     *  *
     * @param PublicSyncAndCreateImageScanTaskRequest $request PublicSyncAndCreateImageScanTaskRequest
     *
     * @return PublicSyncAndCreateImageScanTaskResponse PublicSyncAndCreateImageScanTaskResponse
     */
    public function publicSyncAndCreateImageScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publicSyncAndCreateImageScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of alert events in each attack phase.
     *  *
     * @param QueryAttackCountRequest $request QueryAttackCountRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryAttackCountResponse QueryAttackCountResponse
     */
    public function queryAttackCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $body = [];
        if (!Utils::isUnset($request->from)) {
            $body['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryAttackCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryAttackCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of alert events in each attack phase.
     *  *
     * @param QueryAttackCountRequest $request QueryAttackCountRequest
     *
     * @return QueryAttackCountResponse QueryAttackCountResponse
     */
    public function queryAttackCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryAttackCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a database scan task.
     *  *
     * @param QueryDiscoverDatabaseRequest $request QueryDiscoverDatabaseRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryDiscoverDatabaseResponse QueryDiscoverDatabaseResponse
     */
    public function queryDiscoverDatabaseWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->createMark)) {
            $query['CreateMark'] = $request->createMark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryDiscoverDatabase',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryDiscoverDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a database scan task.
     *  *
     * @param QueryDiscoverDatabaseRequest $request QueryDiscoverDatabaseRequest
     *
     * @return QueryDiscoverDatabaseResponse QueryDiscoverDatabaseResponse
     */
    public function queryDiscoverDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryDiscoverDatabaseWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the ID of an asset group by using the name of the asset group.
     *  *
     * @description You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param QueryGroupIdByGroupNameRequest $request QueryGroupIdByGroupNameRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryGroupIdByGroupNameResponse QueryGroupIdByGroupNameResponse
     */
    public function queryGroupIdByGroupNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->groupName)) {
            $query['GroupName'] = $request->groupName;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryGroupIdByGroupName',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryGroupIdByGroupNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the ID of an asset group by using the name of the asset group.
     *  *
     * @description You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
     * ### Limits
     * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
     *  *
     * @param QueryGroupIdByGroupNameRequest $request QueryGroupIdByGroupNameRequest
     *
     * @return QueryGroupIdByGroupNameResponse QueryGroupIdByGroupNameResponse
     */
    public function queryGroupIdByGroupName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryGroupIdByGroupNameWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whitelist rules.
     *  *
     * @param QueryGroupedSecurityEventMarkMissListRequest $request QueryGroupedSecurityEventMarkMissListRequest
     * @param RuntimeOptions                               $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryGroupedSecurityEventMarkMissListResponse QueryGroupedSecurityEventMarkMissListResponse
     */
    public function queryGroupedSecurityEventMarkMissListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->disposalWay)) {
            $query['DisposalWay'] = $request->disposalWay;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->currentPage)) {
            $body['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->eventName)) {
            $body['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->from)) {
            $body['From'] = $request->from;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remark)) {
            $body['Remark'] = $request->remark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryGroupedSecurityEventMarkMissList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryGroupedSecurityEventMarkMissListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whitelist rules.
     *  *
     * @param QueryGroupedSecurityEventMarkMissListRequest $request QueryGroupedSecurityEventMarkMissListRequest
     *
     * @return QueryGroupedSecurityEventMarkMissListResponse QueryGroupedSecurityEventMarkMissListResponse
     */
    public function queryGroupedSecurityEventMarkMissList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryGroupedSecurityEventMarkMissListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the icons that correspond to nodes and edges.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentIconListResponse QueryIncidentIconListResponse
     */
    public function queryIncidentIconListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'QueryIncidentIconList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentIconListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the icons that correspond to nodes and edges.
     *  *
     * @return QueryIncidentIconListResponse QueryIncidentIconListResponse
     */
    public function queryIncidentIconList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentIconListWithOptions($runtime);
    }

    /**
     * @summary Queries whether a node can be drilled down.
     *  *
     * @param QueryIncidentSubNodesCountRequest $request QueryIncidentSubNodesCountRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentSubNodesCountResponse QueryIncidentSubNodesCountResponse
     */
    public function queryIncidentSubNodesCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->body)) {
            $body['body'] = $request->body;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentSubNodesCount',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentSubNodesCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether a node can be drilled down.
     *  *
     * @param QueryIncidentSubNodesCountRequest $request QueryIncidentSubNodesCountRequest
     *
     * @return QueryIncidentSubNodesCountResponse QueryIncidentSubNodesCountResponse
     */
    public function queryIncidentSubNodesCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentSubNodesCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the provenance graph of an event by using the event ID.
     *  *
     * @param QueryIncidentTracingDetailRequest $request QueryIncidentTracingDetailRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentTracingDetailResponse QueryIncidentTracingDetailResponse
     */
    public function queryIncidentTracingDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->incidentId)) {
            $body['IncidentId'] = $request->incidentId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentTracingDetail',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentTracingDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the provenance graph of an event by using the event ID.
     *  *
     * @param QueryIncidentTracingDetailRequest $request QueryIncidentTracingDetailRequest
     *
     * @return QueryIncidentTracingDetailResponse QueryIncidentTracingDetailResponse
     */
    public function queryIncidentTracingDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentTracingDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries whether an event has a provenance graph based on the event ID.
     *  *
     * @param QueryIncidentTracingJudgeRequest $request QueryIncidentTracingJudgeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentTracingJudgeResponse QueryIncidentTracingJudgeResponse
     */
    public function queryIncidentTracingJudgeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->incidentId)) {
            $body['IncidentId'] = $request->incidentId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentTracingJudge',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentTracingJudgeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries whether an event has a provenance graph based on the event ID.
     *  *
     * @param QueryIncidentTracingJudgeRequest $request QueryIncidentTracingJudgeRequest
     *
     * @return QueryIncidentTracingJudgeResponse QueryIncidentTracingJudgeResponse
     */
    public function queryIncidentTracingJudge($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentTracingJudgeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the extended information about an event node.
     *  *
     * @param QueryIncidentVertexExtendInfoRequest $request QueryIncidentVertexExtendInfoRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentVertexExtendInfoResponse QueryIncidentVertexExtendInfoResponse
     */
    public function queryIncidentVertexExtendInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->offset)) {
            $body['Offset'] = $request->offset;
        }
        if (!Utils::isUnset($request->relationType)) {
            $body['RelationType'] = $request->relationType;
        }
        if (!Utils::isUnset($request->size)) {
            $body['Size'] = $request->size;
        }
        if (!Utils::isUnset($request->vertexId)) {
            $body['VertexId'] = $request->vertexId;
        }
        if (!Utils::isUnset($request->vertexLabel)) {
            $body['VertexLabel'] = $request->vertexLabel;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentVertexExtendInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentVertexExtendInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the extended information about an event node.
     *  *
     * @param QueryIncidentVertexExtendInfoRequest $request QueryIncidentVertexExtendInfoRequest
     *
     * @return QueryIncidentVertexExtendInfoResponse QueryIncidentVertexExtendInfoResponse
     */
    public function queryIncidentVertexExtendInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentVertexExtendInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the detailed information about an event node.
     *  *
     * @param QueryIncidentVertexNodesRequest $tmpReq  QueryIncidentVertexNodesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryIncidentVertexNodesResponse QueryIncidentVertexNodesResponse
     */
    public function queryIncidentVertexNodesWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new QueryIncidentVertexNodesShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->edgeLabelList)) {
            $request->edgeLabelListShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->edgeLabelList, 'EdgeLabelList', 'simple');
        }
        $body = [];
        if (!Utils::isUnset($request->edgeLabelListShrink)) {
            $body['EdgeLabelList'] = $request->edgeLabelListShrink;
        }
        if (!Utils::isUnset($request->offset)) {
            $body['Offset'] = $request->offset;
        }
        if (!Utils::isUnset($request->size)) {
            $body['Size'] = $request->size;
        }
        if (!Utils::isUnset($request->vertexId)) {
            $body['VertexId'] = $request->vertexId;
        }
        if (!Utils::isUnset($request->vertexLabel)) {
            $body['VertexLabel'] = $request->vertexLabel;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryIncidentVertexNodes',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryIncidentVertexNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the detailed information about an event node.
     *  *
     * @param QueryIncidentVertexNodesRequest $request QueryIncidentVertexNodesRequest
     *
     * @return QueryIncidentVertexNodesResponse QueryIncidentVertexNodesResponse
     */
    public function queryIncidentVertexNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryIncidentVertexNodesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the retention period of images that are stored in a Jenkins image repository.
     *  *
     * @param QueryJenkinsImageRegistryPersistenceDayRequest $request QueryJenkinsImageRegistryPersistenceDayRequest
     * @param RuntimeOptions                                 $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryJenkinsImageRegistryPersistenceDayResponse QueryJenkinsImageRegistryPersistenceDayResponse
     */
    public function queryJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryJenkinsImageRegistryPersistenceDay',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryJenkinsImageRegistryPersistenceDayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the retention period of images that are stored in a Jenkins image repository.
     *  *
     * @param QueryJenkinsImageRegistryPersistenceDayRequest $request QueryJenkinsImageRegistryPersistenceDayRequest
     *
     * @return QueryJenkinsImageRegistryPersistenceDayResponse QueryJenkinsImageRegistryPersistenceDayResponse
     */
    public function queryJenkinsImageRegistryPersistenceDay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the result of a database precheck task.
     *  *
     * @param QueryPreCheckDatabaseRequest $request QueryPreCheckDatabaseRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryPreCheckDatabaseResponse QueryPreCheckDatabaseResponse
     */
    public function queryPreCheckDatabaseWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->instanceUuid)) {
            $query['InstanceUuid'] = $request->instanceUuid;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->uniRegionId)) {
            $query['UniRegionId'] = $request->uniRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryPreCheckDatabase',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryPreCheckDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the result of a database precheck task.
     *  *
     * @param QueryPreCheckDatabaseRequest $request QueryPreCheckDatabaseRequest
     *
     * @return QueryPreCheckDatabaseResponse QueryPreCheckDatabaseResponse
     */
    public function queryPreCheckDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryPreCheckDatabaseWithOptions($request, $runtime);
    }

    /**
     * @summary Restarts a server. Only Windows servers are supported.
     *  *
     * @param RebootMachineRequest $request RebootMachineRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return RebootMachineResponse RebootMachineResponse
     */
    public function rebootMachineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RebootMachine',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RebootMachineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Restarts a server. Only Windows servers are supported.
     *  *
     * @param RebootMachineRequest $request RebootMachineRequest
     *
     * @return RebootMachineResponse RebootMachineResponse
     */
    public function rebootMachine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rebootMachineWithOptions($request, $runtime);
    }

    /**
     * @summary Synchronizes assets.
     *  *
     * @param RefreshAssetsRequest $request RefreshAssetsRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return RefreshAssetsResponse RefreshAssetsResponse
     */
    public function refreshAssetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        if (!Utils::isUnset($request->cloudAssetSubType)) {
            $query['CloudAssetSubType'] = $request->cloudAssetSubType;
        }
        if (!Utils::isUnset($request->cloudAssetType)) {
            $query['CloudAssetType'] = $request->cloudAssetType;
        }
        if (!Utils::isUnset($request->vendor)) {
            $query['Vendor'] = $request->vendor;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RefreshAssets',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RefreshAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Synchronizes assets.
     *  *
     * @param RefreshAssetsRequest $request RefreshAssetsRequest
     *
     * @return RefreshAssetsResponse RefreshAssetsResponse
     */
    public function refreshAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshAssetsWithOptions($request, $runtime);
    }

    /**
     * @summary Refreshes the statistics of container assets in the Assets module.
     *  *
     * @param RefreshContainerAssetsRequest $request RefreshContainerAssetsRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return RefreshContainerAssetsResponse RefreshContainerAssetsResponse
     */
    public function refreshContainerAssetsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->assetType)) {
            $query['AssetType'] = $request->assetType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RefreshContainerAssets',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RefreshContainerAssetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Refreshes the statistics of container assets in the Assets module.
     *  *
     * @param RefreshContainerAssetsRequest $request RefreshContainerAssetsRequest
     *
     * @return RefreshContainerAssetsResponse RefreshContainerAssetsResponse
     */
    public function refreshContainerAssets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshContainerAssetsWithOptions($request, $runtime);
    }

    /**
     * @summary Refreshes the list of Object Storage Service (OSS) buckets.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return RefreshOssBucketScanInfoResponse RefreshOssBucketScanInfoResponse
     */
    public function refreshOssBucketScanInfoWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'RefreshOssBucketScanInfo',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RefreshOssBucketScanInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Refreshes the list of Object Storage Service (OSS) buckets.
     *  *
     * @return RefreshOssBucketScanInfoResponse RefreshOssBucketScanInfoResponse
     */
    public function refreshOssBucketScanInfo()
    {
        $runtime = new RuntimeOptions([]);

        return $this->refreshOssBucketScanInfoWithOptions($runtime);
    }

    /**
     * @summary 
     *  *
     * @param ReleaseSasInstanceRequest $request ReleaseSasInstanceRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ReleaseSasInstanceResponse ReleaseSasInstanceResponse
     */
    public function releaseSasInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->chargeType)) {
            $body['ChargeType'] = $request->chargeType;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ReleaseSasInstance',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ReleaseSasInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ReleaseSasInstanceRequest $request ReleaseSasInstanceRequest
     *
     * @return ReleaseSasInstanceResponse ReleaseSasInstanceResponse
     */
    public function releaseSasInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseSasInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Removes an instance from the whitelist.
     *  *
     * @param RemoveCheckInstanceResultWhiteListRequest $request RemoveCheckInstanceResultWhiteListRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveCheckInstanceResultWhiteListResponse RemoveCheckInstanceResultWhiteListResponse
     */
    public function removeCheckInstanceResultWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveCheckInstanceResultWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveCheckInstanceResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes an instance from the whitelist.
     *  *
     * @param RemoveCheckInstanceResultWhiteListRequest $request RemoveCheckInstanceResultWhiteListRequest
     *
     * @return RemoveCheckInstanceResultWhiteListResponse RemoveCheckInstanceResultWhiteListResponse
     */
    public function removeCheckInstanceResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeCheckInstanceResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Removes check items from the whitelist.
     *  *
     * @param RemoveCheckResultWhiteListRequest $request RemoveCheckResultWhiteListRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveCheckResultWhiteListResponse RemoveCheckResultWhiteListResponse
     */
    public function removeCheckResultWhiteListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkGroupId)) {
            $query['CheckGroupId'] = $request->checkGroupId;
        }
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveCheckResultWhiteList',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveCheckResultWhiteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes check items from the whitelist.
     *  *
     * @param RemoveCheckResultWhiteListRequest $request RemoveCheckResultWhiteListRequest
     *
     * @return RemoveCheckResultWhiteListResponse RemoveCheckResultWhiteListResponse
     */
    public function removeCheckResultWhiteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeCheckResultWhiteListWithOptions($request, $runtime);
    }

    /**
     * @summary Resets a honeypot.
     *  *
     * @param ResetHoneypotRequest $request ResetHoneypotRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ResetHoneypotResponse ResetHoneypotResponse
     */
    public function resetHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ResetHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ResetHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Resets a honeypot.
     *  *
     * @param ResetHoneypotRequest $request ResetHoneypotRequest
     *
     * @return ResetHoneypotResponse ResetHoneypotResponse
     */
    public function resetHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resetHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Retries agentless detection tasks.
     *  *
     * @param RetryAgentlessTaskRequest $request RetryAgentlessTaskRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return RetryAgentlessTaskResponse RetryAgentlessTaskResponse
     */
    public function retryAgentlessTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RetryAgentlessTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RetryAgentlessTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Retries agentless detection tasks.
     *  *
     * @param RetryAgentlessTaskRequest $request RetryAgentlessTaskRequest
     *
     * @return RetryAgentlessTaskResponse RetryAgentlessTaskResponse
     */
    public function retryAgentlessTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->retryAgentlessTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Retry installing the honeypot probe.
     *  *
     * @param RetryInstallProbeRequest $request RetryInstallProbeRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return RetryInstallProbeResponse RetryInstallProbeResponse
     */
    public function retryInstallProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RetryInstallProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RetryInstallProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Retry installing the honeypot probe.
     *  *
     * @param RetryInstallProbeRequest $request RetryInstallProbeRequest
     *
     * @return RetryInstallProbeResponse RetryInstallProbeResponse
     */
    public function retryInstallProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->retryInstallProbeWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param RollbackSuspEventQuaraFileRequest $request RollbackSuspEventQuaraFileRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return RollbackSuspEventQuaraFileResponse RollbackSuspEventQuaraFileResponse
     */
    public function rollbackSuspEventQuaraFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->quaraFileId)) {
            $query['QuaraFileId'] = $request->quaraFileId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RollbackSuspEventQuaraFile',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RollbackSuspEventQuaraFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param RollbackSuspEventQuaraFileRequest $request RollbackSuspEventQuaraFileRequest
     *
     * @return RollbackSuspEventQuaraFileResponse RollbackSuspEventQuaraFileResponse
     */
    public function rollbackSuspEventQuaraFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rollbackSuspEventQuaraFileWithOptions($request, $runtime);
    }

    /**
     * @summary SasInstallCode
     *  *
     * @param SasInstallCodeRequest $request SasInstallCodeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return SasInstallCodeResponse SasInstallCodeResponse
     */
    public function sasInstallCodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SasInstallCode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SasInstallCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary SasInstallCode
     *  *
     * @param SasInstallCodeRequest $request SasInstallCodeRequest
     *
     * @return SasInstallCodeResponse SasInstallCodeResponse
     */
    public function sasInstallCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->sasInstallCodeWithOptions($request, $runtime);
    }

    /**
     * @summary Saves a baseline check policy for images.
     *  *
     * @param SaveImageBaselineStrategyRequest $request SaveImageBaselineStrategyRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return SaveImageBaselineStrategyResponse SaveImageBaselineStrategyResponse
     */
    public function saveImageBaselineStrategyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->baselineItemList)) {
            $query['BaselineItemList'] = $request->baselineItemList;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SaveImageBaselineStrategy',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SaveImageBaselineStrategyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Saves a baseline check policy for images.
     *  *
     * @param SaveImageBaselineStrategyRequest $request SaveImageBaselineStrategyRequest
     *
     * @return SaveImageBaselineStrategyResponse SaveImageBaselineStrategyResponse
     */
    public function saveImageBaselineStrategy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveImageBaselineStrategyWithOptions($request, $runtime);
    }

    /**
     * @summary Saves alert settings.
     *  *
     * @param SaveSuspEventUserSettingRequest $request SaveSuspEventUserSettingRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return SaveSuspEventUserSettingResponse SaveSuspEventUserSettingResponse
     */
    public function saveSuspEventUserSettingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->from)) {
            $query['From'] = $request->from;
        }
        if (!Utils::isUnset($request->levelsOn)) {
            $query['LevelsOn'] = $request->levelsOn;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SaveSuspEventUserSetting',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SaveSuspEventUserSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Saves alert settings.
     *  *
     * @param SaveSuspEventUserSettingRequest $request SaveSuspEventUserSettingRequest
     *
     * @return SaveSuspEventUserSettingResponse SaveSuspEventUserSettingResponse
     */
    public function saveSuspEventUserSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveSuspEventUserSettingWithOptions($request, $runtime);
    }

    /**
     * @summary Configures the status of the container firewall feature.
     *  *
     * @param SetClusterInterceptionConfigRequest $request SetClusterInterceptionConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return SetClusterInterceptionConfigResponse SetClusterInterceptionConfigResponse
     */
    public function setClusterInterceptionConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterIds)) {
            $query['ClusterIds'] = $request->clusterIds;
        }
        if (!Utils::isUnset($request->switchOn)) {
            $query['SwitchOn'] = $request->switchOn;
        }
        if (!Utils::isUnset($request->switchType)) {
            $query['SwitchType'] = $request->switchType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetClusterInterceptionConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetClusterInterceptionConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures the status of the container firewall feature.
     *  *
     * @param SetClusterInterceptionConfigRequest $request SetClusterInterceptionConfigRequest
     *
     * @return SetClusterInterceptionConfigResponse SetClusterInterceptionConfigResponse
     */
    public function setClusterInterceptionConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setClusterInterceptionConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the status of sensitive files in an image.
     *  *
     * @param SetImageSensitiveFileStatusRequest $request SetImageSensitiveFileStatusRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return SetImageSensitiveFileStatusResponse SetImageSensitiveFileStatusResponse
     */
    public function setImageSensitiveFileStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->imageUuids)) {
            $query['ImageUuids'] = $request->imageUuids;
        }
        if (!Utils::isUnset($request->sensitiveFileKey)) {
            $query['SensitiveFileKey'] = $request->sensitiveFileKey;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetImageSensitiveFileStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetImageSensitiveFileStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the status of sensitive files in an image.
     *  *
     * @param SetImageSensitiveFileStatusRequest $request SetImageSensitiveFileStatusRequest
     *
     * @return SetImageSensitiveFileStatusResponse SetImageSensitiveFileStatusResponse
     */
    public function setImageSensitiveFileStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setImageSensitiveFileStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Specifies a cycle to scan images for image repositories. Unit: days.
     *  *
     * @param SetRegistryScanDayNumRequest $request SetRegistryScanDayNumRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return SetRegistryScanDayNumResponse SetRegistryScanDayNumResponse
     */
    public function setRegistryScanDayNumWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->scanDayNum)) {
            $query['ScanDayNum'] = $request->scanDayNum;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetRegistryScanDayNum',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetRegistryScanDayNumResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Specifies a cycle to scan images for image repositories. Unit: days.
     *  *
     * @param SetRegistryScanDayNumRequest $request SetRegistryScanDayNumRequest
     *
     * @return SetRegistryScanDayNumResponse SetRegistryScanDayNumResponse
     */
    public function setRegistryScanDayNum($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setRegistryScanDayNumWithOptions($request, $runtime);
    }

    /**
     * @summary Configure the check rules of sensitive files.
     *  *
     * @param SetSensitiveDefineRuleConfigRequest $request SetSensitiveDefineRuleConfigRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return SetSensitiveDefineRuleConfigResponse SetSensitiveDefineRuleConfigResponse
     */
    public function setSensitiveDefineRuleConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->config)) {
            $query['Config'] = $request->config;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetSensitiveDefineRuleConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetSensitiveDefineRuleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configure the check rules of sensitive files.
     *  *
     * @param SetSensitiveDefineRuleConfigRequest $request SetSensitiveDefineRuleConfigRequest
     *
     * @return SetSensitiveDefineRuleConfigResponse SetSensitiveDefineRuleConfigResponse
     */
    public function setSensitiveDefineRuleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSensitiveDefineRuleConfigWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI StartBaselineSecurityCheck is deprecated
     *  *
     * @summary Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
     *  *
     * Deprecated
     *
     * @param StartBaselineSecurityCheckRequest $request StartBaselineSecurityCheckRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return StartBaselineSecurityCheckResponse StartBaselineSecurityCheckResponse
     */
    public function startBaselineSecurityCheckWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->itemIds)) {
            $query['ItemIds'] = $request->itemIds;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->resourceOwnerId)) {
            $query['ResourceOwnerId'] = $request->resourceOwnerId;
        }
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartBaselineSecurityCheck',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartBaselineSecurityCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI StartBaselineSecurityCheck is deprecated
     *  *
     * @summary Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
     *  *
     * Deprecated
     *
     * @param StartBaselineSecurityCheckRequest $request StartBaselineSecurityCheckRequest
     *
     * @return StartBaselineSecurityCheckResponse StartBaselineSecurityCheckResponse
     */
    public function startBaselineSecurityCheck($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startBaselineSecurityCheckWithOptions($request, $runtime);
    }

    /**
     * @summary Starts a database scan task.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return StartDiscoverDatabaseTaskResponse StartDiscoverDatabaseTaskResponse
     */
    public function startDiscoverDatabaseTaskWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'StartDiscoverDatabaseTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartDiscoverDatabaseTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a database scan task.
     *  *
     * @return StartDiscoverDatabaseTaskResponse StartDiscoverDatabaseTaskResponse
     */
    public function startDiscoverDatabaseTask()
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDiscoverDatabaseTaskWithOptions($runtime);
    }

    /**
     * @summary Starts a honeypot.
     *  *
     * @param StartHoneypotRequest $request StartHoneypotRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return StartHoneypotResponse StartHoneypotResponse
     */
    public function startHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a honeypot.
     *  *
     * @param StartHoneypotRequest $request StartHoneypotRequest
     *
     * @return StartHoneypotResponse StartHoneypotResponse
     */
    public function startHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Starts a database precheck task.
     *  *
     * @param StartPreCheckDatabaseRequest $request StartPreCheckDatabaseRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return StartPreCheckDatabaseResponse StartPreCheckDatabaseResponse
     */
    public function startPreCheckDatabaseWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->databaseType)) {
            $query['DatabaseType'] = $request->databaseType;
        }
        if (!Utils::isUnset($request->instanceUuid)) {
            $query['InstanceUuid'] = $request->instanceUuid;
        }
        if (!Utils::isUnset($request->uniRegionId)) {
            $query['UniRegionId'] = $request->uniRegionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartPreCheckDatabase',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartPreCheckDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a database precheck task.
     *  *
     * @param StartPreCheckDatabaseRequest $request StartPreCheckDatabaseRequest
     *
     * @return StartPreCheckDatabaseResponse StartPreCheckDatabaseResponse
     */
    public function startPreCheckDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startPreCheckDatabaseWithOptions($request, $runtime);
    }

    /**
     * @summary Performs a virus scan task on a server or multiple servers.
     *  *
     * @param StartVirusScanTaskRequest $request StartVirusScanTaskRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return StartVirusScanTaskResponse StartVirusScanTaskResponse
     */
    public function startVirusScanTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->targetInfo)) {
            $query['TargetInfo'] = $request->targetInfo;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartVirusScanTask',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartVirusScanTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Performs a virus scan task on a server or multiple servers.
     *  *
     * @param StartVirusScanTaskRequest $request StartVirusScanTaskRequest
     *
     * @return StartVirusScanTaskResponse StartVirusScanTaskResponse
     */
    public function startVirusScanTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startVirusScanTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a honeypot.
     *  *
     * @param StopHoneypotRequest $request StopHoneypotRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return StopHoneypotResponse StopHoneypotResponse
     */
    public function stopHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StopHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StopHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a honeypot.
     *  *
     * @param StopHoneypotRequest $request StopHoneypotRequest
     *
     * @return StopHoneypotResponse StopHoneypotResponse
     */
    public function stopHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Submits a configuration assessment task.
     *  *
     * @param SubmitCheckRequest $request SubmitCheckRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return SubmitCheckResponse SubmitCheckResponse
     */
    public function submitCheckWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->scanRange)) {
            $query['ScanRange'] = $request->scanRange;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SubmitCheck',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SubmitCheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Submits a configuration assessment task.
     *  *
     * @param SubmitCheckRequest $request SubmitCheckRequest
     *
     * @return SubmitCheckResponse SubmitCheckResponse
     */
    public function submitCheck($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitCheckWithOptions($request, $runtime);
    }

    /**
     * @summary Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
     *  *
     * @param UnMarkMonitorAccountsRequest $request UnMarkMonitorAccountsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UnMarkMonitorAccountsResponse UnMarkMonitorAccountsResponse
     */
    public function unMarkMonitorAccountsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->accountIds)) {
            $query['AccountIds'] = $request->accountIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnMarkMonitorAccounts',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnMarkMonitorAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
     *  *
     * @param UnMarkMonitorAccountsRequest $request UnMarkMonitorAccountsRequest
     *
     * @return UnMarkMonitorAccountsResponse UnMarkMonitorAccountsResponse
     */
    public function unMarkMonitorAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unMarkMonitorAccountsWithOptions($request, $runtime);
    }

    /**
     * @summary Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
     *  *
     * @description If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
     * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
     * **Prerequisites**
     * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
     * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
     *  *
     * @param UnbindAegisRequest $request UnbindAegisRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return UnbindAegisResponse UnbindAegisResponse
     */
    public function unbindAegisWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UnbindAegis',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UnbindAegisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
     *  *
     * @description If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
     * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
     * **Prerequisites**
     * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
     * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
     *  *
     * @param UnbindAegisRequest $request UnbindAegisRequest
     *
     * @return UnbindAegisResponse UnbindAegisResponse
     */
    public function unbindAegis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unbindAegisWithOptions($request, $runtime);
    }

    /**
     * @summary Uninstalls the anti-ransomware agent.
     *  *
     * @param UninstallBackupClientRequest $request UninstallBackupClientRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UninstallBackupClientResponse UninstallBackupClientResponse
     */
    public function uninstallBackupClientWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyVersion)) {
            $query['PolicyVersion'] = $request->policyVersion;
        }
        if (!Utils::isUnset($request->uuid)) {
            $query['Uuid'] = $request->uuid;
        }
        if (!Utils::isUnset($request->uuidList)) {
            $query['UuidList'] = $request->uuidList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UninstallBackupClient',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UninstallBackupClientResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Uninstalls the anti-ransomware agent.
     *  *
     * @param UninstallBackupClientRequest $request UninstallBackupClientRequest
     *
     * @return UninstallBackupClientResponse UninstallBackupClientResponse
     */
    public function uninstallBackupClient($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uninstallBackupClientWithOptions($request, $runtime);
    }

    /**
     * @summary Uninstalls the Runtime Application Self-Protection (RASP) agent that is installed on Elastic Compute Service (ECS) instances to enable automatic application protection.
     *  *
     * @param UninstallRaspAttachRequest $request UninstallRaspAttachRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return UninstallRaspAttachResponse UninstallRaspAttachResponse
     */
    public function uninstallRaspAttachWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->applicationId)) {
            $query['ApplicationId'] = $request->applicationId;
        }
        if (!Utils::isUnset($request->ecsUUIDList)) {
            $query['EcsUUIDList'] = $request->ecsUUIDList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UninstallRaspAttach',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UninstallRaspAttachResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Uninstalls the Runtime Application Self-Protection (RASP) agent that is installed on Elastic Compute Service (ECS) instances to enable automatic application protection.
     *  *
     * @param UninstallRaspAttachRequest $request UninstallRaspAttachRequest
     *
     * @return UninstallRaspAttachResponse UninstallRaspAttachResponse
     */
    public function uninstallRaspAttach($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uninstallRaspAttachWithOptions($request, $runtime);
    }

    /**
     * @summary Uninstalls the database backup agent.
     *  *
     * @param UninstallUniBackupAgentRequest $request UninstallUniBackupAgentRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UninstallUniBackupAgentResponse UninstallUniBackupAgentResponse
     */
    public function uninstallUniBackupAgentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->policyId)) {
            $query['PolicyId'] = $request->policyId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UninstallUniBackupAgent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UninstallUniBackupAgentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Uninstalls the database backup agent.
     *  *
     * @param UninstallUniBackupAgentRequest $request UninstallUniBackupAgentRequest
     *
     * @return UninstallUniBackupAgentResponse UninstallUniBackupAgentResponse
     */
    public function uninstallUniBackupAgent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uninstallUniBackupAgentWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the status of the honeypot installation time.
     *  *
     * @param UpdateAlarmEventRequest $request UpdateAlarmEventRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateAlarmEventResponse UpdateAlarmEventResponse
     */
    public function updateAlarmEventWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alarmEventIdList)) {
            $body['AlarmEventIdList'] = $request->alarmEventIdList;
        }
        if (!Utils::isUnset($request->lang)) {
            $body['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->operationCode)) {
            $body['OperationCode'] = $request->operationCode;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateAlarmEvent',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateAlarmEventResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the status of the honeypot installation time.
     *  *
     * @param UpdateAlarmEventRequest $request UpdateAlarmEventRequest
     *
     * @return UpdateAlarmEventResponse UpdateAlarmEventResponse
     */
    public function updateAlarmEvent($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAlarmEventWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies alerting settings for servers.
     *  *
     * @param UpdateClientAlertModeRequest $request UpdateClientAlertModeRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateClientAlertModeResponse UpdateClientAlertModeResponse
     */
    public function updateClientAlertModeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->mode)) {
            $query['Mode'] = $request->mode;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateClientAlertMode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateClientAlertModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies alerting settings for servers.
     *  *
     * @param UpdateClientAlertModeRequest $request UpdateClientAlertModeRequest
     *
     * @return UpdateClientAlertModeResponse UpdateClientAlertModeResponse
     */
    public function updateClientAlertMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateClientAlertModeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the settings of common switches.
     *  *
     * @param UpdateCommonSwitchConfigRequest $request UpdateCommonSwitchConfigRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateCommonSwitchConfigResponse UpdateCommonSwitchConfigResponse
     */
    public function updateCommonSwitchConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->targetDefault)) {
            $query['TargetDefault'] = $request->targetDefault;
        }
        if (!Utils::isUnset($request->type)) {
            $query['Type'] = $request->type;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateCommonSwitchConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateCommonSwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the settings of common switches.
     *  *
     * @param UpdateCommonSwitchConfigRequest $request UpdateCommonSwitchConfigRequest
     *
     * @return UpdateCommonSwitchConfigResponse UpdateCommonSwitchConfigResponse
     */
    public function updateCommonSwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCommonSwitchConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the status of core file monitoring events reported by the Security Center agent.
     *  *
     * @param UpdateFileProtectEventStatusRequest $request UpdateFileProtectEventStatusRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileProtectEventStatusResponse UpdateFileProtectEventStatusResponse
     */
    public function updateFileProtectEventStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateFileProtectEventStatus',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileProtectEventStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the status of core file monitoring events reported by the Security Center agent.
     *  *
     * @param UpdateFileProtectEventStatusRequest $request UpdateFileProtectEventStatusRequest
     *
     * @return UpdateFileProtectEventStatusResponse UpdateFileProtectEventStatusResponse
     */
    public function updateFileProtectEventStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileProtectEventStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Adds remarks to core file monitoring events reported by the Security Center agent.
     *  *
     * @param UpdateFileProtectRemarkRequest $request UpdateFileProtectRemarkRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileProtectRemarkResponse UpdateFileProtectRemarkResponse
     */
    public function updateFileProtectRemarkWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateFileProtectRemark',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileProtectRemarkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds remarks to core file monitoring events reported by the Security Center agent.
     *  *
     * @param UpdateFileProtectRemarkRequest $request UpdateFileProtectRemarkRequest
     *
     * @return UpdateFileProtectRemarkResponse UpdateFileProtectRemarkResponse
     */
    public function updateFileProtectRemark($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileProtectRemarkWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the content of a core file monitoring rule based on the ID of the rule.
     *  *
     * @param UpdateFileProtectRuleRequest $request UpdateFileProtectRuleRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileProtectRuleResponse UpdateFileProtectRuleResponse
     */
    public function updateFileProtectRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->alertLevel)) {
            $query['AlertLevel'] = $request->alertLevel;
        }
        if (!Utils::isUnset($request->fileOps)) {
            $query['FileOps'] = $request->fileOps;
        }
        if (!Utils::isUnset($request->filePaths)) {
            $query['FilePaths'] = $request->filePaths;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->procPaths)) {
            $query['ProcPaths'] = $request->procPaths;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $query['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateFileProtectRule',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileProtectRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the content of a core file monitoring rule based on the ID of the rule.
     *  *
     * @param UpdateFileProtectRuleRequest $request UpdateFileProtectRuleRequest
     *
     * @return UpdateFileProtectRuleResponse UpdateFileProtectRuleResponse
     */
    public function updateFileProtectRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileProtectRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param UpdateFileUploadLimitRequest $request UpdateFileUploadLimitRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileUploadLimitResponse UpdateFileUploadLimitResponse
     */
    public function updateFileUploadLimitWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->limit)) {
            $query['Limit'] = $request->limit;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateFileUploadLimit',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileUploadLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the queries per second (QPS) limit on the files uploaded from the client.
     *  *
     * @param UpdateFileUploadLimitRequest $request UpdateFileUploadLimitRequest
     *
     * @return UpdateFileUploadLimitResponse UpdateFileUploadLimitResponse
     */
    public function updateFileUploadLimit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileUploadLimitWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a specified honeypot.
     *  *
     * @param UpdateHoneypotRequest $request UpdateHoneypotRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotResponse UpdateHoneypotResponse
     */
    public function updateHoneypotWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->honeypotName)) {
            $query['HoneypotName'] = $request->honeypotName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->meta)) {
            $query['Meta'] = $request->meta;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypot',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a specified honeypot.
     *  *
     * @param UpdateHoneypotRequest $request UpdateHoneypotRequest
     *
     * @return UpdateHoneypotResponse UpdateHoneypotResponse
     */
    public function updateHoneypot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configuration of a specified management node.
     *  *
     * @param UpdateHoneypotNodeRequest $request UpdateHoneypotNodeRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotNodeResponse UpdateHoneypotNodeResponse
     */
    public function updateHoneypotNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->availableProbeNum)) {
            $query['AvailableProbeNum'] = $request->availableProbeNum;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $query['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->securityGroupProbeIpList)) {
            $query['SecurityGroupProbeIpList'] = $request->securityGroupProbeIpList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypotNode',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configuration of a specified management node.
     *  *
     * @param UpdateHoneypotNodeRequest $request UpdateHoneypotNodeRequest
     *
     * @return UpdateHoneypotNodeResponse UpdateHoneypotNodeResponse
     */
    public function updateHoneypotNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the configurations of the specified honeypot template.
     *  *
     * @param UpdateHoneypotPresetRequest $request UpdateHoneypotPresetRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotPresetResponse UpdateHoneypotPresetResponse
     */
    public function updateHoneypotPresetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->honeypotPresetId)) {
            $query['HoneypotPresetId'] = $request->honeypotPresetId;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->meta)) {
            $query['Meta'] = $request->meta;
        }
        if (!Utils::isUnset($request->presetName)) {
            $query['PresetName'] = $request->presetName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypotPreset',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotPresetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the configurations of the specified honeypot template.
     *  *
     * @param UpdateHoneypotPresetRequest $request UpdateHoneypotPresetRequest
     *
     * @return UpdateHoneypotPresetResponse UpdateHoneypotPresetResponse
     */
    public function updateHoneypotPreset($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotPresetWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the attributes of a specified probe.
     *  *
     * @param UpdateHoneypotProbeRequest $request UpdateHoneypotProbeRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotProbeResponse UpdateHoneypotProbeResponse
     */
    public function updateHoneypotProbeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->arp)) {
            $query['Arp'] = $request->arp;
        }
        if (!Utils::isUnset($request->displayName)) {
            $query['DisplayName'] = $request->displayName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->ping)) {
            $query['Ping'] = $request->ping;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        if (!Utils::isUnset($request->serviceIpList)) {
            $query['ServiceIpList'] = $request->serviceIpList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypotProbe',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the attributes of a specified probe.
     *  *
     * @param UpdateHoneypotProbeRequest $request UpdateHoneypotProbeRequest
     *
     * @return UpdateHoneypotProbeResponse UpdateHoneypotProbeResponse
     */
    public function updateHoneypotProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotProbeWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a probe service.
     *  *
     * @param UpdateHoneypotProbeBindRequest $request UpdateHoneypotProbeBindRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateHoneypotProbeBindResponse UpdateHoneypotProbeBindResponse
     */
    public function updateHoneypotProbeBindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->bindId)) {
            $query['BindId'] = $request->bindId;
        }
        if (!Utils::isUnset($request->bindPortList)) {
            $query['BindPortList'] = $request->bindPortList;
        }
        if (!Utils::isUnset($request->bindType)) {
            $query['BindType'] = $request->bindType;
        }
        if (!Utils::isUnset($request->currentPage)) {
            $query['CurrentPage'] = $request->currentPage;
        }
        if (!Utils::isUnset($request->honeypotId)) {
            $query['HoneypotId'] = $request->honeypotId;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->ports)) {
            $query['Ports'] = $request->ports;
        }
        if (!Utils::isUnset($request->probeId)) {
            $query['ProbeId'] = $request->probeId;
        }
        if (!Utils::isUnset($request->serviceIpList)) {
            $query['ServiceIpList'] = $request->serviceIpList;
        }
        if (!Utils::isUnset($request->setStatus)) {
            $query['SetStatus'] = $request->setStatus;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateHoneypotProbeBind',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateHoneypotProbeBindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a probe service.
     *  *
     * @param UpdateHoneypotProbeBindRequest $request UpdateHoneypotProbeBindRequest
     *
     * @return UpdateHoneypotProbeBindResponse UpdateHoneypotProbeBindResponse
     */
    public function updateHoneypotProbeBind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateHoneypotProbeBindWithOptions($request, $runtime);
    }

    /**
     * @summary Updates an alert handling rule.
     *  *
     * @param UpdateImageEventOperationRequest $request UpdateImageEventOperationRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateImageEventOperationResponse UpdateImageEventOperationResponse
     */
    public function updateImageEventOperationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->scenarios)) {
            $query['Scenarios'] = $request->scenarios;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateImageEventOperation',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateImageEventOperationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates an alert handling rule.
     *  *
     * @param UpdateImageEventOperationRequest $request UpdateImageEventOperationRequest
     *
     * @return UpdateImageEventOperationResponse UpdateImageEventOperationResponse
     */
    public function updateImageEventOperation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateImageEventOperationWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the vulnerability whitelist of an image.
     *  *
     * @param UpdateImageVulWhitelistTargetRequest $request UpdateImageVulWhitelistTargetRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateImageVulWhitelistTargetResponse UpdateImageVulWhitelistTargetResponse
     */
    public function updateImageVulWhitelistTargetWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->reason)) {
            $query['Reason'] = $request->reason;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->target)) {
            $query['Target'] = $request->target;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateImageVulWhitelistTarget',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateImageVulWhitelistTargetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the vulnerability whitelist of an image.
     *  *
     * @param UpdateImageVulWhitelistTargetRequest $request UpdateImageVulWhitelistTargetRequest
     *
     * @return UpdateImageVulWhitelistTargetResponse UpdateImageVulWhitelistTargetResponse
     */
    public function updateImageVulWhitelistTarget($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateImageVulWhitelistTargetWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the name of a Jenkins image repository.
     *  *
     * @param UpdateJenkinsImageRegistryNameRequest $request UpdateJenkinsImageRegistryNameRequest
     * @param RuntimeOptions                        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateJenkinsImageRegistryNameResponse UpdateJenkinsImageRegistryNameResponse
     */
    public function updateJenkinsImageRegistryNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->registryId)) {
            $body['RegistryId'] = $request->registryId;
        }
        if (!Utils::isUnset($request->registryName)) {
            $body['RegistryName'] = $request->registryName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateJenkinsImageRegistryName',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateJenkinsImageRegistryNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the name of a Jenkins image repository.
     *  *
     * @param UpdateJenkinsImageRegistryNameRequest $request UpdateJenkinsImageRegistryNameRequest
     *
     * @return UpdateJenkinsImageRegistryNameResponse UpdateJenkinsImageRegistryNameResponse
     */
    public function updateJenkinsImageRegistryName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateJenkinsImageRegistryNameWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the retention period of images that are stored in a Jenkins image repository.
     *  *
     * @param UpdateJenkinsImageRegistryPersistenceDayRequest $request UpdateJenkinsImageRegistryPersistenceDayRequest
     * @param RuntimeOptions                                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateJenkinsImageRegistryPersistenceDayResponse UpdateJenkinsImageRegistryPersistenceDayResponse
     */
    public function updateJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->sourceIp)) {
            $query['SourceIp'] = $request->sourceIp;
        }
        $body = [];
        if (!Utils::isUnset($request->persistenceDay)) {
            $body['PersistenceDay'] = $request->persistenceDay;
        }
        if (!Utils::isUnset($request->registryId)) {
            $body['RegistryId'] = $request->registryId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateJenkinsImageRegistryPersistenceDay',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateJenkinsImageRegistryPersistenceDayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the retention period of images that are stored in a Jenkins image repository.
     *  *
     * @param UpdateJenkinsImageRegistryPersistenceDayRequest $request UpdateJenkinsImageRegistryPersistenceDayRequest
     *
     * @return UpdateJenkinsImageRegistryPersistenceDayResponse UpdateJenkinsImageRegistryPersistenceDayResponse
     */
    public function updateJenkinsImageRegistryPersistenceDay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateJenkinsImageRegistryPersistenceDayWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param UpdateMaliciousFileWhitelistConfigRequest $request UpdateMaliciousFileWhitelistConfigRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMaliciousFileWhitelistConfigResponse UpdateMaliciousFileWhitelistConfigResponse
     */
    public function updateMaliciousFileWhitelistConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->configId)) {
            $query['ConfigId'] = $request->configId;
        }
        if (!Utils::isUnset($request->eventName)) {
            $query['EventName'] = $request->eventName;
        }
        if (!Utils::isUnset($request->field)) {
            $query['Field'] = $request->field;
        }
        if (!Utils::isUnset($request->fieldValue)) {
            $query['FieldValue'] = $request->fieldValue;
        }
        if (!Utils::isUnset($request->operator)) {
            $query['Operator'] = $request->operator;
        }
        if (!Utils::isUnset($request->source)) {
            $query['Source'] = $request->source;
        }
        if (!Utils::isUnset($request->targetType)) {
            $query['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->targetValue)) {
            $query['TargetValue'] = $request->targetValue;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateMaliciousFileWhitelistConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMaliciousFileWhitelistConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
     *  *
     * @param UpdateMaliciousFileWhitelistConfigRequest $request UpdateMaliciousFileWhitelistConfigRequest
     *
     * @return UpdateMaliciousFileWhitelistConfigResponse UpdateMaliciousFileWhitelistConfigResponse
     */
    public function updateMaliciousFileWhitelistConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMaliciousFileWhitelistConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the blocking rule for at-risk images.
     *  *
     * @param UpdateOpaStrategyNewRequest $tmpReq  UpdateOpaStrategyNewRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateOpaStrategyNewResponse UpdateOpaStrategyNewResponse
     */
    public function updateOpaStrategyNewWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateOpaStrategyNewShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->alarmDetail)) {
            $request->alarmDetailShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->alarmDetail, 'AlarmDetail', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->alarmDetailShrink)) {
            $query['AlarmDetail'] = $request->alarmDetailShrink;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->clusterName)) {
            $query['ClusterName'] = $request->clusterName;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->imageName)) {
            $query['ImageName'] = $request->imageName;
        }
        if (!Utils::isUnset($request->label)) {
            $query['Label'] = $request->label;
        }
        if (!Utils::isUnset($request->maliciousImage)) {
            $query['MaliciousImage'] = $request->maliciousImage;
        }
        if (!Utils::isUnset($request->ruleAction)) {
            $query['RuleAction'] = $request->ruleAction;
        }
        if (!Utils::isUnset($request->scopes)) {
            $query['Scopes'] = $request->scopes;
        }
        if (!Utils::isUnset($request->strategyId)) {
            $query['StrategyId'] = $request->strategyId;
        }
        if (!Utils::isUnset($request->strategyName)) {
            $query['StrategyName'] = $request->strategyName;
        }
        if (!Utils::isUnset($request->strategyTemplateId)) {
            $query['StrategyTemplateId'] = $request->strategyTemplateId;
        }
        if (!Utils::isUnset($request->unScanedImage)) {
            $query['UnScanedImage'] = $request->unScanedImage;
        }
        if (!Utils::isUnset($request->whiteList)) {
            $query['WhiteList'] = $request->whiteList;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateOpaStrategyNew',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateOpaStrategyNewResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the blocking rule for at-risk images.
     *  *
     * @param UpdateOpaStrategyNewRequest $request UpdateOpaStrategyNewRequest
     *
     * @return UpdateOpaStrategyNewResponse UpdateOpaStrategyNewResponse
     */
    public function updateOpaStrategyNew($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateOpaStrategyNewWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the configurations of a bucket check policy.
     *  *
     * @param UpdateOssScanConfigRequest $request UpdateOssScanConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateOssScanConfigResponse UpdateOssScanConfigResponse
     */
    public function updateOssScanConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->allKeyPrefix)) {
            $query['AllKeyPrefix'] = $request->allKeyPrefix;
        }
        if (!Utils::isUnset($request->bucketNameList)) {
            $query['BucketNameList'] = $request->bucketNameList;
        }
        if (!Utils::isUnset($request->decompressMaxFileCount)) {
            $query['DecompressMaxFileCount'] = $request->decompressMaxFileCount;
        }
        if (!Utils::isUnset($request->decompressMaxLayer)) {
            $query['DecompressMaxLayer'] = $request->decompressMaxLayer;
        }
        if (!Utils::isUnset($request->enable)) {
            $query['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->keyPrefixList)) {
            $query['KeyPrefixList'] = $request->keyPrefixList;
        }
        if (!Utils::isUnset($request->keySuffixList)) {
            $query['KeySuffixList'] = $request->keySuffixList;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->scanDayList)) {
            $query['ScanDayList'] = $request->scanDayList;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateOssScanConfig',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateOssScanConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the configurations of a bucket check policy.
     *  *
     * @param UpdateOssScanConfigRequest $request UpdateOssScanConfigRequest
     *
     * @return UpdateOssScanConfigResponse UpdateOssScanConfigResponse
     */
    public function updateOssScanConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateOssScanConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the unique identifier of an asset selection.
     *  *
     * @param UpdateSelectionKeyByTypeRequest $request UpdateSelectionKeyByTypeRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateSelectionKeyByTypeResponse UpdateSelectionKeyByTypeResponse
     */
    public function updateSelectionKeyByTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->businessType)) {
            $query['BusinessType'] = $request->businessType;
        }
        if (!Utils::isUnset($request->selectionKey)) {
            $query['SelectionKey'] = $request->selectionKey;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateSelectionKeyByType',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateSelectionKeyByTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the unique identifier of an asset selection.
     *  *
     * @param UpdateSelectionKeyByTypeRequest $request UpdateSelectionKeyByTypeRequest
     *
     * @return UpdateSelectionKeyByTypeResponse UpdateSelectionKeyByTypeResponse
     */
    public function updateSelectionKeyByType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateSelectionKeyByTypeWithOptions($request, $runtime);
    }

    /**
     * @summary Upgrades the version of an anti-ransomware policy.
     *  *
     * @param UpgradeBackupPolicyVersionRequest $request UpgradeBackupPolicyVersionRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return UpgradeBackupPolicyVersionResponse UpgradeBackupPolicyVersionResponse
     */
    public function upgradeBackupPolicyVersionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->id)) {
            $query['Id'] = $request->id;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpgradeBackupPolicyVersion',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpgradeBackupPolicyVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Upgrades the version of an anti-ransomware policy.
     *  *
     * @param UpgradeBackupPolicyVersionRequest $request UpgradeBackupPolicyVersionRequest
     *
     * @return UpgradeBackupPolicyVersionResponse UpgradeBackupPolicyVersionResponse
     */
    public function upgradeBackupPolicyVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeBackupPolicyVersionWithOptions($request, $runtime);
    }

    /**
     * @summary Uploads a honeypot file.
     *  *
     * @param UploadedHoneyPotFileRequest $request UploadedHoneyPotFileRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UploadedHoneyPotFileResponse UploadedHoneyPotFileResponse
     */
    public function uploadedHoneyPotFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileKey)) {
            $query['FileKey'] = $request->fileKey;
        }
        if (!Utils::isUnset($request->fileName)) {
            $query['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->fileType)) {
            $query['FileType'] = $request->fileType;
        }
        if (!Utils::isUnset($request->honeypotImageName)) {
            $query['HoneypotImageName'] = $request->honeypotImageName;
        }
        if (!Utils::isUnset($request->lang)) {
            $query['Lang'] = $request->lang;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $query['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->templateExtra)) {
            $query['TemplateExtra'] = $request->templateExtra;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UploadedHoneyPotFile',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UploadedHoneyPotFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Uploads a honeypot file.
     *  *
     * @param UploadedHoneyPotFileRequest $request UploadedHoneyPotFileRequest
     *
     * @return UploadedHoneyPotFileResponse UploadedHoneyPotFileResponse
     */
    public function uploadedHoneyPotFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->uploadedHoneyPotFileWithOptions($request, $runtime);
    }

    /**
     * @summary Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
     *  *
     * @param ValidateHcWarningsRequest $request ValidateHcWarningsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ValidateHcWarningsResponse ValidateHcWarningsResponse
     */
    public function validateHcWarningsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        if (!Utils::isUnset($request->riskIds)) {
            $query['RiskIds'] = $request->riskIds;
        }
        if (!Utils::isUnset($request->uuids)) {
            $query['Uuids'] = $request->uuids;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ValidateHcWarnings',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ValidateHcWarningsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
     *  *
     * @param ValidateHcWarningsRequest $request ValidateHcWarningsRequest
     *
     * @return ValidateHcWarningsResponse ValidateHcWarningsResponse
     */
    public function validateHcWarnings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->validateHcWarningsWithOptions($request, $runtime);
    }

    /**
     * @summary Verifies the instances on which risks are detected based on a check item.
     *  *
     * @param VerifyCheckInstanceResultRequest $request VerifyCheckInstanceResultRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return VerifyCheckInstanceResultResponse VerifyCheckInstanceResultResponse
     */
    public function verifyCheckInstanceResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkId)) {
            $query['CheckId'] = $request->checkId;
        }
        if (!Utils::isUnset($request->instanceIds)) {
            $query['InstanceIds'] = $request->instanceIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'VerifyCheckInstanceResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return VerifyCheckInstanceResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Verifies the instances on which risks are detected based on a check item.
     *  *
     * @param VerifyCheckInstanceResultRequest $request VerifyCheckInstanceResultRequest
     *
     * @return VerifyCheckInstanceResultResponse VerifyCheckInstanceResultResponse
     */
    public function verifyCheckInstanceResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyCheckInstanceResultWithOptions($request, $runtime);
    }

    /**
     * @summary Verifies risk items that are detected based on check items.
     *  *
     * @param VerifyCheckResultRequest $request VerifyCheckResultRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return VerifyCheckResultResponse VerifyCheckResultResponse
     */
    public function verifyCheckResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkIds)) {
            $query['CheckIds'] = $request->checkIds;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'VerifyCheckResult',
            'version'     => '2018-12-03',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return VerifyCheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Verifies risk items that are detected based on check items.
     *  *
     * @param VerifyCheckResultRequest $request VerifyCheckResultRequest
     *
     * @return VerifyCheckResultResponse VerifyCheckResultResponse
     */
    public function verifyCheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->verifyCheckResultWithOptions($request, $runtime);
    }
}
