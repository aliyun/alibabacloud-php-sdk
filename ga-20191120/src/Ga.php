<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Ga\V20191120;

use AlibabaCloud\Dara\Models\RuntimeOptions;
use AlibabaCloud\SDK\Ga\V20191120\Models\AddEntriesToAclRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\AddEntriesToAclResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\AssociateAclsWithListenerRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\AssociateAclsWithListenerResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\AssociateAdditionalCertificatesWithListenerRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\AssociateAdditionalCertificatesWithListenerResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\AssociateResourcesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\AssociateResourcesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\AttachDdosToAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\AttachDdosToAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\AttachLogStoreToEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\AttachLogStoreToEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\BandwidthPackageAddAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\BandwidthPackageAddAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\BandwidthPackageRemoveAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\BandwidthPackageRemoveAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ChangeResourceGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ChangeResourceGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ConfigEndpointProbeRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ConfigEndpointProbeResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateAclRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateAclResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateApplicationMonitorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateApplicationMonitorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBandwidthPackageRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBandwidthPackageResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicAccelerateIpEndpointRelationRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicAccelerateIpEndpointRelationResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicAccelerateIpEndpointRelationsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicAccelerateIpEndpointRelationsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicAccelerateIpRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicAccelerateIpResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicEndpointRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicEndpointResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicEndpointsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicEndpointsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicIpSetRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateBasicIpSetResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateCustomRoutingEndpointGroupDestinationsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateCustomRoutingEndpointGroupDestinationsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateCustomRoutingEndpointGroupsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateCustomRoutingEndpointGroupsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateCustomRoutingEndpointsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateCustomRoutingEndpointsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateCustomRoutingEndpointTrafficPoliciesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateCustomRoutingEndpointTrafficPoliciesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateDomainRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateDomainResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateEndpointGroupsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateEndpointGroupsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateForwardingRulesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateForwardingRulesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateIpSetsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateIpSetsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateListenerRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateListenerResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateSpareIpsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\CreateSpareIpsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteAclRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteAclResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteApplicationMonitorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteApplicationMonitorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBandwidthPackageRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBandwidthPackageResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicAccelerateIpEndpointRelationRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicAccelerateIpEndpointRelationResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicAccelerateIpRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicAccelerateIpResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicEndpointRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicEndpointResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicIpSetRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteBasicIpSetResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteCustomRoutingEndpointGroupDestinationsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteCustomRoutingEndpointGroupDestinationsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteCustomRoutingEndpointGroupsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteCustomRoutingEndpointGroupsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteCustomRoutingEndpointsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteCustomRoutingEndpointsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteCustomRoutingEndpointTrafficPoliciesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteCustomRoutingEndpointTrafficPoliciesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteDomainAcceleratorRelationRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteDomainAcceleratorRelationResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteEndpointGroupsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteEndpointGroupsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteForwardingRulesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteForwardingRulesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteIpSetRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteIpSetResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteIpSetsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteIpSetsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteListenerRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteListenerResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteSpareIpsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DeleteSpareIpsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeAcceleratorAutoRenewAttributeRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeAcceleratorAutoRenewAttributeResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeAcceleratorServiceStatusRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeAcceleratorServiceStatusResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeApplicationMonitorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeApplicationMonitorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeBandwidthPackageAutoRenewAttributeRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeBandwidthPackageAutoRenewAttributeResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeBandwidthPackageRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeBandwidthPackageResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCommodityPriceRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCommodityPriceResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCommodityRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCommodityResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCustomRoutingEndpointGroupDestinationsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCustomRoutingEndpointGroupDestinationsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCustomRoutingEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCustomRoutingEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCustomRoutingEndpointRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCustomRoutingEndpointResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCustomRoutingEndPointTrafficPolicyRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeCustomRoutingEndPointTrafficPolicyResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeIpSetRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeIpSetResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeListenerRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeListenerResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeLogStoreOfEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeLogStoreOfEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeRegionsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DescribeRegionsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DetachDdosFromAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DetachDdosFromAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DetachLogStoreFromEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DetachLogStoreFromEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DetectApplicationMonitorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DetectApplicationMonitorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DisableApplicationMonitorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DisableApplicationMonitorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DisassociateResourcesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DisassociateResourcesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DissociateAclsFromListenerRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DissociateAclsFromListenerResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\DissociateAdditionalCertificatesFromListenerRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\DissociateAdditionalCertificatesFromListenerResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\EnableApplicationMonitorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\EnableApplicationMonitorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetAclRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetAclResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicAccelerateIpEndpointRelationRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicAccelerateIpEndpointRelationResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicAccelerateIpIdleCountRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicAccelerateIpIdleCountResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicAccelerateIpRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicAccelerateIpResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicEndpointRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicEndpointResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicIpSetRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetBasicIpSetResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetGlobalAcceleratorResourcesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetGlobalAcceleratorResourcesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetHealthStatusRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetHealthStatusResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetInvalidDomainCountRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetInvalidDomainCountResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetIpsetsBandwidthLimitRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetIpsetsBandwidthLimitResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetSpareIpRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\GetSpareIpResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAccelerateAreasRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAccelerateAreasResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAcceleratorsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAcceleratorsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAclsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAclsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListApplicationMonitorDetectResultRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListApplicationMonitorDetectResultResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListApplicationMonitorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListApplicationMonitorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAvailableAccelerateAreasRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAvailableAccelerateAreasResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAvailableBusiRegionsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListAvailableBusiRegionsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBandwidthackagesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBandwidthackagesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBandwidthPackagesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBandwidthPackagesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBasicAccelerateIpEndpointRelationsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBasicAccelerateIpEndpointRelationsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBasicAccelerateIpsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBasicAccelerateIpsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBasicAcceleratorsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBasicAcceleratorsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBasicEndpointsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBasicEndpointsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBusiRegionsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListBusiRegionsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCommonAreasRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCommonAreasResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingEndpointGroupDestinationsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingEndpointGroupDestinationsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingEndpointGroupsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingEndpointGroupsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingEndpointsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingEndpointsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingEndpointTrafficPoliciesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingEndpointTrafficPoliciesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingPortMappingsByDestinationRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingPortMappingsByDestinationResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingPortMappingsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListCustomRoutingPortMappingsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListDomainsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListDomainsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListEndpointGroupIpAddressCidrBlocksRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListEndpointGroupIpAddressCidrBlocksResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListEndpointGroupsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListEndpointGroupsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListForwardingRulesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListForwardingRulesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListIpSetsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListIpSetsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListIspTypesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListIspTypesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListListenerCertificatesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListListenerCertificatesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListListenersRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListListenersResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListSpareIpsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListSpareIpsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListSystemSecurityPoliciesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListSystemSecurityPoliciesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListTagResourcesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ListTagResourcesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\OpenAcceleratorServiceRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\OpenAcceleratorServiceResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\QueryCrossBorderApprovalStatusRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\QueryCrossBorderApprovalStatusResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\RemoveEntriesFromAclRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\RemoveEntriesFromAclResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\ReplaceBandwidthPackageRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\ReplaceBandwidthPackageResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\TagResourcesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\TagResourcesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UntagResourcesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UntagResourcesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorAutoRenewAttributeRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorAutoRenewAttributeResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorConfirmRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorConfirmResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorCrossBorderModeRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorCrossBorderModeResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorCrossBorderStatusRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorCrossBorderStatusResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAclAttributeRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAclAttributeResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAdditionalCertificateWithListenerRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateAdditionalCertificateWithListenerResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateApplicationMonitorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateApplicationMonitorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBandwidthPackagaAutoRenewAttributeRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBandwidthPackagaAutoRenewAttributeResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBandwidthPackageRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBandwidthPackageResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBasicAcceleratorRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBasicAcceleratorResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBasicEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBasicEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBasicEndpointRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBasicEndpointResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBasicIpSetRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateBasicIpSetResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateCustomRoutingEndpointGroupAttributeRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateCustomRoutingEndpointGroupAttributeResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateCustomRoutingEndpointGroupDestinationsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateCustomRoutingEndpointGroupDestinationsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateCustomRoutingEndpointsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateCustomRoutingEndpointsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateCustomRoutingEndpointTrafficPoliciesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateCustomRoutingEndpointTrafficPoliciesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateDomainRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateDomainResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateDomainStateRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateDomainStateResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateEndpointGroupAttributeRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateEndpointGroupAttributeResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateEndpointGroupRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateEndpointGroupResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateEndpointGroupsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateEndpointGroupsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateForwardingRulesRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateForwardingRulesResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateIpSetRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateIpSetResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateIpSetsRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateIpSetsResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateListenerRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateListenerResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateLogStoreConfigRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateLogStoreConfigResponse;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateServiceManagedControlRequest;
use AlibabaCloud\SDK\Ga\V20191120\Models\UpdateServiceManagedControlResponse;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;
use Darabonba\OpenApi\Utils;

class Ga extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('ga', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (null !== $endpoint) {
            return $endpoint;
        }

        if (null !== $endpointMap && null !== @$endpointMap[$regionId]) {
            return @$endpointMap[$regionId];
        }

        return Utils::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * Adds IP addresses or CIDR blocks to an access control list (ACL). You can add IP addresses or CIDR blocks to an ACL and configure a whitelist or blacklist to allow or deny requests from clients.
     *
     * @remarks
     *   **AddEntriesToAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetAcl](https://help.aliyun.com/document_detail/258292.html) or [ListAcls](https://help.aliyun.com/document_detail/258291.html) operation to query the status of the ACL to which you want to add IP entries.
     *     *   If the ACL is in the **configuring** state, it indicates that IP entries are added to the ACL. In this case, you can perform only query operations.
     *     *   If the ACL is in the **active** state, it indicates that IP entries are added to the ACL.
     * *   The **AddEntriesToAcl** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - AddEntriesToAclRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddEntriesToAclResponse
     *
     * @param AddEntriesToAclRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return AddEntriesToAclResponse
     */
    public function addEntriesToAclWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclEntries) {
            @$query['AclEntries'] = $request->aclEntries;
        }

        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddEntriesToAcl',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddEntriesToAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds IP addresses or CIDR blocks to an access control list (ACL). You can add IP addresses or CIDR blocks to an ACL and configure a whitelist or blacklist to allow or deny requests from clients.
     *
     * @remarks
     *   **AddEntriesToAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetAcl](https://help.aliyun.com/document_detail/258292.html) or [ListAcls](https://help.aliyun.com/document_detail/258291.html) operation to query the status of the ACL to which you want to add IP entries.
     *     *   If the ACL is in the **configuring** state, it indicates that IP entries are added to the ACL. In this case, you can perform only query operations.
     *     *   If the ACL is in the **active** state, it indicates that IP entries are added to the ACL.
     * *   The **AddEntriesToAcl** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - AddEntriesToAclRequest
     *
     * @returns AddEntriesToAclResponse
     *
     * @param AddEntriesToAclRequest $request
     *
     * @return AddEntriesToAclResponse
     */
    public function addEntriesToAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addEntriesToAclWithOptions($request, $runtime);
    }

    /**
     * Associates access control lists (ACLs) with a listener.
     *
     * @remarks
     * ## Description
     * *   **AssociateAclsWithListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the state of the listener with which you attempt to associate an ACL.
     *     *   If the listener is in the **updating** state, it indicates that the ACL is being associated. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, it indicates that the ACL is associated.
     * *   The **AssociateAclsWithListener** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - AssociateAclsWithListenerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateAclsWithListenerResponse
     *
     * @param AssociateAclsWithListenerRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return AssociateAclsWithListenerResponse
     */
    public function associateAclsWithListenerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclIds) {
            @$query['AclIds'] = $request->aclIds;
        }

        if (null !== $request->aclType) {
            @$query['AclType'] = $request->aclType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateAclsWithListener',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateAclsWithListenerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates access control lists (ACLs) with a listener.
     *
     * @remarks
     * ## Description
     * *   **AssociateAclsWithListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the state of the listener with which you attempt to associate an ACL.
     *     *   If the listener is in the **updating** state, it indicates that the ACL is being associated. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, it indicates that the ACL is associated.
     * *   The **AssociateAclsWithListener** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - AssociateAclsWithListenerRequest
     *
     * @returns AssociateAclsWithListenerResponse
     *
     * @param AssociateAclsWithListenerRequest $request
     *
     * @return AssociateAclsWithListenerResponse
     */
    public function associateAclsWithListener($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateAclsWithListenerWithOptions($request, $runtime);
    }

    /**
     * Associates additional certificates with an HTTPS listener. You can associate multiple certificates with an HTTPS listener and configure virtual endpoint groups and forwarding rules to accelerate access to multiple HTTPS-capable domain names.
     *
     * @remarks
     *   Only HTTPS listeners can be associated with additional certificates.
     * *   **AssociateAdditionalCertificatesWithListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the status of the listener with which you want to associate an additional certificate.
     *     *   If the listener is in the **updating** state, it indicates that the additional certificate is being associated. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, it indicates that the additional certificate is associated.
     * *   The **AssociateAdditionalCertificatesWithListener** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - AssociateAdditionalCertificatesWithListenerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateAdditionalCertificatesWithListenerResponse
     *
     * @param AssociateAdditionalCertificatesWithListenerRequest $request
     * @param RuntimeOptions                                     $runtime
     *
     * @return AssociateAdditionalCertificatesWithListenerResponse
     */
    public function associateAdditionalCertificatesWithListenerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->certificates) {
            @$query['Certificates'] = $request->certificates;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateAdditionalCertificatesWithListener',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateAdditionalCertificatesWithListenerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates additional certificates with an HTTPS listener. You can associate multiple certificates with an HTTPS listener and configure virtual endpoint groups and forwarding rules to accelerate access to multiple HTTPS-capable domain names.
     *
     * @remarks
     *   Only HTTPS listeners can be associated with additional certificates.
     * *   **AssociateAdditionalCertificatesWithListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the status of the listener with which you want to associate an additional certificate.
     *     *   If the listener is in the **updating** state, it indicates that the additional certificate is being associated. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, it indicates that the additional certificate is associated.
     * *   The **AssociateAdditionalCertificatesWithListener** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - AssociateAdditionalCertificatesWithListenerRequest
     *
     * @returns AssociateAdditionalCertificatesWithListenerResponse
     *
     * @param AssociateAdditionalCertificatesWithListenerRequest $request
     *
     * @return AssociateAdditionalCertificatesWithListenerResponse
     */
    public function associateAdditionalCertificatesWithListener($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateAdditionalCertificatesWithListenerWithOptions($request, $runtime);
    }

    /**
     * GA集成云产品
     *
     * @param request - AssociateResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateResourcesResponse
     *
     * @param AssociateResourcesRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return AssociateResourcesResponse
     */
    public function associateResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->associatedMode) {
            @$query['AssociatedMode'] = $request->associatedMode;
        }

        if (null !== $request->associatedResourceId) {
            @$query['AssociatedResourceId'] = $request->associatedResourceId;
        }

        if (null !== $request->associatedResourceRegionId) {
            @$query['AssociatedResourceRegionId'] = $request->associatedResourceRegionId;
        }

        if (null !== $request->associatedResourceType) {
            @$query['AssociatedResourceType'] = $request->associatedResourceType;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateResources',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * GA集成云产品
     *
     * @param request - AssociateResourcesRequest
     *
     * @returns AssociateResourcesResponse
     *
     * @param AssociateResourcesRequest $request
     *
     * @return AssociateResourcesResponse
     */
    public function associateResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateResourcesWithOptions($request, $runtime);
    }

    /**
     * Associates an Anti-DDoS Pro or Anti-DDoS Premium instance with a Global Accelerator (GA) instance.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   **AttachDdosToAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) or [ListAccelerators](https://help.aliyun.com/document_detail/153236.html) operation to query the status of the GA instance.
     *     *   If the GA instance is in the **configuring** state, the Anti-DDoS Pro or Anti-DDoS Premium instance is being associated with the GA instance. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, the Anti-DDoS Pro or Anti-DDoS Premium instance is associated with the GA instance.
     * *   You cannot repeatedly call the **AttachDdosToAccelerator** operation for the same GA instance within a specific period of time.
     *
     * @param request - AttachDdosToAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachDdosToAcceleratorResponse
     *
     * @param AttachDdosToAcceleratorRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return AttachDdosToAcceleratorResponse
     */
    public function attachDdosToAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->ddosConfigList) {
            @$query['DdosConfigList'] = $request->ddosConfigList;
        }

        if (null !== $request->ddosId) {
            @$query['DdosId'] = $request->ddosId;
        }

        if (null !== $request->ddosRegionId) {
            @$query['DdosRegionId'] = $request->ddosRegionId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachDdosToAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachDdosToAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates an Anti-DDoS Pro or Anti-DDoS Premium instance with a Global Accelerator (GA) instance.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   **AttachDdosToAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) or [ListAccelerators](https://help.aliyun.com/document_detail/153236.html) operation to query the status of the GA instance.
     *     *   If the GA instance is in the **configuring** state, the Anti-DDoS Pro or Anti-DDoS Premium instance is being associated with the GA instance. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, the Anti-DDoS Pro or Anti-DDoS Premium instance is associated with the GA instance.
     * *   You cannot repeatedly call the **AttachDdosToAccelerator** operation for the same GA instance within a specific period of time.
     *
     * @param request - AttachDdosToAcceleratorRequest
     *
     * @returns AttachDdosToAcceleratorResponse
     *
     * @param AttachDdosToAcceleratorRequest $request
     *
     * @return AttachDdosToAcceleratorResponse
     */
    public function attachDdosToAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachDdosToAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Associates a Log Service Logstore with an endpoint group.
     *
     * @remarks
     *   **AttachLogStoreToEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the state of an endpoint group.
     *     *   If the endpoint group is in the **updating** state, it indicates that a Logstore is being associated with the group. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that a Logstore is associated with the group.
     * *   The **AttachLogStoreToEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - AttachLogStoreToEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachLogStoreToEndpointGroupResponse
     *
     * @param AttachLogStoreToEndpointGroupRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return AttachLogStoreToEndpointGroupResponse
     */
    public function attachLogStoreToEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->accessLogRecordCustomizedHeaderList) {
            @$query['AccessLogRecordCustomizedHeaderList'] = $request->accessLogRecordCustomizedHeaderList;
        }

        if (null !== $request->accessLogRecordCustomizedHeadersEnabled) {
            @$query['AccessLogRecordCustomizedHeadersEnabled'] = $request->accessLogRecordCustomizedHeadersEnabled;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupIds) {
            @$query['EndpointGroupIds'] = $request->endpointGroupIds;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->slsLogStoreName) {
            @$query['SlsLogStoreName'] = $request->slsLogStoreName;
        }

        if (null !== $request->slsProjectName) {
            @$query['SlsProjectName'] = $request->slsProjectName;
        }

        if (null !== $request->slsRegionId) {
            @$query['SlsRegionId'] = $request->slsRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachLogStoreToEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachLogStoreToEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a Log Service Logstore with an endpoint group.
     *
     * @remarks
     *   **AttachLogStoreToEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the state of an endpoint group.
     *     *   If the endpoint group is in the **updating** state, it indicates that a Logstore is being associated with the group. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that a Logstore is associated with the group.
     * *   The **AttachLogStoreToEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - AttachLogStoreToEndpointGroupRequest
     *
     * @returns AttachLogStoreToEndpointGroupResponse
     *
     * @param AttachLogStoreToEndpointGroupRequest $request
     *
     * @return AttachLogStoreToEndpointGroupResponse
     */
    public function attachLogStoreToEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachLogStoreToEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Associates a bandwidth plan with a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **BandwidthPackageAddAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the bandwidth plan that you want to associate.
     *     *   If the bandwidth plan is in the **binding** state, it indicates that the bandwidth plan is being associated. In this case, you can perform only query operations.
     *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is associated.
     * *   The **BandwidthPackageAddAccelerator** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - BandwidthPackageAddAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BandwidthPackageAddAcceleratorResponse
     *
     * @param BandwidthPackageAddAcceleratorRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return BandwidthPackageAddAcceleratorResponse
     */
    public function bandwidthPackageAddAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BandwidthPackageAddAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BandwidthPackageAddAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a bandwidth plan with a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **BandwidthPackageAddAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the bandwidth plan that you want to associate.
     *     *   If the bandwidth plan is in the **binding** state, it indicates that the bandwidth plan is being associated. In this case, you can perform only query operations.
     *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is associated.
     * *   The **BandwidthPackageAddAccelerator** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - BandwidthPackageAddAcceleratorRequest
     *
     * @returns BandwidthPackageAddAcceleratorResponse
     *
     * @param BandwidthPackageAddAcceleratorRequest $request
     *
     * @return BandwidthPackageAddAcceleratorResponse
     */
    public function bandwidthPackageAddAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->bandwidthPackageAddAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Disassociates a bandwidth plan from a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **BandwidthPackageRemoveAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the bandwidth plan that you attempt to disassociate.
     *     *   If the bandwidth plan is in the **unbinding** state, it indicates that the bandwidth plan is being disassociated. In this case, you can perform only query operations.
     *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is disassociated.
     * *   The **BandwidthPackageRemoveAccelerator** cannot be called repeatedly for the same GA instance.
     *
     * @param request - BandwidthPackageRemoveAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns BandwidthPackageRemoveAcceleratorResponse
     *
     * @param BandwidthPackageRemoveAcceleratorRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return BandwidthPackageRemoveAcceleratorResponse
     */
    public function bandwidthPackageRemoveAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'BandwidthPackageRemoveAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return BandwidthPackageRemoveAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a bandwidth plan from a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **BandwidthPackageRemoveAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the bandwidth plan that you attempt to disassociate.
     *     *   If the bandwidth plan is in the **unbinding** state, it indicates that the bandwidth plan is being disassociated. In this case, you can perform only query operations.
     *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is disassociated.
     * *   The **BandwidthPackageRemoveAccelerator** cannot be called repeatedly for the same GA instance.
     *
     * @param request - BandwidthPackageRemoveAcceleratorRequest
     *
     * @returns BandwidthPackageRemoveAcceleratorResponse
     *
     * @param BandwidthPackageRemoveAcceleratorRequest $request
     *
     * @return BandwidthPackageRemoveAcceleratorResponse
     */
    public function bandwidthPackageRemoveAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->bandwidthPackageRemoveAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Changes the resource group to which a Global Accelerator (GA) resource belongs.
     *
     * @remarks
     * The **ChangeResourceGroup** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - ChangeResourceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ChangeResourceGroupResponse
     *
     * @param ChangeResourceGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ChangeResourceGroupResponse
     */
    public function changeResourceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->newResourceGroupId) {
            @$query['NewResourceGroupId'] = $request->newResourceGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeResourceGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the resource group to which a Global Accelerator (GA) resource belongs.
     *
     * @remarks
     * The **ChangeResourceGroup** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - ChangeResourceGroupRequest
     *
     * @returns ChangeResourceGroupResponse
     *
     * @param ChangeResourceGroupRequest $request
     *
     * @return ChangeResourceGroupResponse
     */
    public function changeResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeResourceGroupWithOptions($request, $runtime);
    }

    /**
     * Configures latency monitoring for an endpoint.
     *
     * @remarks
     *   **ConfigEndpointProbe** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the status of the endpoint group to which an endpoint belongs and determine whether latency monitoring is configured for the endpoint.
     *     *   If the endpoint group is in the **updating** state, it indicates that latency monitoring is being configured for the endpoint. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that latency monitoring is configured for the endpoint.
     * *   The **ConfigEndpointProbe** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - ConfigEndpointProbeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ConfigEndpointProbeResponse
     *
     * @param ConfigEndpointProbeRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ConfigEndpointProbeResponse
     */
    public function configEndpointProbeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->enable) {
            @$query['Enable'] = $request->enable;
        }

        if (null !== $request->endpoint) {
            @$query['Endpoint'] = $request->endpoint;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointType) {
            @$query['EndpointType'] = $request->endpointType;
        }

        if (null !== $request->probePort) {
            @$query['ProbePort'] = $request->probePort;
        }

        if (null !== $request->probeProtocol) {
            @$query['ProbeProtocol'] = $request->probeProtocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ConfigEndpointProbe',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ConfigEndpointProbeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures latency monitoring for an endpoint.
     *
     * @remarks
     *   **ConfigEndpointProbe** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the status of the endpoint group to which an endpoint belongs and determine whether latency monitoring is configured for the endpoint.
     *     *   If the endpoint group is in the **updating** state, it indicates that latency monitoring is being configured for the endpoint. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that latency monitoring is configured for the endpoint.
     * *   The **ConfigEndpointProbe** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - ConfigEndpointProbeRequest
     *
     * @returns ConfigEndpointProbeResponse
     *
     * @param ConfigEndpointProbeRequest $request
     *
     * @return ConfigEndpointProbeResponse
     */
    public function configEndpointProbe($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->configEndpointProbeWithOptions($request, $runtime);
    }

    /**
     * Creates a Global Accelerator (GA) instance. GA is a high-availability and high-performance network acceleration service for global users. By leveraging the high-quality BGP bandwidth and global network of Alibaba Cloud, GA allows service providers to deploy applications across regions and users to connect to the nearest access points for content delivery acceleration. This reduces network issues, such as network latency, network jitters, and packet loss.
     *
     * @remarks
     * ## Description
     * **CreateAccelerator** is an asynchronous operation. After you send a request, the system returns the ID of a GA instance, but the operation is still being performed in the system background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the state of a GA instance.
     * *   If the GA instance is in the **init** state, it indicates that the GA instance is being created. In this case, you can perform only query operations.
     * *   If the GA instance is in the **active** state, it indicates that the GA instance is created.
     *
     * @param request - CreateAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateAcceleratorResponse
     *
     * @param CreateAcceleratorRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateAcceleratorResponse
     */
    public function createAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoRenewDuration) {
            @$query['AutoRenewDuration'] = $request->autoRenewDuration;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->bandwidthBillingType) {
            @$query['BandwidthBillingType'] = $request->bandwidthBillingType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->duration) {
            @$query['Duration'] = $request->duration;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->ipSetConfig) {
            @$query['IpSetConfig'] = $request->ipSetConfig;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pricingCycle) {
            @$query['PricingCycle'] = $request->pricingCycle;
        }

        if (null !== $request->promotionOptionNo) {
            @$query['PromotionOptionNo'] = $request->promotionOptionNo;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a Global Accelerator (GA) instance. GA is a high-availability and high-performance network acceleration service for global users. By leveraging the high-quality BGP bandwidth and global network of Alibaba Cloud, GA allows service providers to deploy applications across regions and users to connect to the nearest access points for content delivery acceleration. This reduces network issues, such as network latency, network jitters, and packet loss.
     *
     * @remarks
     * ## Description
     * **CreateAccelerator** is an asynchronous operation. After you send a request, the system returns the ID of a GA instance, but the operation is still being performed in the system background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the state of a GA instance.
     * *   If the GA instance is in the **init** state, it indicates that the GA instance is being created. In this case, you can perform only query operations.
     * *   If the GA instance is in the **active** state, it indicates that the GA instance is created.
     *
     * @param request - CreateAcceleratorRequest
     *
     * @returns CreateAcceleratorResponse
     *
     * @param CreateAcceleratorRequest $request
     *
     * @return CreateAcceleratorResponse
     */
    public function createAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Creates an access control list (ACL).
     *
     * @remarks
     * *CreateAcl** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetAcl](https://help.aliyun.com/document_detail/258292.html) or [ListAcls](https://help.aliyun.com/document_detail/258291.html) operation to query the state of an ACL.
     * *   If the ACL is in the **init** state, the ACL is being created. In this case, you can only perform only query operations.
     * *   If the ACL is in the **active** state, the ACL is created.
     *
     * @param request - CreateAclRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateAclResponse
     *
     * @param CreateAclRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return CreateAclResponse
     */
    public function createAclWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclEntries) {
            @$query['AclEntries'] = $request->aclEntries;
        }

        if (null !== $request->aclName) {
            @$query['AclName'] = $request->aclName;
        }

        if (null !== $request->addressIPVersion) {
            @$query['AddressIPVersion'] = $request->addressIPVersion;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateAcl',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an access control list (ACL).
     *
     * @remarks
     * *CreateAcl** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetAcl](https://help.aliyun.com/document_detail/258292.html) or [ListAcls](https://help.aliyun.com/document_detail/258291.html) operation to query the state of an ACL.
     * *   If the ACL is in the **init** state, the ACL is being created. In this case, you can only perform only query operations.
     * *   If the ACL is in the **active** state, the ACL is created.
     *
     * @param request - CreateAclRequest
     *
     * @returns CreateAclResponse
     *
     * @param CreateAclRequest $request
     *
     * @return CreateAclResponse
     */
    public function createAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAclWithOptions($request, $runtime);
    }

    /**
     * Creates an origin probing task.
     *
     * @remarks
     * You can call the **CreateApplicationMonitor** operation to create an origin probing task. An origin probing task monitors the network quality between a client and an origin server and checks the availability of the origin server.
     * Before you call this operation, take note of the following items:
     * *   You can create origin detection tasks only for subscription Standard Global Accelerator (GA) instances whose specification is Medium Ⅰ.
     * *   You cannot create an origin probe task for a UDP listener.
     * *   The service port of the URL or IP address that is probed must be within the listening port range.
     * *   **CreateApplicationMonitor** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeApplicationMonitor](https://help.aliyun.com/document_detail/408463.html) or [ListApplicationMonitor](https://help.aliyun.com/document_detail/408462.html) operation to query the status of the origin probing task.
     *     *   If the origin probing task is in the **init** state, it indicates that the task is being created. You can perform only query operations.
     *     *   If the origin probing task is in the **active** state, it indicates that the task is created.
     * *   The **CreateApplicationMonitor** operation cannot be called repeatedly for the same GA instance within a specific period of time.
     *
     * @param request - CreateApplicationMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateApplicationMonitorResponse
     *
     * @param CreateApplicationMonitorRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateApplicationMonitorResponse
     */
    public function createApplicationMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->address) {
            @$query['Address'] = $request->address;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->detectEnable) {
            @$query['DetectEnable'] = $request->detectEnable;
        }

        if (null !== $request->detectThreshold) {
            @$query['DetectThreshold'] = $request->detectThreshold;
        }

        if (null !== $request->detectTimes) {
            @$query['DetectTimes'] = $request->detectTimes;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->optionsJson) {
            @$query['OptionsJson'] = $request->optionsJson;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->silenceTime) {
            @$query['SilenceTime'] = $request->silenceTime;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateApplicationMonitor',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateApplicationMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an origin probing task.
     *
     * @remarks
     * You can call the **CreateApplicationMonitor** operation to create an origin probing task. An origin probing task monitors the network quality between a client and an origin server and checks the availability of the origin server.
     * Before you call this operation, take note of the following items:
     * *   You can create origin detection tasks only for subscription Standard Global Accelerator (GA) instances whose specification is Medium Ⅰ.
     * *   You cannot create an origin probe task for a UDP listener.
     * *   The service port of the URL or IP address that is probed must be within the listening port range.
     * *   **CreateApplicationMonitor** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeApplicationMonitor](https://help.aliyun.com/document_detail/408463.html) or [ListApplicationMonitor](https://help.aliyun.com/document_detail/408462.html) operation to query the status of the origin probing task.
     *     *   If the origin probing task is in the **init** state, it indicates that the task is being created. You can perform only query operations.
     *     *   If the origin probing task is in the **active** state, it indicates that the task is created.
     * *   The **CreateApplicationMonitor** operation cannot be called repeatedly for the same GA instance within a specific period of time.
     *
     * @param request - CreateApplicationMonitorRequest
     *
     * @returns CreateApplicationMonitorResponse
     *
     * @param CreateApplicationMonitorRequest $request
     *
     * @return CreateApplicationMonitorResponse
     */
    public function createApplicationMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createApplicationMonitorWithOptions($request, $runtime);
    }

    /**
     * Creates a bandwidth plan.
     *
     * @remarks
     * To use Global Accelerator (GA) for acceleration, you must purchase a basic bandwidth plan. A basic bandwidth plan supports the following bandwidth types:
     * *   **Basic**: Both the default acceleration region and the default service region are in the Chinese mainland. The accelerated service is deployed on Alibaba Cloud.
     * *   **Enhanced**: Both the default acceleration region and the default service region are in the Chinese mainland. The accelerated service can be deployed on and off Alibaba Cloud.
     * *   **Premium**: Both the default acceleration region and the default service region are outside the Chinese mainland. The accelerated service can be deployed on and off Alibaba Cloud. If you want to accelerate data transfer for clients in the Chinese mainland, you must select China (Hong Kong) as the acceleration region.
     * When you call this operation, take note of the following items:
     * *   **CreateBandwidthPackage** is an asynchronous operation. After you send a request, the system returns the ID of a bandwidth plan, but the bandwidth plan is still being created in the system background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the bandwidth plan.
     *     *   If the bandwidth plan is in the **init** state, it indicates that the bandwidth plan is being created. In this case, you can perform only query operations.
     *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is created.
     * *   The **CreateBandwidthPackage** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - CreateBandwidthPackageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBandwidthPackageResponse
     *
     * @param CreateBandwidthPackageRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CreateBandwidthPackageResponse
     */
    public function createBandwidthPackageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoRenewDuration) {
            @$query['AutoRenewDuration'] = $request->autoRenewDuration;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->bandwidthType) {
            @$query['BandwidthType'] = $request->bandwidthType;
        }

        if (null !== $request->billingType) {
            @$query['BillingType'] = $request->billingType;
        }

        if (null !== $request->cbnGeographicRegionIdA) {
            @$query['CbnGeographicRegionIdA'] = $request->cbnGeographicRegionIdA;
        }

        if (null !== $request->cbnGeographicRegionIdB) {
            @$query['CbnGeographicRegionIdB'] = $request->cbnGeographicRegionIdB;
        }

        if (null !== $request->chargeType) {
            @$query['ChargeType'] = $request->chargeType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->duration) {
            @$query['Duration'] = $request->duration;
        }

        if (null !== $request->pricingCycle) {
            @$query['PricingCycle'] = $request->pricingCycle;
        }

        if (null !== $request->promotionOptionNo) {
            @$query['PromotionOptionNo'] = $request->promotionOptionNo;
        }

        if (null !== $request->ratio) {
            @$query['Ratio'] = $request->ratio;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBandwidthPackage',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a bandwidth plan.
     *
     * @remarks
     * To use Global Accelerator (GA) for acceleration, you must purchase a basic bandwidth plan. A basic bandwidth plan supports the following bandwidth types:
     * *   **Basic**: Both the default acceleration region and the default service region are in the Chinese mainland. The accelerated service is deployed on Alibaba Cloud.
     * *   **Enhanced**: Both the default acceleration region and the default service region are in the Chinese mainland. The accelerated service can be deployed on and off Alibaba Cloud.
     * *   **Premium**: Both the default acceleration region and the default service region are outside the Chinese mainland. The accelerated service can be deployed on and off Alibaba Cloud. If you want to accelerate data transfer for clients in the Chinese mainland, you must select China (Hong Kong) as the acceleration region.
     * When you call this operation, take note of the following items:
     * *   **CreateBandwidthPackage** is an asynchronous operation. After you send a request, the system returns the ID of a bandwidth plan, but the bandwidth plan is still being created in the system background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the bandwidth plan.
     *     *   If the bandwidth plan is in the **init** state, it indicates that the bandwidth plan is being created. In this case, you can perform only query operations.
     *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is created.
     * *   The **CreateBandwidthPackage** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - CreateBandwidthPackageRequest
     *
     * @returns CreateBandwidthPackageResponse
     *
     * @param CreateBandwidthPackageRequest $request
     *
     * @return CreateBandwidthPackageResponse
     */
    public function createBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * Creates an accelerated IP address for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicAccelerateIp** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) operation to query the status of an accelerated IP address:
     *     *   If no status information is returned, the accelerated IP address is being created. In this case, you can perform only query operations.
     *     *   If the accelerated IP address is in the **active** state, the accelerated IP address is created.
     * *   The **CreateBasicAccelerateIp** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - CreateBasicAccelerateIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBasicAccelerateIpResponse
     *
     * @param CreateBasicAccelerateIpRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateBasicAccelerateIpResponse
     */
    public function createBasicAccelerateIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipSetId) {
            @$query['IpSetId'] = $request->ipSetId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBasicAccelerateIp',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBasicAccelerateIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an accelerated IP address for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicAccelerateIp** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) operation to query the status of an accelerated IP address:
     *     *   If no status information is returned, the accelerated IP address is being created. In this case, you can perform only query operations.
     *     *   If the accelerated IP address is in the **active** state, the accelerated IP address is created.
     * *   The **CreateBasicAccelerateIp** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - CreateBasicAccelerateIpRequest
     *
     * @returns CreateBasicAccelerateIpResponse
     *
     * @param CreateBasicAccelerateIpRequest $request
     *
     * @return CreateBasicAccelerateIpResponse
     */
    public function createBasicAccelerateIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBasicAccelerateIpWithOptions($request, $runtime);
    }

    /**
     * Creates a mapping between an accelerated IP address and an endpoint for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicAccelerateIpEndpointRelation** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) or [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) API operation to query the status of an accelerated IP address or an endpoint to determine the association status between the accelerated IP address and endpoint.
     *     *   If the status of the accelerated IP address and endpoint is **binding**, the accelerated IP address is being associated with the endpoint. In this case, you can query the accelerated IP address and endpoint but cannot perform other operations.
     *     *   If the status of the accelerated IP address and endpoint is **bound** and the status returned by the [ListBasicAccelerateIpEndpointRelations](https://help.aliyun.com/document_detail/466803.html) API operation is **active**, the accelerated IP address is associated with the endpoint.
     * *   The **CreateBasicAccelerateIpEndpointRelation** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
     *
     * @param request - CreateBasicAccelerateIpEndpointRelationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBasicAccelerateIpEndpointRelationResponse
     *
     * @param CreateBasicAccelerateIpEndpointRelationRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return CreateBasicAccelerateIpEndpointRelationResponse
     */
    public function createBasicAccelerateIpEndpointRelationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateIpId) {
            @$query['AccelerateIpId'] = $request->accelerateIpId;
        }

        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBasicAccelerateIpEndpointRelation',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBasicAccelerateIpEndpointRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a mapping between an accelerated IP address and an endpoint for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicAccelerateIpEndpointRelation** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) or [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) API operation to query the status of an accelerated IP address or an endpoint to determine the association status between the accelerated IP address and endpoint.
     *     *   If the status of the accelerated IP address and endpoint is **binding**, the accelerated IP address is being associated with the endpoint. In this case, you can query the accelerated IP address and endpoint but cannot perform other operations.
     *     *   If the status of the accelerated IP address and endpoint is **bound** and the status returned by the [ListBasicAccelerateIpEndpointRelations](https://help.aliyun.com/document_detail/466803.html) API operation is **active**, the accelerated IP address is associated with the endpoint.
     * *   The **CreateBasicAccelerateIpEndpointRelation** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
     *
     * @param request - CreateBasicAccelerateIpEndpointRelationRequest
     *
     * @returns CreateBasicAccelerateIpEndpointRelationResponse
     *
     * @param CreateBasicAccelerateIpEndpointRelationRequest $request
     *
     * @return CreateBasicAccelerateIpEndpointRelationResponse
     */
    public function createBasicAccelerateIpEndpointRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBasicAccelerateIpEndpointRelationWithOptions($request, $runtime);
    }

    /**
     * Creates mappings between accelerated IP addresses and endpoints for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   The **CreateBasicAccelerateIpEndpointRelations** is asynchronous. After you send a request, the system returns a request ID and runs the task in the system background. You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) or [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) API operation to query the status of an accelerated IP address or an endpoint to determine the association status.
     *     *   If an accelerated IP address and the endpoint are in the **binding** state, the accelerated IP address is being associated with the endpoint. In this case, you can only query the accelerated IP address and endpoint, but cannot perform other operations.
     *     *   If all the accelerated IP addresses and the endpoint are in the **bound** state, and the association status returned by the [ListBasicAccelerateIpEndpointRelations](https://help.aliyun.com/document_detail/466803.html) API operation is **active**, the accelerated IP addresses are associated with the endpoints.
     * *   The **CreateBasicAccelerateIpEndpointRelations** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
     *
     * @param request - CreateBasicAccelerateIpEndpointRelationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBasicAccelerateIpEndpointRelationsResponse
     *
     * @param CreateBasicAccelerateIpEndpointRelationsRequest $request
     * @param RuntimeOptions                                  $runtime
     *
     * @return CreateBasicAccelerateIpEndpointRelationsResponse
     */
    public function createBasicAccelerateIpEndpointRelationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateIpEndpointRelations) {
            @$query['AccelerateIpEndpointRelations'] = $request->accelerateIpEndpointRelations;
        }

        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBasicAccelerateIpEndpointRelations',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBasicAccelerateIpEndpointRelationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates mappings between accelerated IP addresses and endpoints for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   The **CreateBasicAccelerateIpEndpointRelations** is asynchronous. After you send a request, the system returns a request ID and runs the task in the system background. You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) or [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) API operation to query the status of an accelerated IP address or an endpoint to determine the association status.
     *     *   If an accelerated IP address and the endpoint are in the **binding** state, the accelerated IP address is being associated with the endpoint. In this case, you can only query the accelerated IP address and endpoint, but cannot perform other operations.
     *     *   If all the accelerated IP addresses and the endpoint are in the **bound** state, and the association status returned by the [ListBasicAccelerateIpEndpointRelations](https://help.aliyun.com/document_detail/466803.html) API operation is **active**, the accelerated IP addresses are associated with the endpoints.
     * *   The **CreateBasicAccelerateIpEndpointRelations** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
     *
     * @param request - CreateBasicAccelerateIpEndpointRelationsRequest
     *
     * @returns CreateBasicAccelerateIpEndpointRelationsResponse
     *
     * @param CreateBasicAccelerateIpEndpointRelationsRequest $request
     *
     * @return CreateBasicAccelerateIpEndpointRelationsResponse
     */
    public function createBasicAccelerateIpEndpointRelations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBasicAccelerateIpEndpointRelationsWithOptions($request, $runtime);
    }

    /**
     * Basic Global Accelerator (GA) instances leverage the immense bandwidth of the high-quality global network of Alibaba Cloud to provide end-to-end acceleration services. You can use basic GA instances to accelerate content delivery at Layer 3 (IP). You can call the CreateBasicAccelerator operation to create a basic GA instance.
     *
     * @remarks
     * *CreateBasicAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerator](https://help.aliyun.com/document_detail/353188.html) or [ListBasicAccelerators](https://help.aliyun.com/document_detail/353189.html) operation to query the status of the task.
     * *   If the basic GA instance is in the **init** state, it indicates that the basic GA instance is being created. In this case, you can perform only query operations.
     * *   If the basic GA instance is in the **active** state, it indicates that the basic GA instance is created.
     *
     * @param request - CreateBasicAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBasicAcceleratorResponse
     *
     * @param CreateBasicAcceleratorRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CreateBasicAcceleratorResponse
     */
    public function createBasicAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoRenewDuration) {
            @$query['AutoRenewDuration'] = $request->autoRenewDuration;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->bandwidthBillingType) {
            @$query['BandwidthBillingType'] = $request->bandwidthBillingType;
        }

        if (null !== $request->chargeType) {
            @$query['ChargeType'] = $request->chargeType;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->duration) {
            @$query['Duration'] = $request->duration;
        }

        if (null !== $request->pricingCycle) {
            @$query['PricingCycle'] = $request->pricingCycle;
        }

        if (null !== $request->promotionOptionNo) {
            @$query['PromotionOptionNo'] = $request->promotionOptionNo;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBasicAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBasicAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Basic Global Accelerator (GA) instances leverage the immense bandwidth of the high-quality global network of Alibaba Cloud to provide end-to-end acceleration services. You can use basic GA instances to accelerate content delivery at Layer 3 (IP). You can call the CreateBasicAccelerator operation to create a basic GA instance.
     *
     * @remarks
     * *CreateBasicAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerator](https://help.aliyun.com/document_detail/353188.html) or [ListBasicAccelerators](https://help.aliyun.com/document_detail/353189.html) operation to query the status of the task.
     * *   If the basic GA instance is in the **init** state, it indicates that the basic GA instance is being created. In this case, you can perform only query operations.
     * *   If the basic GA instance is in the **active** state, it indicates that the basic GA instance is created.
     *
     * @param request - CreateBasicAcceleratorRequest
     *
     * @returns CreateBasicAcceleratorResponse
     *
     * @param CreateBasicAcceleratorRequest $request
     *
     * @return CreateBasicAcceleratorResponse
     */
    public function createBasicAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBasicAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Creates an endpoint for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) API operation to query the status of an endpoint.
     *     *   If the endpoint is in the **init** state, the endpoint is being created. In this case, you can perform only query operations.
     *     *   If the endpoint is in the **active** state, the endpoint is created.
     * *   The **CreateBasicEndpoint** API operation cannot be repeatedly called for the same basic GA instance within a specific period of time.
     *
     * @param request - CreateBasicEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBasicEndpointResponse
     *
     * @param CreateBasicEndpointRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateBasicEndpointResponse
     */
    public function createBasicEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointAddress) {
            @$query['EndpointAddress'] = $request->endpointAddress;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointSubAddress) {
            @$query['EndpointSubAddress'] = $request->endpointSubAddress;
        }

        if (null !== $request->endpointSubAddressType) {
            @$query['EndpointSubAddressType'] = $request->endpointSubAddressType;
        }

        if (null !== $request->endpointType) {
            @$query['EndpointType'] = $request->endpointType;
        }

        if (null !== $request->endpointZoneId) {
            @$query['EndpointZoneId'] = $request->endpointZoneId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBasicEndpoint',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBasicEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an endpoint for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) API operation to query the status of an endpoint.
     *     *   If the endpoint is in the **init** state, the endpoint is being created. In this case, you can perform only query operations.
     *     *   If the endpoint is in the **active** state, the endpoint is created.
     * *   The **CreateBasicEndpoint** API operation cannot be repeatedly called for the same basic GA instance within a specific period of time.
     *
     * @param request - CreateBasicEndpointRequest
     *
     * @returns CreateBasicEndpointResponse
     *
     * @param CreateBasicEndpointRequest $request
     *
     * @return CreateBasicEndpointResponse
     */
    public function createBasicEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBasicEndpointWithOptions($request, $runtime);
    }

    /**
     * Creates an endpoint group for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicEndpointGroup** is an asynchronous operation. After a request is sent, the system returns an endpoint group ID and runs the task in the background. You can call the [GetBasicEndpointGroup](https://help.aliyun.com/document_detail/362984.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **init** state, the endpoint is being created. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, the endpoint group is created.
     * *   You cannot call the **CreateBasicEndpointGroup** operation again on the same GA instance before the previous request is completed.
     *
     * @param request - CreateBasicEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBasicEndpointGroupResponse
     *
     * @param CreateBasicEndpointGroupRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateBasicEndpointGroupResponse
     */
    public function createBasicEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->endpointAddress) {
            @$query['EndpointAddress'] = $request->endpointAddress;
        }

        if (null !== $request->endpointGroupRegion) {
            @$query['EndpointGroupRegion'] = $request->endpointGroupRegion;
        }

        if (null !== $request->endpointSubAddress) {
            @$query['EndpointSubAddress'] = $request->endpointSubAddress;
        }

        if (null !== $request->endpointType) {
            @$query['EndpointType'] = $request->endpointType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBasicEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBasicEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an endpoint group for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicEndpointGroup** is an asynchronous operation. After a request is sent, the system returns an endpoint group ID and runs the task in the background. You can call the [GetBasicEndpointGroup](https://help.aliyun.com/document_detail/362984.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **init** state, the endpoint is being created. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, the endpoint group is created.
     * *   You cannot call the **CreateBasicEndpointGroup** operation again on the same GA instance before the previous request is completed.
     *
     * @param request - CreateBasicEndpointGroupRequest
     *
     * @returns CreateBasicEndpointGroupResponse
     *
     * @param CreateBasicEndpointGroupRequest $request
     *
     * @return CreateBasicEndpointGroupResponse
     */
    public function createBasicEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBasicEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Creates multiple endpoints for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicEndpoints** is an asynchronous operation. After you call this operation, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) operation to query the status of endpoints. - If one or more endpoints are in the **init** state, it indicates that the endpoints are being created. In this case, you can continue to perform query operations on the endpoints. If all endpoints are in the **active** state, it indicates that the endpoints are created.
     * *   You cannot call the **CreateBasicEndpoints** operation again on the same GA instance before the previous operation is complete.
     *
     * @param request - CreateBasicEndpointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBasicEndpointsResponse
     *
     * @param CreateBasicEndpointsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateBasicEndpointsResponse
     */
    public function createBasicEndpointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpoints) {
            @$query['Endpoints'] = $request->endpoints;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBasicEndpoints',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBasicEndpointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates multiple endpoints for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **CreateBasicEndpoints** is an asynchronous operation. After you call this operation, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) operation to query the status of endpoints. - If one or more endpoints are in the **init** state, it indicates that the endpoints are being created. In this case, you can continue to perform query operations on the endpoints. If all endpoints are in the **active** state, it indicates that the endpoints are created.
     * *   You cannot call the **CreateBasicEndpoints** operation again on the same GA instance before the previous operation is complete.
     *
     * @param request - CreateBasicEndpointsRequest
     *
     * @returns CreateBasicEndpointsResponse
     *
     * @param CreateBasicEndpointsRequest $request
     *
     * @return CreateBasicEndpointsResponse
     */
    public function createBasicEndpoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBasicEndpointsWithOptions($request, $runtime);
    }

    /**
     * Creates an acceleration region for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     * Take note of the following limits:
     * *   You can specify only one acceleration region for each basic GA instance, and only IPv4 clients can connect to basic GA instances.
     * *   **CreateBasicIpSet** is an asynchronous operation. After you send a request, the system returns an acceleration region ID and runs the task in the background. You can call the [GetBasicIpSet](https://help.aliyun.com/document_detail/362987.html) operation to query the status of the task.
     *     *   If the acceleration region is in the **init** state, the acceleration region is being created. In this case, you can perform only query operations.
     *     *   If the acceleration region is in the **active** state, the acceleration region is created.
     * *   You cannot call the **CreateBasicIpSet** operation again on the same GA instance before the previous task is completed.
     *
     * @param request - CreateBasicIpSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBasicIpSetResponse
     *
     * @param CreateBasicIpSetRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateBasicIpSetResponse
     */
    public function createBasicIpSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateRegionId) {
            @$query['AccelerateRegionId'] = $request->accelerateRegionId;
        }

        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ispType) {
            @$query['IspType'] = $request->ispType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBasicIpSet',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBasicIpSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an acceleration region for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     * Take note of the following limits:
     * *   You can specify only one acceleration region for each basic GA instance, and only IPv4 clients can connect to basic GA instances.
     * *   **CreateBasicIpSet** is an asynchronous operation. After you send a request, the system returns an acceleration region ID and runs the task in the background. You can call the [GetBasicIpSet](https://help.aliyun.com/document_detail/362987.html) operation to query the status of the task.
     *     *   If the acceleration region is in the **init** state, the acceleration region is being created. In this case, you can perform only query operations.
     *     *   If the acceleration region is in the **active** state, the acceleration region is created.
     * *   You cannot call the **CreateBasicIpSet** operation again on the same GA instance before the previous task is completed.
     *
     * @param request - CreateBasicIpSetRequest
     *
     * @returns CreateBasicIpSetResponse
     *
     * @param CreateBasicIpSetRequest $request
     *
     * @return CreateBasicIpSetResponse
     */
    public function createBasicIpSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBasicIpSetWithOptions($request, $runtime);
    }

    /**
     * After you configure a custom routing listener for a Global Accelerator (GA) instance, the GA instance generates a port mapping table based on the listener port range, mapping information (protocols and port ranges) of the associated endpoint groups, and IP addresses of endpoints (vSwitches), and forwards client requests to the specified IP addresses and ports in the vSwitches.
     * You can call this operation to create mappings for an endpoint group of a custom routing listener. Take note of the following items:
     * *   **CreateCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **updating** state, it indicates that the mappings are being created for the endpoint group. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that the mappings are created for the endpoint group.
     * *   You cannot call the **CreateCustomRoutingEndpointGroupDestinations** operation again on the same GA instance before the previous task is completed.
     * ### Prerequisites
     * Make sure that the following prerequisites are met before you call this operation:
     * *   A standard GA instance is created. For more information, see [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html).
     * *   A bandwidth plan is associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](https://help.aliyun.com/document_detail/153239.html).
     * *   An application is deployed as an endpoint to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
     * *   The permissions to use custom routing listeners are acquired and a custom routing listener is created for the GA instance. The custom routing listener feature is in invitational preview. To use the feature, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.11182188.console-base-top.dworkorder.18ae4882n3v6ZW#/ticket/createIndex). For information about how to create a custom routing listener, see [CreateListener](https://help.aliyun.com/document_detail/153253.html).
     * *   An endpoint group is created for the custom routing listener. For more information, see [CreateCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/449363.html).
     *
     * @remarks
     * readAndWrite
     *
     * @param request - CreateCustomRoutingEndpointGroupDestinationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param CreateCustomRoutingEndpointGroupDestinationsRequest $request
     * @param RuntimeOptions                                      $runtime
     *
     * @return CreateCustomRoutingEndpointGroupDestinationsResponse
     */
    public function createCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->destinationConfigurations) {
            @$query['DestinationConfigurations'] = $request->destinationConfigurations;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCustomRoutingEndpointGroupDestinations',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCustomRoutingEndpointGroupDestinationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * After you configure a custom routing listener for a Global Accelerator (GA) instance, the GA instance generates a port mapping table based on the listener port range, mapping information (protocols and port ranges) of the associated endpoint groups, and IP addresses of endpoints (vSwitches), and forwards client requests to the specified IP addresses and ports in the vSwitches.
     * You can call this operation to create mappings for an endpoint group of a custom routing listener. Take note of the following items:
     * *   **CreateCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **updating** state, it indicates that the mappings are being created for the endpoint group. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that the mappings are created for the endpoint group.
     * *   You cannot call the **CreateCustomRoutingEndpointGroupDestinations** operation again on the same GA instance before the previous task is completed.
     * ### Prerequisites
     * Make sure that the following prerequisites are met before you call this operation:
     * *   A standard GA instance is created. For more information, see [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html).
     * *   A bandwidth plan is associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](https://help.aliyun.com/document_detail/153239.html).
     * *   An application is deployed as an endpoint to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
     * *   The permissions to use custom routing listeners are acquired and a custom routing listener is created for the GA instance. The custom routing listener feature is in invitational preview. To use the feature, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.11182188.console-base-top.dworkorder.18ae4882n3v6ZW#/ticket/createIndex). For information about how to create a custom routing listener, see [CreateListener](https://help.aliyun.com/document_detail/153253.html).
     * *   An endpoint group is created for the custom routing listener. For more information, see [CreateCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/449363.html).
     *
     * @remarks
     * readAndWrite
     *
     * @param request - CreateCustomRoutingEndpointGroupDestinationsRequest
     *
     * @returns CreateCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param CreateCustomRoutingEndpointGroupDestinationsRequest $request
     *
     * @return CreateCustomRoutingEndpointGroupDestinationsResponse
     */
    public function createCustomRoutingEndpointGroupDestinations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime);
    }

    /**
     * Creates endpoint groups for a custom routing listener.
     *
     * @remarks
     * Global Accelerator (GA) forwards client requests to endpoints in an endpoint group based on the routing type of the listener that is associated with the endpoint group.
     * *   After you configure an intelligent routing listener for a GA instance, the GA instance selects a nearby and healthy endpoint group and forwards client requests to a healthy endpoint in the endpoint group.
     * *   After you configure a custom routing listener for a GA instance, the instance generates a port mapping table based on the listener port range, protocols and port ranges of the associated endpoint groups, and IP addresses of endpoints (vSwitches), and forwards client requests to specified IP addresses and ports in the vSwitches.
     * You can call this operation to create endpoint groups for custom routing listeners. For information about how to create endpoint groups for intelligent routing listeners, see [CreateEndpointGroup](https://help.aliyun.com/document_detail/153259.html).
     * When you call this operation, take note of the following items:
     * *   **CreateCustomRoutingEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) or [ListCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/449374.html) operation to query the status of the endpoint groups that are associated with custom routing listeners.
     *     *   If one or more endpoint groups are in the **init** state, it indicates that the endpoint groups are being created. In this case, you can perform only query operations.
     *     *   If all endpoint groups are in the **active** state, it indicates that the endpoint groups are created.
     * *   The **CreateCustomRoutingEndpointGroups** operation cannot be called repeatedly for the same GA instance within a specific period of time.
     * ### Prerequisites
     * Make sure that the following requirements are met before you call this operation:
     * *   A standard GA instance is created. For more information, see [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html).
     * *   A bandwidth plan is associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](https://help.aliyun.com/document_detail/153239.html).
     * *   An application is deployed to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
     * *   The permissions to use custom routing listeners are acquired and a custom routing listener is created for the GA instance. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](https://help.aliyun.com/document_detail/153253.html).
     *
     * @param request - CreateCustomRoutingEndpointGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCustomRoutingEndpointGroupsResponse
     *
     * @param CreateCustomRoutingEndpointGroupsRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return CreateCustomRoutingEndpointGroupsResponse
     */
    public function createCustomRoutingEndpointGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointGroupConfigurations) {
            @$query['EndpointGroupConfigurations'] = $request->endpointGroupConfigurations;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCustomRoutingEndpointGroups',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCustomRoutingEndpointGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates endpoint groups for a custom routing listener.
     *
     * @remarks
     * Global Accelerator (GA) forwards client requests to endpoints in an endpoint group based on the routing type of the listener that is associated with the endpoint group.
     * *   After you configure an intelligent routing listener for a GA instance, the GA instance selects a nearby and healthy endpoint group and forwards client requests to a healthy endpoint in the endpoint group.
     * *   After you configure a custom routing listener for a GA instance, the instance generates a port mapping table based on the listener port range, protocols and port ranges of the associated endpoint groups, and IP addresses of endpoints (vSwitches), and forwards client requests to specified IP addresses and ports in the vSwitches.
     * You can call this operation to create endpoint groups for custom routing listeners. For information about how to create endpoint groups for intelligent routing listeners, see [CreateEndpointGroup](https://help.aliyun.com/document_detail/153259.html).
     * When you call this operation, take note of the following items:
     * *   **CreateCustomRoutingEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) or [ListCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/449374.html) operation to query the status of the endpoint groups that are associated with custom routing listeners.
     *     *   If one or more endpoint groups are in the **init** state, it indicates that the endpoint groups are being created. In this case, you can perform only query operations.
     *     *   If all endpoint groups are in the **active** state, it indicates that the endpoint groups are created.
     * *   The **CreateCustomRoutingEndpointGroups** operation cannot be called repeatedly for the same GA instance within a specific period of time.
     * ### Prerequisites
     * Make sure that the following requirements are met before you call this operation:
     * *   A standard GA instance is created. For more information, see [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html).
     * *   A bandwidth plan is associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](https://help.aliyun.com/document_detail/153239.html).
     * *   An application is deployed to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
     * *   The permissions to use custom routing listeners are acquired and a custom routing listener is created for the GA instance. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](https://help.aliyun.com/document_detail/153253.html).
     *
     * @param request - CreateCustomRoutingEndpointGroupsRequest
     *
     * @returns CreateCustomRoutingEndpointGroupsResponse
     *
     * @param CreateCustomRoutingEndpointGroupsRequest $request
     *
     * @return CreateCustomRoutingEndpointGroupsResponse
     */
    public function createCustomRoutingEndpointGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomRoutingEndpointGroupsWithOptions($request, $runtime);
    }

    /**
     * Creates traffic destinations for an endpoint that is associated with a custom routing listener.
     *
     * @remarks
     * This operation takes effect only when the traffic access policy of an endpoint allows traffic to specified destinations. You can call the [DescribeCustomRoutingEndpoint](https://help.aliyun.com/document_detail/449386.html) operation to query the traffic access policy of an endpoint. This operation takes effect only if the value of **TrafficToEndpointPolicy** is set to **AllowCustom**, which allows traffic to specific destinations.
     * When you call this operation, take note of the following items:
     * *   **CreateCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **updating** state, the traffic destinations are being created. In this state, you can only query the traffic destinations.
     *     *   If the endpoint group is in the **active** state, the traffic destinations are created.
     * *   You cannot call the **CreateCustomRoutingEndpointTrafficPolicies** operation repeatedly for the same GA instance in a specific period of time.
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   A standard GA instance is created. For more information, see [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html).
     * *   If the bandwidth metering method of the standard GA instance is **pay-by-bandwidth**, a bandwidth plan must be associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](https://help.aliyun.com/document_detail/153239.html).
     * *   An application that serves as the endpoint of the standard GA instance is deployed to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
     * *   The permissions to use custom routing listeners are acquired, and a custom routing listener is created. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](https://help.aliyun.com/document_detail/153253.html).
     * *   Endpoint groups are created for the custom routing listener. For more information, see [CreateCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/449363.html).
     * *   Endpoints are created for the custom routing listener. For more information, see [CreateCustomRoutingEndpoints](https://help.aliyun.com/document_detail/449382.html).
     *
     * @param request - CreateCustomRoutingEndpointTrafficPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCustomRoutingEndpointTrafficPoliciesResponse
     *
     * @param CreateCustomRoutingEndpointTrafficPoliciesRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return CreateCustomRoutingEndpointTrafficPoliciesResponse
     */
    public function createCustomRoutingEndpointTrafficPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->policyConfigurations) {
            @$query['PolicyConfigurations'] = $request->policyConfigurations;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCustomRoutingEndpointTrafficPolicies',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCustomRoutingEndpointTrafficPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates traffic destinations for an endpoint that is associated with a custom routing listener.
     *
     * @remarks
     * This operation takes effect only when the traffic access policy of an endpoint allows traffic to specified destinations. You can call the [DescribeCustomRoutingEndpoint](https://help.aliyun.com/document_detail/449386.html) operation to query the traffic access policy of an endpoint. This operation takes effect only if the value of **TrafficToEndpointPolicy** is set to **AllowCustom**, which allows traffic to specific destinations.
     * When you call this operation, take note of the following items:
     * *   **CreateCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **updating** state, the traffic destinations are being created. In this state, you can only query the traffic destinations.
     *     *   If the endpoint group is in the **active** state, the traffic destinations are created.
     * *   You cannot call the **CreateCustomRoutingEndpointTrafficPolicies** operation repeatedly for the same GA instance in a specific period of time.
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   A standard GA instance is created. For more information, see [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html).
     * *   If the bandwidth metering method of the standard GA instance is **pay-by-bandwidth**, a bandwidth plan must be associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](https://help.aliyun.com/document_detail/153239.html).
     * *   An application that serves as the endpoint of the standard GA instance is deployed to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
     * *   The permissions to use custom routing listeners are acquired, and a custom routing listener is created. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](https://help.aliyun.com/document_detail/153253.html).
     * *   Endpoint groups are created for the custom routing listener. For more information, see [CreateCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/449363.html).
     * *   Endpoints are created for the custom routing listener. For more information, see [CreateCustomRoutingEndpoints](https://help.aliyun.com/document_detail/449382.html).
     *
     * @param request - CreateCustomRoutingEndpointTrafficPoliciesRequest
     *
     * @returns CreateCustomRoutingEndpointTrafficPoliciesResponse
     *
     * @param CreateCustomRoutingEndpointTrafficPoliciesRequest $request
     *
     * @return CreateCustomRoutingEndpointTrafficPoliciesResponse
     */
    public function createCustomRoutingEndpointTrafficPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomRoutingEndpointTrafficPoliciesWithOptions($request, $runtime);
    }

    /**
     * Creates endpoints for a custom routing listener.
     *
     * @remarks
     * After you configure a custom routing listener for a Global Accelerator (GA) instance, the instance generates a port mapping table based on the listener port range, the protocols and port ranges of the associated endpoint groups, and the IP addresses of endpoints (vSwitches), and forwards client requests to specified IP addresses and ports in the vSwitches.
     * This operation is used to create endpoints for custom routing listeners. When you call this operation, take note of the following items:
     * *   **CreateCustomRoutingEndpoints** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of an endpoint group and determine whether endpoints are created in the endpoint group.
     *     *   If the endpoint group is in the **updating** state, it indicates that endpoints are being created. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that endpoints are created.
     * *   The **CreateCustomRoutingEndpoints** operation cannot be called repeatedly for the same GA instance within a specific period of time.
     * ### Prerequisites
     * The following operations are complete before you call this operation:
     * *   Create a standard GA instance. For more information, see [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html).
     * *   Associate a bandwidth plan with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](https://help.aliyun.com/document_detail/153239.html).
     * *   Deploy an application that serves as the endpoint of the GA instance. The application is used to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
     * *   Apply for permissions to use custom routing listeners and create a custom routing listener for the standard GA instance. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](https://help.aliyun.com/document_detail/153253.html).
     * *   Create an endpoint group for the custom routing listener. For more information, see [CreateCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/449363.html).
     *
     * @param request - CreateCustomRoutingEndpointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCustomRoutingEndpointsResponse
     *
     * @param CreateCustomRoutingEndpointsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CreateCustomRoutingEndpointsResponse
     */
    public function createCustomRoutingEndpointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointConfigurations) {
            @$query['EndpointConfigurations'] = $request->endpointConfigurations;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCustomRoutingEndpoints',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCustomRoutingEndpointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates endpoints for a custom routing listener.
     *
     * @remarks
     * After you configure a custom routing listener for a Global Accelerator (GA) instance, the instance generates a port mapping table based on the listener port range, the protocols and port ranges of the associated endpoint groups, and the IP addresses of endpoints (vSwitches), and forwards client requests to specified IP addresses and ports in the vSwitches.
     * This operation is used to create endpoints for custom routing listeners. When you call this operation, take note of the following items:
     * *   **CreateCustomRoutingEndpoints** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of an endpoint group and determine whether endpoints are created in the endpoint group.
     *     *   If the endpoint group is in the **updating** state, it indicates that endpoints are being created. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that endpoints are created.
     * *   The **CreateCustomRoutingEndpoints** operation cannot be called repeatedly for the same GA instance within a specific period of time.
     * ### Prerequisites
     * The following operations are complete before you call this operation:
     * *   Create a standard GA instance. For more information, see [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html).
     * *   Associate a bandwidth plan with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](https://help.aliyun.com/document_detail/153239.html).
     * *   Deploy an application that serves as the endpoint of the GA instance. The application is used to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
     * *   Apply for permissions to use custom routing listeners and create a custom routing listener for the standard GA instance. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](https://help.aliyun.com/document_detail/153253.html).
     * *   Create an endpoint group for the custom routing listener. For more information, see [CreateCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/449363.html).
     *
     * @param request - CreateCustomRoutingEndpointsRequest
     *
     * @returns CreateCustomRoutingEndpointsResponse
     *
     * @param CreateCustomRoutingEndpointsRequest $request
     *
     * @return CreateCustomRoutingEndpointsResponse
     */
    public function createCustomRoutingEndpoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCustomRoutingEndpointsWithOptions($request, $runtime);
    }

    /**
     * Creates a domain name and associates the domain name with Global Accelerator (GA) instances.
     *
     * @remarks
     * After you associate an accelerated domain name that has obtained an ICP number with a Global Accelerator (GA) instance, you do not need to complete filing for the accelerated domain name or its subdomains on Alibaba Cloud.
     * You can call this operation to add an accelerated domain name and associate the accelerated domain name with GA instances. When you call this operation, take note of the following items:
     * *   If your accelerated domain name is hosted in the Chinese mainland, you must obtain an ICP number for the domain name.
     * *   The same accelerated domain name cannot be repeatedly associated with the same GA instance.
     * *   You cannot repeatedly call the **CreateDomain** operation by using the same Alibaba Cloud account within a specific period of time.
     *
     * @param request - CreateDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDomainResponse
     *
     * @param CreateDomainRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CreateDomainResponse
     */
    public function createDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorIds) {
            @$query['AcceleratorIds'] = $request->acceleratorIds;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDomain',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a domain name and associates the domain name with Global Accelerator (GA) instances.
     *
     * @remarks
     * After you associate an accelerated domain name that has obtained an ICP number with a Global Accelerator (GA) instance, you do not need to complete filing for the accelerated domain name or its subdomains on Alibaba Cloud.
     * You can call this operation to add an accelerated domain name and associate the accelerated domain name with GA instances. When you call this operation, take note of the following items:
     * *   If your accelerated domain name is hosted in the Chinese mainland, you must obtain an ICP number for the domain name.
     * *   The same accelerated domain name cannot be repeatedly associated with the same GA instance.
     * *   You cannot repeatedly call the **CreateDomain** operation by using the same Alibaba Cloud account within a specific period of time.
     *
     * @param request - CreateDomainRequest
     *
     * @returns CreateDomainResponse
     *
     * @param CreateDomainRequest $request
     *
     * @return CreateDomainResponse
     */
    public function createDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDomainWithOptions($request, $runtime);
    }

    /**
     * Creates an endpoint group.
     *
     * @remarks
     *   When you call this operation to create a virtual endpoint group for a Layer 4 listener, make sure that a default endpoint group is created.
     * *   **CreateEndpointGroup** is an asynchronous operation. After you send a request, the system returns the ID of an endpoint group, but the endpoint group is still being created in the system background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the state of the endpoint group.
     *     *   If the endpoint group is in the **init** state, it indicates that the endpoint group is being created. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that the endpoint group is created.
     * *   The **CreateEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - CreateEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateEndpointGroupResponse
     *
     * @param CreateEndpointGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateEndpointGroupResponse
     */
    public function createEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointConfigurations) {
            @$query['EndpointConfigurations'] = $request->endpointConfigurations;
        }

        if (null !== $request->endpointGroupRegion) {
            @$query['EndpointGroupRegion'] = $request->endpointGroupRegion;
        }

        if (null !== $request->endpointGroupType) {
            @$query['EndpointGroupType'] = $request->endpointGroupType;
        }

        if (null !== $request->endpointIpVersion) {
            @$query['EndpointIpVersion'] = $request->endpointIpVersion;
        }

        if (null !== $request->endpointProtocolVersion) {
            @$query['EndpointProtocolVersion'] = $request->endpointProtocolVersion;
        }

        if (null !== $request->endpointRequestProtocol) {
            @$query['EndpointRequestProtocol'] = $request->endpointRequestProtocol;
        }

        if (null !== $request->healthCheckEnabled) {
            @$query['HealthCheckEnabled'] = $request->healthCheckEnabled;
        }

        if (null !== $request->healthCheckHost) {
            @$query['HealthCheckHost'] = $request->healthCheckHost;
        }

        if (null !== $request->healthCheckIntervalSeconds) {
            @$query['HealthCheckIntervalSeconds'] = $request->healthCheckIntervalSeconds;
        }

        if (null !== $request->healthCheckPath) {
            @$query['HealthCheckPath'] = $request->healthCheckPath;
        }

        if (null !== $request->healthCheckPort) {
            @$query['HealthCheckPort'] = $request->healthCheckPort;
        }

        if (null !== $request->healthCheckProtocol) {
            @$query['HealthCheckProtocol'] = $request->healthCheckProtocol;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->portOverrides) {
            @$query['PortOverrides'] = $request->portOverrides;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->thresholdCount) {
            @$query['ThresholdCount'] = $request->thresholdCount;
        }

        if (null !== $request->trafficPercentage) {
            @$query['TrafficPercentage'] = $request->trafficPercentage;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an endpoint group.
     *
     * @remarks
     *   When you call this operation to create a virtual endpoint group for a Layer 4 listener, make sure that a default endpoint group is created.
     * *   **CreateEndpointGroup** is an asynchronous operation. After you send a request, the system returns the ID of an endpoint group, but the endpoint group is still being created in the system background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the state of the endpoint group.
     *     *   If the endpoint group is in the **init** state, it indicates that the endpoint group is being created. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that the endpoint group is created.
     * *   The **CreateEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - CreateEndpointGroupRequest
     *
     * @returns CreateEndpointGroupResponse
     *
     * @param CreateEndpointGroupRequest $request
     *
     * @return CreateEndpointGroupResponse
     */
    public function createEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Creates multiple endpoint groups at a time.
     *
     * @remarks
     *   You can call this operation to create multiple endpoint groups at a time. However, you cannot create a default endpoint group and a virtual endpoint group at the same time.
     * *   You cannot create a virtual endpoint group for a Layer 4 listener. To create a virtual endpoint group for a Layer 4 listener, call the [CreateEndpointGroup](https://help.aliyun.com/document_detail/2302394.html) operation.
     * *   **CreateEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) or [ListEndpointGroups](https://help.aliyun.com/document_detail/153261.html) operation to query the status of endpoint groups.
     *     *   If the endpoint groups are in the **init** state, the endpoint groups are being created. In this case, you can perform only query operations.
     *     *   If all endpoint groups are in the **active** state, the endpoint groups are created.
     * *   The **CreateEndpointGroups** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - CreateEndpointGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateEndpointGroupsResponse
     *
     * @param CreateEndpointGroupsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateEndpointGroupsResponse
     */
    public function createEndpointGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $body = [];
        $bodyFlat = [];
        if (null !== $request->endpointGroupConfigurations) {
            @$bodyFlat['EndpointGroupConfigurations'] = $request->endpointGroupConfigurations;
        }

        $body = Dara::merge([
        ], $body, Utils::query($bodyFlat));
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateEndpointGroups',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateEndpointGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates multiple endpoint groups at a time.
     *
     * @remarks
     *   You can call this operation to create multiple endpoint groups at a time. However, you cannot create a default endpoint group and a virtual endpoint group at the same time.
     * *   You cannot create a virtual endpoint group for a Layer 4 listener. To create a virtual endpoint group for a Layer 4 listener, call the [CreateEndpointGroup](https://help.aliyun.com/document_detail/2302394.html) operation.
     * *   **CreateEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) or [ListEndpointGroups](https://help.aliyun.com/document_detail/153261.html) operation to query the status of endpoint groups.
     *     *   If the endpoint groups are in the **init** state, the endpoint groups are being created. In this case, you can perform only query operations.
     *     *   If all endpoint groups are in the **active** state, the endpoint groups are created.
     * *   The **CreateEndpointGroups** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - CreateEndpointGroupsRequest
     *
     * @returns CreateEndpointGroupsResponse
     *
     * @param CreateEndpointGroupsRequest $request
     *
     * @return CreateEndpointGroupsResponse
     */
    public function createEndpointGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createEndpointGroupsWithOptions($request, $runtime);
    }

    /**
     * If you want to distribute and process traffic based on request attributes, such as domain names and paths, or information in requests, such as HTTP headers and cookies, you can create custom forwarding rules for a listener. The listener forwards requests based on the forwarding rules. You can call the CreateForwardingRules operation to create forwarding rules.
     *
     * @remarks
     * Before you call this operation to create forwarding rules, we recommend that you learn how forwarding rules work and how requests are matched against forwarding rules. For more information, see [Configure forwarding rules](https://help.aliyun.com/document_detail/204224.html).
     * When you call this operation, take note of the following items:
     * *   **CreateForwardingRules** is an asynchronous operation. After you send a request, the system returns a forwarding rule ID and runs the task in the background. You can call the [ListForwardingRules](https://help.aliyun.com/document_detail/205817.html) operation to query the status of a forwarding rule.
     *     *   If the forwarding rule is in the **configuring** state, the rule is being created. In this case, you can only perform query operations.
     *     *   If the forwarding rule is in the **active** state, the rule is created.
     * *   The **CreateForwardingRules** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - CreateForwardingRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateForwardingRulesResponse
     *
     * @param CreateForwardingRulesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateForwardingRulesResponse
     */
    public function createForwardingRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $body = [];
        $bodyFlat = [];
        if (null !== $request->forwardingRules) {
            @$bodyFlat['ForwardingRules'] = $request->forwardingRules;
        }

        $body = Dara::merge([
        ], $body, Utils::query($bodyFlat));
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateForwardingRules',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateForwardingRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * If you want to distribute and process traffic based on request attributes, such as domain names and paths, or information in requests, such as HTTP headers and cookies, you can create custom forwarding rules for a listener. The listener forwards requests based on the forwarding rules. You can call the CreateForwardingRules operation to create forwarding rules.
     *
     * @remarks
     * Before you call this operation to create forwarding rules, we recommend that you learn how forwarding rules work and how requests are matched against forwarding rules. For more information, see [Configure forwarding rules](https://help.aliyun.com/document_detail/204224.html).
     * When you call this operation, take note of the following items:
     * *   **CreateForwardingRules** is an asynchronous operation. After you send a request, the system returns a forwarding rule ID and runs the task in the background. You can call the [ListForwardingRules](https://help.aliyun.com/document_detail/205817.html) operation to query the status of a forwarding rule.
     *     *   If the forwarding rule is in the **configuring** state, the rule is being created. In this case, you can only perform query operations.
     *     *   If the forwarding rule is in the **active** state, the rule is created.
     * *   The **CreateForwardingRules** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - CreateForwardingRulesRequest
     *
     * @returns CreateForwardingRulesResponse
     *
     * @param CreateForwardingRulesRequest $request
     *
     * @return CreateForwardingRulesResponse
     */
    public function createForwardingRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createForwardingRulesWithOptions($request, $runtime);
    }

    /**
     * Creates acceleration regions.
     *
     * @remarks
     *   **CreateIpSets** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of the task.
     *     *   If acceleration regions are in the **init** state, it indicates that the acceleration regions are being created. In this case, you can perform only query operations.
     *     *   If acceleration regions are in the **active** state, it indicates that the acceleration regions are created.
     * *   You cannot call the **CreateIpSets** operation again on the same GA instance before the previous operation is completed.
     *
     * @param request - CreateIpSetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateIpSetsResponse
     *
     * @param CreateIpSetsRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CreateIpSetsResponse
     */
    public function createIpSetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateRegion) {
            @$query['AccelerateRegion'] = $request->accelerateRegion;
        }

        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateIpSets',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateIpSetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates acceleration regions.
     *
     * @remarks
     *   **CreateIpSets** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of the task.
     *     *   If acceleration regions are in the **init** state, it indicates that the acceleration regions are being created. In this case, you can perform only query operations.
     *     *   If acceleration regions are in the **active** state, it indicates that the acceleration regions are created.
     * *   You cannot call the **CreateIpSets** operation again on the same GA instance before the previous operation is completed.
     *
     * @param request - CreateIpSetsRequest
     *
     * @returns CreateIpSetsResponse
     *
     * @param CreateIpSetsRequest $request
     *
     * @return CreateIpSetsResponse
     */
    public function createIpSets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createIpSetsWithOptions($request, $runtime);
    }

    /**
     * A listener checks connection requests and distributes the requests to endpoints based on forwarding rules that are defined by the scheduling algorithm. You can call the CreateListener operation to create a listener for a GA instance.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   **CreateListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the status of the task.
     *     *   If the listener is in the **init** state, the listener is being created. In this state, you can perform only query operations.
     *     *   If the listener is in the **active** state, the listener is created.
     * *   You cannot repeatedly call the **CreateListener** operation for the same GA instance within the specified period of time.
     *
     * @param request - CreateListenerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateListenerResponse
     *
     * @param CreateListenerRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateListenerResponse
     */
    public function createListenerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->certificates) {
            @$query['Certificates'] = $request->certificates;
        }

        if (null !== $request->clientAffinity) {
            @$query['ClientAffinity'] = $request->clientAffinity;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->customRoutingEndpointGroupConfigurations) {
            @$query['CustomRoutingEndpointGroupConfigurations'] = $request->customRoutingEndpointGroupConfigurations;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->endpointGroupConfigurations) {
            @$query['EndpointGroupConfigurations'] = $request->endpointGroupConfigurations;
        }

        if (null !== $request->httpVersion) {
            @$query['HttpVersion'] = $request->httpVersion;
        }

        if (null !== $request->idleTimeout) {
            @$query['IdleTimeout'] = $request->idleTimeout;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->portRanges) {
            @$query['PortRanges'] = $request->portRanges;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->requestTimeout) {
            @$query['RequestTimeout'] = $request->requestTimeout;
        }

        if (null !== $request->securityPolicyId) {
            @$query['SecurityPolicyId'] = $request->securityPolicyId;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        if (null !== $request->XForwardedForConfig) {
            @$query['XForwardedForConfig'] = $request->XForwardedForConfig;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateListener',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateListenerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * A listener checks connection requests and distributes the requests to endpoints based on forwarding rules that are defined by the scheduling algorithm. You can call the CreateListener operation to create a listener for a GA instance.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   **CreateListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the status of the task.
     *     *   If the listener is in the **init** state, the listener is being created. In this state, you can perform only query operations.
     *     *   If the listener is in the **active** state, the listener is created.
     * *   You cannot repeatedly call the **CreateListener** operation for the same GA instance within the specified period of time.
     *
     * @param request - CreateListenerRequest
     *
     * @returns CreateListenerResponse
     *
     * @param CreateListenerRequest $request
     *
     * @return CreateListenerResponse
     */
    public function createListener($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createListenerWithOptions($request, $runtime);
    }

    /**
     * Creates secondary IP addresses for a CNAME that is assigned to a Global Accelerator (GA) instance. If an acceleration area of the GA instance becomes unavailable, access traffic is redirected to the secondary IP addresses.
     *
     * @remarks
     *   **CreateSpareIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of a GA instance.
     *     *   If the GA instance is in the **configuring** state, it indicates that secondary IP addresses are being created for the CNAME that is assigned to the GA instance. In this case, you can only perform query operations.
     *     *   If the GA instance is in the **active** state, it indicates that secondary IP addresses are created for the CNAME that is assigned to the GA instance.
     * *   The **CreateSpareIps** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - CreateSpareIpsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateSpareIpsResponse
     *
     * @param CreateSpareIpsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateSpareIpsResponse
     */
    public function createSpareIpsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->spareIps) {
            @$query['SpareIps'] = $request->spareIps;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateSpareIps',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateSpareIpsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates secondary IP addresses for a CNAME that is assigned to a Global Accelerator (GA) instance. If an acceleration area of the GA instance becomes unavailable, access traffic is redirected to the secondary IP addresses.
     *
     * @remarks
     *   **CreateSpareIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of a GA instance.
     *     *   If the GA instance is in the **configuring** state, it indicates that secondary IP addresses are being created for the CNAME that is assigned to the GA instance. In this case, you can only perform query operations.
     *     *   If the GA instance is in the **active** state, it indicates that secondary IP addresses are created for the CNAME that is assigned to the GA instance.
     * *   The **CreateSpareIps** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - CreateSpareIpsRequest
     *
     * @returns CreateSpareIpsResponse
     *
     * @param CreateSpareIpsRequest $request
     *
     * @return CreateSpareIpsResponse
     */
    public function createSpareIps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSpareIpsWithOptions($request, $runtime);
    }

    /**
     * Deletes a Global Accelerator (GA) instance.
     *
     * @remarks
     *   You cannot delete subscription GA instances.
     * *   **DeleteAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of the task.
     *     *   If the GA instance is in the **deleting** state, the GA instance is being deleted. In this case, you can perform only query operations.
     *     *   If the GA instance cannot be queried, the GA instance is deleted.
     *
     * @param request - DeleteAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteAcceleratorResponse
     *
     * @param DeleteAcceleratorRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteAcceleratorResponse
     */
    public function deleteAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a Global Accelerator (GA) instance.
     *
     * @remarks
     *   You cannot delete subscription GA instances.
     * *   **DeleteAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of the task.
     *     *   If the GA instance is in the **deleting** state, the GA instance is being deleted. In this case, you can perform only query operations.
     *     *   If the GA instance cannot be queried, the GA instance is deleted.
     *
     * @param request - DeleteAcceleratorRequest
     *
     * @returns DeleteAcceleratorResponse
     *
     * @param DeleteAcceleratorRequest $request
     *
     * @return DeleteAcceleratorResponse
     */
    public function deleteAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Deletes a access control list (ACL) of a Global Accelerator (GA) instance.
     *
     * @remarks
     * *DeleteAcl** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetAcl](https://help.aliyun.com/document_detail/258292.html) operation to query the status of an ACL.
     * *   If the ACL is in the **deleting** state, it indicates that the ACL is being deleted. In this case, you can perform only query operations.
     * *   If the ACL cannot be queried, it indicates that the ACL is deleted.
     *
     * @param request - DeleteAclRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteAclResponse
     *
     * @param DeleteAclRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return DeleteAclResponse
     */
    public function deleteAclWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteAcl',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a access control list (ACL) of a Global Accelerator (GA) instance.
     *
     * @remarks
     * *DeleteAcl** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetAcl](https://help.aliyun.com/document_detail/258292.html) operation to query the status of an ACL.
     * *   If the ACL is in the **deleting** state, it indicates that the ACL is being deleted. In this case, you can perform only query operations.
     * *   If the ACL cannot be queried, it indicates that the ACL is deleted.
     *
     * @param request - DeleteAclRequest
     *
     * @returns DeleteAclResponse
     *
     * @param DeleteAclRequest $request
     *
     * @return DeleteAclResponse
     */
    public function deleteAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAclWithOptions($request, $runtime);
    }

    /**
     * Deletes an origin probing task.
     *
     * @remarks
     *   **DeleteApplicationMonitor** is an asynchronous operation. After you call this operation, the system returns a request ID, but the operation is still being performed in the system background. You can call the [ListApplicationMonitor](https://help.aliyun.com/document_detail/408462.html) operation to query the state of an origin probing task.
     *     *   If the origin probing task is in the **deleting** state, it indicates that the task is being deleted. In this case, you can perform only query operations.
     *     *   If the origin probing task cannot be queried, it indicates that the task is deleted.
     * *   The **DeleteApplicationMonitor** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteApplicationMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteApplicationMonitorResponse
     *
     * @param DeleteApplicationMonitorRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteApplicationMonitorResponse
     */
    public function deleteApplicationMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteApplicationMonitor',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteApplicationMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an origin probing task.
     *
     * @remarks
     *   **DeleteApplicationMonitor** is an asynchronous operation. After you call this operation, the system returns a request ID, but the operation is still being performed in the system background. You can call the [ListApplicationMonitor](https://help.aliyun.com/document_detail/408462.html) operation to query the state of an origin probing task.
     *     *   If the origin probing task is in the **deleting** state, it indicates that the task is being deleted. In this case, you can perform only query operations.
     *     *   If the origin probing task cannot be queried, it indicates that the task is deleted.
     * *   The **DeleteApplicationMonitor** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteApplicationMonitorRequest
     *
     * @returns DeleteApplicationMonitorResponse
     *
     * @param DeleteApplicationMonitorRequest $request
     *
     * @return DeleteApplicationMonitorResponse
     */
    public function deleteApplicationMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteApplicationMonitorWithOptions($request, $runtime);
    }

    /**
     * Deletes a bandwidth plan.
     *
     * @remarks
     *   By default, subscription bandwidth plans cannot be deleted. If you want to unsubscribe from subscription bandwidth plans, go to the [Unsubscribe](https://usercenter2-intl.aliyun.com/refund/refund) page. Before you can unsubscribe from a subscription bandwidth plan that is associated with a Global Accelerator (GA) instance, you must disassociate the bandwidth plan from the GA instance. For information about how to disassociate a bandwidth plan from a GA instance, see [BandwidthPackageRemoveAccelerator](https://help.aliyun.com/document_detail/153240.html).
     * *   Bandwidth plans that are associated with GA instances cannot be deleted. Before you can delete a bandwidth plan that is associated with a GA instance, you must disassociate the bandwidth plan from the GA instance. For information about how to disassociate a bandwidth plan from a GA instance, see [BandwidthPackageRemoveAccelerator](https://help.aliyun.com/document_detail/153240.html).
     * *   **DeleteBandwidthPackage** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the task.
     *     *   If the bandwidth plan is in the **deleting** state, the bandwidth plan is being deleted. In this case, you can perform only query operations.
     *     *   If the bandwidth plan cannot be found, the bandwidth plan is deleted.
     * *   The **DeleteBandwidthPackage** operation cannot be repeatedly called for the same bandwidth plan within a specific period of time.
     *
     * @param request - DeleteBandwidthPackageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBandwidthPackageResponse
     *
     * @param DeleteBandwidthPackageRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteBandwidthPackageResponse
     */
    public function deleteBandwidthPackageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBandwidthPackage',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a bandwidth plan.
     *
     * @remarks
     *   By default, subscription bandwidth plans cannot be deleted. If you want to unsubscribe from subscription bandwidth plans, go to the [Unsubscribe](https://usercenter2-intl.aliyun.com/refund/refund) page. Before you can unsubscribe from a subscription bandwidth plan that is associated with a Global Accelerator (GA) instance, you must disassociate the bandwidth plan from the GA instance. For information about how to disassociate a bandwidth plan from a GA instance, see [BandwidthPackageRemoveAccelerator](https://help.aliyun.com/document_detail/153240.html).
     * *   Bandwidth plans that are associated with GA instances cannot be deleted. Before you can delete a bandwidth plan that is associated with a GA instance, you must disassociate the bandwidth plan from the GA instance. For information about how to disassociate a bandwidth plan from a GA instance, see [BandwidthPackageRemoveAccelerator](https://help.aliyun.com/document_detail/153240.html).
     * *   **DeleteBandwidthPackage** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the task.
     *     *   If the bandwidth plan is in the **deleting** state, the bandwidth plan is being deleted. In this case, you can perform only query operations.
     *     *   If the bandwidth plan cannot be found, the bandwidth plan is deleted.
     * *   The **DeleteBandwidthPackage** operation cannot be repeatedly called for the same bandwidth plan within a specific period of time.
     *
     * @param request - DeleteBandwidthPackageRequest
     *
     * @returns DeleteBandwidthPackageResponse
     *
     * @param DeleteBandwidthPackageRequest $request
     *
     * @return DeleteBandwidthPackageResponse
     */
    public function deleteBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * Deletes an accelerated IP address of a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **DeleteBasicAccelerateIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) operation to query the status of an accelerated IP address.
     *     *   If an accelerated IP address is in the **deleting** state, the accelerated IP address is being deleted. In this case, you can perform only query operations.
     *     *   If the system fails to return information about an accelerated IP address, the accelerated IP address is deleted.
     * *   You cannot repeatedly call the **DeleteBasicAccelerateIp** operation for the same basic GA instance within a specific period of time.
     *
     * @param request - DeleteBasicAccelerateIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBasicAccelerateIpResponse
     *
     * @param DeleteBasicAccelerateIpRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DeleteBasicAccelerateIpResponse
     */
    public function deleteBasicAccelerateIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateIpId) {
            @$query['AccelerateIpId'] = $request->accelerateIpId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBasicAccelerateIp',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBasicAccelerateIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an accelerated IP address of a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **DeleteBasicAccelerateIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) operation to query the status of an accelerated IP address.
     *     *   If an accelerated IP address is in the **deleting** state, the accelerated IP address is being deleted. In this case, you can perform only query operations.
     *     *   If the system fails to return information about an accelerated IP address, the accelerated IP address is deleted.
     * *   You cannot repeatedly call the **DeleteBasicAccelerateIp** operation for the same basic GA instance within a specific period of time.
     *
     * @param request - DeleteBasicAccelerateIpRequest
     *
     * @returns DeleteBasicAccelerateIpResponse
     *
     * @param DeleteBasicAccelerateIpRequest $request
     *
     * @return DeleteBasicAccelerateIpResponse
     */
    public function deleteBasicAccelerateIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBasicAccelerateIpWithOptions($request, $runtime);
    }

    /**
     * Deletes a mapping between an accelerated IP address and an endpoint for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **DeleteBasicAccelerateIpEndpointRelation** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the following operations to check whether an accelerated IP address is disassociated from an endpoint:
     *     *   You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) and [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) operations to query the status of an accelerated IP address and an endpoint. If the accelerated IP address and the endpoint are in the **unbinding** state, the accelerated IP address is being disassociated from the endpoint. In this case, you can query the IP address and endpoint but cannot perform other operations.
     *     *   If the association status between the accelerated IP address and the endpoint cannot be queried by calling the [ListBasicAccelerateIpEndpointRelations](https://help.aliyun.com/document_detail/466803.html) operation, the accelerated IP address is disassociated from the endpoint.
     * *   The **DeleteBasicAccelerateIpEndpointRelation** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
     *
     * @param request - DeleteBasicAccelerateIpEndpointRelationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBasicAccelerateIpEndpointRelationResponse
     *
     * @param DeleteBasicAccelerateIpEndpointRelationRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return DeleteBasicAccelerateIpEndpointRelationResponse
     */
    public function deleteBasicAccelerateIpEndpointRelationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateIpId) {
            @$query['AccelerateIpId'] = $request->accelerateIpId;
        }

        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBasicAccelerateIpEndpointRelation',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBasicAccelerateIpEndpointRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a mapping between an accelerated IP address and an endpoint for a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **DeleteBasicAccelerateIpEndpointRelation** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the following operations to check whether an accelerated IP address is disassociated from an endpoint:
     *     *   You can call the [GetBasicAccelerateIp](https://help.aliyun.com/document_detail/466794.html) and [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) operations to query the status of an accelerated IP address and an endpoint. If the accelerated IP address and the endpoint are in the **unbinding** state, the accelerated IP address is being disassociated from the endpoint. In this case, you can query the IP address and endpoint but cannot perform other operations.
     *     *   If the association status between the accelerated IP address and the endpoint cannot be queried by calling the [ListBasicAccelerateIpEndpointRelations](https://help.aliyun.com/document_detail/466803.html) operation, the accelerated IP address is disassociated from the endpoint.
     * *   The **DeleteBasicAccelerateIpEndpointRelation** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
     *
     * @param request - DeleteBasicAccelerateIpEndpointRelationRequest
     *
     * @returns DeleteBasicAccelerateIpEndpointRelationResponse
     *
     * @param DeleteBasicAccelerateIpEndpointRelationRequest $request
     *
     * @return DeleteBasicAccelerateIpEndpointRelationResponse
     */
    public function deleteBasicAccelerateIpEndpointRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBasicAccelerateIpEndpointRelationWithOptions($request, $runtime);
    }

    /**
     * Deletes a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   You cannot delete subscription basic GA instances. You can unsubscribe from a basic GA instance on the [Unsubscribe](https://usercenter2-intl.aliyun.com/refund/refund) page. Before you unsubscribe from a basic GA instance, make sure that the acceleration areas and endpoint groups of the GA instance are deleted and no bandwidth plans are associated with the GA instance.
     *     *   For information about how to delete an acceleration area, see [DeleteBasicIpSet](https://help.aliyun.com/document_detail/2253388.html).
     *     *   For information about how to delete an endpoint group, see [DeleteBasicEndpointGroup](https://help.aliyun.com/document_detail/2253399.html).
     *     *   For information about how to disassociate a bandwidth plan from a basic GA instance, see [BandwidthPackageRemoveAccelerator](https://help.aliyun.com/document_detail/153240.html).
     * *   Before you call this operation to delete a pay-as-you-go basic GA instance, make sure that all data is migrated and the acceleration areas and endpoint groups of the instance are deleted.
     *     *   For information about how to delete an acceleration area, see [DeleteBasicIpSet](https://help.aliyun.com/document_detail/2253388.html).
     *     *   For information about how to delete an endpoint group, see [DeleteBasicEndpointGroup](https://help.aliyun.com/document_detail/2253399.html).
     * *   **DeleteBasicAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerator](https://help.aliyun.com/document_detail/353188.html) operation to query the status of the task.
     *     *   If the basic GA instance is in the **deleting** state, it indicates that the instance is being deleted. In this case, you can perform only query operations.
     *     *   If the information about the basic GA instance is not displayed in the response, it indicates that the instance is deleted.
     *
     * @param request - DeleteBasicAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBasicAcceleratorResponse
     *
     * @param DeleteBasicAcceleratorRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteBasicAcceleratorResponse
     */
    public function deleteBasicAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBasicAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBasicAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   You cannot delete subscription basic GA instances. You can unsubscribe from a basic GA instance on the [Unsubscribe](https://usercenter2-intl.aliyun.com/refund/refund) page. Before you unsubscribe from a basic GA instance, make sure that the acceleration areas and endpoint groups of the GA instance are deleted and no bandwidth plans are associated with the GA instance.
     *     *   For information about how to delete an acceleration area, see [DeleteBasicIpSet](https://help.aliyun.com/document_detail/2253388.html).
     *     *   For information about how to delete an endpoint group, see [DeleteBasicEndpointGroup](https://help.aliyun.com/document_detail/2253399.html).
     *     *   For information about how to disassociate a bandwidth plan from a basic GA instance, see [BandwidthPackageRemoveAccelerator](https://help.aliyun.com/document_detail/153240.html).
     * *   Before you call this operation to delete a pay-as-you-go basic GA instance, make sure that all data is migrated and the acceleration areas and endpoint groups of the instance are deleted.
     *     *   For information about how to delete an acceleration area, see [DeleteBasicIpSet](https://help.aliyun.com/document_detail/2253388.html).
     *     *   For information about how to delete an endpoint group, see [DeleteBasicEndpointGroup](https://help.aliyun.com/document_detail/2253399.html).
     * *   **DeleteBasicAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerator](https://help.aliyun.com/document_detail/353188.html) operation to query the status of the task.
     *     *   If the basic GA instance is in the **deleting** state, it indicates that the instance is being deleted. In this case, you can perform only query operations.
     *     *   If the information about the basic GA instance is not displayed in the response, it indicates that the instance is deleted.
     *
     * @param request - DeleteBasicAcceleratorRequest
     *
     * @returns DeleteBasicAcceleratorResponse
     *
     * @param DeleteBasicAcceleratorRequest $request
     *
     * @return DeleteBasicAcceleratorResponse
     */
    public function deleteBasicAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBasicAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Deletes an endpoint that is associated with a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **DeleteBasicEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) operation to query the status of endpoints.
     *     *   If the endpoint is in the **deleting** state, it indicates that the endpoint is being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint cannot be found, it indicates that the endpoint is deleted.
     * *   The **DeleteBasicEndpoint** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
     *
     * @param request - DeleteBasicEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBasicEndpointResponse
     *
     * @param DeleteBasicEndpointRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteBasicEndpointResponse
     */
    public function deleteBasicEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBasicEndpoint',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBasicEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an endpoint that is associated with a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **DeleteBasicEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](https://help.aliyun.com/document_detail/466831.html) operation to query the status of endpoints.
     *     *   If the endpoint is in the **deleting** state, it indicates that the endpoint is being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint cannot be found, it indicates that the endpoint is deleted.
     * *   The **DeleteBasicEndpoint** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
     *
     * @param request - DeleteBasicEndpointRequest
     *
     * @returns DeleteBasicEndpointResponse
     *
     * @param DeleteBasicEndpointRequest $request
     *
     * @return DeleteBasicEndpointResponse
     */
    public function deleteBasicEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBasicEndpointWithOptions($request, $runtime);
    }

    /**
     * Deletes an endpoint group that is associated with a basic Global Accelerator (GA) instance.
     *
     * @remarks
     * Before you delete an endpoint group, take note of the following items:
     * *   If an endpoint in the endpoint group is associated with an accelerated IP address, you cannot delete the endpoint group. You can call the [DeleteBasicAccelerateIpEndpointRelation](https://help.aliyun.com/document_detail/2253413.html) operation to disassociate the endpoint from the accelerated IP address.
     * *   If no endpoint in the endpoint group is associated with an accelerated IP address, you can delete the endpoint group. When you delete an endpoint group, all endpoints in the endpoint group are deleted.
     * *   **DeleteBasicEndpointGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicEndpointGroup](https://help.aliyun.com/document_detail/362984.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **deleting** state, the endpoint group is being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint group cannot be queried, the endpoint group is deleted.
     * *   The **DeleteBasicEndpointGroup** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - DeleteBasicEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBasicEndpointGroupResponse
     *
     * @param DeleteBasicEndpointGroupRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteBasicEndpointGroupResponse
     */
    public function deleteBasicEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBasicEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBasicEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an endpoint group that is associated with a basic Global Accelerator (GA) instance.
     *
     * @remarks
     * Before you delete an endpoint group, take note of the following items:
     * *   If an endpoint in the endpoint group is associated with an accelerated IP address, you cannot delete the endpoint group. You can call the [DeleteBasicAccelerateIpEndpointRelation](https://help.aliyun.com/document_detail/2253413.html) operation to disassociate the endpoint from the accelerated IP address.
     * *   If no endpoint in the endpoint group is associated with an accelerated IP address, you can delete the endpoint group. When you delete an endpoint group, all endpoints in the endpoint group are deleted.
     * *   **DeleteBasicEndpointGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicEndpointGroup](https://help.aliyun.com/document_detail/362984.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **deleting** state, the endpoint group is being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint group cannot be queried, the endpoint group is deleted.
     * *   The **DeleteBasicEndpointGroup** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - DeleteBasicEndpointGroupRequest
     *
     * @returns DeleteBasicEndpointGroupResponse
     *
     * @param DeleteBasicEndpointGroupRequest $request
     *
     * @return DeleteBasicEndpointGroupResponse
     */
    public function deleteBasicEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBasicEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes the acceleration region of a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   If an accelerated IP address is associated with an endpoint, you cannot delete the acceleration region. You can call the [DeleteBasicAccelerateIpEndpointRelation](https://help.aliyun.com/document_detail/2253413.html) operation to disassociate the accelerated IP address from the endpoint.
     * *   \\*\\*DeleteBasicIpSet\\*\\* is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicIpSet](https://help.aliyun.com/document_detail/362987.html) operation to query the status of the task.
     *     *   If the acceleration region is in the **deleting** state, it indicates that the acceleration region is being deleted. In this case, you can perform only query operations.
     *     *   If the acceleration region cannot be queried, it indicates that the acceleration region is deleted.
     * *   The \\*\\*DeleteBasicIpSet\\*\\* operation cannot be repeatedly called for the same basic GA instance within a specific period of time.
     *
     * @param request - DeleteBasicIpSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBasicIpSetResponse
     *
     * @param DeleteBasicIpSetRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteBasicIpSetResponse
     */
    public function deleteBasicIpSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipSetId) {
            @$query['IpSetId'] = $request->ipSetId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBasicIpSet',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBasicIpSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the acceleration region of a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   If an accelerated IP address is associated with an endpoint, you cannot delete the acceleration region. You can call the [DeleteBasicAccelerateIpEndpointRelation](https://help.aliyun.com/document_detail/2253413.html) operation to disassociate the accelerated IP address from the endpoint.
     * *   \\*\\*DeleteBasicIpSet\\*\\* is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicIpSet](https://help.aliyun.com/document_detail/362987.html) operation to query the status of the task.
     *     *   If the acceleration region is in the **deleting** state, it indicates that the acceleration region is being deleted. In this case, you can perform only query operations.
     *     *   If the acceleration region cannot be queried, it indicates that the acceleration region is deleted.
     * *   The \\*\\*DeleteBasicIpSet\\*\\* operation cannot be repeatedly called for the same basic GA instance within a specific period of time.
     *
     * @param request - DeleteBasicIpSetRequest
     *
     * @returns DeleteBasicIpSetResponse
     *
     * @param DeleteBasicIpSetRequest $request
     *
     * @return DeleteBasicIpSetResponse
     */
    public function deleteBasicIpSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBasicIpSetWithOptions($request, $runtime);
    }

    /**
     * Deletes mappings from an endpoint group that is associated with a custom routing listener.
     *
     * @remarks
     *   **DeleteCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) to query the status of the task.
     *     *   If the endpoint group is in the **updating** state, it indicates that mappings are being deleted from the endpoint group. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state and no information about the mappings that you want to delete is found in the response when you call the [DescribeCustomRoutingEndpointGroupDestinations](https://help.aliyun.com/document_detail/449378.html) operation, it indicates the mappings are deleted from the endpoint group.
     * *   You cannot call the **DeleteCustomRoutingEndpointGroupDestinations** operation again on the same Global Accelerator (GA) instance before the previous request is completed.
     *
     * @param request - DeleteCustomRoutingEndpointGroupDestinationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param DeleteCustomRoutingEndpointGroupDestinationsRequest $request
     * @param RuntimeOptions                                      $runtime
     *
     * @return DeleteCustomRoutingEndpointGroupDestinationsResponse
     */
    public function deleteCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->destinationIds) {
            @$query['DestinationIds'] = $request->destinationIds;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomRoutingEndpointGroupDestinations',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomRoutingEndpointGroupDestinationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes mappings from an endpoint group that is associated with a custom routing listener.
     *
     * @remarks
     *   **DeleteCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) to query the status of the task.
     *     *   If the endpoint group is in the **updating** state, it indicates that mappings are being deleted from the endpoint group. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state and no information about the mappings that you want to delete is found in the response when you call the [DescribeCustomRoutingEndpointGroupDestinations](https://help.aliyun.com/document_detail/449378.html) operation, it indicates the mappings are deleted from the endpoint group.
     * *   You cannot call the **DeleteCustomRoutingEndpointGroupDestinations** operation again on the same Global Accelerator (GA) instance before the previous request is completed.
     *
     * @param request - DeleteCustomRoutingEndpointGroupDestinationsRequest
     *
     * @returns DeleteCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param DeleteCustomRoutingEndpointGroupDestinationsRequest $request
     *
     * @return DeleteCustomRoutingEndpointGroupDestinationsResponse
     */
    public function deleteCustomRoutingEndpointGroupDestinations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime);
    }

    /**
     * Deletes multiple endpoint groups that are associated with a custom routing listener.
     *
     * @remarks
     *   **DeleteCustomRoutingEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the state of the endpoint groups associated with a custom routing listener that you attempt to delete.
     *     *   If the endpoint groups are in the **deleting** state, the endpoint groups are being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint groups cannot be queried, the endpoint groups are deleted.
     * *   You cannot use the **DeleteCustomRoutingEndpointGroups** operation on the same Global Accelerator (GA) instance before the previous operation is complete.
     *
     * @param request - DeleteCustomRoutingEndpointGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCustomRoutingEndpointGroupsResponse
     *
     * @param DeleteCustomRoutingEndpointGroupsRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DeleteCustomRoutingEndpointGroupsResponse
     */
    public function deleteCustomRoutingEndpointGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointGroupIds) {
            @$query['EndpointGroupIds'] = $request->endpointGroupIds;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomRoutingEndpointGroups',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomRoutingEndpointGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes multiple endpoint groups that are associated with a custom routing listener.
     *
     * @remarks
     *   **DeleteCustomRoutingEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the state of the endpoint groups associated with a custom routing listener that you attempt to delete.
     *     *   If the endpoint groups are in the **deleting** state, the endpoint groups are being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint groups cannot be queried, the endpoint groups are deleted.
     * *   You cannot use the **DeleteCustomRoutingEndpointGroups** operation on the same Global Accelerator (GA) instance before the previous operation is complete.
     *
     * @param request - DeleteCustomRoutingEndpointGroupsRequest
     *
     * @returns DeleteCustomRoutingEndpointGroupsResponse
     *
     * @param DeleteCustomRoutingEndpointGroupsRequest $request
     *
     * @return DeleteCustomRoutingEndpointGroupsResponse
     */
    public function deleteCustomRoutingEndpointGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomRoutingEndpointGroupsWithOptions($request, $runtime);
    }

    /**
     * Deletes traffic destinations from an endpoint.
     *
     * @remarks
     *   **DeleteCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of an endpoint group to check whether the traffic destinations are deleted.
     *     *   If the endpoint group is in the **updating** state, the traffic destinations are being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state and the traffic destinations that you want to delete cannot be queried by calling the [DescribeCustomRoutingEndPointTrafficPolicy](https://help.aliyun.com/document_detail/449392.html) operation, the traffic destinations are deleted.
     * *   The **DeleteCustomRoutingEndpointTrafficPolicies** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteCustomRoutingEndpointTrafficPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCustomRoutingEndpointTrafficPoliciesResponse
     *
     * @param DeleteCustomRoutingEndpointTrafficPoliciesRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return DeleteCustomRoutingEndpointTrafficPoliciesResponse
     */
    public function deleteCustomRoutingEndpointTrafficPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->policyIds) {
            @$query['PolicyIds'] = $request->policyIds;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomRoutingEndpointTrafficPolicies',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomRoutingEndpointTrafficPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes traffic destinations from an endpoint.
     *
     * @remarks
     *   **DeleteCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of an endpoint group to check whether the traffic destinations are deleted.
     *     *   If the endpoint group is in the **updating** state, the traffic destinations are being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state and the traffic destinations that you want to delete cannot be queried by calling the [DescribeCustomRoutingEndPointTrafficPolicy](https://help.aliyun.com/document_detail/449392.html) operation, the traffic destinations are deleted.
     * *   The **DeleteCustomRoutingEndpointTrafficPolicies** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteCustomRoutingEndpointTrafficPoliciesRequest
     *
     * @returns DeleteCustomRoutingEndpointTrafficPoliciesResponse
     *
     * @param DeleteCustomRoutingEndpointTrafficPoliciesRequest $request
     *
     * @return DeleteCustomRoutingEndpointTrafficPoliciesResponse
     */
    public function deleteCustomRoutingEndpointTrafficPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomRoutingEndpointTrafficPoliciesWithOptions($request, $runtime);
    }

    /**
     * Deletes endpoints from a custom routing listener.
     *
     * @remarks
     *   **DeleteCustomRoutingEndpoints** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) to query the status of the task.
     *     *   If an endpoint group is in the **updating** state, the endpoint is being deleted. In this case, you can perform only query operations.
     *     *   If an endpoint group is in the **active** state and the endpoint cannot be found after you call the [DescribeCustomRoutingEndpoint](https://help.aliyun.com/document_detail/449386.html) operation, the endpoint is deleted.
     * *   You cannot call the **DeleteCustomRoutingEndpoints** operation again on the same Global Accelerator (GA) instance before the previous task is completed.
     *
     * @param request - DeleteCustomRoutingEndpointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteCustomRoutingEndpointsResponse
     *
     * @param DeleteCustomRoutingEndpointsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DeleteCustomRoutingEndpointsResponse
     */
    public function deleteCustomRoutingEndpointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointIds) {
            @$query['EndpointIds'] = $request->endpointIds;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteCustomRoutingEndpoints',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteCustomRoutingEndpointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes endpoints from a custom routing listener.
     *
     * @remarks
     *   **DeleteCustomRoutingEndpoints** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) to query the status of the task.
     *     *   If an endpoint group is in the **updating** state, the endpoint is being deleted. In this case, you can perform only query operations.
     *     *   If an endpoint group is in the **active** state and the endpoint cannot be found after you call the [DescribeCustomRoutingEndpoint](https://help.aliyun.com/document_detail/449386.html) operation, the endpoint is deleted.
     * *   You cannot call the **DeleteCustomRoutingEndpoints** operation again on the same Global Accelerator (GA) instance before the previous task is completed.
     *
     * @param request - DeleteCustomRoutingEndpointsRequest
     *
     * @returns DeleteCustomRoutingEndpointsResponse
     *
     * @param DeleteCustomRoutingEndpointsRequest $request
     *
     * @return DeleteCustomRoutingEndpointsResponse
     */
    public function deleteCustomRoutingEndpoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteCustomRoutingEndpointsWithOptions($request, $runtime);
    }

    /**
     * Disassociates a domain name from Global Accelerator (GA) instances.
     *
     * @remarks
     * You cannot call the **DeleteDomainAcceleratorRelation** operation again by using the same Alibaba Cloud account before the previous operation is complete.
     *
     * @param request - DeleteDomainAcceleratorRelationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDomainAcceleratorRelationResponse
     *
     * @param DeleteDomainAcceleratorRelationRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DeleteDomainAcceleratorRelationResponse
     */
    public function deleteDomainAcceleratorRelationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorIds) {
            @$query['AcceleratorIds'] = $request->acceleratorIds;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDomainAcceleratorRelation',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDomainAcceleratorRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a domain name from Global Accelerator (GA) instances.
     *
     * @remarks
     * You cannot call the **DeleteDomainAcceleratorRelation** operation again by using the same Alibaba Cloud account before the previous operation is complete.
     *
     * @param request - DeleteDomainAcceleratorRelationRequest
     *
     * @returns DeleteDomainAcceleratorRelationResponse
     *
     * @param DeleteDomainAcceleratorRelationRequest $request
     *
     * @return DeleteDomainAcceleratorRelationResponse
     */
    public function deleteDomainAcceleratorRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDomainAcceleratorRelationWithOptions($request, $runtime);
    }

    /**
     * Deletes an endpoint group.
     *
     * @remarks
     *   **DeleteEndpointGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the status of the endpoint group.
     *     *   If the endpoint group is in the **deleting** state, it indicates that the endpoint group is being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint group cannot be queried, it indicates that the endpoint group is deleted.
     * *   The **DeleteEndpointGroup** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - DeleteEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteEndpointGroupResponse
     *
     * @param DeleteEndpointGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteEndpointGroupResponse
     */
    public function deleteEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an endpoint group.
     *
     * @remarks
     *   **DeleteEndpointGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the status of the endpoint group.
     *     *   If the endpoint group is in the **deleting** state, it indicates that the endpoint group is being deleted. In this case, you can perform only query operations.
     *     *   If the endpoint group cannot be queried, it indicates that the endpoint group is deleted.
     * *   The **DeleteEndpointGroup** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - DeleteEndpointGroupRequest
     *
     * @returns DeleteEndpointGroupResponse
     *
     * @param DeleteEndpointGroupRequest $request
     *
     * @return DeleteEndpointGroupResponse
     */
    public function deleteEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes endpoint groups.
     *
     * @remarks
     *   **DeleteEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the status of the task.
     *     *   If an endpoint group is in the **deleting** state, the endpoint group is being deleted. In this case, you can perform only query operations.
     *     *   If an endpoint group cannot be queried, the endpoint group is deleted.
     * *   The **DeleteEndpointGroups** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteEndpointGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteEndpointGroupsResponse
     *
     * @param DeleteEndpointGroupsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteEndpointGroupsResponse
     */
    public function deleteEndpointGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointGroupIds) {
            @$query['EndpointGroupIds'] = $request->endpointGroupIds;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteEndpointGroups',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteEndpointGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes endpoint groups.
     *
     * @remarks
     *   **DeleteEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the status of the task.
     *     *   If an endpoint group is in the **deleting** state, the endpoint group is being deleted. In this case, you can perform only query operations.
     *     *   If an endpoint group cannot be queried, the endpoint group is deleted.
     * *   The **DeleteEndpointGroups** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteEndpointGroupsRequest
     *
     * @returns DeleteEndpointGroupsResponse
     *
     * @param DeleteEndpointGroupsRequest $request
     *
     * @return DeleteEndpointGroupsResponse
     */
    public function deleteEndpointGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteEndpointGroupsWithOptions($request, $runtime);
    }

    /**
     * Deletes forwarding rules.
     *
     * @remarks
     *   **DeleteForwardingRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListForwardingRules](https://help.aliyun.com/document_detail/205817.html) operation to query the status of the task.
     *     *   If a forwarding rule is in the **deleting** state, the forwarding rule is being deleted. In this case, you can perform only query operations.
     *     *   If a forwarding rule cannot be queried, the forwarding rule is deleted.
     * *   The **DeleteForwardingRules** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteForwardingRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteForwardingRulesResponse
     *
     * @param DeleteForwardingRulesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteForwardingRulesResponse
     */
    public function deleteForwardingRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->forwardingRuleIds) {
            @$query['ForwardingRuleIds'] = $request->forwardingRuleIds;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteForwardingRules',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteForwardingRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes forwarding rules.
     *
     * @remarks
     *   **DeleteForwardingRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListForwardingRules](https://help.aliyun.com/document_detail/205817.html) operation to query the status of the task.
     *     *   If a forwarding rule is in the **deleting** state, the forwarding rule is being deleted. In this case, you can perform only query operations.
     *     *   If a forwarding rule cannot be queried, the forwarding rule is deleted.
     * *   The **DeleteForwardingRules** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteForwardingRulesRequest
     *
     * @returns DeleteForwardingRulesResponse
     *
     * @param DeleteForwardingRulesRequest $request
     *
     * @return DeleteForwardingRulesResponse
     */
    public function deleteForwardingRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteForwardingRulesWithOptions($request, $runtime);
    }

    /**
     * Deletes an acceleration region.
     *
     * @remarks
     *   **DeleteIpSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of an acceleration region.
     *     *   If the acceleration region is in the **deleting** state, it indicates that the acceleration region is being deleted. In this case, you can perform only query operations.
     *     *   If the acceleration region cannot be queried, it indicates that the acceleration region is deleted.
     * *   The **DeleteIpSet** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - DeleteIpSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIpSetResponse
     *
     * @param DeleteIpSetRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return DeleteIpSetResponse
     */
    public function deleteIpSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipSetId) {
            @$query['IpSetId'] = $request->ipSetId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIpSet',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIpSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an acceleration region.
     *
     * @remarks
     *   **DeleteIpSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of an acceleration region.
     *     *   If the acceleration region is in the **deleting** state, it indicates that the acceleration region is being deleted. In this case, you can perform only query operations.
     *     *   If the acceleration region cannot be queried, it indicates that the acceleration region is deleted.
     * *   The **DeleteIpSet** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - DeleteIpSetRequest
     *
     * @returns DeleteIpSetResponse
     *
     * @param DeleteIpSetRequest $request
     *
     * @return DeleteIpSetResponse
     */
    public function deleteIpSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpSetWithOptions($request, $runtime);
    }

    /**
     * Deletes acceleration regions.
     *
     * @remarks
     *   **DeleteIpSets** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of the task.
     *     *   If the acceleration region is in the **deleting** state, the acceleration region is being deleted. In this case, you can perform only query operations.
     *     *   If you cannot query the acceleration region, the acceleration region is deleted.
     * *   You cannot repeatedly call the **DeleteIpSets** operation for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteIpSetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteIpSetsResponse
     *
     * @param DeleteIpSetsRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DeleteIpSetsResponse
     */
    public function deleteIpSetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipSetIds) {
            @$query['IpSetIds'] = $request->ipSetIds;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteIpSets',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteIpSetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes acceleration regions.
     *
     * @remarks
     *   **DeleteIpSets** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of the task.
     *     *   If the acceleration region is in the **deleting** state, the acceleration region is being deleted. In this case, you can perform only query operations.
     *     *   If you cannot query the acceleration region, the acceleration region is deleted.
     * *   You cannot repeatedly call the **DeleteIpSets** operation for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteIpSetsRequest
     *
     * @returns DeleteIpSetsResponse
     *
     * @param DeleteIpSetsRequest $request
     *
     * @return DeleteIpSetsResponse
     */
    public function deleteIpSets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteIpSetsWithOptions($request, $runtime);
    }

    /**
     * Deletes a listener.
     *
     * @remarks
     *   Before you call the **DeleteListener** operation, make sure that no endpoint groups are associated with the listener that you want to delete. For information about how to delete an endpoint group, see the following topics:
     *     *   [DeleteEndpointGroup](https://help.aliyun.com/document_detail/2253305.html): deletes an endpoint group that is associated with an intelligent routing listener.
     *     *   [DeleteEndpointGroups](https://help.aliyun.com/document_detail/2253311.html): deletes multiple endpoint groups that are associated with intelligent routing listeners at the same time.
     *     *   [DeleteCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/2303183.html): deletes multiple endpoint groups that are associated with custom routing listeners at the same time.
     * *   **DeleteListener** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the status of the listener.
     *     *   If the listener is in the **deleting** state, the listener is being deleted. In this case, you can perform only query operations.
     *     *   If the listener cannot be queried, the listener is deleted.
     * *   You cannot repeatedly call the **DeleteListener** operation to delete the listeners of the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteListenerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteListenerResponse
     *
     * @param DeleteListenerRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteListenerResponse
     */
    public function deleteListenerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteListener',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteListenerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a listener.
     *
     * @remarks
     *   Before you call the **DeleteListener** operation, make sure that no endpoint groups are associated with the listener that you want to delete. For information about how to delete an endpoint group, see the following topics:
     *     *   [DeleteEndpointGroup](https://help.aliyun.com/document_detail/2253305.html): deletes an endpoint group that is associated with an intelligent routing listener.
     *     *   [DeleteEndpointGroups](https://help.aliyun.com/document_detail/2253311.html): deletes multiple endpoint groups that are associated with intelligent routing listeners at the same time.
     *     *   [DeleteCustomRoutingEndpointGroups](https://help.aliyun.com/document_detail/2303183.html): deletes multiple endpoint groups that are associated with custom routing listeners at the same time.
     * *   **DeleteListener** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the status of the listener.
     *     *   If the listener is in the **deleting** state, the listener is being deleted. In this case, you can perform only query operations.
     *     *   If the listener cannot be queried, the listener is deleted.
     * *   You cannot repeatedly call the **DeleteListener** operation to delete the listeners of the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DeleteListenerRequest
     *
     * @returns DeleteListenerResponse
     *
     * @param DeleteListenerRequest $request
     *
     * @return DeleteListenerResponse
     */
    public function deleteListener($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteListenerWithOptions($request, $runtime);
    }

    /**
     * Deletes the secondary IP addresses that are associated with a CNAME.
     *
     * @remarks
     *   **DeleteSpareIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of a GA instance.
     *     *   If the GA instance is in the **configuring** state, it indicates that the secondary IP addresses for the CNAME are being deleted. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state and the secondary IP addresses for the CNAME cannot be queried by calling the [ListSpareIps](https://help.aliyun.com/document_detail/262121.html) operation, it indicates that the IP addresses are deleted.
     * *   The **DeleteSpareIps** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - DeleteSpareIpsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSpareIpsResponse
     *
     * @param DeleteSpareIpsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteSpareIpsResponse
     */
    public function deleteSpareIpsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->spareIps) {
            @$query['SpareIps'] = $request->spareIps;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSpareIps',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSpareIpsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the secondary IP addresses that are associated with a CNAME.
     *
     * @remarks
     *   **DeleteSpareIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of a GA instance.
     *     *   If the GA instance is in the **configuring** state, it indicates that the secondary IP addresses for the CNAME are being deleted. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state and the secondary IP addresses for the CNAME cannot be queried by calling the [ListSpareIps](https://help.aliyun.com/document_detail/262121.html) operation, it indicates that the IP addresses are deleted.
     * *   The **DeleteSpareIps** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - DeleteSpareIpsRequest
     *
     * @returns DeleteSpareIpsResponse
     *
     * @param DeleteSpareIpsRequest $request
     *
     * @return DeleteSpareIpsResponse
     */
    public function deleteSpareIps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSpareIpsWithOptions($request, $runtime);
    }

    /**
     * Queries information about a Global Accelerator (GA) instance.
     *
     * @param request - DescribeAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAcceleratorResponse
     *
     * @param DescribeAcceleratorRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeAcceleratorResponse
     */
    public function describeAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about a Global Accelerator (GA) instance.
     *
     * @param request - DescribeAcceleratorRequest
     *
     * @returns DescribeAcceleratorResponse
     *
     * @param DescribeAcceleratorRequest $request
     *
     * @return DescribeAcceleratorResponse
     */
    public function describeAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Queries the auto-renewal status of a Global Accelerator (GA) instance.
     *
     * @param request - DescribeAcceleratorAutoRenewAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAcceleratorAutoRenewAttributeResponse
     *
     * @param DescribeAcceleratorAutoRenewAttributeRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeAcceleratorAutoRenewAttributeResponse
     */
    public function describeAcceleratorAutoRenewAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAcceleratorAutoRenewAttribute',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAcceleratorAutoRenewAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the auto-renewal status of a Global Accelerator (GA) instance.
     *
     * @param request - DescribeAcceleratorAutoRenewAttributeRequest
     *
     * @returns DescribeAcceleratorAutoRenewAttributeResponse
     *
     * @param DescribeAcceleratorAutoRenewAttributeRequest $request
     *
     * @return DescribeAcceleratorAutoRenewAttributeResponse
     */
    public function describeAcceleratorAutoRenewAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAcceleratorAutoRenewAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries the status of a pay-as-you-go Global Accelerator (GA) instance.
     *
     * @param request - DescribeAcceleratorServiceStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAcceleratorServiceStatusResponse
     *
     * @param DescribeAcceleratorServiceStatusRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeAcceleratorServiceStatusResponse
     */
    public function describeAcceleratorServiceStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAcceleratorServiceStatus',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAcceleratorServiceStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of a pay-as-you-go Global Accelerator (GA) instance.
     *
     * @param request - DescribeAcceleratorServiceStatusRequest
     *
     * @returns DescribeAcceleratorServiceStatusResponse
     *
     * @param DescribeAcceleratorServiceStatusRequest $request
     *
     * @return DescribeAcceleratorServiceStatusResponse
     */
    public function describeAcceleratorServiceStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAcceleratorServiceStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the detailed information about an origin probing task.
     *
     * @param request - DescribeApplicationMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeApplicationMonitorResponse
     *
     * @param DescribeApplicationMonitorRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeApplicationMonitorResponse
     */
    public function describeApplicationMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeApplicationMonitor',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeApplicationMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the detailed information about an origin probing task.
     *
     * @param request - DescribeApplicationMonitorRequest
     *
     * @returns DescribeApplicationMonitorResponse
     *
     * @param DescribeApplicationMonitorRequest $request
     *
     * @return DescribeApplicationMonitorResponse
     */
    public function describeApplicationMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeApplicationMonitorWithOptions($request, $runtime);
    }

    /**
     * Queries information about a bandwidth plan.
     *
     * @param request - DescribeBandwidthPackageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBandwidthPackageResponse
     *
     * @param DescribeBandwidthPackageRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeBandwidthPackageResponse
     */
    public function describeBandwidthPackageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBandwidthPackage',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about a bandwidth plan.
     *
     * @param request - DescribeBandwidthPackageRequest
     *
     * @returns DescribeBandwidthPackageResponse
     *
     * @param DescribeBandwidthPackageRequest $request
     *
     * @return DescribeBandwidthPackageResponse
     */
    public function describeBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * Queries the auto-renewal status of a bandwidth plan.
     *
     * @param request - DescribeBandwidthPackageAutoRenewAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBandwidthPackageAutoRenewAttributeResponse
     *
     * @param DescribeBandwidthPackageAutoRenewAttributeRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return DescribeBandwidthPackageAutoRenewAttributeResponse
     */
    public function describeBandwidthPackageAutoRenewAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBandwidthPackageAutoRenewAttribute',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBandwidthPackageAutoRenewAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the auto-renewal status of a bandwidth plan.
     *
     * @param request - DescribeBandwidthPackageAutoRenewAttributeRequest
     *
     * @returns DescribeBandwidthPackageAutoRenewAttributeResponse
     *
     * @param DescribeBandwidthPackageAutoRenewAttributeRequest $request
     *
     * @return DescribeBandwidthPackageAutoRenewAttributeResponse
     */
    public function describeBandwidthPackageAutoRenewAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBandwidthPackageAutoRenewAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries information about commodities.
     *
     * @param request - DescribeCommodityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCommodityResponse
     *
     * @param DescribeCommodityRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeCommodityResponse
     */
    public function describeCommodityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->orderType) {
            @$query['OrderType'] = $request->orderType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCommodity',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCommodityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about commodities.
     *
     * @param request - DescribeCommodityRequest
     *
     * @returns DescribeCommodityResponse
     *
     * @param DescribeCommodityRequest $request
     *
     * @return DescribeCommodityResponse
     */
    public function describeCommodity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommodityWithOptions($request, $runtime);
    }

    /**
     * Queries the prices of commodities.
     *
     * @remarks
     * You can call the [DescribeCommodity](https://help.aliyun.com/document_detail/2253233.html) operation to query information about the commodity modules.
     *
     * @param request - DescribeCommodityPriceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCommodityPriceResponse
     *
     * @param DescribeCommodityPriceRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeCommodityPriceResponse
     */
    public function describeCommodityPriceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->orders) {
            @$query['Orders'] = $request->orders;
        }

        if (null !== $request->promotionOptionNo) {
            @$query['PromotionOptionNo'] = $request->promotionOptionNo;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCommodityPrice',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCommodityPriceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the prices of commodities.
     *
     * @remarks
     * You can call the [DescribeCommodity](https://help.aliyun.com/document_detail/2253233.html) operation to query information about the commodity modules.
     *
     * @param request - DescribeCommodityPriceRequest
     *
     * @returns DescribeCommodityPriceResponse
     *
     * @param DescribeCommodityPriceRequest $request
     *
     * @return DescribeCommodityPriceResponse
     */
    public function describeCommodityPrice($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCommodityPriceWithOptions($request, $runtime);
    }

    /**
     * Queries a traffic destination of an endpoint.
     *
     * @param request - DescribeCustomRoutingEndPointTrafficPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomRoutingEndPointTrafficPolicyResponse
     *
     * @param DescribeCustomRoutingEndPointTrafficPolicyRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return DescribeCustomRoutingEndPointTrafficPolicyResponse
     */
    public function describeCustomRoutingEndPointTrafficPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->policyId) {
            @$query['PolicyId'] = $request->policyId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomRoutingEndPointTrafficPolicy',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomRoutingEndPointTrafficPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a traffic destination of an endpoint.
     *
     * @param request - DescribeCustomRoutingEndPointTrafficPolicyRequest
     *
     * @returns DescribeCustomRoutingEndPointTrafficPolicyResponse
     *
     * @param DescribeCustomRoutingEndPointTrafficPolicyRequest $request
     *
     * @return DescribeCustomRoutingEndPointTrafficPolicyResponse
     */
    public function describeCustomRoutingEndPointTrafficPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomRoutingEndPointTrafficPolicyWithOptions($request, $runtime);
    }

    /**
     * Queries a specified endpoint that is associated with a custom routing listener.
     *
     * @param request - DescribeCustomRoutingEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomRoutingEndpointResponse
     *
     * @param DescribeCustomRoutingEndpointRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeCustomRoutingEndpointResponse
     */
    public function describeCustomRoutingEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endpointGroup) {
            @$query['EndpointGroup'] = $request->endpointGroup;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomRoutingEndpoint',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomRoutingEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a specified endpoint that is associated with a custom routing listener.
     *
     * @param request - DescribeCustomRoutingEndpointRequest
     *
     * @returns DescribeCustomRoutingEndpointResponse
     *
     * @param DescribeCustomRoutingEndpointRequest $request
     *
     * @return DescribeCustomRoutingEndpointResponse
     */
    public function describeCustomRoutingEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomRoutingEndpointWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a specific endpoint group that is associated with a custom routing listener.
     *
     * @param request - DescribeCustomRoutingEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomRoutingEndpointGroupResponse
     *
     * @param DescribeCustomRoutingEndpointGroupRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeCustomRoutingEndpointGroupResponse
     */
    public function describeCustomRoutingEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomRoutingEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomRoutingEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a specific endpoint group that is associated with a custom routing listener.
     *
     * @param request - DescribeCustomRoutingEndpointGroupRequest
     *
     * @returns DescribeCustomRoutingEndpointGroupResponse
     *
     * @param DescribeCustomRoutingEndpointGroupRequest $request
     *
     * @return DescribeCustomRoutingEndpointGroupResponse
     */
    public function describeCustomRoutingEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomRoutingEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the mapping configuration of a specified endpoint group that is associated with a custom routing listener.
     *
     * @param request - DescribeCustomRoutingEndpointGroupDestinationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param DescribeCustomRoutingEndpointGroupDestinationsRequest $request
     * @param RuntimeOptions                                        $runtime
     *
     * @return DescribeCustomRoutingEndpointGroupDestinationsResponse
     */
    public function describeCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destinationId) {
            @$query['DestinationId'] = $request->destinationId;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustomRoutingEndpointGroupDestinations',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustomRoutingEndpointGroupDestinationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the mapping configuration of a specified endpoint group that is associated with a custom routing listener.
     *
     * @param request - DescribeCustomRoutingEndpointGroupDestinationsRequest
     *
     * @returns DescribeCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param DescribeCustomRoutingEndpointGroupDestinationsRequest $request
     *
     * @return DescribeCustomRoutingEndpointGroupDestinationsResponse
     */
    public function describeCustomRoutingEndpointGroupDestinations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime);
    }

    /**
     * Queries information about an endpoint group.
     *
     * @param request - DescribeEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEndpointGroupResponse
     *
     * @param DescribeEndpointGroupRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeEndpointGroupResponse
     */
    public function describeEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about an endpoint group.
     *
     * @param request - DescribeEndpointGroupRequest
     *
     * @returns DescribeEndpointGroupResponse
     *
     * @param DescribeEndpointGroupRequest $request
     *
     * @return DescribeEndpointGroupResponse
     */
    public function describeEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Queries information about an acceleration region.
     *
     * @param request - DescribeIpSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeIpSetResponse
     *
     * @param DescribeIpSetRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DescribeIpSetResponse
     */
    public function describeIpSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipSetId) {
            @$query['IpSetId'] = $request->ipSetId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeIpSet',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeIpSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about an acceleration region.
     *
     * @param request - DescribeIpSetRequest
     *
     * @returns DescribeIpSetResponse
     *
     * @param DescribeIpSetRequest $request
     *
     * @return DescribeIpSetResponse
     */
    public function describeIpSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeIpSetWithOptions($request, $runtime);
    }

    /**
     * Queries configuration information about a listener of a Global Accelerator (GA) instance.
     *
     * @remarks
     * This operation is used to query configuration information about a listener of a GA instance. The information includes the routing type of the listener, the status of the listener, the timestamp that indicates when the listener was created, and the listener ports.
     *
     * @param request - DescribeListenerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeListenerResponse
     *
     * @param DescribeListenerRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeListenerResponse
     */
    public function describeListenerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeListener',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeListenerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries configuration information about a listener of a Global Accelerator (GA) instance.
     *
     * @remarks
     * This operation is used to query configuration information about a listener of a GA instance. The information includes the routing type of the listener, the status of the listener, the timestamp that indicates when the listener was created, and the listener ports.
     *
     * @param request - DescribeListenerRequest
     *
     * @returns DescribeListenerResponse
     *
     * @param DescribeListenerRequest $request
     *
     * @return DescribeListenerResponse
     */
    public function describeListener($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeListenerWithOptions($request, $runtime);
    }

    /**
     * Queries the Simple Log Service project and Logstore associated with an endpoint group.
     *
     * @param request - DescribeLogStoreOfEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLogStoreOfEndpointGroupResponse
     *
     * @param DescribeLogStoreOfEndpointGroupRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeLogStoreOfEndpointGroupResponse
     */
    public function describeLogStoreOfEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLogStoreOfEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLogStoreOfEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the Simple Log Service project and Logstore associated with an endpoint group.
     *
     * @param request - DescribeLogStoreOfEndpointGroupRequest
     *
     * @returns DescribeLogStoreOfEndpointGroupResponse
     *
     * @param DescribeLogStoreOfEndpointGroupRequest $request
     *
     * @return DescribeLogStoreOfEndpointGroupResponse
     */
    public function describeLogStoreOfEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogStoreOfEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the regions where Global Accelerator (GA) instances are deployed.
     *
     * @param request - DescribeRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRegionsResponse
     *
     * @param DescribeRegionsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeRegionsResponse
     */
    public function describeRegionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRegions',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the regions where Global Accelerator (GA) instances are deployed.
     *
     * @param request - DescribeRegionsRequest
     *
     * @returns DescribeRegionsResponse
     *
     * @param DescribeRegionsRequest $request
     *
     * @return DescribeRegionsResponse
     */
    public function describeRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRegionsWithOptions($request, $runtime);
    }

    /**
     * Disassociates a Global Accelerator (GA) instance from an Anti-DDoS Pro or Anti-DDoS Premium instance.
     *
     * @remarks
     *   The **DetachDdosFromAccelerator** operation is asynchronous. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) or [ListAccelerators](https://help.aliyun.com/document_detail/153236.html) operation to query the status of the GA instance.
     *     *   If the GA instance is in the **configuring** state, the Anti-DDoS Pro/Premium instance is being disassociated from the GA instance. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, the Anti-DDoS Pro/Premium instance is disassociated from the GA instance.
     * *   **DetachDdosFromAccelerator** cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - DetachDdosFromAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachDdosFromAcceleratorResponse
     *
     * @param DetachDdosFromAcceleratorRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DetachDdosFromAcceleratorResponse
     */
    public function detachDdosFromAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->ddosConfigList) {
            @$query['DdosConfigList'] = $request->ddosConfigList;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachDdosFromAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachDdosFromAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a Global Accelerator (GA) instance from an Anti-DDoS Pro or Anti-DDoS Premium instance.
     *
     * @remarks
     *   The **DetachDdosFromAccelerator** operation is asynchronous. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) or [ListAccelerators](https://help.aliyun.com/document_detail/153236.html) operation to query the status of the GA instance.
     *     *   If the GA instance is in the **configuring** state, the Anti-DDoS Pro/Premium instance is being disassociated from the GA instance. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, the Anti-DDoS Pro/Premium instance is disassociated from the GA instance.
     * *   **DetachDdosFromAccelerator** cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - DetachDdosFromAcceleratorRequest
     *
     * @returns DetachDdosFromAcceleratorResponse
     *
     * @param DetachDdosFromAcceleratorRequest $request
     *
     * @return DetachDdosFromAcceleratorResponse
     */
    public function detachDdosFromAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachDdosFromAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Disassociates a Log Service Logstore from an endpoint group.
     *
     * @remarks
     * ## Description
     * *   **DetachLogStoreFromEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the state of an endpoint group.
     *     *   If the endpoint group is in the **updating** state, the Log Service Logstore is being disassociated from the endpoint group. In this case, you can perform only query operations.
     *     <!---->
     *     *   If the endpoint group is in the **active** state, the Log Service Logstore is disassociated from the endpoint group.
     * *   The **DetachLogStoreFromEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DetachLogStoreFromEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachLogStoreFromEndpointGroupResponse
     *
     * @param DetachLogStoreFromEndpointGroupRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DetachLogStoreFromEndpointGroupResponse
     */
    public function detachLogStoreFromEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupIds) {
            @$query['EndpointGroupIds'] = $request->endpointGroupIds;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachLogStoreFromEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachLogStoreFromEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a Log Service Logstore from an endpoint group.
     *
     * @remarks
     * ## Description
     * *   **DetachLogStoreFromEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the state of an endpoint group.
     *     *   If the endpoint group is in the **updating** state, the Log Service Logstore is being disassociated from the endpoint group. In this case, you can perform only query operations.
     *     <!---->
     *     *   If the endpoint group is in the **active** state, the Log Service Logstore is disassociated from the endpoint group.
     * *   The **DetachLogStoreFromEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DetachLogStoreFromEndpointGroupRequest
     *
     * @returns DetachLogStoreFromEndpointGroupResponse
     *
     * @param DetachLogStoreFromEndpointGroupRequest $request
     *
     * @return DetachLogStoreFromEndpointGroupResponse
     */
    public function detachLogStoreFromEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachLogStoreFromEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Enables the diagnostic feature for an origin probing task.
     *
     * @param request - DetectApplicationMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetectApplicationMonitorResponse
     *
     * @param DetectApplicationMonitorRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DetectApplicationMonitorResponse
     */
    public function detectApplicationMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetectApplicationMonitor',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetectApplicationMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables the diagnostic feature for an origin probing task.
     *
     * @param request - DetectApplicationMonitorRequest
     *
     * @returns DetectApplicationMonitorResponse
     *
     * @param DetectApplicationMonitorRequest $request
     *
     * @return DetectApplicationMonitorResponse
     */
    public function detectApplicationMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detectApplicationMonitorWithOptions($request, $runtime);
    }

    /**
     * Disables an origin probing task.
     *
     * @param request - DisableApplicationMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DisableApplicationMonitorResponse
     *
     * @param DisableApplicationMonitorRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DisableApplicationMonitorResponse
     */
    public function disableApplicationMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DisableApplicationMonitor',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisableApplicationMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disables an origin probing task.
     *
     * @param request - DisableApplicationMonitorRequest
     *
     * @returns DisableApplicationMonitorResponse
     *
     * @param DisableApplicationMonitorRequest $request
     *
     * @return DisableApplicationMonitorResponse
     */
    public function disableApplicationMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disableApplicationMonitorWithOptions($request, $runtime);
    }

    /**
     * 解绑GA集成云产品
     *
     * @param request - DisassociateResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DisassociateResourcesResponse
     *
     * @param DisassociateResourcesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DisassociateResourcesResponse
     */
    public function disassociateResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->associatedResourceId) {
            @$query['AssociatedResourceId'] = $request->associatedResourceId;
        }

        if (null !== $request->associatedResourceRegionId) {
            @$query['AssociatedResourceRegionId'] = $request->associatedResourceRegionId;
        }

        if (null !== $request->associatedResourceType) {
            @$query['AssociatedResourceType'] = $request->associatedResourceType;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DisassociateResources',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DisassociateResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 解绑GA集成云产品
     *
     * @param request - DisassociateResourcesRequest
     *
     * @returns DisassociateResourcesResponse
     *
     * @param DisassociateResourcesRequest $request
     *
     * @return DisassociateResourcesResponse
     */
    public function disassociateResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->disassociateResourcesWithOptions($request, $runtime);
    }

    /**
     * Disassociates access control lists (ACLs) from a listener.
     *
     * @remarks
     * ## Description
     * *   **DissociateAclsFromListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the state of a listener:
     *     *   If the listener is in the **updating** state, ACLs are being disassociated from the listener. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, ACLs are disassociated from the listener.
     * *   The **DissociateAclsFromListener** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DissociateAclsFromListenerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DissociateAclsFromListenerResponse
     *
     * @param DissociateAclsFromListenerRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DissociateAclsFromListenerResponse
     */
    public function dissociateAclsFromListenerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclIds) {
            @$query['AclIds'] = $request->aclIds;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DissociateAclsFromListener',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DissociateAclsFromListenerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates access control lists (ACLs) from a listener.
     *
     * @remarks
     * ## Description
     * *   **DissociateAclsFromListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the state of a listener:
     *     *   If the listener is in the **updating** state, ACLs are being disassociated from the listener. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, ACLs are disassociated from the listener.
     * *   The **DissociateAclsFromListener** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - DissociateAclsFromListenerRequest
     *
     * @returns DissociateAclsFromListenerResponse
     *
     * @param DissociateAclsFromListenerRequest $request
     *
     * @return DissociateAclsFromListenerResponse
     */
    public function dissociateAclsFromListener($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dissociateAclsFromListenerWithOptions($request, $runtime);
    }

    /**
     * Disassociates an additional certificate from an HTTPS listener.
     *
     * @remarks
     * ## Description
     * *   **DissociateAdditionalCertificatesFromListener** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the state of an HTTPS listener.
     *     *   If the listener is in the **updating** state, it indicates that the additional certificate is being dissociated from the listener. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, it indicates that the additional certificate is dissociated from the listener.
     * *   The **DissociateAdditionalCertificatesFromListener** operation cannot be repeatedly called for the same Global Accelerator (GA) instance with a specific period of time.
     *
     * @param request - DissociateAdditionalCertificatesFromListenerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DissociateAdditionalCertificatesFromListenerResponse
     *
     * @param DissociateAdditionalCertificatesFromListenerRequest $request
     * @param RuntimeOptions                                      $runtime
     *
     * @return DissociateAdditionalCertificatesFromListenerResponse
     */
    public function dissociateAdditionalCertificatesFromListenerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->domains) {
            @$query['Domains'] = $request->domains;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DissociateAdditionalCertificatesFromListener',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DissociateAdditionalCertificatesFromListenerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates an additional certificate from an HTTPS listener.
     *
     * @remarks
     * ## Description
     * *   **DissociateAdditionalCertificatesFromListener** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the state of an HTTPS listener.
     *     *   If the listener is in the **updating** state, it indicates that the additional certificate is being dissociated from the listener. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, it indicates that the additional certificate is dissociated from the listener.
     * *   The **DissociateAdditionalCertificatesFromListener** operation cannot be repeatedly called for the same Global Accelerator (GA) instance with a specific period of time.
     *
     * @param request - DissociateAdditionalCertificatesFromListenerRequest
     *
     * @returns DissociateAdditionalCertificatesFromListenerResponse
     *
     * @param DissociateAdditionalCertificatesFromListenerRequest $request
     *
     * @return DissociateAdditionalCertificatesFromListenerResponse
     */
    public function dissociateAdditionalCertificatesFromListener($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dissociateAdditionalCertificatesFromListenerWithOptions($request, $runtime);
    }

    /**
     * Enables an origin probing task.
     *
     * @param request - EnableApplicationMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EnableApplicationMonitorResponse
     *
     * @param EnableApplicationMonitorRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return EnableApplicationMonitorResponse
     */
    public function enableApplicationMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EnableApplicationMonitor',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EnableApplicationMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables an origin probing task.
     *
     * @param request - EnableApplicationMonitorRequest
     *
     * @returns EnableApplicationMonitorResponse
     *
     * @param EnableApplicationMonitorRequest $request
     *
     * @return EnableApplicationMonitorResponse
     */
    public function enableApplicationMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->enableApplicationMonitorWithOptions($request, $runtime);
    }

    /**
     * Queries an access control list (ACL).
     *
     * @param request - GetAclRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAclResponse
     *
     * @param GetAclRequest  $request
     * @param RuntimeOptions $runtime
     *
     * @return GetAclResponse
     */
    public function getAclWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetAcl',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries an access control list (ACL).
     *
     * @param request - GetAclRequest
     *
     * @returns GetAclResponse
     *
     * @param GetAclRequest $request
     *
     * @return GetAclResponse
     */
    public function getAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAclWithOptions($request, $runtime);
    }

    /**
     * Queries the status of an accelerated IP address of a basic Global Accelerator (GA) instance.
     *
     * @param request - GetBasicAccelerateIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBasicAccelerateIpResponse
     *
     * @param GetBasicAccelerateIpRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetBasicAccelerateIpResponse
     */
    public function getBasicAccelerateIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateIpId) {
            @$query['AccelerateIpId'] = $request->accelerateIpId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetBasicAccelerateIp',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBasicAccelerateIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of an accelerated IP address of a basic Global Accelerator (GA) instance.
     *
     * @param request - GetBasicAccelerateIpRequest
     *
     * @returns GetBasicAccelerateIpResponse
     *
     * @param GetBasicAccelerateIpRequest $request
     *
     * @return GetBasicAccelerateIpResponse
     */
    public function getBasicAccelerateIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBasicAccelerateIpWithOptions($request, $runtime);
    }

    /**
     * Queries whether the accelerated IP address of a basic Global Accelerator (GA) instance is associated with an endpoint.
     *
     * @param request - GetBasicAccelerateIpEndpointRelationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBasicAccelerateIpEndpointRelationResponse
     *
     * @param GetBasicAccelerateIpEndpointRelationRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return GetBasicAccelerateIpEndpointRelationResponse
     */
    public function getBasicAccelerateIpEndpointRelationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateIpId) {
            @$query['AccelerateIpId'] = $request->accelerateIpId;
        }

        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetBasicAccelerateIpEndpointRelation',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBasicAccelerateIpEndpointRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether the accelerated IP address of a basic Global Accelerator (GA) instance is associated with an endpoint.
     *
     * @param request - GetBasicAccelerateIpEndpointRelationRequest
     *
     * @returns GetBasicAccelerateIpEndpointRelationResponse
     *
     * @param GetBasicAccelerateIpEndpointRelationRequest $request
     *
     * @return GetBasicAccelerateIpEndpointRelationResponse
     */
    public function getBasicAccelerateIpEndpointRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBasicAccelerateIpEndpointRelationWithOptions($request, $runtime);
    }

    /**
     * Queries the number of idle accelerated IP addresses of a Global Accelerator (GA) instance.
     *
     * @param request - GetBasicAccelerateIpIdleCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBasicAccelerateIpIdleCountResponse
     *
     * @param GetBasicAccelerateIpIdleCountRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return GetBasicAccelerateIpIdleCountResponse
     */
    public function getBasicAccelerateIpIdleCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipSetId) {
            @$query['IpSetId'] = $request->ipSetId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetBasicAccelerateIpIdleCount',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBasicAccelerateIpIdleCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of idle accelerated IP addresses of a Global Accelerator (GA) instance.
     *
     * @param request - GetBasicAccelerateIpIdleCountRequest
     *
     * @returns GetBasicAccelerateIpIdleCountResponse
     *
     * @param GetBasicAccelerateIpIdleCountRequest $request
     *
     * @return GetBasicAccelerateIpIdleCountResponse
     */
    public function getBasicAccelerateIpIdleCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBasicAccelerateIpIdleCountWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a basic Global Accelerator (GA) instance.
     *
     * @param request - GetBasicAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBasicAcceleratorResponse
     *
     * @param GetBasicAcceleratorRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetBasicAcceleratorResponse
     */
    public function getBasicAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetBasicAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBasicAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a basic Global Accelerator (GA) instance.
     *
     * @param request - GetBasicAcceleratorRequest
     *
     * @returns GetBasicAcceleratorResponse
     *
     * @param GetBasicAcceleratorRequest $request
     *
     * @return GetBasicAcceleratorResponse
     */
    public function getBasicAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBasicAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Queries detailed information about an endpoint that is associated with a basic Global Accelerator (GA) instance.
     *
     * @param request - GetBasicEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBasicEndpointResponse
     *
     * @param GetBasicEndpointRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return GetBasicEndpointResponse
     */
    public function getBasicEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetBasicEndpoint',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBasicEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries detailed information about an endpoint that is associated with a basic Global Accelerator (GA) instance.
     *
     * @param request - GetBasicEndpointRequest
     *
     * @returns GetBasicEndpointResponse
     *
     * @param GetBasicEndpointRequest $request
     *
     * @return GetBasicEndpointResponse
     */
    public function getBasicEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBasicEndpointWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the endpoint group of a basic GA instance.
     *
     * @param request - GetBasicEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBasicEndpointGroupResponse
     *
     * @param GetBasicEndpointGroupRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetBasicEndpointGroupResponse
     */
    public function getBasicEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetBasicEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBasicEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the endpoint group of a basic GA instance.
     *
     * @param request - GetBasicEndpointGroupRequest
     *
     * @returns GetBasicEndpointGroupResponse
     *
     * @param GetBasicEndpointGroupRequest $request
     *
     * @return GetBasicEndpointGroupResponse
     */
    public function getBasicEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBasicEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the acceleration region of a basic Global Accelerator (GA) instance.
     *
     * @param request - GetBasicIpSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBasicIpSetResponse
     *
     * @param GetBasicIpSetRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return GetBasicIpSetResponse
     */
    public function getBasicIpSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipSetId) {
            @$query['IpSetId'] = $request->ipSetId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetBasicIpSet',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBasicIpSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the acceleration region of a basic Global Accelerator (GA) instance.
     *
     * @param request - GetBasicIpSetRequest
     *
     * @returns GetBasicIpSetResponse
     *
     * @param GetBasicIpSetRequest $request
     *
     * @return GetBasicIpSetResponse
     */
    public function getBasicIpSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBasicIpSetWithOptions($request, $runtime);
    }

    /**
     * 获取GA实例关联的云产品
     *
     * @param request - GetGlobalAcceleratorResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetGlobalAcceleratorResourcesResponse
     *
     * @param GetGlobalAcceleratorResourcesRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return GetGlobalAcceleratorResourcesResponse
     */
    public function getGlobalAcceleratorResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->associatedResourceId) {
            @$query['AssociatedResourceId'] = $request->associatedResourceId;
        }

        if (null !== $request->associatedResourceRegionId) {
            @$query['AssociatedResourceRegionId'] = $request->associatedResourceRegionId;
        }

        if (null !== $request->associatedResourceType) {
            @$query['AssociatedResourceType'] = $request->associatedResourceType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetGlobalAcceleratorResources',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetGlobalAcceleratorResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 获取GA实例关联的云产品
     *
     * @param request - GetGlobalAcceleratorResourcesRequest
     *
     * @returns GetGlobalAcceleratorResourcesResponse
     *
     * @param GetGlobalAcceleratorResourcesRequest $request
     *
     * @return GetGlobalAcceleratorResourcesResponse
     */
    public function getGlobalAcceleratorResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getGlobalAcceleratorResourcesWithOptions($request, $runtime);
    }

    /**
     * Queries the health status of the endpoints and endpoint groups of a listener.
     *
     * @param request - GetHealthStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetHealthStatusResponse
     *
     * @param GetHealthStatusRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetHealthStatusResponse
     */
    public function getHealthStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetHealthStatus',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetHealthStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the health status of the endpoints and endpoint groups of a listener.
     *
     * @param request - GetHealthStatusRequest
     *
     * @returns GetHealthStatusResponse
     *
     * @param GetHealthStatusRequest $request
     *
     * @return GetHealthStatusResponse
     */
    public function getHealthStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getHealthStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the number of invalid domain names.
     *
     * @param request - GetInvalidDomainCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInvalidDomainCountResponse
     *
     * @param GetInvalidDomainCountRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetInvalidDomainCountResponse
     */
    public function getInvalidDomainCountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetInvalidDomainCount',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInvalidDomainCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of invalid domain names.
     *
     * @param request - GetInvalidDomainCountRequest
     *
     * @returns GetInvalidDomainCountResponse
     *
     * @param GetInvalidDomainCountRequest $request
     *
     * @return GetInvalidDomainCountResponse
     */
    public function getInvalidDomainCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInvalidDomainCountWithOptions($request, $runtime);
    }

    /**
     * Queries the maximum bandwidth of an acceleration area.
     *
     * @param request - GetIpsetsBandwidthLimitRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetIpsetsBandwidthLimitResponse
     *
     * @param GetIpsetsBandwidthLimitRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetIpsetsBandwidthLimitResponse
     */
    public function getIpsetsBandwidthLimitWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetIpsetsBandwidthLimit',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetIpsetsBandwidthLimitResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the maximum bandwidth of an acceleration area.
     *
     * @param request - GetIpsetsBandwidthLimitRequest
     *
     * @returns GetIpsetsBandwidthLimitResponse
     *
     * @param GetIpsetsBandwidthLimitRequest $request
     *
     * @return GetIpsetsBandwidthLimitResponse
     */
    public function getIpsetsBandwidthLimit($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getIpsetsBandwidthLimitWithOptions($request, $runtime);
    }

    /**
     * Queries the status of a secondary IP address that is associated with a CNAME.
     *
     * @param request - GetSpareIpRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSpareIpResponse
     *
     * @param GetSpareIpRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return GetSpareIpResponse
     */
    public function getSpareIpWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->spareIp) {
            @$query['SpareIp'] = $request->spareIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSpareIp',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSpareIpResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of a secondary IP address that is associated with a CNAME.
     *
     * @param request - GetSpareIpRequest
     *
     * @returns GetSpareIpResponse
     *
     * @param GetSpareIpRequest $request
     *
     * @return GetSpareIpResponse
     */
    public function getSpareIp($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSpareIpWithOptions($request, $runtime);
    }

    /**
     * Queries available acceleration areas and regions.
     *
     * @param request - ListAccelerateAreasRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAccelerateAreasResponse
     *
     * @param ListAccelerateAreasRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListAccelerateAreasResponse
     */
    public function listAccelerateAreasWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAccelerateAreas',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAccelerateAreasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries available acceleration areas and regions.
     *
     * @param request - ListAccelerateAreasRequest
     *
     * @returns ListAccelerateAreasResponse
     *
     * @param ListAccelerateAreasRequest $request
     *
     * @return ListAccelerateAreasResponse
     */
    public function listAccelerateAreas($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAccelerateAreasWithOptions($request, $runtime);
    }

    /**
     * Queries Global Accelerator (GA) instances.
     *
     * @param request - ListAcceleratorsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAcceleratorsResponse
     *
     * @param ListAcceleratorsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListAcceleratorsResponse
     */
    public function listAcceleratorsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->state) {
            @$query['State'] = $request->state;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAccelerators',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAcceleratorsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Global Accelerator (GA) instances.
     *
     * @param request - ListAcceleratorsRequest
     *
     * @returns ListAcceleratorsResponse
     *
     * @param ListAcceleratorsRequest $request
     *
     * @return ListAcceleratorsResponse
     */
    public function listAccelerators($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAcceleratorsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of access control lists (ACLs).
     *
     * @param request - ListAclsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAclsResponse
     *
     * @param ListAclsRequest $request
     * @param RuntimeOptions  $runtime
     *
     * @return ListAclsResponse
     */
    public function listAclsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclIds) {
            @$query['AclIds'] = $request->aclIds;
        }

        if (null !== $request->aclName) {
            @$query['AclName'] = $request->aclName;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAcls',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAclsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of access control lists (ACLs).
     *
     * @param request - ListAclsRequest
     *
     * @returns ListAclsResponse
     *
     * @param ListAclsRequest $request
     *
     * @return ListAclsResponse
     */
    public function listAcls($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAclsWithOptions($request, $runtime);
    }

    /**
     * Queries origin probing tasks.
     *
     * @param request - ListApplicationMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListApplicationMonitorResponse
     *
     * @param ListApplicationMonitorRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListApplicationMonitorResponse
     */
    public function listApplicationMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->searchValue) {
            @$query['SearchValue'] = $request->searchValue;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListApplicationMonitor',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListApplicationMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries origin probing tasks.
     *
     * @param request - ListApplicationMonitorRequest
     *
     * @returns ListApplicationMonitorResponse
     *
     * @param ListApplicationMonitorRequest $request
     *
     * @return ListApplicationMonitorResponse
     */
    public function listApplicationMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listApplicationMonitorWithOptions($request, $runtime);
    }

    /**
     * Queries the diagnostic results of origin probing tasks.
     *
     * @param request - ListApplicationMonitorDetectResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListApplicationMonitorDetectResultResponse
     *
     * @param ListApplicationMonitorDetectResultRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ListApplicationMonitorDetectResultResponse
     */
    public function listApplicationMonitorDetectResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->beginTime) {
            @$query['BeginTime'] = $request->beginTime;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListApplicationMonitorDetectResult',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListApplicationMonitorDetectResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the diagnostic results of origin probing tasks.
     *
     * @param request - ListApplicationMonitorDetectResultRequest
     *
     * @returns ListApplicationMonitorDetectResultResponse
     *
     * @param ListApplicationMonitorDetectResultRequest $request
     *
     * @return ListApplicationMonitorDetectResultResponse
     */
    public function listApplicationMonitorDetectResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listApplicationMonitorDetectResultWithOptions($request, $runtime);
    }

    /**
     * Queries available acceleration regions.
     *
     * @param request - ListAvailableAccelerateAreasRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAvailableAccelerateAreasResponse
     *
     * @param ListAvailableAccelerateAreasRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListAvailableAccelerateAreasResponse
     */
    public function listAvailableAccelerateAreasWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->accessMode) {
            @$query['AccessMode'] = $request->accessMode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAvailableAccelerateAreas',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAvailableAccelerateAreasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries available acceleration regions.
     *
     * @param request - ListAvailableAccelerateAreasRequest
     *
     * @returns ListAvailableAccelerateAreasResponse
     *
     * @param ListAvailableAccelerateAreasRequest $request
     *
     * @return ListAvailableAccelerateAreasResponse
     */
    public function listAvailableAccelerateAreas($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAvailableAccelerateAreasWithOptions($request, $runtime);
    }

    /**
     * Queries the available acceleration regions of a Global Accelerator (GA) instance.
     *
     * @param request - ListAvailableBusiRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAvailableBusiRegionsResponse
     *
     * @param ListAvailableBusiRegionsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListAvailableBusiRegionsResponse
     */
    public function listAvailableBusiRegionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListAvailableBusiRegions',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAvailableBusiRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the available acceleration regions of a Global Accelerator (GA) instance.
     *
     * @param request - ListAvailableBusiRegionsRequest
     *
     * @returns ListAvailableBusiRegionsResponse
     *
     * @param ListAvailableBusiRegionsRequest $request
     *
     * @return ListAvailableBusiRegionsResponse
     */
    public function listAvailableBusiRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAvailableBusiRegionsWithOptions($request, $runtime);
    }

    /**
     * Queries bandwidth plans.
     *
     * @param request - ListBandwidthPackagesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBandwidthPackagesResponse
     *
     * @param ListBandwidthPackagesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListBandwidthPackagesResponse
     */
    public function listBandwidthPackagesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->state) {
            @$query['State'] = $request->state;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBandwidthPackages',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBandwidthPackagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries bandwidth plans.
     *
     * @param request - ListBandwidthPackagesRequest
     *
     * @returns ListBandwidthPackagesResponse
     *
     * @param ListBandwidthPackagesRequest $request
     *
     * @return ListBandwidthPackagesResponse
     */
    public function listBandwidthPackages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBandwidthPackagesWithOptions($request, $runtime);
    }

    /**
     * Queries bandwidth plans.
     *
     * @remarks
     * To query the detailed information about a bandwidth plan, call the **ListBandwidthPackages** operation. For more information, see [ListBandwidthPackages](https://help.aliyun.com/document_detail/2253239.html).
     *
     * @param request - ListBandwidthackagesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBandwidthackagesResponse
     *
     * @param ListBandwidthackagesRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListBandwidthackagesResponse
     */
    public function listBandwidthackagesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBandwidthackages',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBandwidthackagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries bandwidth plans.
     *
     * @remarks
     * To query the detailed information about a bandwidth plan, call the **ListBandwidthPackages** operation. For more information, see [ListBandwidthPackages](https://help.aliyun.com/document_detail/2253239.html).
     *
     * @param request - ListBandwidthackagesRequest
     *
     * @returns ListBandwidthackagesResponse
     *
     * @param ListBandwidthackagesRequest $request
     *
     * @return ListBandwidthackagesResponse
     */
    public function listBandwidthackages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBandwidthackagesWithOptions($request, $runtime);
    }

    /**
     * Queries whether the accelerated IP address of a basic Global Accelerator (GA) instance is associated with an endpoint.
     *
     * @param request - ListBasicAccelerateIpEndpointRelationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBasicAccelerateIpEndpointRelationsResponse
     *
     * @param ListBasicAccelerateIpEndpointRelationsRequest $request
     * @param RuntimeOptions                                $runtime
     *
     * @return ListBasicAccelerateIpEndpointRelationsResponse
     */
    public function listBasicAccelerateIpEndpointRelationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateIpId) {
            @$query['AccelerateIpId'] = $request->accelerateIpId;
        }

        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBasicAccelerateIpEndpointRelations',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBasicAccelerateIpEndpointRelationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether the accelerated IP address of a basic Global Accelerator (GA) instance is associated with an endpoint.
     *
     * @param request - ListBasicAccelerateIpEndpointRelationsRequest
     *
     * @returns ListBasicAccelerateIpEndpointRelationsResponse
     *
     * @param ListBasicAccelerateIpEndpointRelationsRequest $request
     *
     * @return ListBasicAccelerateIpEndpointRelationsResponse
     */
    public function listBasicAccelerateIpEndpointRelations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBasicAccelerateIpEndpointRelationsWithOptions($request, $runtime);
    }

    /**
     * Queries the accelerated IP addresses in the acceleration region of a basic Global Accelerator (GA) instance.
     *
     * @param request - ListBasicAccelerateIpsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBasicAccelerateIpsResponse
     *
     * @param ListBasicAccelerateIpsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListBasicAccelerateIpsResponse
     */
    public function listBasicAccelerateIpsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accelerateIpAddress) {
            @$query['AccelerateIpAddress'] = $request->accelerateIpAddress;
        }

        if (null !== $request->accelerateIpId) {
            @$query['AccelerateIpId'] = $request->accelerateIpId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipSetId) {
            @$query['IpSetId'] = $request->ipSetId;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBasicAccelerateIps',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBasicAccelerateIpsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the accelerated IP addresses in the acceleration region of a basic Global Accelerator (GA) instance.
     *
     * @param request - ListBasicAccelerateIpsRequest
     *
     * @returns ListBasicAccelerateIpsResponse
     *
     * @param ListBasicAccelerateIpsRequest $request
     *
     * @return ListBasicAccelerateIpsResponse
     */
    public function listBasicAccelerateIps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBasicAccelerateIpsWithOptions($request, $runtime);
    }

    /**
     * Queries basic Global Accelerator (GA) instances.
     *
     * @param request - ListBasicAcceleratorsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBasicAcceleratorsResponse
     *
     * @param ListBasicAcceleratorsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListBasicAcceleratorsResponse
     */
    public function listBasicAcceleratorsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->state) {
            @$query['State'] = $request->state;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBasicAccelerators',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBasicAcceleratorsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries basic Global Accelerator (GA) instances.
     *
     * @param request - ListBasicAcceleratorsRequest
     *
     * @returns ListBasicAcceleratorsResponse
     *
     * @param ListBasicAcceleratorsRequest $request
     *
     * @return ListBasicAcceleratorsResponse
     */
    public function listBasicAccelerators($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBasicAcceleratorsWithOptions($request, $runtime);
    }

    /**
     * Queries the endpoints that are associated with a basic Global Accelerator (GA) instance.
     *
     * @param request - ListBasicEndpointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBasicEndpointsResponse
     *
     * @param ListBasicEndpointsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListBasicEndpointsResponse
     */
    public function listBasicEndpointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->endpointType) {
            @$query['EndpointType'] = $request->endpointType;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBasicEndpoints',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBasicEndpointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the endpoints that are associated with a basic Global Accelerator (GA) instance.
     *
     * @param request - ListBasicEndpointsRequest
     *
     * @returns ListBasicEndpointsResponse
     *
     * @param ListBasicEndpointsRequest $request
     *
     * @return ListBasicEndpointsResponse
     */
    public function listBasicEndpoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBasicEndpointsWithOptions($request, $runtime);
    }

    /**
     * Queries the acceleration regions that are supported by Global Accelerator (GA).
     *
     * @param request - ListBusiRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBusiRegionsResponse
     *
     * @param ListBusiRegionsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListBusiRegionsResponse
     */
    public function listBusiRegionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListBusiRegions',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBusiRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the acceleration regions that are supported by Global Accelerator (GA).
     *
     * @param request - ListBusiRegionsRequest
     *
     * @returns ListBusiRegionsResponse
     *
     * @param ListBusiRegionsRequest $request
     *
     * @return ListBusiRegionsResponse
     */
    public function listBusiRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBusiRegionsWithOptions($request, $runtime);
    }

    /**
     * Queries available acceleration areas and regions.
     *
     * @remarks
     * You can call this operation to query the acceleration areas and regions that you can specify on the wizard page of Global Accelerator (GA) and for free-trial GA instances. You can filter acceleration areas and regions based on specified conditions.
     *
     * @param request - ListCommonAreasRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCommonAreasResponse
     *
     * @param ListCommonAreasRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListCommonAreasResponse
     */
    public function listCommonAreasWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipVersion) {
            @$query['IpVersion'] = $request->ipVersion;
        }

        if (null !== $request->isEpg) {
            @$query['IsEpg'] = $request->isEpg;
        }

        if (null !== $request->isIpSet) {
            @$query['IsIpSet'] = $request->isIpSet;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCommonAreas',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCommonAreasResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries available acceleration areas and regions.
     *
     * @remarks
     * You can call this operation to query the acceleration areas and regions that you can specify on the wizard page of Global Accelerator (GA) and for free-trial GA instances. You can filter acceleration areas and regions based on specified conditions.
     *
     * @param request - ListCommonAreasRequest
     *
     * @returns ListCommonAreasResponse
     *
     * @param ListCommonAreasRequest $request
     *
     * @return ListCommonAreasResponse
     */
    public function listCommonAreas($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCommonAreasWithOptions($request, $runtime);
    }

    /**
     * Queries endpoint group mapping configurations of a custom routing listener of a Global Accelerator (GA) instance.
     *
     * @param request - ListCustomRoutingEndpointGroupDestinationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param ListCustomRoutingEndpointGroupDestinationsRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return ListCustomRoutingEndpointGroupDestinationsResponse
     */
    public function listCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->fromPort) {
            @$query['FromPort'] = $request->fromPort;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->protocols) {
            @$query['Protocols'] = $request->protocols;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->toPort) {
            @$query['ToPort'] = $request->toPort;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCustomRoutingEndpointGroupDestinations',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCustomRoutingEndpointGroupDestinationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries endpoint group mapping configurations of a custom routing listener of a Global Accelerator (GA) instance.
     *
     * @param request - ListCustomRoutingEndpointGroupDestinationsRequest
     *
     * @returns ListCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param ListCustomRoutingEndpointGroupDestinationsRequest $request
     *
     * @return ListCustomRoutingEndpointGroupDestinationsResponse
     */
    public function listCustomRoutingEndpointGroupDestinations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime);
    }

    /**
     * Queries the endpoint groups that are associated with a custom routing listener.
     *
     * @remarks
     * ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code for different SDKs.](https://api.aliyun.com/#product=Ga\\&api=ListCustomRoutingEndpointGroups\\&type=RPC\\&version=2019-11-20)
     *
     * @param request - ListCustomRoutingEndpointGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCustomRoutingEndpointGroupsResponse
     *
     * @param ListCustomRoutingEndpointGroupsRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ListCustomRoutingEndpointGroupsResponse
     */
    public function listCustomRoutingEndpointGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->accessLogSwitch) {
            @$query['AccessLogSwitch'] = $request->accessLogSwitch;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCustomRoutingEndpointGroups',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCustomRoutingEndpointGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the endpoint groups that are associated with a custom routing listener.
     *
     * @remarks
     * ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code for different SDKs.](https://api.aliyun.com/#product=Ga\\&api=ListCustomRoutingEndpointGroups\\&type=RPC\\&version=2019-11-20)
     *
     * @param request - ListCustomRoutingEndpointGroupsRequest
     *
     * @returns ListCustomRoutingEndpointGroupsResponse
     *
     * @param ListCustomRoutingEndpointGroupsRequest $request
     *
     * @return ListCustomRoutingEndpointGroupsResponse
     */
    public function listCustomRoutingEndpointGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCustomRoutingEndpointGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries the traffic policies of an endpoint that belongs to a custom routing listener.
     *
     * @param request - ListCustomRoutingEndpointTrafficPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCustomRoutingEndpointTrafficPoliciesResponse
     *
     * @param ListCustomRoutingEndpointTrafficPoliciesRequest $request
     * @param RuntimeOptions                                  $runtime
     *
     * @return ListCustomRoutingEndpointTrafficPoliciesResponse
     */
    public function listCustomRoutingEndpointTrafficPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->address) {
            @$query['Address'] = $request->address;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCustomRoutingEndpointTrafficPolicies',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCustomRoutingEndpointTrafficPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the traffic policies of an endpoint that belongs to a custom routing listener.
     *
     * @param request - ListCustomRoutingEndpointTrafficPoliciesRequest
     *
     * @returns ListCustomRoutingEndpointTrafficPoliciesResponse
     *
     * @param ListCustomRoutingEndpointTrafficPoliciesRequest $request
     *
     * @return ListCustomRoutingEndpointTrafficPoliciesResponse
     */
    public function listCustomRoutingEndpointTrafficPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCustomRoutingEndpointTrafficPoliciesWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of an endpoint.
     *
     * @param request - ListCustomRoutingEndpointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCustomRoutingEndpointsResponse
     *
     * @param ListCustomRoutingEndpointsRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListCustomRoutingEndpointsResponse
     */
    public function listCustomRoutingEndpointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCustomRoutingEndpoints',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCustomRoutingEndpointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of an endpoint.
     *
     * @param request - ListCustomRoutingEndpointsRequest
     *
     * @returns ListCustomRoutingEndpointsResponse
     *
     * @param ListCustomRoutingEndpointsRequest $request
     *
     * @return ListCustomRoutingEndpointsResponse
     */
    public function listCustomRoutingEndpoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCustomRoutingEndpointsWithOptions($request, $runtime);
    }

    /**
     * Queries the port mapping table of a custom routing listener.
     *
     * @remarks
     * After you configure a custom routing listener for a Global Accelerator (GA) instance, the instance generates a port mapping table based on the listener port range, backend service protocols and port ranges of the associated endpoint groups, and IP addresses of endpoints (vSwitches). The custom routing listener forwards client requests to specified IP addresses and ports in the vSwitches based on the port mapping table. This operation is used to query the generated port mapping table.
     *
     * @param request - ListCustomRoutingPortMappingsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCustomRoutingPortMappingsResponse
     *
     * @param ListCustomRoutingPortMappingsRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ListCustomRoutingPortMappingsResponse
     */
    public function listCustomRoutingPortMappingsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCustomRoutingPortMappings',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCustomRoutingPortMappingsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the port mapping table of a custom routing listener.
     *
     * @remarks
     * After you configure a custom routing listener for a Global Accelerator (GA) instance, the instance generates a port mapping table based on the listener port range, backend service protocols and port ranges of the associated endpoint groups, and IP addresses of endpoints (vSwitches). The custom routing listener forwards client requests to specified IP addresses and ports in the vSwitches based on the port mapping table. This operation is used to query the generated port mapping table.
     *
     * @param request - ListCustomRoutingPortMappingsRequest
     *
     * @returns ListCustomRoutingPortMappingsResponse
     *
     * @param ListCustomRoutingPortMappingsRequest $request
     *
     * @return ListCustomRoutingPortMappingsResponse
     */
    public function listCustomRoutingPortMappings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCustomRoutingPortMappingsWithOptions($request, $runtime);
    }

    /**
     * Queries the port mapping table of a specified backend instance that is associated with a custom routing listener.
     *
     * @param request - ListCustomRoutingPortMappingsByDestinationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCustomRoutingPortMappingsByDestinationResponse
     *
     * @param ListCustomRoutingPortMappingsByDestinationRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return ListCustomRoutingPortMappingsByDestinationResponse
     */
    public function listCustomRoutingPortMappingsByDestinationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destinationAddress) {
            @$query['DestinationAddress'] = $request->destinationAddress;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCustomRoutingPortMappingsByDestination',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCustomRoutingPortMappingsByDestinationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the port mapping table of a specified backend instance that is associated with a custom routing listener.
     *
     * @param request - ListCustomRoutingPortMappingsByDestinationRequest
     *
     * @returns ListCustomRoutingPortMappingsByDestinationResponse
     *
     * @param ListCustomRoutingPortMappingsByDestinationRequest $request
     *
     * @return ListCustomRoutingPortMappingsByDestinationResponse
     */
    public function listCustomRoutingPortMappingsByDestination($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCustomRoutingPortMappingsByDestinationWithOptions($request, $runtime);
    }

    /**
     * Queries accelerated domain names.
     *
     * @param request - ListDomainsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDomainsResponse
     *
     * @param ListDomainsRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return ListDomainsResponse
     */
    public function listDomainsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->state) {
            @$query['State'] = $request->state;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDomains',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDomainsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries accelerated domain names.
     *
     * @param request - ListDomainsRequest
     *
     * @returns ListDomainsResponse
     *
     * @param ListDomainsRequest $request
     *
     * @return ListDomainsResponse
     */
    public function listDomains($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDomainsWithOptions($request, $runtime);
    }

    /**
     * Queries the public CIDR blocks to which the endpoint group IP addresses belong. The CIDR blocks can be used to configure ACLs in terminals.
     *
     * @param request - ListEndpointGroupIpAddressCidrBlocksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEndpointGroupIpAddressCidrBlocksResponse
     *
     * @param ListEndpointGroupIpAddressCidrBlocksRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return ListEndpointGroupIpAddressCidrBlocksResponse
     */
    public function listEndpointGroupIpAddressCidrBlocksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->endpointGroupRegion) {
            @$query['EndpointGroupRegion'] = $request->endpointGroupRegion;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEndpointGroupIpAddressCidrBlocks',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEndpointGroupIpAddressCidrBlocksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the public CIDR blocks to which the endpoint group IP addresses belong. The CIDR blocks can be used to configure ACLs in terminals.
     *
     * @param request - ListEndpointGroupIpAddressCidrBlocksRequest
     *
     * @returns ListEndpointGroupIpAddressCidrBlocksResponse
     *
     * @param ListEndpointGroupIpAddressCidrBlocksRequest $request
     *
     * @return ListEndpointGroupIpAddressCidrBlocksResponse
     */
    public function listEndpointGroupIpAddressCidrBlocks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEndpointGroupIpAddressCidrBlocksWithOptions($request, $runtime);
    }

    /**
     * Queries a list of endpoint groups.
     *
     * @param request - ListEndpointGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEndpointGroupsResponse
     *
     * @param ListEndpointGroupsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListEndpointGroupsResponse
     */
    public function listEndpointGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->accessLogSwitch) {
            @$query['AccessLogSwitch'] = $request->accessLogSwitch;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointGroupType) {
            @$query['EndpointGroupType'] = $request->endpointGroupType;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEndpointGroups',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEndpointGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of endpoint groups.
     *
     * @param request - ListEndpointGroupsRequest
     *
     * @returns ListEndpointGroupsResponse
     *
     * @param ListEndpointGroupsRequest $request
     *
     * @return ListEndpointGroupsResponse
     */
    public function listEndpointGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEndpointGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries forwarding rules.
     *
     * @remarks
     * >  This operation is used to query only custom forwarding rules, not the default forwarding rule.
     *
     * @param request - ListForwardingRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListForwardingRulesResponse
     *
     * @param ListForwardingRulesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListForwardingRulesResponse
     */
    public function listForwardingRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->forwardingRuleId) {
            @$query['ForwardingRuleId'] = $request->forwardingRuleId;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListForwardingRules',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListForwardingRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries forwarding rules.
     *
     * @remarks
     * >  This operation is used to query only custom forwarding rules, not the default forwarding rule.
     *
     * @param request - ListForwardingRulesRequest
     *
     * @returns ListForwardingRulesResponse
     *
     * @param ListForwardingRulesRequest $request
     *
     * @return ListForwardingRulesResponse
     */
    public function listForwardingRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listForwardingRulesWithOptions($request, $runtime);
    }

    /**
     * Queries acceleration regions.
     *
     * @param request - ListIpSetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListIpSetsResponse
     *
     * @param ListIpSetsRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ListIpSetsResponse
     */
    public function listIpSetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListIpSets',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListIpSetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries acceleration regions.
     *
     * @param request - ListIpSetsRequest
     *
     * @returns ListIpSetsResponse
     *
     * @param ListIpSetsRequest $request
     *
     * @return ListIpSetsResponse
     */
    public function listIpSets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listIpSetsWithOptions($request, $runtime);
    }

    /**
     * Queries the line types of elastic IP addresses (EIPs) that are supported in an acceleration region.
     *
     * @param request - ListIspTypesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListIspTypesResponse
     *
     * @param ListIspTypesRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ListIspTypesResponse
     */
    public function listIspTypesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->acceleratorType) {
            @$query['AcceleratorType'] = $request->acceleratorType;
        }

        if (null !== $request->businessRegionId) {
            @$query['BusinessRegionId'] = $request->businessRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListIspTypes',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListIspTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the line types of elastic IP addresses (EIPs) that are supported in an acceleration region.
     *
     * @param request - ListIspTypesRequest
     *
     * @returns ListIspTypesResponse
     *
     * @param ListIspTypesRequest $request
     *
     * @return ListIspTypesResponse
     */
    public function listIspTypes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listIspTypesWithOptions($request, $runtime);
    }

    /**
     * Queries the certificates associated with a listener.
     *
     * @param request - ListListenerCertificatesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListListenerCertificatesResponse
     *
     * @param ListListenerCertificatesRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListListenerCertificatesResponse
     */
    public function listListenerCertificatesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->role) {
            @$query['Role'] = $request->role;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListListenerCertificates',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListListenerCertificatesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the certificates associated with a listener.
     *
     * @param request - ListListenerCertificatesRequest
     *
     * @returns ListListenerCertificatesResponse
     *
     * @param ListListenerCertificatesRequest $request
     *
     * @return ListListenerCertificatesResponse
     */
    public function listListenerCertificates($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listListenerCertificatesWithOptions($request, $runtime);
    }

    /**
     * Queries the listeners of a Global Accelerator (GA) instance.
     *
     * @remarks
     * This operation is used to query information about the listeners of a GA instance, including the status of each listener, the timestamp that indicates when each listener was created, and the listener ports.
     *
     * @param request - ListListenersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListListenersResponse
     *
     * @param ListListenersRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ListListenersResponse
     */
    public function listListenersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListListeners',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListListenersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the listeners of a Global Accelerator (GA) instance.
     *
     * @remarks
     * This operation is used to query information about the listeners of a GA instance, including the status of each listener, the timestamp that indicates when each listener was created, and the listener ports.
     *
     * @param request - ListListenersRequest
     *
     * @returns ListListenersResponse
     *
     * @param ListListenersRequest $request
     *
     * @return ListListenersResponse
     */
    public function listListeners($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listListenersWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the secondary IP addresses that are associated with a CNAME.
     *
     * @param request - ListSpareIpsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSpareIpsResponse
     *
     * @param ListSpareIpsRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ListSpareIpsResponse
     */
    public function listSpareIpsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListSpareIps',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSpareIpsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the secondary IP addresses that are associated with a CNAME.
     *
     * @param request - ListSpareIpsRequest
     *
     * @returns ListSpareIpsResponse
     *
     * @param ListSpareIpsRequest $request
     *
     * @return ListSpareIpsResponse
     */
    public function listSpareIps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSpareIpsWithOptions($request, $runtime);
    }

    /**
     * Queries the TLS security policies that are supported by HTTPS listeners.
     *
     * @remarks
     * You can select a TLS security policy when you create an HTTPS listener. This API operation is used to query the TLS security policies that are supported by HTTPS listeners.
     *
     * @param request - ListSystemSecurityPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSystemSecurityPoliciesResponse
     *
     * @param ListSystemSecurityPoliciesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListSystemSecurityPoliciesResponse
     */
    public function listSystemSecurityPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListSystemSecurityPolicies',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSystemSecurityPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the TLS security policies that are supported by HTTPS listeners.
     *
     * @remarks
     * You can select a TLS security policy when you create an HTTPS listener. This API operation is used to query the TLS security policies that are supported by HTTPS listeners.
     *
     * @param request - ListSystemSecurityPoliciesRequest
     *
     * @returns ListSystemSecurityPoliciesResponse
     *
     * @param ListSystemSecurityPoliciesRequest $request
     *
     * @return ListSystemSecurityPoliciesResponse
     */
    public function listSystemSecurityPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSystemSecurityPoliciesWithOptions($request, $runtime);
    }

    /**
     * Queries the tags that are added to Global Accelerator (GA) resources.
     *
     * @remarks
     *   You must specify **ResourceId** or **Tag** in the request to specify the object that you want to query.********
     * *   **Tag** is a resource tag that consists of a key-value pair (Key and Value). If you specify only **Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Value**, an error message is returned.
     * *   If you specify **Tag** and **ResourceId** to filter tags, **ResourceId** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain the key-value pairs are returned.
     *
     * @param request - ListTagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTagResourcesResponse
     *
     * @param ListTagResourcesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListTagResourcesResponse
     */
    public function listTagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTagResources',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the tags that are added to Global Accelerator (GA) resources.
     *
     * @remarks
     *   You must specify **ResourceId** or **Tag** in the request to specify the object that you want to query.********
     * *   **Tag** is a resource tag that consists of a key-value pair (Key and Value). If you specify only **Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Value**, an error message is returned.
     * *   If you specify **Tag** and **ResourceId** to filter tags, **ResourceId** must match all specified key-value pairs.
     * *   If you specify multiple key-value pairs, resources that contain the key-value pairs are returned.
     *
     * @param request - ListTagResourcesRequest
     *
     * @returns ListTagResourcesResponse
     *
     * @param ListTagResourcesRequest $request
     *
     * @return ListTagResourcesResponse
     */
    public function listTagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTagResourcesWithOptions($request, $runtime);
    }

    /**
     * Activates the pay-as-you-go Global Accelerator (GA) service. If you want to use pay-as-you-go GA instances, you must activate the pay-as-you-go GA service first.
     *
     * @param request - OpenAcceleratorServiceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OpenAcceleratorServiceResponse
     *
     * @param OpenAcceleratorServiceRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return OpenAcceleratorServiceResponse
     */
    public function openAcceleratorServiceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'OpenAcceleratorService',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OpenAcceleratorServiceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Activates the pay-as-you-go Global Accelerator (GA) service. If you want to use pay-as-you-go GA instances, you must activate the pay-as-you-go GA service first.
     *
     * @param request - OpenAcceleratorServiceRequest
     *
     * @returns OpenAcceleratorServiceResponse
     *
     * @param OpenAcceleratorServiceRequest $request
     *
     * @return OpenAcceleratorServiceResponse
     */
    public function openAcceleratorService($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->openAcceleratorServiceWithOptions($request, $runtime);
    }

    /**
     * Inquire about the approval status of cross-border permissions for an Alibaba Cloud account (main account).
     *
     * @param request - QueryCrossBorderApprovalStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryCrossBorderApprovalStatusResponse
     *
     * @param QueryCrossBorderApprovalStatusRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return QueryCrossBorderApprovalStatusResponse
     */
    public function queryCrossBorderApprovalStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryCrossBorderApprovalStatus',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryCrossBorderApprovalStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Inquire about the approval status of cross-border permissions for an Alibaba Cloud account (main account).
     *
     * @param request - QueryCrossBorderApprovalStatusRequest
     *
     * @returns QueryCrossBorderApprovalStatusResponse
     *
     * @param QueryCrossBorderApprovalStatusRequest $request
     *
     * @return QueryCrossBorderApprovalStatusResponse
     */
    public function queryCrossBorderApprovalStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryCrossBorderApprovalStatusWithOptions($request, $runtime);
    }

    /**
     * Deletes IP entries from an access control list (ACL).
     *
     * @remarks
     *   **RemoveEntriesFromAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetAcl](https://help.aliyun.com/document_detail/258292.html) or [ListAcls](https://help.aliyun.com/document_detail/258291.html) operation to query the status of the ACL from which you want to delete IP entries.
     *     *   If the ACL is in the **configuring** state, it indicates that the IP entries are being deleted. In this case, you can perform only query operations.
     *     *   If the ACL is in the **active** state, it indicates that the IP entries are deleted.
     * *   The **RemoveEntriesFromAcl** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - RemoveEntriesFromAclRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveEntriesFromAclResponse
     *
     * @param RemoveEntriesFromAclRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return RemoveEntriesFromAclResponse
     */
    public function removeEntriesFromAclWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclEntries) {
            @$query['AclEntries'] = $request->aclEntries;
        }

        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveEntriesFromAcl',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveEntriesFromAclResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes IP entries from an access control list (ACL).
     *
     * @remarks
     *   **RemoveEntriesFromAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetAcl](https://help.aliyun.com/document_detail/258292.html) or [ListAcls](https://help.aliyun.com/document_detail/258291.html) operation to query the status of the ACL from which you want to delete IP entries.
     *     *   If the ACL is in the **configuring** state, it indicates that the IP entries are being deleted. In this case, you can perform only query operations.
     *     *   If the ACL is in the **active** state, it indicates that the IP entries are deleted.
     * *   The **RemoveEntriesFromAcl** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - RemoveEntriesFromAclRequest
     *
     * @returns RemoveEntriesFromAclResponse
     *
     * @param RemoveEntriesFromAclRequest $request
     *
     * @return RemoveEntriesFromAclResponse
     */
    public function removeEntriesFromAcl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeEntriesFromAclWithOptions($request, $runtime);
    }

    /**
     * Replaces the bandwidth plans of Global Accelerator (GA) instances.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   The GA instance continues to forward network traffic.
     * *   **ReplaceBandwidthPackage** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) or [ListAccelerators](https://help.aliyun.com/document_detail/153236.html) operation to query the status of the GA instance.
     *     *   If the GA instance is in the **configuring** state, it indicates that the associated bandwidth plan is being replaced. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, it indicates that the associated bandwidth plan is replaced.
     * *   The **ReplaceBandwidthPackage** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - ReplaceBandwidthPackageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReplaceBandwidthPackageResponse
     *
     * @param ReplaceBandwidthPackageRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ReplaceBandwidthPackageResponse
     */
    public function replaceBandwidthPackageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->targetBandwidthPackageId) {
            @$query['TargetBandwidthPackageId'] = $request->targetBandwidthPackageId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReplaceBandwidthPackage',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReplaceBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Replaces the bandwidth plans of Global Accelerator (GA) instances.
     *
     * @remarks
     * When you call this operation, take note of the following items:
     * *   The GA instance continues to forward network traffic.
     * *   **ReplaceBandwidthPackage** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) or [ListAccelerators](https://help.aliyun.com/document_detail/153236.html) operation to query the status of the GA instance.
     *     *   If the GA instance is in the **configuring** state, it indicates that the associated bandwidth plan is being replaced. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, it indicates that the associated bandwidth plan is replaced.
     * *   The **ReplaceBandwidthPackage** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - ReplaceBandwidthPackageRequest
     *
     * @returns ReplaceBandwidthPackageResponse
     *
     * @param ReplaceBandwidthPackageRequest $request
     *
     * @return ReplaceBandwidthPackageResponse
     */
    public function replaceBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->replaceBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * Adds tags to Global Accelerator (GA) resources.
     *
     * @remarks
     * You can add up to 20 tags to each GA resource. When you call this operation, Alibaba Cloud first checks the number of existing tags attached to the resource. If the quota is reached, an error message is returned.
     *
     * @param request - TagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TagResourcesResponse
     *
     * @param TagResourcesRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return TagResourcesResponse
     */
    public function tagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TagResources',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds tags to Global Accelerator (GA) resources.
     *
     * @remarks
     * You can add up to 20 tags to each GA resource. When you call this operation, Alibaba Cloud first checks the number of existing tags attached to the resource. If the quota is reached, an error message is returned.
     *
     * @param request - TagResourcesRequest
     *
     * @returns TagResourcesResponse
     *
     * @param TagResourcesRequest $request
     *
     * @return TagResourcesResponse
     */
    public function tagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->tagResourcesWithOptions($request, $runtime);
    }

    /**
     * Removes tags from Global Accelerator (GA) resources.
     *
     * @param request - UntagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UntagResourcesResponse
     *
     * @param UntagResourcesRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return UntagResourcesResponse
     */
    public function untagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->all) {
            @$query['All'] = $request->all;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tagKey) {
            @$query['TagKey'] = $request->tagKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UntagResources',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UntagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes tags from Global Accelerator (GA) resources.
     *
     * @param request - UntagResourcesRequest
     *
     * @returns UntagResourcesResponse
     *
     * @param UntagResourcesRequest $request
     *
     * @return UntagResourcesResponse
     */
    public function untagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->untagResourcesWithOptions($request, $runtime);
    }

    /**
     * Modifies a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **UpdateAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of a GA instance.
     *     *   If the GA instance is in the **configuring** state, the GA instance is being modified. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, the GA instance is modified.
     * *   The **UpdateAccelerator** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - UpdateAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAcceleratorResponse
     *
     * @param UpdateAcceleratorRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return UpdateAcceleratorResponse
     */
    public function updateAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->spec) {
            @$query['Spec'] = $request->spec;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **UpdateAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of a GA instance.
     *     *   If the GA instance is in the **configuring** state, the GA instance is being modified. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, the GA instance is modified.
     * *   The **UpdateAccelerator** operation cannot be repeatedly called for the same GA instance within a specific period of time.
     *
     * @param request - UpdateAcceleratorRequest
     *
     * @returns UpdateAcceleratorResponse
     *
     * @param UpdateAcceleratorRequest $request
     *
     * @return UpdateAcceleratorResponse
     */
    public function updateAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Modifies the auto-renewal settings of a Global Accelerator (GA) instance.
     *
     * @remarks
     * You cannot repeatedly call the **UpdateAcceleratorAutoRenewAttribute** operation for the same GA instance within a specific period of time.
     *
     * @param request - UpdateAcceleratorAutoRenewAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAcceleratorAutoRenewAttributeResponse
     *
     * @param UpdateAcceleratorAutoRenewAttributeRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return UpdateAcceleratorAutoRenewAttributeResponse
     */
    public function updateAcceleratorAutoRenewAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoRenewDuration) {
            @$query['AutoRenewDuration'] = $request->autoRenewDuration;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->renewalStatus) {
            @$query['RenewalStatus'] = $request->renewalStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateAcceleratorAutoRenewAttribute',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAcceleratorAutoRenewAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the auto-renewal settings of a Global Accelerator (GA) instance.
     *
     * @remarks
     * You cannot repeatedly call the **UpdateAcceleratorAutoRenewAttribute** operation for the same GA instance within a specific period of time.
     *
     * @param request - UpdateAcceleratorAutoRenewAttributeRequest
     *
     * @returns UpdateAcceleratorAutoRenewAttributeResponse
     *
     * @param UpdateAcceleratorAutoRenewAttributeRequest $request
     *
     * @return UpdateAcceleratorAutoRenewAttributeResponse
     */
    public function updateAcceleratorAutoRenewAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAcceleratorAutoRenewAttributeWithOptions($request, $runtime);
    }

    /**
     * Confirms the updated specification of a Global Accelerator (GA) instance.
     *
     * @remarks
     * After you modify the specification of a GA instance, you must confirm the modification. The **UpdateAcceleratorConfirm** operation is used to confirm the specification of a GA instance that is modified. When you call this operation to confirm the specification of a GA instance, take note of the following items:
     * *   **UpdateAcceleratorConfirm** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of a GA instance.
     *     *   If the GA instance is in the **configuring** state, it indicates that the specification of the instance is being modified. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, it indicates that the specification of the instance is modified.
     * *   The **UpdateAcceleratorConfirm** operation cannot be called repeatedly for the same GA instance within a specific period of time.
     *
     * @param request - UpdateAcceleratorConfirmRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAcceleratorConfirmResponse
     *
     * @param UpdateAcceleratorConfirmRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdateAcceleratorConfirmResponse
     */
    public function updateAcceleratorConfirmWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateAcceleratorConfirm',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAcceleratorConfirmResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Confirms the updated specification of a Global Accelerator (GA) instance.
     *
     * @remarks
     * After you modify the specification of a GA instance, you must confirm the modification. The **UpdateAcceleratorConfirm** operation is used to confirm the specification of a GA instance that is modified. When you call this operation to confirm the specification of a GA instance, take note of the following items:
     * *   **UpdateAcceleratorConfirm** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of a GA instance.
     *     *   If the GA instance is in the **configuring** state, it indicates that the specification of the instance is being modified. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, it indicates that the specification of the instance is modified.
     * *   The **UpdateAcceleratorConfirm** operation cannot be called repeatedly for the same GA instance within a specific period of time.
     *
     * @param request - UpdateAcceleratorConfirmRequest
     *
     * @returns UpdateAcceleratorConfirmResponse
     *
     * @param UpdateAcceleratorConfirmRequest $request
     *
     * @return UpdateAcceleratorConfirmResponse
     */
    public function updateAcceleratorConfirm($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAcceleratorConfirmWithOptions($request, $runtime);
    }

    /**
     * Changes the type of transmission network for a Global Accelerator (GA) instance.
     *
     * @remarks
     * You can call this operation to change the type of transmission network for a **standard** GA instance whose bandwidth metering method is **pay-by-data-transfer**. Before you call this operation, make sure that the following requirements are met:
     * *   Cloud Data Transfer (CDT) is activated. When you call the [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html) operation and set **BandwidthBillingType** to **CDT** to create a **standard** GA instance whose bandwidth metering method is **pay-by-data-transfer**, CDT is automatically activated. The data transfer fees are managed by CDT.
     * *   If you want to set **CrossBorderMode** to **private**, which specifies cross-border Express Connect circuit as the type of transmission network, make sure that real-name verification is complete for your enterprise account. For more information, see [Real-name verification](https://help.aliyun.com/document_detail/52595.html).
     *
     * @param request - UpdateAcceleratorCrossBorderModeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAcceleratorCrossBorderModeResponse
     *
     * @param UpdateAcceleratorCrossBorderModeRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return UpdateAcceleratorCrossBorderModeResponse
     */
    public function updateAcceleratorCrossBorderModeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->crossBorderMode) {
            @$query['CrossBorderMode'] = $request->crossBorderMode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateAcceleratorCrossBorderMode',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAcceleratorCrossBorderModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the type of transmission network for a Global Accelerator (GA) instance.
     *
     * @remarks
     * You can call this operation to change the type of transmission network for a **standard** GA instance whose bandwidth metering method is **pay-by-data-transfer**. Before you call this operation, make sure that the following requirements are met:
     * *   Cloud Data Transfer (CDT) is activated. When you call the [CreateAccelerator](https://help.aliyun.com/document_detail/206786.html) operation and set **BandwidthBillingType** to **CDT** to create a **standard** GA instance whose bandwidth metering method is **pay-by-data-transfer**, CDT is automatically activated. The data transfer fees are managed by CDT.
     * *   If you want to set **CrossBorderMode** to **private**, which specifies cross-border Express Connect circuit as the type of transmission network, make sure that real-name verification is complete for your enterprise account. For more information, see [Real-name verification](https://help.aliyun.com/document_detail/52595.html).
     *
     * @param request - UpdateAcceleratorCrossBorderModeRequest
     *
     * @returns UpdateAcceleratorCrossBorderModeResponse
     *
     * @param UpdateAcceleratorCrossBorderModeRequest $request
     *
     * @return UpdateAcceleratorCrossBorderModeResponse
     */
    public function updateAcceleratorCrossBorderMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAcceleratorCrossBorderModeWithOptions($request, $runtime);
    }

    /**
     * Enables cross-border data transmission for a Global Accelerator (GA) instance.
     *
     * @remarks
     * You can call this operation to enable or disable cross-border data transmission for basic or standard GA instances that use Cloud Data Transfer (CDT) to bill data transfers.
     *
     * @param request - UpdateAcceleratorCrossBorderStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAcceleratorCrossBorderStatusResponse
     *
     * @param UpdateAcceleratorCrossBorderStatusRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return UpdateAcceleratorCrossBorderStatusResponse
     */
    public function updateAcceleratorCrossBorderStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->crossBorderStatus) {
            @$query['CrossBorderStatus'] = $request->crossBorderStatus;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateAcceleratorCrossBorderStatus',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAcceleratorCrossBorderStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables cross-border data transmission for a Global Accelerator (GA) instance.
     *
     * @remarks
     * You can call this operation to enable or disable cross-border data transmission for basic or standard GA instances that use Cloud Data Transfer (CDT) to bill data transfers.
     *
     * @param request - UpdateAcceleratorCrossBorderStatusRequest
     *
     * @returns UpdateAcceleratorCrossBorderStatusResponse
     *
     * @param UpdateAcceleratorCrossBorderStatusRequest $request
     *
     * @return UpdateAcceleratorCrossBorderStatusResponse
     */
    public function updateAcceleratorCrossBorderStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAcceleratorCrossBorderStatusWithOptions($request, $runtime);
    }

    /**
     * Modifies the attributes of an access control list (ACL) of a Global Accelerator (GA) instance.
     *
     * @param request - UpdateAclAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAclAttributeResponse
     *
     * @param UpdateAclAttributeRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return UpdateAclAttributeResponse
     */
    public function updateAclAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aclId) {
            @$query['AclId'] = $request->aclId;
        }

        if (null !== $request->aclName) {
            @$query['AclName'] = $request->aclName;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateAclAttribute',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAclAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the attributes of an access control list (ACL) of a Global Accelerator (GA) instance.
     *
     * @param request - UpdateAclAttributeRequest
     *
     * @returns UpdateAclAttributeResponse
     *
     * @param UpdateAclAttributeRequest $request
     *
     * @return UpdateAclAttributeResponse
     */
    public function updateAclAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAclAttributeWithOptions($request, $runtime);
    }

    /**
     * Replaces an expired additional certificate for an HTTPS listener.
     *
     * @remarks
     * The UpdateAdditionalCertificateWithListener operation is used to replace an additional certificate. This operation is suitable for scenarios in which the original certificate expires and needs to be replaced with a new certificate and the associated domain name remains unchanged.
     * *   **UpdateAdditionalCertificateWithListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListListenerCertificates](https://help.aliyun.com/document_detail/307743.html) to query the status of the task:
     *     *   If the certificate to be replaced is in the **updating** state, the certificate is being replaced. In this case, you can only query the certificate.
     *     *   If the new certificate is in the **active** state, the new certificate is in effect.
     * *   You cannot repeatedly call the **UpdateAdditionalCertificateWithListener** operation for the same GA instance within a specific period of time.
     *
     * @param request - UpdateAdditionalCertificateWithListenerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateAdditionalCertificateWithListenerResponse
     *
     * @param UpdateAdditionalCertificateWithListenerRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return UpdateAdditionalCertificateWithListenerResponse
     */
    public function updateAdditionalCertificateWithListenerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->certificateId) {
            @$query['CertificateId'] = $request->certificateId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateAdditionalCertificateWithListener',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateAdditionalCertificateWithListenerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Replaces an expired additional certificate for an HTTPS listener.
     *
     * @remarks
     * The UpdateAdditionalCertificateWithListener operation is used to replace an additional certificate. This operation is suitable for scenarios in which the original certificate expires and needs to be replaced with a new certificate and the associated domain name remains unchanged.
     * *   **UpdateAdditionalCertificateWithListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListListenerCertificates](https://help.aliyun.com/document_detail/307743.html) to query the status of the task:
     *     *   If the certificate to be replaced is in the **updating** state, the certificate is being replaced. In this case, you can only query the certificate.
     *     *   If the new certificate is in the **active** state, the new certificate is in effect.
     * *   You cannot repeatedly call the **UpdateAdditionalCertificateWithListener** operation for the same GA instance within a specific period of time.
     *
     * @param request - UpdateAdditionalCertificateWithListenerRequest
     *
     * @returns UpdateAdditionalCertificateWithListenerResponse
     *
     * @param UpdateAdditionalCertificateWithListenerRequest $request
     *
     * @return UpdateAdditionalCertificateWithListenerResponse
     */
    public function updateAdditionalCertificateWithListener($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateAdditionalCertificateWithListenerWithOptions($request, $runtime);
    }

    /**
     * Modifies an origin probing task.
     *
     * @remarks
     * *UpdateApplicationMonitor** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeApplicationMonitor](https://help.aliyun.com/document_detail/408463.html) or [ListApplicationMonitor](https://help.aliyun.com/document_detail/408462.html) operation to check whether the configurations of an origin probing task are modified.
     * *   If the values of modified parameters remain unchanged, it indicates that the origin probing task is being modified. In this case, you can perform only query operations.
     * *   If the values of modified parameters change, it indicates that the origin probing task is modified.
     *
     * @param request - UpdateApplicationMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateApplicationMonitorResponse
     *
     * @param UpdateApplicationMonitorRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdateApplicationMonitorResponse
     */
    public function updateApplicationMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->address) {
            @$query['Address'] = $request->address;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->detectEnable) {
            @$query['DetectEnable'] = $request->detectEnable;
        }

        if (null !== $request->detectThreshold) {
            @$query['DetectThreshold'] = $request->detectThreshold;
        }

        if (null !== $request->detectTimes) {
            @$query['DetectTimes'] = $request->detectTimes;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->optionsJson) {
            @$query['OptionsJson'] = $request->optionsJson;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->silenceTime) {
            @$query['SilenceTime'] = $request->silenceTime;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateApplicationMonitor',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateApplicationMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies an origin probing task.
     *
     * @remarks
     * *UpdateApplicationMonitor** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeApplicationMonitor](https://help.aliyun.com/document_detail/408463.html) or [ListApplicationMonitor](https://help.aliyun.com/document_detail/408462.html) operation to check whether the configurations of an origin probing task are modified.
     * *   If the values of modified parameters remain unchanged, it indicates that the origin probing task is being modified. In this case, you can perform only query operations.
     * *   If the values of modified parameters change, it indicates that the origin probing task is modified.
     *
     * @param request - UpdateApplicationMonitorRequest
     *
     * @returns UpdateApplicationMonitorResponse
     *
     * @param UpdateApplicationMonitorRequest $request
     *
     * @return UpdateApplicationMonitorResponse
     */
    public function updateApplicationMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateApplicationMonitorWithOptions($request, $runtime);
    }

    /**
     * Changes the auto-renewal status of a bandwidth plan.
     *
     * @remarks
     * You cannot repeatedly call the **UpdateBandwidthPackagaAutoRenewAttribute** operation to modify the auto-renewal settings of a bandwidth plan.
     *
     * @param request - UpdateBandwidthPackagaAutoRenewAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateBandwidthPackagaAutoRenewAttributeResponse
     *
     * @param UpdateBandwidthPackagaAutoRenewAttributeRequest $request
     * @param RuntimeOptions                                  $runtime
     *
     * @return UpdateBandwidthPackagaAutoRenewAttributeResponse
     */
    public function updateBandwidthPackagaAutoRenewAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoRenewDuration) {
            @$query['AutoRenewDuration'] = $request->autoRenewDuration;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->renewalStatus) {
            @$query['RenewalStatus'] = $request->renewalStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateBandwidthPackagaAutoRenewAttribute',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateBandwidthPackagaAutoRenewAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the auto-renewal status of a bandwidth plan.
     *
     * @remarks
     * You cannot repeatedly call the **UpdateBandwidthPackagaAutoRenewAttribute** operation to modify the auto-renewal settings of a bandwidth plan.
     *
     * @param request - UpdateBandwidthPackagaAutoRenewAttributeRequest
     *
     * @returns UpdateBandwidthPackagaAutoRenewAttributeResponse
     *
     * @param UpdateBandwidthPackagaAutoRenewAttributeRequest $request
     *
     * @return UpdateBandwidthPackagaAutoRenewAttributeResponse
     */
    public function updateBandwidthPackagaAutoRenewAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBandwidthPackagaAutoRenewAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of a bandwidth plan.
     *
     * @remarks
     * Take note of the following items:
     * *   **UpdateBandwidthPackage** is a synchronous operation when you call the operation to modify the configuration excluding the bandwidth value of a bandwidth plan. The new configuration immediately takes effect after the operation is performed.
     * *   **UpdateBandwidthPackage** is an asynchronous operation when you call the operation to modify the configuration including the bandwidth value of a bandwidth plan that is not associated with a Global Accelerator (GA) instance. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the task.
     *     *   If the parameter values of the bandwidth plan remain unchanged, the bandwidth plan is being modified. In this case, you can perform only query operations.
     *     *   If the parameter values of the bandwidth plan are changed, the bandwidth plan is modified.
     * *   **UpdateBandwidthPackage** is an asynchronous operation when you call the operation to modify the configuration including the bandwidth value of a bandwidth plan that is associated with a GA instance. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of the task.
     *     *   If the GA instance is in the **configuring** state, the bandwidth plan is being modified. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, the bandwidth plan is modified.
     * *   You cannot repeatedly call the **UpdateBandwidthPackage** operation for the same bandwidth plan within a specific period of time.
     *
     * @param request - UpdateBandwidthPackageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateBandwidthPackageResponse
     *
     * @param UpdateBandwidthPackageRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return UpdateBandwidthPackageResponse
     */
    public function updateBandwidthPackageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->bandwidthPackageId) {
            @$query['BandwidthPackageId'] = $request->bandwidthPackageId;
        }

        if (null !== $request->bandwidthType) {
            @$query['BandwidthType'] = $request->bandwidthType;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateBandwidthPackage',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateBandwidthPackageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of a bandwidth plan.
     *
     * @remarks
     * Take note of the following items:
     * *   **UpdateBandwidthPackage** is a synchronous operation when you call the operation to modify the configuration excluding the bandwidth value of a bandwidth plan. The new configuration immediately takes effect after the operation is performed.
     * *   **UpdateBandwidthPackage** is an asynchronous operation when you call the operation to modify the configuration including the bandwidth value of a bandwidth plan that is not associated with a Global Accelerator (GA) instance. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](https://help.aliyun.com/document_detail/153241.html) operation to query the status of the task.
     *     *   If the parameter values of the bandwidth plan remain unchanged, the bandwidth plan is being modified. In this case, you can perform only query operations.
     *     *   If the parameter values of the bandwidth plan are changed, the bandwidth plan is modified.
     * *   **UpdateBandwidthPackage** is an asynchronous operation when you call the operation to modify the configuration including the bandwidth value of a bandwidth plan that is associated with a GA instance. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](https://help.aliyun.com/document_detail/153235.html) operation to query the status of the task.
     *     *   If the GA instance is in the **configuring** state, the bandwidth plan is being modified. In this case, you can perform only query operations.
     *     *   If the GA instance is in the **active** state, the bandwidth plan is modified.
     * *   You cannot repeatedly call the **UpdateBandwidthPackage** operation for the same bandwidth plan within a specific period of time.
     *
     * @param request - UpdateBandwidthPackageRequest
     *
     * @returns UpdateBandwidthPackageResponse
     *
     * @param UpdateBandwidthPackageRequest $request
     *
     * @return UpdateBandwidthPackageResponse
     */
    public function updateBandwidthPackage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBandwidthPackageWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of a basic Global Accelerator (GA) instance.
     *
     * @param request - UpdateBasicAcceleratorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateBasicAcceleratorResponse
     *
     * @param UpdateBasicAcceleratorRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return UpdateBasicAcceleratorResponse
     */
    public function updateBasicAcceleratorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateBasicAccelerator',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateBasicAcceleratorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of a basic Global Accelerator (GA) instance.
     *
     * @param request - UpdateBasicAcceleratorRequest
     *
     * @returns UpdateBasicAcceleratorResponse
     *
     * @param UpdateBasicAcceleratorRequest $request
     *
     * @return UpdateBasicAcceleratorResponse
     */
    public function updateBasicAccelerator($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBasicAcceleratorWithOptions($request, $runtime);
    }

    /**
     * Modifies the name of an endpoint that is associated with a basic Global Accelerator (GA) instance.
     *
     * @param request - UpdateBasicEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateBasicEndpointResponse
     *
     * @param UpdateBasicEndpointRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return UpdateBasicEndpointResponse
     */
    public function updateBasicEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateBasicEndpoint',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateBasicEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name of an endpoint that is associated with a basic Global Accelerator (GA) instance.
     *
     * @param request - UpdateBasicEndpointRequest
     *
     * @returns UpdateBasicEndpointResponse
     *
     * @param UpdateBasicEndpointRequest $request
     *
     * @return UpdateBasicEndpointResponse
     */
    public function updateBasicEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBasicEndpointWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of an endpoint group that is associated with a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **UpdateBasicEndpointGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. The system modifies the configurations of an endpoint group that is associated with a basic GA instance by deleting the endpoint group and creating a new endpoint group. You can call the [GetBasicAccelerator](https://help.aliyun.com/document_detail/353188.html) operation to query the status of the task.
     *     *   If the basic GA instance is in the **configuring** state, the configurations of the endpoint group are being modified. In this case, you can perform only query operations.
     *     *   If the basic GA instance is in the **active** state, the configurations of the endpoint group are modified.
     * *   The **UpdateBasicEndpointGroup** operation cannot be repeatedly called for the same basic GA instance within a specific period of time.
     *
     * @param request - UpdateBasicEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateBasicEndpointGroupResponse
     *
     * @param UpdateBasicEndpointGroupRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdateBasicEndpointGroupResponse
     */
    public function updateBasicEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->endpointAddress) {
            @$query['EndpointAddress'] = $request->endpointAddress;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointSubAddress) {
            @$query['EndpointSubAddress'] = $request->endpointSubAddress;
        }

        if (null !== $request->endpointType) {
            @$query['EndpointType'] = $request->endpointType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateBasicEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateBasicEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of an endpoint group that is associated with a basic Global Accelerator (GA) instance.
     *
     * @remarks
     *   **UpdateBasicEndpointGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. The system modifies the configurations of an endpoint group that is associated with a basic GA instance by deleting the endpoint group and creating a new endpoint group. You can call the [GetBasicAccelerator](https://help.aliyun.com/document_detail/353188.html) operation to query the status of the task.
     *     *   If the basic GA instance is in the **configuring** state, the configurations of the endpoint group are being modified. In this case, you can perform only query operations.
     *     *   If the basic GA instance is in the **active** state, the configurations of the endpoint group are modified.
     * *   The **UpdateBasicEndpointGroup** operation cannot be repeatedly called for the same basic GA instance within a specific period of time.
     *
     * @param request - UpdateBasicEndpointGroupRequest
     *
     * @returns UpdateBasicEndpointGroupResponse
     *
     * @param UpdateBasicEndpointGroupRequest $request
     *
     * @return UpdateBasicEndpointGroupResponse
     */
    public function updateBasicEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBasicEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Modifies the bandwidth of an acceleration region of a basic Global Accelerator (GA) instance.
     *
     * @remarks
     * Before you call this operation, take note of the following limits:
     * *   You can modify the bandwidth of an acceleration region of a basic GA instance only if the bandwidth metering method of the basic GA instance is **pay-by-data-transfer**.
     * *   **UpdateBasicIpSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicIpSet](https://help.aliyun.com/document_detail/362987.html) operation to query the status of the task.
     *     *   If the acceleration region is in the **updating** state, it indicates that the bandwidth of the acceleration region is being modified. In this case, you can perform only query operations.
     *     *   If the acceleration region is in the **active** state, it indicates that the bandwidth of the acceleration region is modified.
     * *   You cannot repeatedly call the **UpdateBasicIpSet** operation for the same basic GA instance within a specific period of time.
     *
     * @param request - UpdateBasicIpSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateBasicIpSetResponse
     *
     * @param UpdateBasicIpSetRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return UpdateBasicIpSetResponse
     */
    public function updateBasicIpSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipSetId) {
            @$query['IpSetId'] = $request->ipSetId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateBasicIpSet',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateBasicIpSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the bandwidth of an acceleration region of a basic Global Accelerator (GA) instance.
     *
     * @remarks
     * Before you call this operation, take note of the following limits:
     * *   You can modify the bandwidth of an acceleration region of a basic GA instance only if the bandwidth metering method of the basic GA instance is **pay-by-data-transfer**.
     * *   **UpdateBasicIpSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetBasicIpSet](https://help.aliyun.com/document_detail/362987.html) operation to query the status of the task.
     *     *   If the acceleration region is in the **updating** state, it indicates that the bandwidth of the acceleration region is being modified. In this case, you can perform only query operations.
     *     *   If the acceleration region is in the **active** state, it indicates that the bandwidth of the acceleration region is modified.
     * *   You cannot repeatedly call the **UpdateBasicIpSet** operation for the same basic GA instance within a specific period of time.
     *
     * @param request - UpdateBasicIpSetRequest
     *
     * @returns UpdateBasicIpSetResponse
     *
     * @param UpdateBasicIpSetRequest $request
     *
     * @return UpdateBasicIpSetResponse
     */
    public function updateBasicIpSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBasicIpSetWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of an endpoint group that is associated with a custom routing listener.
     *
     * @param request - UpdateCustomRoutingEndpointGroupAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCustomRoutingEndpointGroupAttributeResponse
     *
     * @param UpdateCustomRoutingEndpointGroupAttributeRequest $request
     * @param RuntimeOptions                                   $runtime
     *
     * @return UpdateCustomRoutingEndpointGroupAttributeResponse
     */
    public function updateCustomRoutingEndpointGroupAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCustomRoutingEndpointGroupAttribute',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCustomRoutingEndpointGroupAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of an endpoint group that is associated with a custom routing listener.
     *
     * @param request - UpdateCustomRoutingEndpointGroupAttributeRequest
     *
     * @returns UpdateCustomRoutingEndpointGroupAttributeResponse
     *
     * @param UpdateCustomRoutingEndpointGroupAttributeRequest $request
     *
     * @return UpdateCustomRoutingEndpointGroupAttributeResponse
     */
    public function updateCustomRoutingEndpointGroupAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCustomRoutingEndpointGroupAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the mapping configurations of an endpoint group that is associated with a custom routing listener.
     *
     * @remarks
     *   **UpdateCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of an endpoint group associated with a custom routing listener to check whether the mapping configurations of the endpoint group are modified.
     *     *   If the endpoint group is in the **updating** state, the mapping configurations of the endpoint group are being modified. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, the mapping configurations of the endpoint group are modified.
     * *   The **UpdateCustomRoutingEndpointGroupDestinations** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - UpdateCustomRoutingEndpointGroupDestinationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param UpdateCustomRoutingEndpointGroupDestinationsRequest $request
     * @param RuntimeOptions                                      $runtime
     *
     * @return UpdateCustomRoutingEndpointGroupDestinationsResponse
     */
    public function updateCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->destinationConfigurations) {
            @$query['DestinationConfigurations'] = $request->destinationConfigurations;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCustomRoutingEndpointGroupDestinations',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCustomRoutingEndpointGroupDestinationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the mapping configurations of an endpoint group that is associated with a custom routing listener.
     *
     * @remarks
     *   **UpdateCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of an endpoint group associated with a custom routing listener to check whether the mapping configurations of the endpoint group are modified.
     *     *   If the endpoint group is in the **updating** state, the mapping configurations of the endpoint group are being modified. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, the mapping configurations of the endpoint group are modified.
     * *   The **UpdateCustomRoutingEndpointGroupDestinations** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - UpdateCustomRoutingEndpointGroupDestinationsRequest
     *
     * @returns UpdateCustomRoutingEndpointGroupDestinationsResponse
     *
     * @param UpdateCustomRoutingEndpointGroupDestinationsRequest $request
     *
     * @return UpdateCustomRoutingEndpointGroupDestinationsResponse
     */
    public function updateCustomRoutingEndpointGroupDestinations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCustomRoutingEndpointGroupDestinationsWithOptions($request, $runtime);
    }

    /**
     * Modifies the traffic policies for an endpoint that is associated with a custom routing listener.
     *
     * @remarks
     *   **UpdateCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **updating** state, traffic policies are being modified for endpoints in the endpoint group. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, traffic policies are modified for endpoints in the endpoint group.
     * *   The **UpdateCustomRoutingEndpointTrafficPolicies** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - UpdateCustomRoutingEndpointTrafficPoliciesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCustomRoutingEndpointTrafficPoliciesResponse
     *
     * @param UpdateCustomRoutingEndpointTrafficPoliciesRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return UpdateCustomRoutingEndpointTrafficPoliciesResponse
     */
    public function updateCustomRoutingEndpointTrafficPoliciesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointId) {
            @$query['EndpointId'] = $request->endpointId;
        }

        if (null !== $request->policyConfigurations) {
            @$query['PolicyConfigurations'] = $request->policyConfigurations;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCustomRoutingEndpointTrafficPolicies',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCustomRoutingEndpointTrafficPoliciesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the traffic policies for an endpoint that is associated with a custom routing listener.
     *
     * @remarks
     *   **UpdateCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the status of the task.
     *     *   If the endpoint group is in the **updating** state, traffic policies are being modified for endpoints in the endpoint group. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, traffic policies are modified for endpoints in the endpoint group.
     * *   The **UpdateCustomRoutingEndpointTrafficPolicies** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - UpdateCustomRoutingEndpointTrafficPoliciesRequest
     *
     * @returns UpdateCustomRoutingEndpointTrafficPoliciesResponse
     *
     * @param UpdateCustomRoutingEndpointTrafficPoliciesRequest $request
     *
     * @return UpdateCustomRoutingEndpointTrafficPoliciesResponse
     */
    public function updateCustomRoutingEndpointTrafficPolicies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCustomRoutingEndpointTrafficPoliciesWithOptions($request, $runtime);
    }

    /**
     * Modifies the endpoints of a custom routing listener.
     *
     * @remarks
     * ## Description
     * *   **UpdateCustomRoutingEndpoints** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the state of the endpoint groups associated with a custom routing listener to check whether the endpoints in the endpoint groups are modified.
     *     *   If an endpoint group is in the **updating** state, the endpoints in the endpoint group are being modified. In this case, you can perform only query operations.
     *     *   If an endpoint group is in the **active** state, the endpoints in the endpoint group are modified.
     * *   The **UpdateCustomRoutingEndpoints** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - UpdateCustomRoutingEndpointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateCustomRoutingEndpointsResponse
     *
     * @param UpdateCustomRoutingEndpointsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return UpdateCustomRoutingEndpointsResponse
     */
    public function updateCustomRoutingEndpointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointConfigurations) {
            @$query['EndpointConfigurations'] = $request->endpointConfigurations;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateCustomRoutingEndpoints',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateCustomRoutingEndpointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the endpoints of a custom routing listener.
     *
     * @remarks
     * ## Description
     * *   **UpdateCustomRoutingEndpoints** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](https://help.aliyun.com/document_detail/449373.html) operation to query the state of the endpoint groups associated with a custom routing listener to check whether the endpoints in the endpoint groups are modified.
     *     *   If an endpoint group is in the **updating** state, the endpoints in the endpoint group are being modified. In this case, you can perform only query operations.
     *     *   If an endpoint group is in the **active** state, the endpoints in the endpoint group are modified.
     * *   The **UpdateCustomRoutingEndpoints** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - UpdateCustomRoutingEndpointsRequest
     *
     * @returns UpdateCustomRoutingEndpointsResponse
     *
     * @param UpdateCustomRoutingEndpointsRequest $request
     *
     * @return UpdateCustomRoutingEndpointsResponse
     */
    public function updateCustomRoutingEndpoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateCustomRoutingEndpointsWithOptions($request, $runtime);
    }

    /**
     * Modifies an accelerated domain name.
     *
     * @remarks
     * You can call this operation to modify an accelerated domain name. If the new accelerated domain name is hosted in the Chinese mainland, you must obtain an Internet content provider (ICP) number for the domain name.
     * You cannot call the **UpdateDomain** operation again by using the same Alibaba Cloud account before the previous request is completed.
     *
     * @param request - UpdateDomainRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateDomainResponse
     *
     * @param UpdateDomainRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return UpdateDomainResponse
     */
    public function updateDomainWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->targetDomain) {
            @$query['TargetDomain'] = $request->targetDomain;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateDomain',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateDomainResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies an accelerated domain name.
     *
     * @remarks
     * You can call this operation to modify an accelerated domain name. If the new accelerated domain name is hosted in the Chinese mainland, you must obtain an Internet content provider (ICP) number for the domain name.
     * You cannot call the **UpdateDomain** operation again by using the same Alibaba Cloud account before the previous request is completed.
     *
     * @param request - UpdateDomainRequest
     *
     * @returns UpdateDomainResponse
     *
     * @param UpdateDomainRequest $request
     *
     * @return UpdateDomainResponse
     */
    public function updateDomain($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDomainWithOptions($request, $runtime);
    }

    /**
     * Updates the ICP filing status of an accelerated domain name.
     *
     * @remarks
     * You can call this operation to query and update the ICP filing status of an accelerated domain name.
     * The **UpdateDomainState** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation with the same Alibaba Cloud account.
     *
     * @param request - UpdateDomainStateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateDomainStateResponse
     *
     * @param UpdateDomainStateRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return UpdateDomainStateResponse
     */
    public function updateDomainStateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->domain) {
            @$query['Domain'] = $request->domain;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateDomainState',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateDomainStateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the ICP filing status of an accelerated domain name.
     *
     * @remarks
     * You can call this operation to query and update the ICP filing status of an accelerated domain name.
     * The **UpdateDomainState** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation with the same Alibaba Cloud account.
     *
     * @param request - UpdateDomainStateRequest
     *
     * @returns UpdateDomainStateResponse
     *
     * @param UpdateDomainStateRequest $request
     *
     * @return UpdateDomainStateResponse
     */
    public function updateDomainState($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDomainStateWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of an endpoint group.
     *
     * @remarks
     *   **UpdateEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the state of an endpoint group.
     *     *   If the endpoint group is in the **updating** state, it indicates that the configurations of the endpoint group are being modified. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that the configurations of the endpoint group are modified.
     * *   The **UpdateEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - UpdateEndpointGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateEndpointGroupResponse
     *
     * @param UpdateEndpointGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return UpdateEndpointGroupResponse
     */
    public function updateEndpointGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->endpointConfigurations) {
            @$query['EndpointConfigurations'] = $request->endpointConfigurations;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->endpointGroupRegion) {
            @$query['EndpointGroupRegion'] = $request->endpointGroupRegion;
        }

        if (null !== $request->endpointIpVersion) {
            @$query['EndpointIpVersion'] = $request->endpointIpVersion;
        }

        if (null !== $request->endpointProtocolVersion) {
            @$query['EndpointProtocolVersion'] = $request->endpointProtocolVersion;
        }

        if (null !== $request->endpointRequestProtocol) {
            @$query['EndpointRequestProtocol'] = $request->endpointRequestProtocol;
        }

        if (null !== $request->healthCheckEnabled) {
            @$query['HealthCheckEnabled'] = $request->healthCheckEnabled;
        }

        if (null !== $request->healthCheckHost) {
            @$query['HealthCheckHost'] = $request->healthCheckHost;
        }

        if (null !== $request->healthCheckIntervalSeconds) {
            @$query['HealthCheckIntervalSeconds'] = $request->healthCheckIntervalSeconds;
        }

        if (null !== $request->healthCheckPath) {
            @$query['HealthCheckPath'] = $request->healthCheckPath;
        }

        if (null !== $request->healthCheckPort) {
            @$query['HealthCheckPort'] = $request->healthCheckPort;
        }

        if (null !== $request->healthCheckProtocol) {
            @$query['HealthCheckProtocol'] = $request->healthCheckProtocol;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->portOverrides) {
            @$query['PortOverrides'] = $request->portOverrides;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->thresholdCount) {
            @$query['ThresholdCount'] = $request->thresholdCount;
        }

        if (null !== $request->trafficPercentage) {
            @$query['TrafficPercentage'] = $request->trafficPercentage;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateEndpointGroup',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateEndpointGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of an endpoint group.
     *
     * @remarks
     *   **UpdateEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) operation to query the state of an endpoint group.
     *     *   If the endpoint group is in the **updating** state, it indicates that the configurations of the endpoint group are being modified. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that the configurations of the endpoint group are modified.
     * *   The **UpdateEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
     *
     * @param request - UpdateEndpointGroupRequest
     *
     * @returns UpdateEndpointGroupResponse
     *
     * @param UpdateEndpointGroupRequest $request
     *
     * @return UpdateEndpointGroupResponse
     */
    public function updateEndpointGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateEndpointGroupWithOptions($request, $runtime);
    }

    /**
     * Modifies the name and description of an endpoint group.
     *
     * @param request - UpdateEndpointGroupAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateEndpointGroupAttributeResponse
     *
     * @param UpdateEndpointGroupAttributeRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return UpdateEndpointGroupAttributeResponse
     */
    public function updateEndpointGroupAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateEndpointGroupAttribute',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateEndpointGroupAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name and description of an endpoint group.
     *
     * @param request - UpdateEndpointGroupAttributeRequest
     *
     * @returns UpdateEndpointGroupAttributeResponse
     *
     * @param UpdateEndpointGroupAttributeRequest $request
     *
     * @return UpdateEndpointGroupAttributeResponse
     */
    public function updateEndpointGroupAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateEndpointGroupAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the endpoint groups that are associated with a listener.
     *
     * @remarks
     * ### Description
     * *   **UpdateEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) or [ListEndpointGroups](https://help.aliyun.com/document_detail/153261.html) operation to query the status of an endpoint group.
     *     *   If the endpoint group is in the **updating** state, it indicates that the configuration of the endpoint group is being modified. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that the configuration of the endpoint group is modified.
     * *   The **UpdateEndpointGroups** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - UpdateEndpointGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateEndpointGroupsResponse
     *
     * @param UpdateEndpointGroupsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateEndpointGroupsResponse
     */
    public function updateEndpointGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->endpointGroupConfigurations) {
            @$query['EndpointGroupConfigurations'] = $request->endpointGroupConfigurations;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateEndpointGroups',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateEndpointGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the endpoint groups that are associated with a listener.
     *
     * @remarks
     * ### Description
     * *   **UpdateEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](https://help.aliyun.com/document_detail/153260.html) or [ListEndpointGroups](https://help.aliyun.com/document_detail/153261.html) operation to query the status of an endpoint group.
     *     *   If the endpoint group is in the **updating** state, it indicates that the configuration of the endpoint group is being modified. In this case, you can perform only query operations.
     *     *   If the endpoint group is in the **active** state, it indicates that the configuration of the endpoint group is modified.
     * *   The **UpdateEndpointGroups** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - UpdateEndpointGroupsRequest
     *
     * @returns UpdateEndpointGroupsResponse
     *
     * @param UpdateEndpointGroupsRequest $request
     *
     * @return UpdateEndpointGroupsResponse
     */
    public function updateEndpointGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateEndpointGroupsWithOptions($request, $runtime);
    }

    /**
     * Updates a forwarding rule.
     *
     * @remarks
     *   **UpdateForwardingRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListForwardingRules](https://help.aliyun.com/document_detail/205817.html) operation to query the status of a forwarding rule.
     *     *   If the forwarding rule is in the **configuring** state, it indicates that the forwarding rule is being modified. In this case, you can perform only query operations.
     *     *   If the forwarding rule is in the **active** state, it indicates that the forwarding rule is modified.
     * *   The **UpdateForwardingRules** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - UpdateForwardingRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateForwardingRulesResponse
     *
     * @param UpdateForwardingRulesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdateForwardingRulesResponse
     */
    public function updateForwardingRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->forwardingRules) {
            @$query['ForwardingRules'] = $request->forwardingRules;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateForwardingRules',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateForwardingRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a forwarding rule.
     *
     * @remarks
     *   **UpdateForwardingRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListForwardingRules](https://help.aliyun.com/document_detail/205817.html) operation to query the status of a forwarding rule.
     *     *   If the forwarding rule is in the **configuring** state, it indicates that the forwarding rule is being modified. In this case, you can perform only query operations.
     *     *   If the forwarding rule is in the **active** state, it indicates that the forwarding rule is modified.
     * *   The **UpdateForwardingRules** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
     *
     * @param request - UpdateForwardingRulesRequest
     *
     * @returns UpdateForwardingRulesResponse
     *
     * @param UpdateForwardingRulesRequest $request
     *
     * @return UpdateForwardingRulesResponse
     */
    public function updateForwardingRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateForwardingRulesWithOptions($request, $runtime);
    }

    /**
     * Modifies the attributes of an acceleration region in an acceleration area for a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **UpdateIpSet** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of an acceleration region.
     *     *   If the acceleration region is in the **updating** state, it indicates that the acceleration region is being modified. In this case, you can continue to perform query operations on the acceleration regions.
     *     *   If the acceleration region is in the **active** state, it indicates that the acceleration region is modified.
     * *   You cannot call the **UpdateIpSet** operation again on the same GA instance before the previous operation is complete.
     *
     * @param request - UpdateIpSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateIpSetResponse
     *
     * @param UpdateIpSetRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return UpdateIpSetResponse
     */
    public function updateIpSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->bandwidth) {
            @$query['Bandwidth'] = $request->bandwidth;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ipSetId) {
            @$query['IpSetId'] = $request->ipSetId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateIpSet',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateIpSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the attributes of an acceleration region in an acceleration area for a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **UpdateIpSet** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of an acceleration region.
     *     *   If the acceleration region is in the **updating** state, it indicates that the acceleration region is being modified. In this case, you can continue to perform query operations on the acceleration regions.
     *     *   If the acceleration region is in the **active** state, it indicates that the acceleration region is modified.
     * *   You cannot call the **UpdateIpSet** operation again on the same GA instance before the previous operation is complete.
     *
     * @param request - UpdateIpSetRequest
     *
     * @returns UpdateIpSetResponse
     *
     * @param UpdateIpSetRequest $request
     *
     * @return UpdateIpSetResponse
     */
    public function updateIpSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateIpSetWithOptions($request, $runtime);
    }

    /**
     * Modifies the attributes of acceleration regions in an acceleration area for a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **UpdateIpSets** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of the task.
     *     *   If an acceleration region is in the **updating** state, the acceleration region is being modified. In this case, you can perform only query operations.
     *     *   If an acceleration region is in the **active** state, the acceleration region is modified.
     * *   You cannot repeatedly call the **UpdateIpSets** operation for the same GA instance within a specific period of time.
     *
     * @param request - UpdateIpSetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateIpSetsResponse
     *
     * @param UpdateIpSetsRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return UpdateIpSetsResponse
     */
    public function updateIpSetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipSets) {
            @$query['IpSets'] = $request->ipSets;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateIpSets',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateIpSetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the attributes of acceleration regions in an acceleration area for a Global Accelerator (GA) instance.
     *
     * @remarks
     *   **UpdateIpSets** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](https://help.aliyun.com/document_detail/153246.html) operation to query the status of the task.
     *     *   If an acceleration region is in the **updating** state, the acceleration region is being modified. In this case, you can perform only query operations.
     *     *   If an acceleration region is in the **active** state, the acceleration region is modified.
     * *   You cannot repeatedly call the **UpdateIpSets** operation for the same GA instance within a specific period of time.
     *
     * @param request - UpdateIpSetsRequest
     *
     * @returns UpdateIpSetsResponse
     *
     * @param UpdateIpSetsRequest $request
     *
     * @return UpdateIpSetsResponse
     */
    public function updateIpSets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateIpSetsWithOptions($request, $runtime);
    }

    /**
     * Modifies the configurations of a listener for a Global Accelerator (GA) instance.
     *
     * @remarks
     * This operation can be called to modify the configurations such as the protocol and ports of a listener to meet your business requirements.
     * When you call this operation, take note of the following items:
     * *   **UpdateListener** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the status of a listener.
     *     *   If the listener is in the **updating** state, it indicates that its configurations are being modified. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, it indicates that its configurations are modified.
     * *   The **UpdateListener** operation cannot be repeatedly called to modify listener configurations for the same GA instance within a specific period of time.
     *
     * @param request - UpdateListenerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateListenerResponse
     *
     * @param UpdateListenerRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return UpdateListenerResponse
     */
    public function updateListenerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backendPorts) {
            @$query['BackendPorts'] = $request->backendPorts;
        }

        if (null !== $request->certificates) {
            @$query['Certificates'] = $request->certificates;
        }

        if (null !== $request->clientAffinity) {
            @$query['ClientAffinity'] = $request->clientAffinity;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->httpVersion) {
            @$query['HttpVersion'] = $request->httpVersion;
        }

        if (null !== $request->idleTimeout) {
            @$query['IdleTimeout'] = $request->idleTimeout;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->portRanges) {
            @$query['PortRanges'] = $request->portRanges;
        }

        if (null !== $request->protocol) {
            @$query['Protocol'] = $request->protocol;
        }

        if (null !== $request->proxyProtocol) {
            @$query['ProxyProtocol'] = $request->proxyProtocol;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->requestTimeout) {
            @$query['RequestTimeout'] = $request->requestTimeout;
        }

        if (null !== $request->securityPolicyId) {
            @$query['SecurityPolicyId'] = $request->securityPolicyId;
        }

        if (null !== $request->XForwardedForConfig) {
            @$query['XForwardedForConfig'] = $request->XForwardedForConfig;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateListener',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateListenerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configurations of a listener for a Global Accelerator (GA) instance.
     *
     * @remarks
     * This operation can be called to modify the configurations such as the protocol and ports of a listener to meet your business requirements.
     * When you call this operation, take note of the following items:
     * *   **UpdateListener** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](https://help.aliyun.com/document_detail/153254.html) operation to query the status of a listener.
     *     *   If the listener is in the **updating** state, it indicates that its configurations are being modified. In this case, you can perform only query operations.
     *     *   If the listener is in the **active** state, it indicates that its configurations are modified.
     * *   The **UpdateListener** operation cannot be repeatedly called to modify listener configurations for the same GA instance within a specific period of time.
     *
     * @param request - UpdateListenerRequest
     *
     * @returns UpdateListenerResponse
     *
     * @param UpdateListenerRequest $request
     *
     * @return UpdateListenerResponse
     */
    public function updateListener($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateListenerWithOptions($request, $runtime);
    }

    /**
     * 修改SLS日志配置.
     *
     * @param request - UpdateLogStoreConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateLogStoreConfigResponse
     *
     * @param UpdateLogStoreConfigRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateLogStoreConfigResponse
     */
    public function updateLogStoreConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceleratorId) {
            @$query['AcceleratorId'] = $request->acceleratorId;
        }

        if (null !== $request->accessLogRecordCustomizedHeaderList) {
            @$query['AccessLogRecordCustomizedHeaderList'] = $request->accessLogRecordCustomizedHeaderList;
        }

        if (null !== $request->accessLogRecordCustomizedHeadersEnabled) {
            @$query['AccessLogRecordCustomizedHeadersEnabled'] = $request->accessLogRecordCustomizedHeadersEnabled;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->endpointGroupId) {
            @$query['EndpointGroupId'] = $request->endpointGroupId;
        }

        if (null !== $request->listenerId) {
            @$query['ListenerId'] = $request->listenerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->slsLogStoreName) {
            @$query['SlsLogStoreName'] = $request->slsLogStoreName;
        }

        if (null !== $request->slsProjectName) {
            @$query['SlsProjectName'] = $request->slsProjectName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateLogStoreConfig',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateLogStoreConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 修改SLS日志配置.
     *
     * @param request - UpdateLogStoreConfigRequest
     *
     * @returns UpdateLogStoreConfigResponse
     *
     * @param UpdateLogStoreConfigRequest $request
     *
     * @return UpdateLogStoreConfigResponse
     */
    public function updateLogStoreConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateLogStoreConfigWithOptions($request, $runtime);
    }

    /**
     * Changes the control mode of a resource from managed mode to unmanaged mode.
     *
     * @remarks
     *   This operation is applicable only to **managed** Global Accelerator (GA) instances.
     * *   After you change the control mode of a GA instance from managed mode to unmanaged mode, you cannot change the mode of the instance to managed mode.
     * *   After you change the control mode of a GA instance from managed mode to unmanaged mode, you can obtain all operation permissions on the instance.
     *   <warning>If you change or delete a configuration of a GA instance whose control mode is changed from managed mode to unmanaged mode, the cloud services that depend on the instance may not work as expected. Proceed with caution.
     *
     * @param request - UpdateServiceManagedControlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateServiceManagedControlResponse
     *
     * @param UpdateServiceManagedControlRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return UpdateServiceManagedControlResponse
     */
    public function updateServiceManagedControlWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->serviceManaged) {
            @$query['ServiceManaged'] = $request->serviceManaged;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateServiceManagedControl',
            'version' => '2019-11-20',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateServiceManagedControlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the control mode of a resource from managed mode to unmanaged mode.
     *
     * @remarks
     *   This operation is applicable only to **managed** Global Accelerator (GA) instances.
     * *   After you change the control mode of a GA instance from managed mode to unmanaged mode, you cannot change the mode of the instance to managed mode.
     * *   After you change the control mode of a GA instance from managed mode to unmanaged mode, you can obtain all operation permissions on the instance.
     *   <warning>If you change or delete a configuration of a GA instance whose control mode is changed from managed mode to unmanaged mode, the cloud services that depend on the instance may not work as expected. Proceed with caution.
     *
     * @param request - UpdateServiceManagedControlRequest
     *
     * @returns UpdateServiceManagedControlResponse
     *
     * @param UpdateServiceManagedControlRequest $request
     *
     * @return UpdateServiceManagedControlResponse
     */
    public function updateServiceManagedControl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateServiceManagedControlWithOptions($request, $runtime);
    }
}
