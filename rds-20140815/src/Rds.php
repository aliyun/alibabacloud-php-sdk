<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Rds\V20140815;

use AlibabaCloud\Dara\Models\RuntimeOptions;
use AlibabaCloud\SDK\Rds\V20140815\Models\ActivateMigrationTargetInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ActivateMigrationTargetInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\AddTagsToResourceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\AddTagsToResourceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\AllocateInstancePublicConnectionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\AllocateInstancePublicConnectionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\AllocateReadWriteSplittingConnectionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\AllocateReadWriteSplittingConnectionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\AssociateEipAddressWithRCInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\AssociateEipAddressWithRCInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\AttachRCDiskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\AttachRCDiskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\AttachRCInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\AttachRCInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\AttachRCInstancesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\AttachWhitelistTemplateToInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\AttachWhitelistTemplateToInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\AuthorizeRCSecurityGroupPermissionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\AuthorizeRCSecurityGroupPermissionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\AuthorizeRCSecurityGroupPermissionShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CalculateDBInstanceWeightRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CalculateDBInstanceWeightResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CancelActiveOperationTasksRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CancelActiveOperationTasksResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckAccountNameAvailableRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckAccountNameAvailableResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckCloudResourceAuthorizedRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckCloudResourceAuthorizedResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckCreateDdrDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckCreateDdrDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckDBNameAvailableRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckDBNameAvailableResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckInstanceExistRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckInstanceExistResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckServiceLinkedRoleRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CheckServiceLinkedRoleResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CloneDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CloneDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CloneDBInstanceShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CloneParameterGroupRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CloneParameterGroupResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ConfirmNotifyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ConfirmNotifyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ConfirmNotifyShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CopyDatabaseBetweenInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CopyDatabaseBetweenInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CopyDatabaseRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CopyDatabaseResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateAccountRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateAccountResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateBackupRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateBackupResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateCloudMigrationPrecheckTaskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateCloudMigrationPrecheckTaskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateCloudMigrationTaskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateCloudMigrationTaskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDatabaseRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDatabaseResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceEndpointAddressRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceEndpointAddressResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceEndpointRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceEndpointResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceEndpointShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceForRebuildRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceForRebuildResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceSecurityGroupRuleRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceSecurityGroupRuleResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBInstanceShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBNodesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBNodesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBNodesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBProxyEndpointAddressRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDBProxyEndpointAddressResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDdrInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateDdrInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateGadInstanceMemberRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateGadInstanceMemberResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateGADInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateGADInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateMaskingRulesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateMaskingRulesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateMaskingRulesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateMigrateTaskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateMigrateTaskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateOnlineDatabaseTaskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateOnlineDatabaseTaskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateOrderForDeleteDBNodesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateOrderForDeleteDBNodesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateOrderForDeleteDBNodesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateParameterGroupRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateParameterGroupResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreatePostgresExtensionsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreatePostgresExtensionsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateRCDeploymentSetRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateRCDeploymentSetResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateRCDiskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateRCDiskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateRCNodePoolRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateRCNodePoolResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateRCNodePoolShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateRCSnapshotRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateRCSnapshotResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateReadOnlyDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateReadOnlyDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateReplicationLinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateReplicationLinkResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateSecretRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateSecretResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateServiceLinkedRoleRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateServiceLinkedRoleResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateTempDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateTempDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateYouhuiForOrderRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\CreateYouhuiForOrderResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteAccountRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteAccountResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteADSettingRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteADSettingResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteBackupFileRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteBackupFileResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteBackupRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteBackupResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDatabaseRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDatabaseResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBInstanceEndpointAddressRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBInstanceEndpointAddressResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBInstanceEndpointRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBInstanceEndpointResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBInstanceSecurityGroupRuleRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBInstanceSecurityGroupRuleResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBNodesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBNodesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBNodesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBProxyEndpointAddressRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteDBProxyEndpointAddressResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteGadInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteGadInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteMaskingRulesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteMaskingRulesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteParameterGroupRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteParameterGroupResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeletePostgresExtensionsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeletePostgresExtensionsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCClusterNodesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCClusterNodesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCClusterNodesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCDeploymentSetRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCDeploymentSetResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCDiskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCDiskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCInstancesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCNodePoolRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCNodePoolResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCSnapshotRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteRCSnapshotResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteReplicationLinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteReplicationLinkResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteSecretRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteSecretResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteSlotRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteSlotResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteUserBackupFileRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DeleteUserBackupFileResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescibeImportsFromDatabaseRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescibeImportsFromDatabaseResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAccountMaskingPrivilegeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAccountMaskingPrivilegeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAccountsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAccountsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeActionEventPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeActionEventPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeActiveOperationTasksRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeActiveOperationTasksResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeADInfoRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeADInfoResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAllWhitelistTemplateRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAllWhitelistTemplateResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAnalyticdbByPrimaryDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAnalyticdbByPrimaryDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableClassesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableClassesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableCrossRegionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableCrossRegionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableMetricsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableMetricsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableRecoveryTimeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableRecoveryTimeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableZonesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeAvailableZonesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBackupDatabaseRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBackupDatabaseResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBackupPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBackupPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBackupsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBackupsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBackupTasksRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBackupTasksResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBinlogFilesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeBinlogFilesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCharacterSetNameRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCharacterSetNameResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeClassDetailsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeClassDetailsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCloudMigrationPrecheckResultRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCloudMigrationPrecheckResultResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCloudMigrationResultRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCloudMigrationResultResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCollationTimeZonesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCollationTimeZonesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCrossBackupMetaListRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCrossBackupMetaListResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCrossRegionBackupDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCrossRegionBackupDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCrossRegionBackupsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCrossRegionBackupsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCrossRegionLogBackupFilesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCrossRegionLogBackupFilesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCurrentModifyOrderRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCurrentModifyOrderResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCustinsResourceInfoRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeCustinsResourceInfoResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDatabasesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDatabasesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceAttributeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceAttributeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceByTagsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceByTagsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceConnectivityRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceConnectivityResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceDetailRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceDetailResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceEncryptionKeyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceEncryptionKeyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceEndpointsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceEndpointsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceHAConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceHAConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceIPArrayListRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceIPArrayListResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceIpHostnameRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceIpHostnameResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceMetricsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceMetricsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceMonitorRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceMonitorResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceNetInfoForChannelRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceNetInfoForChannelResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceNetInfoRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceNetInfoResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancePerformanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancePerformanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancePromoteActivityRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancePromoteActivityResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceProxyConfigurationRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceProxyConfigurationResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceReplicationRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceReplicationResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesAsCsvRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesAsCsvResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesByExpireTimeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesByExpireTimeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesByPerformanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesByPerformanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceSecurityGroupRuleRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceSecurityGroupRuleResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesForCloneRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesForCloneResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceSSLRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceSSLResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceTDERequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBInstanceTDEResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBMiniEngineVersionsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBMiniEngineVersionsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBProxyEndpointRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBProxyEndpointResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBProxyPerformanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBProxyPerformanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBProxyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDBProxyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDedicatedHostGroupsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDedicatedHostGroupsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDedicatedHostsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDedicatedHostsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDetachedBackupsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDetachedBackupsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDTCSecurityIpHostsForSQLServerRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeDTCSecurityIpHostsForSQLServerResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeErrorLogsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeErrorLogsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeEventsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeEventsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeGadInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeGadInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHADiagnoseConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHADiagnoseConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHASwitchConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHASwitchConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHistoryEventsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHistoryEventsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHistoryEventsStatRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHistoryEventsStatResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHistoryTasksRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHistoryTasksResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHistoryTasksStatRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHistoryTasksStatResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHostGroupElasticStrategyParametersRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHostGroupElasticStrategyParametersResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHostWebShellRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeHostWebShellResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeInstanceAutoRenewalAttributeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeInstanceAutoRenewalAttributeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeInstanceCrossBackupPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeInstanceCrossBackupPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeInstanceKeywordsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeInstanceKeywordsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeInstanceLinkedWhitelistTemplateRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeInstanceLinkedWhitelistTemplateResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeKmsAssociateResourcesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeKmsAssociateResourcesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeLocalAvailableRecoveryTimeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeLocalAvailableRecoveryTimeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeLogBackupFilesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeLogBackupFilesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMarketingActivityRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMarketingActivityResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMaskingRulesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMaskingRulesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMetaListRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMetaListResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMigrateTaskByIdRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMigrateTaskByIdResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMigrateTasksRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeMigrateTasksResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeModifyParameterLogRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeModifyParameterLogResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeModifyPGHbaConfigLogRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeModifyPGHbaConfigLogResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeOssDownloadsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeOssDownloadsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeParameterGroupRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeParameterGroupResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeParameterGroupsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeParameterGroupsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeParametersRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeParametersResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeParameterTemplatesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeParameterTemplatesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribePGHbaConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribePGHbaConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribePostgresExtensionsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribePostgresExtensionsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribePriceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribePriceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribePriceShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeQuickSaleConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeQuickSaleConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCClusterConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCClusterConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCClusterNodesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCClusterNodesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCClustersRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCClustersResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCDeploymentSetsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCDeploymentSetsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCDisksRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCDisksResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCImageListRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCImageListResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstanceAttributeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstanceAttributeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstanceTypeFamiliesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstanceTypeFamiliesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstanceTypesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstanceTypesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstanceTypesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstanceVncUrlRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCInstanceVncUrlResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCMetricListRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCMetricListResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCNodePoolRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCNodePoolResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCSecurityGroupListRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCSecurityGroupListResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCSecurityGroupPermissionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCSecurityGroupPermissionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCSnapshotsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRCSnapshotsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRdsResourceSettingsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRdsResourceSettingsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeReadDBInstanceDelayRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeReadDBInstanceDelayResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRegionInfosRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRegionInfosResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRegionsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRegionsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRenewalPriceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeRenewalPriceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeReplicationLinkLogsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeReplicationLinkLogsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeResourceDetailsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeResourceDetailsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeResourceUsageRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeResourceUsageResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSecretsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSecretsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSecurityGroupConfigurationRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSecurityGroupConfigurationResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSlotsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSlotsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSlowLogRecordsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSlowLogRecordsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSlowLogsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSlowLogsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLCollectorPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLCollectorPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLCollectorRetentionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLCollectorRetentionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLLogFilesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLLogFilesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLLogRecordsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLLogRecordsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLLogReportListRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSQLLogReportListResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSupportOnlineResizeDiskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeSupportOnlineResizeDiskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeTagsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeTagsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeTasksRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeTasksResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeUpgradeMajorVersionPrecheckTaskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeUpgradeMajorVersionPrecheckTaskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeUpgradeMajorVersionTasksRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeUpgradeMajorVersionTasksResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeVSwitchesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeVSwitchesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeWhitelistTemplateLinkedInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeWhitelistTemplateLinkedInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeWhitelistTemplateRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DescribeWhitelistTemplateResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DestroyDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DestroyDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DetachGadInstanceMemberRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DetachGadInstanceMemberResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DetachRCDiskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DetachRCDiskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\DetachWhitelistTemplateToInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\DetachWhitelistTemplateToInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\EvaluateLocalExtendDiskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\EvaluateLocalExtendDiskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\GetDBInstanceTopologyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\GetDBInstanceTopologyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\GetDbProxyInstanceSslRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\GetDbProxyInstanceSslResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\GrantAccountPrivilegeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\GrantAccountPrivilegeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\GrantOperatorPermissionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\GrantOperatorPermissionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ImportUserBackupFileRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ImportUserBackupFileResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ListClassesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ListClassesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ListTagResourcesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ListTagResourcesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ListUserBackupFilesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ListUserBackupFilesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\LockAccountRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\LockAccountResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateConnectionToOtherZoneRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateConnectionToOtherZoneResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateDBNodesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateDBNodesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateDBNodesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateSecurityIPModeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateSecurityIPModeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateToOtherZoneRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\MigrateToOtherZoneResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyAccountCheckPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyAccountCheckPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyAccountDescriptionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyAccountDescriptionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyAccountMaskingPrivilegeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyAccountMaskingPrivilegeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyAccountSecurityPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyAccountSecurityPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyActionEventPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyActionEventPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyActiveOperationTasksRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyActiveOperationTasksResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyADInfoRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyADInfoResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyBackupPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyBackupPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyCollationTimeZoneRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyCollationTimeZoneResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyCustinsResourceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyCustinsResourceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDasInstanceConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDasInstanceConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDatabaseConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDatabaseConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBDescriptionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBDescriptionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceAutoUpgradeMinorVersionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceAutoUpgradeMinorVersionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceConnectionStringRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceConnectionStringResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceDelayedReplicationTimeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceDelayedReplicationTimeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceDeletionProtectionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceDeletionProtectionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceDescriptionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceDescriptionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceEndpointAddressRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceEndpointAddressResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceEndpointRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceEndpointResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceEndpointShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceHAConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceHAConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceMaintainTimeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceMaintainTimeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceMetricsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceMetricsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceMonitorRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceMonitorResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceNetworkExpireTimeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceNetworkExpireTimeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceNetworkTypeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceNetworkTypeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstancePayTypeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstancePayTypeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceReplicationSwitchRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceReplicationSwitchResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceSecurityGroupRuleRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceSecurityGroupRuleResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceSpecRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceSpecResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceSpecShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceSSLRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceSSLResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceTDERequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBInstanceTDEResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBNodeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBNodeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBNodeShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyEndpointAddressRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyEndpointAddressResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyEndpointRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyEndpointResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyInstanceShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDbProxyInstanceSslRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDbProxyInstanceSslResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDBProxyShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDTCSecurityIpHostsForSQLServerRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyDTCSecurityIpHostsForSQLServerResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyEventInfoRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyEventInfoResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyHADiagnoseConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyHADiagnoseConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyHASwitchConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyHASwitchConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyInstanceAutoRenewalAttributeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyInstanceAutoRenewalAttributeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyInstanceCrossBackupPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyInstanceCrossBackupPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyMaskingRulesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyMaskingRulesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyMaskingRulesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyParameterGroupRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyParameterGroupResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyParameterRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyParameterResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyPGHbaConfigRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyPGHbaConfigResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCDiskSpecRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCDiskSpecResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceAttributeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceAttributeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceChargeTypeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceChargeTypeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceDescriptionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceDescriptionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceKeyPairRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceKeyPairResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceNetworkSpecRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceNetworkSpecResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCSecurityGroupPermissionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyRCSecurityGroupPermissionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyReadonlyInstanceDelayReplicationTimeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyReadonlyInstanceDelayReplicationTimeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyReadWriteSplittingConnectionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyReadWriteSplittingConnectionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyResourceGroupRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyResourceGroupResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifySecurityGroupConfigurationRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifySecurityGroupConfigurationResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifySecurityIpsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifySecurityIpsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifySQLCollectorPolicyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifySQLCollectorPolicyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifySQLCollectorRetentionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifySQLCollectorRetentionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyTaskInfoRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyTaskInfoResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyWhitelistTemplateRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ModifyWhitelistTemplateResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\PreCheckCreateOrderForDeleteDBNodesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\PreCheckCreateOrderForDeleteDBNodesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\PreCheckCreateOrderForDeleteDBNodesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\PurgeDBInstanceLogRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\PurgeDBInstanceLogResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\QueryNotifyRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\QueryNotifyResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\QueryRecommendByCodeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\QueryRecommendByCodeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RebootRCInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RebootRCInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RebootRCInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RebootRCInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RebootRCInstancesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RebuildDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RebuildDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RebuildReplicationLinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RebuildReplicationLinkResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReceiveDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReceiveDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RecoveryDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RecoveryDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReleaseInstanceConnectionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReleaseInstanceConnectionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReleaseInstancePublicConnectionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReleaseInstancePublicConnectionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReleaseReadWriteSplittingConnectionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReleaseReadWriteSplittingConnectionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RemoveTagsFromResourceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RemoveTagsFromResourceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RenewInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RenewInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RenewRCInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RenewRCInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReplaceRCInstanceSystemDiskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ReplaceRCInstanceSystemDiskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ResetAccountPasswordRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ResetAccountPasswordResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ResetAccountRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ResetAccountResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\ResizeRCInstanceDiskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\ResizeRCInstanceDiskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RestartDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RestartDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RestoreDdrTableRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RestoreDdrTableResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RestoreTableRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RestoreTableResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RevokeAccountPrivilegeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RevokeAccountPrivilegeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RevokeOperatorPermissionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RevokeOperatorPermissionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RevokeRCSecurityGroupPermissionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RevokeRCSecurityGroupPermissionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RevokeRCSecurityGroupPermissionShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RunRCInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\RunRCInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\RunRCInstancesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\StartDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\StartDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\StartRCInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\StartRCInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\StartRCInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\StartRCInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\StartRCInstancesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\StopDBInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\StopDBInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\StopRCInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\StopRCInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\StopRCInstancesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\StopRCInstancesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\StopRCInstancesShrinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchDBInstanceHARequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchDBInstanceHAResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchDBInstanceNetTypeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchDBInstanceNetTypeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchDBInstanceVpcRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchDBInstanceVpcResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchOverMajorVersionUpgradeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchOverMajorVersionUpgradeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchReplicationLinkRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\SwitchReplicationLinkResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\SyncRCKeyPairRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\SyncRCKeyPairResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\SyncRCSecurityGroupRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\SyncRCSecurityGroupResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\TagResourcesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\TagResourcesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\TerminateMigrateTaskRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\TerminateMigrateTaskResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\TransformDBInstancePayTypeRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\TransformDBInstancePayTypeResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UnassociateEipAddressWithRCInstanceRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UnassociateEipAddressWithRCInstanceResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UnlockAccountRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UnlockAccountResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UntagResourcesRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UntagResourcesResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpdatePostgresExtensionsRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpdatePostgresExtensionsResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpdateUserBackupFileRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpdateUserBackupFileResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBInstanceEngineVersionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBInstanceEngineVersionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBInstanceKernelVersionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBInstanceKernelVersionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBInstanceMajorVersionPrecheckRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBInstanceMajorVersionPrecheckResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBInstanceMajorVersionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBInstanceMajorVersionResponse;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBProxyInstanceKernelVersionRequest;
use AlibabaCloud\SDK\Rds\V20140815\Models\UpgradeDBProxyInstanceKernelVersionResponse;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;
use Darabonba\OpenApi\Utils;

class Rds extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap = [
            'cn-qingdao' => 'rds.aliyuncs.com',
            'cn-beijing' => 'rds.aliyuncs.com',
            'cn-hangzhou' => 'rds.aliyuncs.com',
            'cn-shanghai' => 'rds.aliyuncs.com',
            'cn-shenzhen' => 'rds.aliyuncs.com',
            'cn-heyuan' => 'rds.aliyuncs.com',
            'cn-hongkong' => 'rds.aliyuncs.com',
            'ap-southeast-1' => 'rds.aliyuncs.com',
            'us-west-1' => 'rds.aliyuncs.com',
            'us-east-1' => 'rds.aliyuncs.com',
            'cn-shanghai-finance-1' => 'rds.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'rds.aliyuncs.com',
            'cn-north-2-gov-1' => 'rds.aliyuncs.com',
            'ap-northeast-2-pop' => 'rds.aliyuncs.com',
            'cn-beijing-finance-1' => 'rds.aliyuncs.com',
            'cn-beijing-finance-pop' => 'rds.aliyuncs.com',
            'cn-beijing-gov-1' => 'rds.aliyuncs.com',
            'cn-beijing-nu16-b01' => 'rds.aliyuncs.com',
            'cn-edge-1' => 'rds.aliyuncs.com',
            'cn-fujian' => 'rds.aliyuncs.com',
            'cn-haidian-cm12-c01' => 'rds.aliyuncs.com',
            'cn-hangzhou-bj-b01' => 'rds.aliyuncs.com',
            'cn-hangzhou-finance' => 'rds-vpc.cn-hangzhou-finance.aliyuncs.com',
            'cn-hangzhou-internal-prod-1' => 'rds.aliyuncs.com',
            'cn-hangzhou-internal-test-1' => 'rds.aliyuncs.com',
            'cn-hangzhou-internal-test-2' => 'rds.aliyuncs.com',
            'cn-hangzhou-internal-test-3' => 'rds.aliyuncs.com',
            'cn-hangzhou-test-306' => 'rds.aliyuncs.com',
            'cn-hongkong-finance-pop' => 'rds.aliyuncs.com',
            'cn-qingdao-nebula' => 'rds.aliyuncs.com',
            'cn-shanghai-et15-b01' => 'rds.aliyuncs.com',
            'cn-shanghai-et2-b01' => 'rds.aliyuncs.com',
            'cn-shanghai-inner' => 'rds.aliyuncs.com',
            'cn-shanghai-internal-test-1' => 'rds.aliyuncs.com',
            'cn-shenzhen-inner' => 'rds.aliyuncs.com',
            'cn-shenzhen-st4-d01' => 'rds.aliyuncs.com',
            'cn-shenzhen-su18-b01' => 'rds.aliyuncs.com',
            'cn-wuhan' => 'rds.aliyuncs.com',
            'cn-yushanfang' => 'rds.aliyuncs.com',
            'cn-zhangbei' => 'rds.aliyuncs.com',
            'cn-zhangbei-na61-b01' => 'rds.aliyuncs.com',
            'cn-zhangjiakou-na62-a01' => 'rds.aliyuncs.com',
            'cn-zhengzhou-nebula-1' => 'rds.aliyuncs.com',
            'eu-west-1-oxs' => 'rds.aliyuncs.com',
            'rus-west-1-pop' => 'rds.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('rds', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (null !== $endpoint) {
            return $endpoint;
        }

        if (null !== $endpointMap && null !== @$endpointMap[$regionId]) {
            return @$endpointMap[$regionId];
        }

        return Utils::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * Switches workloads over from the source PostgreSQL instance to the destination ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the cloud migration feature](https://help.aliyun.com/document_detail/365562.html)
     *
     * @param request - ActivateMigrationTargetInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ActivateMigrationTargetInstanceResponse
     *
     * @param ActivateMigrationTargetInstanceRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ActivateMigrationTargetInstanceResponse
     */
    public function activateMigrationTargetInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->forceSwitch) {
            @$query['ForceSwitch'] = $request->forceSwitch;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        if (null !== $request->switchTimeMode) {
            @$query['SwitchTimeMode'] = $request->switchTimeMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ActivateMigrationTargetInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ActivateMigrationTargetInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Switches workloads over from the source PostgreSQL instance to the destination ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the cloud migration feature](https://help.aliyun.com/document_detail/365562.html)
     *
     * @param request - ActivateMigrationTargetInstanceRequest
     *
     * @returns ActivateMigrationTargetInstanceResponse
     *
     * @param ActivateMigrationTargetInstanceRequest $request
     *
     * @return ActivateMigrationTargetInstanceResponse
     */
    public function activateMigrationTargetInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->activateMigrationTargetInstanceWithOptions($request, $runtime);
    }

    /**
     * Adds tags to an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Usage notes
     * *   Each tag consists of a tag key and a tag value. The tag key is required, and the tag value is optional.
     * *   The tag key and tag value cannot start with aliyun.
     * *   The tag key and tag value are not case-sensitive.
     * *   The maximum length of a tag key is 64 characters, and the maximum length of a tag value is 128 characters.
     * *   A maximum of 10 tags can be added to each instance. Each tag that is added to the same instance must have a unique tag key. If you add a new tag to the instance and the key of the new tag is the same as that of an existing tag, the new tag overwrites the existing tag.
     *
     * @param request - AddTagsToResourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddTagsToResourceResponse
     *
     * @param AddTagsToResourceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return AddTagsToResourceResponse
     */
    public function addTagsToResourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->proxyId) {
            @$query['proxyId'] = $request->proxyId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddTagsToResource',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddTagsToResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds tags to an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Usage notes
     * *   Each tag consists of a tag key and a tag value. The tag key is required, and the tag value is optional.
     * *   The tag key and tag value cannot start with aliyun.
     * *   The tag key and tag value are not case-sensitive.
     * *   The maximum length of a tag key is 64 characters, and the maximum length of a tag value is 128 characters.
     * *   A maximum of 10 tags can be added to each instance. Each tag that is added to the same instance must have a unique tag key. If you add a new tag to the instance and the key of the new tag is the same as that of an existing tag, the new tag overwrites the existing tag.
     *
     * @param request - AddTagsToResourceRequest
     *
     * @returns AddTagsToResourceResponse
     *
     * @param AddTagsToResourceRequest $request
     *
     * @return AddTagsToResourceResponse
     */
    public function addTagsToResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addTagsToResourceWithOptions($request, $runtime);
    }

    /**
     * Apply for a public endpoint for an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Apply for a public endpoint for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/26128.html)
     * *   [Apply for a public endpoint for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/97738.html)
     * *   [Apply for a public endpoint for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/97736.html)
     * *   [Apply for a public endpoint for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97740.html)
     *
     * @param request - AllocateInstancePublicConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AllocateInstancePublicConnectionResponse
     *
     * @param AllocateInstancePublicConnectionRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return AllocateInstancePublicConnectionResponse
     */
    public function allocateInstancePublicConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->babelfishPort) {
            @$query['BabelfishPort'] = $request->babelfishPort;
        }

        if (null !== $request->connectionStringPrefix) {
            @$query['ConnectionStringPrefix'] = $request->connectionStringPrefix;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->generalGroupName) {
            @$query['GeneralGroupName'] = $request->generalGroupName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->PGBouncerPort) {
            @$query['PGBouncerPort'] = $request->PGBouncerPort;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AllocateInstancePublicConnection',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AllocateInstancePublicConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Apply for a public endpoint for an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Apply for a public endpoint for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/26128.html)
     * *   [Apply for a public endpoint for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/97738.html)
     * *   [Apply for a public endpoint for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/97736.html)
     * *   [Apply for a public endpoint for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97740.html)
     *
     * @param request - AllocateInstancePublicConnectionRequest
     *
     * @returns AllocateInstancePublicConnectionResponse
     *
     * @param AllocateInstancePublicConnectionRequest $request
     *
     * @return AllocateInstancePublicConnectionResponse
     */
    public function allocateInstancePublicConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateInstancePublicConnectionWithOptions($request, $runtime);
    }

    /**
     * Applies for a read-only routing endpoint for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Feature description
     * If read-only instances are attached to a primary ApsaraDB RDS for SQL Server instance, you can call this operation to apply for a unified read-only routing endpoint for the primary instance. After you apply for a read-only routing endpoint for a primary instance, the existing endpoints of the primary instance and its read-only instances remain valid. In addition, you can still apply for internal and public endpoints.
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
     * *   The instance is in the Running state.
     * *   Read-only instances are attached to the primary instance.
     * *   The instance does not have an ongoing Data Transmission Service (DTS) migration task.
     * *   The instance runs one of the following database versions and RDS editions:
     *     *   SQL Server on RDS Cluster Edition
     *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
     *     *   MySQL 5.6
     *
     * @param request - AllocateReadWriteSplittingConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AllocateReadWriteSplittingConnectionResponse
     *
     * @param AllocateReadWriteSplittingConnectionRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return AllocateReadWriteSplittingConnectionResponse
     */
    public function allocateReadWriteSplittingConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->connectionStringPrefix) {
            @$query['ConnectionStringPrefix'] = $request->connectionStringPrefix;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->distributionType) {
            @$query['DistributionType'] = $request->distributionType;
        }

        if (null !== $request->maxDelayTime) {
            @$query['MaxDelayTime'] = $request->maxDelayTime;
        }

        if (null !== $request->netType) {
            @$query['NetType'] = $request->netType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AllocateReadWriteSplittingConnection',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AllocateReadWriteSplittingConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Applies for a read-only routing endpoint for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Feature description
     * If read-only instances are attached to a primary ApsaraDB RDS for SQL Server instance, you can call this operation to apply for a unified read-only routing endpoint for the primary instance. After you apply for a read-only routing endpoint for a primary instance, the existing endpoints of the primary instance and its read-only instances remain valid. In addition, you can still apply for internal and public endpoints.
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
     * *   The instance is in the Running state.
     * *   Read-only instances are attached to the primary instance.
     * *   The instance does not have an ongoing Data Transmission Service (DTS) migration task.
     * *   The instance runs one of the following database versions and RDS editions:
     *     *   SQL Server on RDS Cluster Edition
     *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
     *     *   MySQL 5.6
     *
     * @param request - AllocateReadWriteSplittingConnectionRequest
     *
     * @returns AllocateReadWriteSplittingConnectionResponse
     *
     * @param AllocateReadWriteSplittingConnectionRequest $request
     *
     * @return AllocateReadWriteSplittingConnectionResponse
     */
    public function allocateReadWriteSplittingConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->allocateReadWriteSplittingConnectionWithOptions($request, $runtime);
    }

    /**
     * Associates an elastic IP address (EIP) with an RDS Custom for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Introduction to ApsaraDB RDS Custom](https://help.aliyun.com/document_detail/2864363.html)
     * ### [](#)Precautions
     * If the RDS Custom instance uses a public IP address, the public IP address is automatically released after you associate an EIP with the instance.
     *
     * @param request - AssociateEipAddressWithRCInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AssociateEipAddressWithRCInstanceResponse
     *
     * @param AssociateEipAddressWithRCInstanceRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return AssociateEipAddressWithRCInstanceResponse
     */
    public function associateEipAddressWithRCInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocationId) {
            @$query['AllocationId'] = $request->allocationId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AssociateEipAddressWithRCInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AssociateEipAddressWithRCInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates an elastic IP address (EIP) with an RDS Custom for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Introduction to ApsaraDB RDS Custom](https://help.aliyun.com/document_detail/2864363.html)
     * ### [](#)Precautions
     * If the RDS Custom instance uses a public IP address, the public IP address is automatically released after you associate an EIP with the instance.
     *
     * @param request - AssociateEipAddressWithRCInstanceRequest
     *
     * @returns AssociateEipAddressWithRCInstanceResponse
     *
     * @param AssociateEipAddressWithRCInstanceRequest $request
     *
     * @return AssociateEipAddressWithRCInstanceResponse
     */
    public function associateEipAddressWithRCInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->associateEipAddressWithRCInstanceWithOptions($request, $runtime);
    }

    /**
     * Attaches a pay-as-you-go data disk or a system disk to an RDS Custom instance. The instance and the disk must reside in the same zone.
     *
     * @param request - AttachRCDiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachRCDiskResponse
     *
     * @param AttachRCDiskRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return AttachRCDiskResponse
     */
    public function attachRCDiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->deleteWithInstance) {
            @$query['DeleteWithInstance'] = $request->deleteWithInstance;
        }

        if (null !== $request->diskId) {
            @$query['DiskId'] = $request->diskId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachRCDisk',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachRCDiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Attaches a pay-as-you-go data disk or a system disk to an RDS Custom instance. The instance and the disk must reside in the same zone.
     *
     * @param request - AttachRCDiskRequest
     *
     * @returns AttachRCDiskResponse
     *
     * @param AttachRCDiskRequest $request
     *
     * @return AttachRCDiskResponse
     */
    public function attachRCDisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachRCDiskWithOptions($request, $runtime);
    }

    /**
     * Adds RDS Custom nodes to a Container Service for Kubernetes (ACK) cluster.
     *
     * @param tmpReq - AttachRCInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachRCInstancesResponse
     *
     * @param AttachRCInstancesRequest $tmpReq
     * @param RuntimeOptions           $runtime
     *
     * @return AttachRCInstancesResponse
     */
    public function attachRCInstancesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new AttachRCInstancesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->instanceIds) {
            $request->instanceIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->instanceIds, 'InstanceIds', 'simple');
        }

        $query = [];
        if (null !== $request->instanceIdsShrink) {
            @$query['InstanceIds'] = $request->instanceIdsShrink;
        }

        if (null !== $request->keyPair) {
            @$query['KeyPair'] = $request->keyPair;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachRCInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachRCInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds RDS Custom nodes to a Container Service for Kubernetes (ACK) cluster.
     *
     * @param request - AttachRCInstancesRequest
     *
     * @returns AttachRCInstancesResponse
     *
     * @param AttachRCInstancesRequest $request
     *
     * @return AttachRCInstancesResponse
     */
    public function attachRCInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachRCInstancesWithOptions($request, $runtime);
    }

    /**
     * Associates a whitelist template with an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - AttachWhitelistTemplateToInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AttachWhitelistTemplateToInstanceResponse
     *
     * @param AttachWhitelistTemplateToInstanceRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return AttachWhitelistTemplateToInstanceResponse
     */
    public function attachWhitelistTemplateToInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->insName) {
            @$query['InsName'] = $request->insName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AttachWhitelistTemplateToInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AttachWhitelistTemplateToInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a whitelist template with an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - AttachWhitelistTemplateToInstanceRequest
     *
     * @returns AttachWhitelistTemplateToInstanceResponse
     *
     * @param AttachWhitelistTemplateToInstanceRequest $request
     *
     * @return AttachWhitelistTemplateToInstanceResponse
     */
    public function attachWhitelistTemplateToInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->attachWhitelistTemplateToInstanceWithOptions($request, $runtime);
    }

    /**
     * 新增RC安全组规则.
     *
     * @param tmpReq - AuthorizeRCSecurityGroupPermissionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AuthorizeRCSecurityGroupPermissionResponse
     *
     * @param AuthorizeRCSecurityGroupPermissionRequest $tmpReq
     * @param RuntimeOptions                            $runtime
     *
     * @return AuthorizeRCSecurityGroupPermissionResponse
     */
    public function authorizeRCSecurityGroupPermissionWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new AuthorizeRCSecurityGroupPermissionShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->securityGroupPermissions) {
            $request->securityGroupPermissionsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->securityGroupPermissions, 'SecurityGroupPermissions', 'json');
        }

        $query = [];
        if (null !== $request->direction) {
            @$query['Direction'] = $request->direction;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        if (null !== $request->securityGroupPermissionsShrink) {
            @$query['SecurityGroupPermissions'] = $request->securityGroupPermissionsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AuthorizeRCSecurityGroupPermission',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AuthorizeRCSecurityGroupPermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 新增RC安全组规则.
     *
     * @param request - AuthorizeRCSecurityGroupPermissionRequest
     *
     * @returns AuthorizeRCSecurityGroupPermissionResponse
     *
     * @param AuthorizeRCSecurityGroupPermissionRequest $request
     *
     * @return AuthorizeRCSecurityGroupPermissionResponse
     */
    public function authorizeRCSecurityGroupPermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->authorizeRCSecurityGroupPermissionWithOptions($request, $runtime);
    }

    /**
     * Queries system-assigned read weights.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Feature description
     * When the [read/write splitting](https://help.aliyun.com/document_detail/51073.html) feature is enabled, this operation is used to calculate system-assigned read weights. For more information about custom read weights, see [DescribeDBInstanceNetInfo](https://help.aliyun.com/document_detail/610423.html).
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   If the instance runs MySQL, the instance uses a shared proxy.
     * *   The instance runs one of the following MySQL versions and RDS editions:
     *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
     *     *   MySQL 5.6
     *     *   SQL Server on RDS Cluster Edition
     *
     * @param request - CalculateDBInstanceWeightRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CalculateDBInstanceWeightResponse
     *
     * @param CalculateDBInstanceWeightRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CalculateDBInstanceWeightResponse
     */
    public function calculateDBInstanceWeightWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CalculateDBInstanceWeight',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CalculateDBInstanceWeightResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries system-assigned read weights.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Feature description
     * When the [read/write splitting](https://help.aliyun.com/document_detail/51073.html) feature is enabled, this operation is used to calculate system-assigned read weights. For more information about custom read weights, see [DescribeDBInstanceNetInfo](https://help.aliyun.com/document_detail/610423.html).
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   If the instance runs MySQL, the instance uses a shared proxy.
     * *   The instance runs one of the following MySQL versions and RDS editions:
     *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
     *     *   MySQL 5.6
     *     *   SQL Server on RDS Cluster Edition
     *
     * @param request - CalculateDBInstanceWeightRequest
     *
     * @returns CalculateDBInstanceWeightResponse
     *
     * @param CalculateDBInstanceWeightRequest $request
     *
     * @return CalculateDBInstanceWeightResponse
     */
    public function calculateDBInstanceWeight($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->calculateDBInstanceWeightWithOptions($request, $runtime);
    }

    /**
     * Cancels O\\&M tasks that are not started.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Scheduled events for ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/104183.html)
     * *   [Scheduled events for ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/104452.html)
     * *   [Scheduled events for ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/104451.html)
     * *   [Scheduled events for ApsaraDB RDS for MariaDB instances](https://help.aliyun.com/document_detail/104454.html)
     * ### [](#)Usage notes
     * Tasks cannot be canceled in the following situations:
     * *   The allowCancel parameter is set to 0.
     * *   The current time is later than the task start time.
     * *   The status of the task is not set to 3. The value 3 specifies that the task is waiting to be executed.
     *
     * @param request - CancelActiveOperationTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CancelActiveOperationTasksResponse
     *
     * @param CancelActiveOperationTasksRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return CancelActiveOperationTasksResponse
     */
    public function cancelActiveOperationTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ids) {
            @$query['Ids'] = $request->ids;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CancelActiveOperationTasks',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CancelActiveOperationTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Cancels O\\&M tasks that are not started.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Scheduled events for ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/104183.html)
     * *   [Scheduled events for ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/104452.html)
     * *   [Scheduled events for ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/104451.html)
     * *   [Scheduled events for ApsaraDB RDS for MariaDB instances](https://help.aliyun.com/document_detail/104454.html)
     * ### [](#)Usage notes
     * Tasks cannot be canceled in the following situations:
     * *   The allowCancel parameter is set to 0.
     * *   The current time is later than the task start time.
     * *   The status of the task is not set to 3. The value 3 specifies that the task is waiting to be executed.
     *
     * @param request - CancelActiveOperationTasksRequest
     *
     * @returns CancelActiveOperationTasksResponse
     *
     * @param CancelActiveOperationTasksRequest $request
     *
     * @return CancelActiveOperationTasksResponse
     */
    public function cancelActiveOperationTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cancelActiveOperationTasksWithOptions($request, $runtime);
    }

    /**
     * Checks whether the username of the account that you want to create on an instance is available.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - CheckAccountNameAvailableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckAccountNameAvailableResponse
     *
     * @param CheckAccountNameAvailableRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CheckAccountNameAvailableResponse
     */
    public function checkAccountNameAvailableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckAccountNameAvailable',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckAccountNameAvailableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether the username of the account that you want to create on an instance is available.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - CheckAccountNameAvailableRequest
     *
     * @returns CheckAccountNameAvailableResponse
     *
     * @param CheckAccountNameAvailableRequest $request
     *
     * @return CheckAccountNameAvailableResponse
     */
    public function checkAccountNameAvailable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkAccountNameAvailableWithOptions($request, $runtime);
    }

    /**
     * Checks permissions that are granted on an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - CheckCloudResourceAuthorizedRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckCloudResourceAuthorizedResponse
     *
     * @param CheckCloudResourceAuthorizedRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CheckCloudResourceAuthorizedResponse
     */
    public function checkCloudResourceAuthorizedWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->targetRegionId) {
            @$query['TargetRegionId'] = $request->targetRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckCloudResourceAuthorized',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckCloudResourceAuthorizedResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks permissions that are granted on an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - CheckCloudResourceAuthorizedRequest
     *
     * @returns CheckCloudResourceAuthorizedResponse
     *
     * @param CheckCloudResourceAuthorizedRequest $request
     *
     * @return CheckCloudResourceAuthorizedResponse
     */
    public function checkCloudResourceAuthorized($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkCloudResourceAuthorizedWithOptions($request, $runtime);
    }

    /**
     * Queries whether an instance can be restored by using a cross-region backup set.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * >  If your ApsaraDB RDS for PostgreSQL instance uses the new architecture and is created after October 10, 2022, this feature is not supported for the RDS instance. For more information, see [[Notice\\] SLR authorization is required to create an ApsaraDB RDS for PostgreSQL instance from October 10, 2022](~~452313~~).
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html) and [Restore the data of an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120875.html)
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html) and [Restore the data of an ApsaraDB RDS for PostgreSQL across regions](https://help.aliyun.com/document_detail/206662.html)
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html) and [Restore the data of an ApsaraDB RDS for SQL Server across regions](https://help.aliyun.com/document_detail/187924.html)
     *
     * @param request - CheckCreateDdrDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckCreateDdrDBInstanceResponse
     *
     * @param CheckCreateDdrDBInstanceRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CheckCreateDdrDBInstanceResponse
     */
    public function checkCreateDdrDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupSetId) {
            @$query['BackupSetId'] = $request->backupSetId;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreTime) {
            @$query['RestoreTime'] = $request->restoreTime;
        }

        if (null !== $request->restoreType) {
            @$query['RestoreType'] = $request->restoreType;
        }

        if (null !== $request->sourceDBInstanceName) {
            @$query['SourceDBInstanceName'] = $request->sourceDBInstanceName;
        }

        if (null !== $request->sourceRegion) {
            @$query['SourceRegion'] = $request->sourceRegion;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckCreateDdrDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckCreateDdrDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether an instance can be restored by using a cross-region backup set.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * >  If your ApsaraDB RDS for PostgreSQL instance uses the new architecture and is created after October 10, 2022, this feature is not supported for the RDS instance. For more information, see [[Notice\\] SLR authorization is required to create an ApsaraDB RDS for PostgreSQL instance from October 10, 2022](~~452313~~).
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html) and [Restore the data of an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120875.html)
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html) and [Restore the data of an ApsaraDB RDS for PostgreSQL across regions](https://help.aliyun.com/document_detail/206662.html)
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html) and [Restore the data of an ApsaraDB RDS for SQL Server across regions](https://help.aliyun.com/document_detail/187924.html)
     *
     * @param request - CheckCreateDdrDBInstanceRequest
     *
     * @returns CheckCreateDdrDBInstanceResponse
     *
     * @param CheckCreateDdrDBInstanceRequest $request
     *
     * @return CheckCreateDdrDBInstanceResponse
     */
    public function checkCreateDdrDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkCreateDdrDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Checks whether a database name is unique and conforms to the naming conventions on an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - CheckDBNameAvailableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckDBNameAvailableResponse
     *
     * @param CheckDBNameAvailableRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CheckDBNameAvailableResponse
     */
    public function checkDBNameAvailableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckDBNameAvailable',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckDBNameAvailableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether a database name is unique and conforms to the naming conventions on an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - CheckDBNameAvailableRequest
     *
     * @returns CheckDBNameAvailableResponse
     *
     * @param CheckDBNameAvailableRequest $request
     *
     * @return CheckDBNameAvailableResponse
     */
    public function checkDBNameAvailable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkDBNameAvailableWithOptions($request, $runtime);
    }

    /**
     * You can call the CheckInstanceExist operation to query whether an ApsaraDB RDS instance exists.
     *
     * @param request - CheckInstanceExistRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckInstanceExistResponse
     *
     * @param CheckInstanceExistRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CheckInstanceExistResponse
     */
    public function checkInstanceExistWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckInstanceExist',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckInstanceExistResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can call the CheckInstanceExist operation to query whether an ApsaraDB RDS instance exists.
     *
     * @param request - CheckInstanceExistRequest
     *
     * @returns CheckInstanceExistResponse
     *
     * @param CheckInstanceExistRequest $request
     *
     * @return CheckInstanceExistResponse
     */
    public function checkInstanceExist($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkInstanceExistWithOptions($request, $runtime);
    }

    /**
     * Checks whether a service-linked role (SLR) is created.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     *
     * @param request - CheckServiceLinkedRoleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckServiceLinkedRoleResponse
     *
     * @param CheckServiceLinkedRoleRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CheckServiceLinkedRoleResponse
     */
    public function checkServiceLinkedRoleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serviceLinkedRole) {
            @$query['ServiceLinkedRole'] = $request->serviceLinkedRole;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckServiceLinkedRole',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckServiceLinkedRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether a service-linked role (SLR) is created.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     *
     * @param request - CheckServiceLinkedRoleRequest
     *
     * @returns CheckServiceLinkedRoleResponse
     *
     * @param CheckServiceLinkedRoleRequest $request
     *
     * @return CheckServiceLinkedRoleResponse
     */
    public function checkServiceLinkedRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkServiceLinkedRoleWithOptions($request, $runtime);
    }

    /**
     * Restores the data of an original instance to a new instance. The new instance is called a cloned instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Restore data of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96147.html)
     * *   [Restore data of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96776.html)
     * *   [Restore data of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95722.html)
     * *   [Restore data of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97151.html)
     *
     * @param tmpReq - CloneDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CloneDBInstanceResponse
     *
     * @param CloneDBInstanceRequest $tmpReq
     * @param RuntimeOptions         $runtime
     *
     * @return CloneDBInstanceResponse
     */
    public function cloneDBInstanceWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CloneDBInstanceShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->serverlessConfig) {
            $request->serverlessConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->serverlessConfig, 'ServerlessConfig', 'json');
        }

        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->backupType) {
            @$query['BackupType'] = $request->backupType;
        }

        if (null !== $request->bpeEnabled) {
            @$query['BpeEnabled'] = $request->bpeEnabled;
        }

        if (null !== $request->burstingEnabled) {
            @$query['BurstingEnabled'] = $request->burstingEnabled;
        }

        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceDescription) {
            @$query['DBInstanceDescription'] = $request->DBInstanceDescription;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->dbNames) {
            @$query['DbNames'] = $request->dbNames;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->deletionProtection) {
            @$query['DeletionProtection'] = $request->deletionProtection;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->ioAccelerationEnabled) {
            @$query['IoAccelerationEnabled'] = $request->ioAccelerationEnabled;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreTable) {
            @$query['RestoreTable'] = $request->restoreTable;
        }

        if (null !== $request->restoreTime) {
            @$query['RestoreTime'] = $request->restoreTime;
        }

        if (null !== $request->serverlessConfigShrink) {
            @$query['ServerlessConfig'] = $request->serverlessConfigShrink;
        }

        if (null !== $request->tableMeta) {
            @$query['TableMeta'] = $request->tableMeta;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        if (null !== $request->zoneIdSlave1) {
            @$query['ZoneIdSlave1'] = $request->zoneIdSlave1;
        }

        if (null !== $request->zoneIdSlave2) {
            @$query['ZoneIdSlave2'] = $request->zoneIdSlave2;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CloneDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CloneDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restores the data of an original instance to a new instance. The new instance is called a cloned instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Restore data of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96147.html)
     * *   [Restore data of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96776.html)
     * *   [Restore data of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95722.html)
     * *   [Restore data of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97151.html)
     *
     * @param request - CloneDBInstanceRequest
     *
     * @returns CloneDBInstanceResponse
     *
     * @param CloneDBInstanceRequest $request
     *
     * @return CloneDBInstanceResponse
     */
    public function cloneDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cloneDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Replicates a parameter template to the current region or another region.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - CloneParameterGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CloneParameterGroupResponse
     *
     * @param CloneParameterGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CloneParameterGroupResponse
     */
    public function cloneParameterGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->parameterGroupDesc) {
            @$query['ParameterGroupDesc'] = $request->parameterGroupDesc;
        }

        if (null !== $request->parameterGroupId) {
            @$query['ParameterGroupId'] = $request->parameterGroupId;
        }

        if (null !== $request->parameterGroupName) {
            @$query['ParameterGroupName'] = $request->parameterGroupName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->targetRegionId) {
            @$query['TargetRegionId'] = $request->targetRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CloneParameterGroup',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CloneParameterGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Replicates a parameter template to the current region or another region.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - CloneParameterGroupRequest
     *
     * @returns CloneParameterGroupResponse
     *
     * @param CloneParameterGroupRequest $request
     *
     * @return CloneParameterGroupResponse
     */
    public function cloneParameterGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->cloneParameterGroupWithOptions($request, $runtime);
    }

    /**
     * Marks the notifications of an instance within your Alibaba Cloud account as confirmed.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Feature description
     * After you call the [QueryNotify](https://help.aliyun.com/document_detail/610443.html) operation to query notifications for an instance, you can call this operation to mark the notifications as confirmed.
     *
     * @param tmpReq - ConfirmNotifyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ConfirmNotifyResponse
     *
     * @param ConfirmNotifyRequest $tmpReq
     * @param RuntimeOptions       $runtime
     *
     * @return ConfirmNotifyResponse
     */
    public function confirmNotifyWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ConfirmNotifyShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->notifyIdList) {
            $request->notifyIdListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->notifyIdList, 'NotifyIdList', 'json');
        }

        $body = [];
        if (null !== $request->confirmor) {
            @$body['Confirmor'] = $request->confirmor;
        }

        if (null !== $request->notifyIdListShrink) {
            @$body['NotifyIdList'] = $request->notifyIdListShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ConfirmNotify',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ConfirmNotifyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Marks the notifications of an instance within your Alibaba Cloud account as confirmed.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Feature description
     * After you call the [QueryNotify](https://help.aliyun.com/document_detail/610443.html) operation to query notifications for an instance, you can call this operation to mark the notifications as confirmed.
     *
     * @param request - ConfirmNotifyRequest
     *
     * @returns ConfirmNotifyResponse
     *
     * @param ConfirmNotifyRequest $request
     *
     * @return ConfirmNotifyResponse
     */
    public function confirmNotify($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->confirmNotifyWithOptions($request, $runtime);
    }

    /**
     * Replicates the databases of an instance that runs SQL Server 2008 R2 to another instance. This operation is phased out.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - CopyDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CopyDatabaseResponse
     *
     * @param CopyDatabaseRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CopyDatabaseResponse
     */
    public function copyDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->dstDBName) {
            @$query['DstDBName'] = $request->dstDBName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->reserveAccount) {
            @$query['ReserveAccount'] = $request->reserveAccount;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->srcDBName) {
            @$query['SrcDBName'] = $request->srcDBName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CopyDatabase',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CopyDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Replicates the databases of an instance that runs SQL Server 2008 R2 to another instance. This operation is phased out.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - CopyDatabaseRequest
     *
     * @returns CopyDatabaseResponse
     *
     * @param CopyDatabaseRequest $request
     *
     * @return CopyDatabaseResponse
     */
    public function copyDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyDatabaseWithOptions($request, $runtime);
    }

    /**
     * Replicates databases between RDS SQL Server instances.
     *
     * @remarks
     * ### Supported database engines
     * RDS SQL Server
     * ### References
     * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Replicate databases between ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/95702.html)
     *
     * @param request - CopyDatabaseBetweenInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CopyDatabaseBetweenInstancesResponse
     *
     * @param CopyDatabaseBetweenInstancesRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CopyDatabaseBetweenInstancesResponse
     */
    public function copyDatabaseBetweenInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->dbNames) {
            @$query['DbNames'] = $request->dbNames;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreTime) {
            @$query['RestoreTime'] = $request->restoreTime;
        }

        if (null !== $request->syncUserPrivilege) {
            @$query['SyncUserPrivilege'] = $request->syncUserPrivilege;
        }

        if (null !== $request->targetDBInstanceId) {
            @$query['TargetDBInstanceId'] = $request->targetDBInstanceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CopyDatabaseBetweenInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CopyDatabaseBetweenInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Replicates databases between RDS SQL Server instances.
     *
     * @remarks
     * ### Supported database engines
     * RDS SQL Server
     * ### References
     * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Replicate databases between ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/95702.html)
     *
     * @param request - CopyDatabaseBetweenInstancesRequest
     *
     * @returns CopyDatabaseBetweenInstancesResponse
     *
     * @param CopyDatabaseBetweenInstancesRequest $request
     *
     * @return CopyDatabaseBetweenInstancesResponse
     */
    public function copyDatabaseBetweenInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->copyDatabaseBetweenInstancesWithOptions($request, $runtime);
    }

    /**
     * Creates a database account.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * ### References
     * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Create an account on an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96089.html)
     * *   [Create an account on an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96753.html)
     * *   [Create an account on an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95810.html)
     * *   [Create an account on an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97132.html)
     *
     * @param request - CreateAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateAccountResponse
     *
     * @param CreateAccountRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return CreateAccountResponse
     */
    public function createAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountDescription) {
            @$query['AccountDescription'] = $request->accountDescription;
        }

        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->accountPassword) {
            @$query['AccountPassword'] = $request->accountPassword;
        }

        if (null !== $request->accountType) {
            @$query['AccountType'] = $request->accountType;
        }

        if (null !== $request->checkPolicy) {
            @$query['CheckPolicy'] = $request->checkPolicy;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateAccount',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a database account.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * ### References
     * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Create an account on an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96089.html)
     * *   [Create an account on an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96753.html)
     * *   [Create an account on an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95810.html)
     * *   [Create an account on an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97132.html)
     *
     * @param request - CreateAccountRequest
     *
     * @returns CreateAccountResponse
     *
     * @param CreateAccountRequest $request
     *
     * @return CreateAccountResponse
     */
    public function createAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createAccountWithOptions($request, $runtime);
    }

    /**
     * Creates a backup file for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Feature description
     * This operation uses the backup feature of ApsaraDB RDS to create a backup set. You can also call an operation of Database Backup (DBS) to create a backup set. For more information, see [List of operations by function](https://help.aliyun.com/document_detail/2402073.html).
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The instance is in the Running state.
     * *   The instance does not have ongoing backup tasks.
     * *   The number of backup sets that can be created for an instance per day cannot exceed 20.
     * ### [](#)References
     * *   [Use the data backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/378074.html)
     * *   [Use the data backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96772.html)
     * *   [Use the data backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95717.html)
     * *   [Use the data backup feature for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97147.html)
     *
     * @param request - CreateBackupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBackupResponse
     *
     * @param CreateBackupRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CreateBackupResponse
     */
    public function createBackupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupMethod) {
            @$query['BackupMethod'] = $request->backupMethod;
        }

        if (null !== $request->backupStrategy) {
            @$query['BackupStrategy'] = $request->backupStrategy;
        }

        if (null !== $request->backupType) {
            @$query['BackupType'] = $request->backupType;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateBackup',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBackupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a backup file for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Feature description
     * This operation uses the backup feature of ApsaraDB RDS to create a backup set. You can also call an operation of Database Backup (DBS) to create a backup set. For more information, see [List of operations by function](https://help.aliyun.com/document_detail/2402073.html).
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The instance is in the Running state.
     * *   The instance does not have ongoing backup tasks.
     * *   The number of backup sets that can be created for an instance per day cannot exceed 20.
     * ### [](#)References
     * *   [Use the data backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/378074.html)
     * *   [Use the data backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96772.html)
     * *   [Use the data backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95717.html)
     * *   [Use the data backup feature for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97147.html)
     *
     * @param request - CreateBackupRequest
     *
     * @returns CreateBackupResponse
     *
     * @param CreateBackupRequest $request
     *
     * @return CreateBackupResponse
     */
    public function createBackup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBackupWithOptions($request, $runtime);
    }

    /**
     * Creates an assessment task for cloud migration to an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the cloud migration feature](https://help.aliyun.com/document_detail/365562.html)
     *
     * @param request - CreateCloudMigrationPrecheckTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCloudMigrationPrecheckTaskResponse
     *
     * @param CreateCloudMigrationPrecheckTaskRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return CreateCloudMigrationPrecheckTaskResponse
     */
    public function createCloudMigrationPrecheckTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceAccount) {
            @$query['SourceAccount'] = $request->sourceAccount;
        }

        if (null !== $request->sourceCategory) {
            @$query['SourceCategory'] = $request->sourceCategory;
        }

        if (null !== $request->sourceIpAddress) {
            @$query['SourceIpAddress'] = $request->sourceIpAddress;
        }

        if (null !== $request->sourcePassword) {
            @$query['SourcePassword'] = $request->sourcePassword;
        }

        if (null !== $request->sourcePort) {
            @$query['SourcePort'] = $request->sourcePort;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCloudMigrationPrecheckTask',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCloudMigrationPrecheckTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an assessment task for cloud migration to an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the cloud migration feature](https://help.aliyun.com/document_detail/365562.html)
     *
     * @param request - CreateCloudMigrationPrecheckTaskRequest
     *
     * @returns CreateCloudMigrationPrecheckTaskResponse
     *
     * @param CreateCloudMigrationPrecheckTaskRequest $request
     *
     * @return CreateCloudMigrationPrecheckTaskResponse
     */
    public function createCloudMigrationPrecheckTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCloudMigrationPrecheckTaskWithOptions($request, $runtime);
    }

    /**
     * Creates a cloud migration task for an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the cloud migration feature](https://help.aliyun.com/document_detail/365562.html)
     *
     * @param request - CreateCloudMigrationTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateCloudMigrationTaskResponse
     *
     * @param CreateCloudMigrationTaskRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateCloudMigrationTaskResponse
     */
    public function createCloudMigrationTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceAccount) {
            @$query['SourceAccount'] = $request->sourceAccount;
        }

        if (null !== $request->sourceCategory) {
            @$query['SourceCategory'] = $request->sourceCategory;
        }

        if (null !== $request->sourceIpAddress) {
            @$query['SourceIpAddress'] = $request->sourceIpAddress;
        }

        if (null !== $request->sourcePassword) {
            @$query['SourcePassword'] = $request->sourcePassword;
        }

        if (null !== $request->sourcePort) {
            @$query['SourcePort'] = $request->sourcePort;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateCloudMigrationTask',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateCloudMigrationTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a cloud migration task for an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the cloud migration feature](https://help.aliyun.com/document_detail/365562.html)
     *
     * @param request - CreateCloudMigrationTaskRequest
     *
     * @returns CreateCloudMigrationTaskResponse
     *
     * @param CreateCloudMigrationTaskRequest $request
     *
     * @return CreateCloudMigrationTaskResponse
     */
    public function createCloudMigrationTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createCloudMigrationTaskWithOptions($request, $runtime);
    }

    /**
     * Creates an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the related topics. If an error message appears when you call this operation, you can search for the error message to view the cause of the error.
     * *   [Create an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/148036.html).
     * *   [Create a serverless ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/412231.html).
     * *   [Create an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/148038.html)
     * *   [Create a serverless ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/607753.html)
     * *   [Create an ApsaraDB RDS for PostgreSQL instance for which Babelfish is enabled](https://help.aliyun.com/document_detail/428615.html)
     * *   [Create an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/148037.html)
     * *   [Create a serverless ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/603465.html)
     * *   [Create an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/148040.html)
     *
     * @param tmpReq - CreateDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDBInstanceResponse
     *
     * @param CreateDBInstanceRequest $tmpReq
     * @param RuntimeOptions          $runtime
     *
     * @return CreateDBInstanceResponse
     */
    public function createDBInstanceWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateDBInstanceShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->serverlessConfig) {
            $request->serverlessConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->serverlessConfig, 'ServerlessConfig', 'json');
        }

        $query = [];
        if (null !== $request->amount) {
            @$query['Amount'] = $request->amount;
        }

        if (null !== $request->autoCreateProxy) {
            @$query['AutoCreateProxy'] = $request->autoCreateProxy;
        }

        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->babelfishConfig) {
            @$query['BabelfishConfig'] = $request->babelfishConfig;
        }

        if (null !== $request->bpeEnabled) {
            @$query['BpeEnabled'] = $request->bpeEnabled;
        }

        if (null !== $request->burstingEnabled) {
            @$query['BurstingEnabled'] = $request->burstingEnabled;
        }

        if (null !== $request->businessInfo) {
            @$query['BusinessInfo'] = $request->businessInfo;
        }

        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->coldDataEnabled) {
            @$query['ColdDataEnabled'] = $request->coldDataEnabled;
        }

        if (null !== $request->connectionMode) {
            @$query['ConnectionMode'] = $request->connectionMode;
        }

        if (null !== $request->connectionString) {
            @$query['ConnectionString'] = $request->connectionString;
        }

        if (null !== $request->createStrategy) {
            @$query['CreateStrategy'] = $request->createStrategy;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceDescription) {
            @$query['DBInstanceDescription'] = $request->DBInstanceDescription;
        }

        if (null !== $request->DBInstanceNetType) {
            @$query['DBInstanceNetType'] = $request->DBInstanceNetType;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->DBIsIgnoreCase) {
            @$query['DBIsIgnoreCase'] = $request->DBIsIgnoreCase;
        }

        if (null !== $request->DBParamGroupId) {
            @$query['DBParamGroupId'] = $request->DBParamGroupId;
        }

        if (null !== $request->DBTimeZone) {
            @$query['DBTimeZone'] = $request->DBTimeZone;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->deletionProtection) {
            @$query['DeletionProtection'] = $request->deletionProtection;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->encryptionKey) {
            @$query['EncryptionKey'] = $request->encryptionKey;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->ioAccelerationEnabled) {
            @$query['IoAccelerationEnabled'] = $request->ioAccelerationEnabled;
        }

        if (null !== $request->optimizedWrites) {
            @$query['OptimizedWrites'] = $request->optimizedWrites;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->promotionCode) {
            @$query['PromotionCode'] = $request->promotionCode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->roleARN) {
            @$query['RoleARN'] = $request->roleARN;
        }

        if (null !== $request->securityIPList) {
            @$query['SecurityIPList'] = $request->securityIPList;
        }

        if (null !== $request->serverlessConfigShrink) {
            @$query['ServerlessConfig'] = $request->serverlessConfigShrink;
        }

        if (null !== $request->storageAutoScale) {
            @$query['StorageAutoScale'] = $request->storageAutoScale;
        }

        if (null !== $request->storageThreshold) {
            @$query['StorageThreshold'] = $request->storageThreshold;
        }

        if (null !== $request->storageUpperBound) {
            @$query['StorageUpperBound'] = $request->storageUpperBound;
        }

        if (null !== $request->systemDBCharset) {
            @$query['SystemDBCharset'] = $request->systemDBCharset;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->targetDedicatedHostIdForLog) {
            @$query['TargetDedicatedHostIdForLog'] = $request->targetDedicatedHostIdForLog;
        }

        if (null !== $request->targetDedicatedHostIdForMaster) {
            @$query['TargetDedicatedHostIdForMaster'] = $request->targetDedicatedHostIdForMaster;
        }

        if (null !== $request->targetDedicatedHostIdForSlave) {
            @$query['TargetDedicatedHostIdForSlave'] = $request->targetDedicatedHostIdForSlave;
        }

        if (null !== $request->targetMinorVersion) {
            @$query['TargetMinorVersion'] = $request->targetMinorVersion;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        if (null !== $request->userBackupId) {
            @$query['UserBackupId'] = $request->userBackupId;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->whitelistTemplateList) {
            @$query['WhitelistTemplateList'] = $request->whitelistTemplateList;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        if (null !== $request->zoneIdSlave1) {
            @$query['ZoneIdSlave1'] = $request->zoneIdSlave1;
        }

        if (null !== $request->zoneIdSlave2) {
            @$query['ZoneIdSlave2'] = $request->zoneIdSlave2;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the related topics. If an error message appears when you call this operation, you can search for the error message to view the cause of the error.
     * *   [Create an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/148036.html).
     * *   [Create a serverless ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/412231.html).
     * *   [Create an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/148038.html)
     * *   [Create a serverless ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/607753.html)
     * *   [Create an ApsaraDB RDS for PostgreSQL instance for which Babelfish is enabled](https://help.aliyun.com/document_detail/428615.html)
     * *   [Create an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/148037.html)
     * *   [Create a serverless ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/603465.html)
     * *   [Create an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/148040.html)
     *
     * @param request - CreateDBInstanceRequest
     *
     * @returns CreateDBInstanceResponse
     *
     * @param CreateDBInstanceRequest $request
     *
     * @return CreateDBInstanceResponse
     */
    public function createDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Creates an endpoint for an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Create a read-only endpoint for a cluster](https://help.aliyun.com/document_detail/464132.html)
     *
     * @param tmpReq - CreateDBInstanceEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDBInstanceEndpointResponse
     *
     * @param CreateDBInstanceEndpointRequest $tmpReq
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateDBInstanceEndpointResponse
     */
    public function createDBInstanceEndpointWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateDBInstanceEndpointShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->nodeItems) {
            $request->nodeItemsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->nodeItems, 'NodeItems', 'json');
        }

        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->connectionStringPrefix) {
            @$query['ConnectionStringPrefix'] = $request->connectionStringPrefix;
        }

        if (null !== $request->DBInstanceEndpointDescription) {
            @$query['DBInstanceEndpointDescription'] = $request->DBInstanceEndpointDescription;
        }

        if (null !== $request->DBInstanceEndpointType) {
            @$query['DBInstanceEndpointType'] = $request->DBInstanceEndpointType;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->nodeItemsShrink) {
            @$query['NodeItems'] = $request->nodeItemsShrink;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDBInstanceEndpoint',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDBInstanceEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an endpoint for an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Create a read-only endpoint for a cluster](https://help.aliyun.com/document_detail/464132.html)
     *
     * @param request - CreateDBInstanceEndpointRequest
     *
     * @returns CreateDBInstanceEndpointResponse
     *
     * @param CreateDBInstanceEndpointRequest $request
     *
     * @return CreateDBInstanceEndpointResponse
     */
    public function createDBInstanceEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDBInstanceEndpointWithOptions($request, $runtime);
    }

    /**
     * Creates a public endpoint for an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * MySQL
     * ### [](#)Precautions
     * *   You can create a public endpoint of an endpoint type only when no public endpoint is created for this endpoint type.
     * *   The node weights and other configurations are the same as those of the internal endpoint of this endpoint type. Each type of endpoint can contain an internal endpoint and a public endpoint.
     *
     * @param request - CreateDBInstanceEndpointAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDBInstanceEndpointAddressResponse
     *
     * @param CreateDBInstanceEndpointAddressRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return CreateDBInstanceEndpointAddressResponse
     */
    public function createDBInstanceEndpointAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->connectionStringPrefix) {
            @$query['ConnectionStringPrefix'] = $request->connectionStringPrefix;
        }

        if (null !== $request->DBInstanceEndpointId) {
            @$query['DBInstanceEndpointId'] = $request->DBInstanceEndpointId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ipType) {
            @$query['IpType'] = $request->ipType;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDBInstanceEndpointAddress',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDBInstanceEndpointAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a public endpoint for an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * MySQL
     * ### [](#)Precautions
     * *   You can create a public endpoint of an endpoint type only when no public endpoint is created for this endpoint type.
     * *   The node weights and other configurations are the same as those of the internal endpoint of this endpoint type. Each type of endpoint can contain an internal endpoint and a public endpoint.
     *
     * @param request - CreateDBInstanceEndpointAddressRequest
     *
     * @returns CreateDBInstanceEndpointAddressResponse
     *
     * @param CreateDBInstanceEndpointAddressRequest $request
     *
     * @return CreateDBInstanceEndpointAddressResponse
     */
    public function createDBInstanceEndpointAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDBInstanceEndpointAddressWithOptions($request, $runtime);
    }

    /**
     * Rebuilds an instance from the recycle bin.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * ### References
     * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
     * *   [Manage ApsaraDB RDS for MySQL instances in the recycle bin](https://help.aliyun.com/document_detail/96065.html)
     * *   [Manage ApsaraDB RDS for PostgreSQL instances in the recycle bin](https://help.aliyun.com/document_detail/96752.html)
     * *   [Manage ApsaraDB RDS for SQL Server instances in the recycle bin](https://help.aliyun.com/document_detail/95669.html)
     * *   [Manage ApsaraDB RDS for MariaDB instances in the recycle bin](https://help.aliyun.com/document_detail/97131.html)
     *
     * @param request - CreateDBInstanceForRebuildRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDBInstanceForRebuildResponse
     *
     * @param CreateDBInstanceForRebuildRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return CreateDBInstanceForRebuildResponse
     */
    public function createDBInstanceForRebuildWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceDescription) {
            @$query['DBInstanceDescription'] = $request->DBInstanceDescription;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceNetType) {
            @$query['DBInstanceNetType'] = $request->DBInstanceNetType;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityIPList) {
            @$query['SecurityIPList'] = $request->securityIPList;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        if (null !== $request->zoneIdSlave1) {
            @$query['ZoneIdSlave1'] = $request->zoneIdSlave1;
        }

        if (null !== $request->zoneIdSlave2) {
            @$query['ZoneIdSlave2'] = $request->zoneIdSlave2;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDBInstanceForRebuild',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDBInstanceForRebuildResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Rebuilds an instance from the recycle bin.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * ### References
     * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
     * *   [Manage ApsaraDB RDS for MySQL instances in the recycle bin](https://help.aliyun.com/document_detail/96065.html)
     * *   [Manage ApsaraDB RDS for PostgreSQL instances in the recycle bin](https://help.aliyun.com/document_detail/96752.html)
     * *   [Manage ApsaraDB RDS for SQL Server instances in the recycle bin](https://help.aliyun.com/document_detail/95669.html)
     * *   [Manage ApsaraDB RDS for MariaDB instances in the recycle bin](https://help.aliyun.com/document_detail/97131.html)
     *
     * @param request - CreateDBInstanceForRebuildRequest
     *
     * @returns CreateDBInstanceForRebuildResponse
     *
     * @param CreateDBInstanceForRebuildRequest $request
     *
     * @return CreateDBInstanceForRebuildResponse
     */
    public function createDBInstanceForRebuild($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDBInstanceForRebuildWithOptions($request, $runtime);
    }

    /**
     * Adds a security group rule to an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Configure security group settings for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - CreateDBInstanceSecurityGroupRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDBInstanceSecurityGroupRuleResponse
     *
     * @param CreateDBInstanceSecurityGroupRuleRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return CreateDBInstanceSecurityGroupRuleResponse
     */
    public function createDBInstanceSecurityGroupRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ipProtocol) {
            @$query['IpProtocol'] = $request->ipProtocol;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->portRange) {
            @$query['PortRange'] = $request->portRange;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceCidrIp) {
            @$query['SourceCidrIp'] = $request->sourceCidrIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDBInstanceSecurityGroupRule',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDBInstanceSecurityGroupRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a security group rule to an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Configure security group settings for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - CreateDBInstanceSecurityGroupRuleRequest
     *
     * @returns CreateDBInstanceSecurityGroupRuleResponse
     *
     * @param CreateDBInstanceSecurityGroupRuleRequest $request
     *
     * @return CreateDBInstanceSecurityGroupRuleResponse
     */
    public function createDBInstanceSecurityGroupRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDBInstanceSecurityGroupRuleWithOptions($request, $runtime);
    }

    /**
     * Adds a node to an ApsaraDB RDS for MySQL or ApsaraDB RDS for PostgreSQL instance that runs RDS Cluster Edition. An RDS instance that runs RDS Cluster Edition is referred to as an RDS cluster.
     *
     * @remarks
     * ### Supported database engines
     * MySQL
     * ### References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Add a node to an ApsaraDB RDS for MySQL cluster](https://help.aliyun.com/document_detail/464129.html)
     *
     * @param tmpReq - CreateDBNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDBNodesResponse
     *
     * @param CreateDBNodesRequest $tmpReq
     * @param RuntimeOptions       $runtime
     *
     * @return CreateDBNodesResponse
     */
    public function createDBNodesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateDBNodesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->DBNode) {
            $request->DBNodeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->DBNode, 'DBNode', 'json');
        }

        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBNodeShrink) {
            @$query['DBNode'] = $request->DBNodeShrink;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDBNodes',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDBNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a node to an ApsaraDB RDS for MySQL or ApsaraDB RDS for PostgreSQL instance that runs RDS Cluster Edition. An RDS instance that runs RDS Cluster Edition is referred to as an RDS cluster.
     *
     * @remarks
     * ### Supported database engines
     * MySQL
     * ### References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Add a node to an ApsaraDB RDS for MySQL cluster](https://help.aliyun.com/document_detail/464129.html)
     *
     * @param request - CreateDBNodesRequest
     *
     * @returns CreateDBNodesResponse
     *
     * @param CreateDBNodesRequest $request
     *
     * @return CreateDBNodesResponse
     */
    public function createDBNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDBNodesWithOptions($request, $runtime);
    }

    /**
     * Creates the endpoint that is used to connect to the dedicated proxy of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/184921.html)
     * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418274.html)
     *
     * @param request - CreateDBProxyEndpointAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDBProxyEndpointAddressResponse
     *
     * @param CreateDBProxyEndpointAddressRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CreateDBProxyEndpointAddressResponse
     */
    public function createDBProxyEndpointAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->connectionStringPrefix) {
            @$query['ConnectionStringPrefix'] = $request->connectionStringPrefix;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyConnectStringNetType) {
            @$query['DBProxyConnectStringNetType'] = $request->DBProxyConnectStringNetType;
        }

        if (null !== $request->DBProxyEndpointId) {
            @$query['DBProxyEndpointId'] = $request->DBProxyEndpointId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->DBProxyNewConnectStringPort) {
            @$query['DBProxyNewConnectStringPort'] = $request->DBProxyNewConnectStringPort;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDBProxyEndpointAddress',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDBProxyEndpointAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates the endpoint that is used to connect to the dedicated proxy of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/184921.html)
     * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418274.html)
     *
     * @param request - CreateDBProxyEndpointAddressRequest
     *
     * @returns CreateDBProxyEndpointAddressResponse
     *
     * @param CreateDBProxyEndpointAddressRequest $request
     *
     * @return CreateDBProxyEndpointAddressResponse
     */
    public function createDBProxyEndpointAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDBProxyEndpointAddressWithOptions($request, $runtime);
    }

    /**
     * Creates a database in an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Create a database in an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96105.html)
     * *   [Create a database in an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96758.html)
     * *   [Create a database in an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95698.html)
     * *   [Create a database in an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97136.html)
     *
     * @param request - CreateDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDatabaseResponse
     *
     * @param CreateDatabaseRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateDatabaseResponse
     */
    public function createDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->characterSetName) {
            @$query['CharacterSetName'] = $request->characterSetName;
        }

        if (null !== $request->DBDescription) {
            @$query['DBDescription'] = $request->DBDescription;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDatabase',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a database in an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Create a database in an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96105.html)
     * *   [Create a database in an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96758.html)
     * *   [Create a database in an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95698.html)
     * *   [Create a database in an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97136.html)
     *
     * @param request - CreateDatabaseRequest
     *
     * @returns CreateDatabaseResponse
     *
     * @param CreateDatabaseRequest $request
     *
     * @return CreateDatabaseResponse
     */
    public function createDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDatabaseWithOptions($request, $runtime);
    }

    /**
     * Restores data to a new instance across regions.
     *
     * @remarks
     * >  Before restoration, you can call the CheckCreateDdrDBInstance operation to check whether a cross-region backup set can be used for cross-region restoration.
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - CreateDdrInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDdrInstanceResponse
     *
     * @param CreateDdrInstanceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateDdrInstanceResponse
     */
    public function createDdrInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupSetId) {
            @$query['BackupSetId'] = $request->backupSetId;
        }

        if (null !== $request->backupSetRegion) {
            @$query['BackupSetRegion'] = $request->backupSetRegion;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->connectionMode) {
            @$query['ConnectionMode'] = $request->connectionMode;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceDescription) {
            @$query['DBInstanceDescription'] = $request->DBInstanceDescription;
        }

        if (null !== $request->DBInstanceNetType) {
            @$query['DBInstanceNetType'] = $request->DBInstanceNetType;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->encryptionKey) {
            @$query['EncryptionKey'] = $request->encryptionKey;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreTime) {
            @$query['RestoreTime'] = $request->restoreTime;
        }

        if (null !== $request->restoreType) {
            @$query['RestoreType'] = $request->restoreType;
        }

        if (null !== $request->roleARN) {
            @$query['RoleARN'] = $request->roleARN;
        }

        if (null !== $request->securityIPList) {
            @$query['SecurityIPList'] = $request->securityIPList;
        }

        if (null !== $request->sourceDBInstanceName) {
            @$query['SourceDBInstanceName'] = $request->sourceDBInstanceName;
        }

        if (null !== $request->sourceRegion) {
            @$query['SourceRegion'] = $request->sourceRegion;
        }

        if (null !== $request->systemDBCharset) {
            @$query['SystemDBCharset'] = $request->systemDBCharset;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDdrInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDdrInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restores data to a new instance across regions.
     *
     * @remarks
     * >  Before restoration, you can call the CheckCreateDdrDBInstance operation to check whether a cross-region backup set can be used for cross-region restoration.
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - CreateDdrInstanceRequest
     *
     * @returns CreateDdrInstanceResponse
     *
     * @param CreateDdrInstanceRequest $request
     *
     * @return CreateDdrInstanceResponse
     */
    public function createDdrInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDdrInstanceWithOptions($request, $runtime);
    }

    /**
     * Creates an ApsaraDB RDS global active database cluster.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   MySQL
     * <props="china">
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Create and release an ApsaraDB RDS global active database cluster](https://help.aliyun.com/document_detail/328592.html)
     *
     * @param request - CreateGADInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateGADInstanceResponse
     *
     * @param CreateGADInstanceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateGADInstanceResponse
     */
    public function createGADInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->centralDBInstanceId) {
            @$query['CentralDBInstanceId'] = $request->centralDBInstanceId;
        }

        if (null !== $request->centralRdsDtsAdminAccount) {
            @$query['CentralRdsDtsAdminAccount'] = $request->centralRdsDtsAdminAccount;
        }

        if (null !== $request->centralRdsDtsAdminPassword) {
            @$query['CentralRdsDtsAdminPassword'] = $request->centralRdsDtsAdminPassword;
        }

        if (null !== $request->centralRegionId) {
            @$query['CentralRegionId'] = $request->centralRegionId;
        }

        if (null !== $request->DBList) {
            @$query['DBList'] = $request->DBList;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->unitNode) {
            @$query['UnitNode'] = $request->unitNode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateGADInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateGADInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an ApsaraDB RDS global active database cluster.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   MySQL
     * <props="china">
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Create and release an ApsaraDB RDS global active database cluster](https://help.aliyun.com/document_detail/328592.html)
     *
     * @param request - CreateGADInstanceRequest
     *
     * @returns CreateGADInstanceResponse
     *
     * @param CreateGADInstanceRequest $request
     *
     * @return CreateGADInstanceResponse
     */
    public function createGADInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createGADInstanceWithOptions($request, $runtime);
    }

    /**
     * Adds nodes to an ApsaraDB RDS global active database cluster.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Add or remove unit nodes](https://help.aliyun.com/document_detail/331851.html)
     *
     * @param request - CreateGadInstanceMemberRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateGadInstanceMemberResponse
     *
     * @param CreateGadInstanceMemberRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateGadInstanceMemberResponse
     */
    public function createGadInstanceMemberWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->centralDBInstanceId) {
            @$query['CentralDBInstanceId'] = $request->centralDBInstanceId;
        }

        if (null !== $request->centralRdsDtsAdminAccount) {
            @$query['CentralRdsDtsAdminAccount'] = $request->centralRdsDtsAdminAccount;
        }

        if (null !== $request->centralRdsDtsAdminPassword) {
            @$query['CentralRdsDtsAdminPassword'] = $request->centralRdsDtsAdminPassword;
        }

        if (null !== $request->centralRegionId) {
            @$query['CentralRegionId'] = $request->centralRegionId;
        }

        if (null !== $request->DBList) {
            @$query['DBList'] = $request->DBList;
        }

        if (null !== $request->gadInstanceId) {
            @$query['GadInstanceId'] = $request->gadInstanceId;
        }

        if (null !== $request->unitNode) {
            @$query['UnitNode'] = $request->unitNode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateGadInstanceMember',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateGadInstanceMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds nodes to an ApsaraDB RDS global active database cluster.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Add or remove unit nodes](https://help.aliyun.com/document_detail/331851.html)
     *
     * @param request - CreateGadInstanceMemberRequest
     *
     * @returns CreateGadInstanceMemberResponse
     *
     * @param CreateGadInstanceMemberRequest $request
     *
     * @return CreateGadInstanceMemberResponse
     */
    public function createGadInstanceMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createGadInstanceMemberWithOptions($request, $runtime);
    }

    /**
     * 创建全密态规则.
     *
     * @param tmpReq - CreateMaskingRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMaskingRulesResponse
     *
     * @param CreateMaskingRulesRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return CreateMaskingRulesResponse
     */
    public function createMaskingRulesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateMaskingRulesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->ruleConfig) {
            $request->ruleConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->ruleConfig, 'RuleConfig', 'json');
        }

        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->defaultAlgo) {
            @$query['DefaultAlgo'] = $request->defaultAlgo;
        }

        if (null !== $request->maskingAlgo) {
            @$query['MaskingAlgo'] = $request->maskingAlgo;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->ruleConfigShrink) {
            @$query['RuleConfig'] = $request->ruleConfigShrink;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateMaskingRules',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMaskingRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 创建全密态规则.
     *
     * @param request - CreateMaskingRulesRequest
     *
     * @returns CreateMaskingRulesResponse
     *
     * @param CreateMaskingRulesRequest $request
     *
     * @return CreateMaskingRulesResponse
     */
    public function createMaskingRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMaskingRulesWithOptions($request, $runtime);
    }

    /**
     * Creates a migration task to restore backup files from an Object Storage Service (OSS) bucket to an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)Limits
     * Data migration across Alibaba Cloud accounts is not supported. For example, backup files in an Object Storage Service (OSS) bucket within Alibaba Cloud Account A cannot be migrated to an ApsaraDB RDS for SQL Server instance within Alibaba Cloud Account B.
     * >  You can migrate backup files from an OSS bucket within Alibaba Cloud Account A to an OSS bucket within Alibaba Cloud Account B. Make sure that the data in the OSS bucket and the RDS instance belong to the same Alibaba Cloud account. Then, you can call this operation to create a migration task. For more information, see [Use Data Online Migration to migrate data between accounts](https://help.aliyun.com/document_detail/342762.html).
     * ### [](#)References
     * >  Before you call this operation, carefully read the following topic. Make sure that you fully understand the prerequisites, preparations, and impacts for calling this operation.
     * [Migrate data from a self-managed SQL Server instance to an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/100019.html)
     *
     * @param request - CreateMigrateTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMigrateTaskResponse
     *
     * @param CreateMigrateTaskRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateMigrateTaskResponse
     */
    public function createMigrateTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupMode) {
            @$query['BackupMode'] = $request->backupMode;
        }

        if (null !== $request->checkDBMode) {
            @$query['CheckDBMode'] = $request->checkDBMode;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->isOnlineDB) {
            @$query['IsOnlineDB'] = $request->isOnlineDB;
        }

        if (null !== $request->migrateTaskId) {
            @$query['MigrateTaskId'] = $request->migrateTaskId;
        }

        if (null !== $request->OSSUrls) {
            @$query['OSSUrls'] = $request->OSSUrls;
        }

        if (null !== $request->ossObjectPositions) {
            @$query['OssObjectPositions'] = $request->ossObjectPositions;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateMigrateTask',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMigrateTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a migration task to restore backup files from an Object Storage Service (OSS) bucket to an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)Limits
     * Data migration across Alibaba Cloud accounts is not supported. For example, backup files in an Object Storage Service (OSS) bucket within Alibaba Cloud Account A cannot be migrated to an ApsaraDB RDS for SQL Server instance within Alibaba Cloud Account B.
     * >  You can migrate backup files from an OSS bucket within Alibaba Cloud Account A to an OSS bucket within Alibaba Cloud Account B. Make sure that the data in the OSS bucket and the RDS instance belong to the same Alibaba Cloud account. Then, you can call this operation to create a migration task. For more information, see [Use Data Online Migration to migrate data between accounts](https://help.aliyun.com/document_detail/342762.html).
     * ### [](#)References
     * >  Before you call this operation, carefully read the following topic. Make sure that you fully understand the prerequisites, preparations, and impacts for calling this operation.
     * [Migrate data from a self-managed SQL Server instance to an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/100019.html)
     *
     * @param request - CreateMigrateTaskRequest
     *
     * @returns CreateMigrateTaskResponse
     *
     * @param CreateMigrateTaskRequest $request
     *
     * @return CreateMigrateTaskResponse
     */
    public function createMigrateTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMigrateTaskWithOptions($request, $runtime);
    }

    /**
     * Opens the database that is involved in a backup data migration task of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * This operation is used to migrate backup data to the cloud. Before you call this operation, make sure that you understand the descriptions in the following topics:
     * *   [Migrate the full backup data of a self-managed SQL Server database to an ApsaraDB RDS instance that runs SQL Server 2008 R2](https://help.aliyun.com/document_detail/95737.html)
     * *   [Migrate full backup data of SQL Server 2012, 2014, 2016, 2017, or 2019 databases](https://help.aliyun.com/document_detail/95738.html)
     * *   [Migrate incremental backup data to ApsaraDB RDS for SQL Server 2012, 2014, 2016, 2017, or 2019](https://help.aliyun.com/document_detail/95736.html)
     *
     * @param request - CreateOnlineDatabaseTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOnlineDatabaseTaskResponse
     *
     * @param CreateOnlineDatabaseTaskRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateOnlineDatabaseTaskResponse
     */
    public function createOnlineDatabaseTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkDBMode) {
            @$query['CheckDBMode'] = $request->checkDBMode;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->migrateTaskId) {
            @$query['MigrateTaskId'] = $request->migrateTaskId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOnlineDatabaseTask',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOnlineDatabaseTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Opens the database that is involved in a backup data migration task of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * This operation is used to migrate backup data to the cloud. Before you call this operation, make sure that you understand the descriptions in the following topics:
     * *   [Migrate the full backup data of a self-managed SQL Server database to an ApsaraDB RDS instance that runs SQL Server 2008 R2](https://help.aliyun.com/document_detail/95737.html)
     * *   [Migrate full backup data of SQL Server 2012, 2014, 2016, 2017, or 2019 databases](https://help.aliyun.com/document_detail/95738.html)
     * *   [Migrate incremental backup data to ApsaraDB RDS for SQL Server 2012, 2014, 2016, 2017, or 2019](https://help.aliyun.com/document_detail/95736.html)
     *
     * @param request - CreateOnlineDatabaseTaskRequest
     *
     * @returns CreateOnlineDatabaseTaskResponse
     *
     * @param CreateOnlineDatabaseTaskRequest $request
     *
     * @return CreateOnlineDatabaseTaskResponse
     */
    public function createOnlineDatabaseTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOnlineDatabaseTaskWithOptions($request, $runtime);
    }

    /**
     * Deletes a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS MySQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](https://help.aliyun.com/document_detail/464130.html)
     *
     * @param tmpReq - CreateOrderForDeleteDBNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateOrderForDeleteDBNodesResponse
     *
     * @param CreateOrderForDeleteDBNodesRequest $tmpReq
     * @param RuntimeOptions                     $runtime
     *
     * @return CreateOrderForDeleteDBNodesResponse
     */
    public function createOrderForDeleteDBNodesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateOrderForDeleteDBNodesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->DBNodeId) {
            $request->DBNodeIdShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->DBNodeId, 'DBNodeId', 'json');
        }

        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->businessInfo) {
            @$query['BusinessInfo'] = $request->businessInfo;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBNodeIdShrink) {
            @$query['DBNodeId'] = $request->DBNodeIdShrink;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->nodeType) {
            @$query['NodeType'] = $request->nodeType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->promotionCode) {
            @$query['PromotionCode'] = $request->promotionCode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resource) {
            @$query['Resource'] = $request->resource;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateOrderForDeleteDBNodes',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateOrderForDeleteDBNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS MySQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](https://help.aliyun.com/document_detail/464130.html)
     *
     * @param request - CreateOrderForDeleteDBNodesRequest
     *
     * @returns CreateOrderForDeleteDBNodesResponse
     *
     * @param CreateOrderForDeleteDBNodesRequest $request
     *
     * @return CreateOrderForDeleteDBNodesResponse
     */
    public function createOrderForDeleteDBNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createOrderForDeleteDBNodesWithOptions($request, $runtime);
    }

    /**
     * Creates a parameter template for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - CreateParameterGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateParameterGroupResponse
     *
     * @param CreateParameterGroupRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateParameterGroupResponse
     */
    public function createParameterGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->parameterGroupDesc) {
            @$query['ParameterGroupDesc'] = $request->parameterGroupDesc;
        }

        if (null !== $request->parameterGroupName) {
            @$query['ParameterGroupName'] = $request->parameterGroupName;
        }

        if (null !== $request->parameters) {
            @$query['Parameters'] = $request->parameters;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateParameterGroup',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateParameterGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a parameter template for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - CreateParameterGroupRequest
     *
     * @returns CreateParameterGroupResponse
     *
     * @param CreateParameterGroupRequest $request
     *
     * @return CreateParameterGroupResponse
     */
    public function createParameterGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createParameterGroupWithOptions($request, $runtime);
    }

    /**
     * Creates an extension for a database.
     *
     * @remarks
     * ### [](#)Supported database engines
     * PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Manage extensions](https://help.aliyun.com/document_detail/2402409.html)
     * ### [](#)Usage notes
     * Install only the extensions that are supported by the major engine version of the instance. Otherwise, the installation fails.
     * *   For more information, see [Supported extensions](https://help.aliyun.com/document_detail/142340.html).
     * *   You can call an API operation to query the major engine version of the instance. For more information, see [DescribeDBInstanceAttribute](https://help.aliyun.com/document_detail/610394.html).
     *
     * @param request - CreatePostgresExtensionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreatePostgresExtensionsResponse
     *
     * @param CreatePostgresExtensionsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreatePostgresExtensionsResponse
     */
    public function createPostgresExtensionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBNames) {
            @$query['DBNames'] = $request->DBNames;
        }

        if (null !== $request->extensions) {
            @$query['Extensions'] = $request->extensions;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->riskConfirmed) {
            @$query['RiskConfirmed'] = $request->riskConfirmed;
        }

        if (null !== $request->sourceDatabase) {
            @$query['SourceDatabase'] = $request->sourceDatabase;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreatePostgresExtensions',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreatePostgresExtensionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an extension for a database.
     *
     * @remarks
     * ### [](#)Supported database engines
     * PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Manage extensions](https://help.aliyun.com/document_detail/2402409.html)
     * ### [](#)Usage notes
     * Install only the extensions that are supported by the major engine version of the instance. Otherwise, the installation fails.
     * *   For more information, see [Supported extensions](https://help.aliyun.com/document_detail/142340.html).
     * *   You can call an API operation to query the major engine version of the instance. For more information, see [DescribeDBInstanceAttribute](https://help.aliyun.com/document_detail/610394.html).
     *
     * @param request - CreatePostgresExtensionsRequest
     *
     * @returns CreatePostgresExtensionsResponse
     *
     * @param CreatePostgresExtensionsRequest $request
     *
     * @return CreatePostgresExtensionsResponse
     */
    public function createPostgresExtensions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPostgresExtensionsWithOptions($request, $runtime);
    }

    /**
     * Creates a deployment set for an RDS Custom instance in a region. Before you call this operation, you must specify parameters such as OnUnableToRedeployFailedInstance, DeploymentSetName, and Strategy.
     *
     * @param request - CreateRCDeploymentSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRCDeploymentSetResponse
     *
     * @param CreateRCDeploymentSetRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateRCDeploymentSetResponse
     */
    public function createRCDeploymentSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->deploymentSetName) {
            @$query['DeploymentSetName'] = $request->deploymentSetName;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->groupCount) {
            @$query['GroupCount'] = $request->groupCount;
        }

        if (null !== $request->onUnableToRedeployFailedInstance) {
            @$query['OnUnableToRedeployFailedInstance'] = $request->onUnableToRedeployFailedInstance;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->strategy) {
            @$query['Strategy'] = $request->strategy;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRCDeploymentSet',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRCDeploymentSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a deployment set for an RDS Custom instance in a region. Before you call this operation, you must specify parameters such as OnUnableToRedeployFailedInstance, DeploymentSetName, and Strategy.
     *
     * @param request - CreateRCDeploymentSetRequest
     *
     * @returns CreateRCDeploymentSetResponse
     *
     * @param CreateRCDeploymentSetRequest $request
     *
     * @return CreateRCDeploymentSetResponse
     */
    public function createRCDeploymentSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRCDeploymentSetWithOptions($request, $runtime);
    }

    /**
     * Creates a data disk for an RDS Custom instance.
     *
     * @param request - CreateRCDiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRCDiskResponse
     *
     * @param CreateRCDiskRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CreateRCDiskResponse
     */
    public function createRCDiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->diskCategory) {
            @$query['DiskCategory'] = $request->diskCategory;
        }

        if (null !== $request->diskName) {
            @$query['DiskName'] = $request->diskName;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->performanceLevel) {
            @$query['PerformanceLevel'] = $request->performanceLevel;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->periodUnit) {
            @$query['PeriodUnit'] = $request->periodUnit;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->size) {
            @$query['Size'] = $request->size;
        }

        if (null !== $request->snapshotId) {
            @$query['SnapshotId'] = $request->snapshotId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRCDisk',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRCDiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a data disk for an RDS Custom instance.
     *
     * @param request - CreateRCDiskRequest
     *
     * @returns CreateRCDiskResponse
     *
     * @param CreateRCDiskRequest $request
     *
     * @return CreateRCDiskResponse
     */
    public function createRCDisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRCDiskWithOptions($request, $runtime);
    }

    /**
     * Creates an edge node pool in the Container Service for Kubernetes (ACK) Edge cluster to which the RDS Custom instance belongs.
     *
     * @param tmpReq - CreateRCNodePoolRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRCNodePoolResponse
     *
     * @param CreateRCNodePoolRequest $tmpReq
     * @param RuntimeOptions          $runtime
     *
     * @return CreateRCNodePoolResponse
     */
    public function createRCNodePoolWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateRCNodePoolShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->dataDisk) {
            $request->dataDiskShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->dataDisk, 'DataDisk', 'json');
        }

        if (null !== $tmpReq->systemDisk) {
            $request->systemDiskShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->systemDisk, 'SystemDisk', 'json');
        }

        $query = [];
        if (null !== $request->amount) {
            @$query['Amount'] = $request->amount;
        }

        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->createMode) {
            @$query['CreateMode'] = $request->createMode;
        }

        if (null !== $request->dataDiskShrink) {
            @$query['DataDisk'] = $request->dataDiskShrink;
        }

        if (null !== $request->deploymentSetId) {
            @$query['DeploymentSetId'] = $request->deploymentSetId;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->imageId) {
            @$query['ImageId'] = $request->imageId;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->instanceName) {
            @$query['InstanceName'] = $request->instanceName;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->internetChargeType) {
            @$query['InternetChargeType'] = $request->internetChargeType;
        }

        if (null !== $request->internetMaxBandwidthOut) {
            @$query['InternetMaxBandwidthOut'] = $request->internetMaxBandwidthOut;
        }

        if (null !== $request->ioOptimized) {
            @$query['IoOptimized'] = $request->ioOptimized;
        }

        if (null !== $request->keyPairName) {
            @$query['KeyPairName'] = $request->keyPairName;
        }

        if (null !== $request->nodePoolName) {
            @$query['NodePoolName'] = $request->nodePoolName;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->periodUnit) {
            @$query['PeriodUnit'] = $request->periodUnit;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->securityEnhancementStrategy) {
            @$query['SecurityEnhancementStrategy'] = $request->securityEnhancementStrategy;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        if (null !== $request->spotStrategy) {
            @$query['SpotStrategy'] = $request->spotStrategy;
        }

        if (null !== $request->supportCase) {
            @$query['SupportCase'] = $request->supportCase;
        }

        if (null !== $request->systemDiskShrink) {
            @$query['SystemDisk'] = $request->systemDiskShrink;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->userData) {
            @$query['UserData'] = $request->userData;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRCNodePool',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRCNodePoolResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an edge node pool in the Container Service for Kubernetes (ACK) Edge cluster to which the RDS Custom instance belongs.
     *
     * @param request - CreateRCNodePoolRequest
     *
     * @returns CreateRCNodePoolResponse
     *
     * @param CreateRCNodePoolRequest $request
     *
     * @return CreateRCNodePoolResponse
     */
    public function createRCNodePool($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRCNodePoolWithOptions($request, $runtime);
    }

    /**
     * Creates a snapshot for a cloud disk.
     *
     * @remarks
     * In the following scenarios, you cannot create snapshots for a specific disk:
     * *   The number of manual snapshots of the disk has reached 256.
     * *   A snapshot is being created for the disk.
     * *   The instance to which the disk is attached has never been started.
     * *   The instance to which the disk is attached is not in the **Stopped** or **Running** state.
     * When you create a snapshot, take note of the following items:
     * *   If a snapshot is being created, the snapshot cannot be used to create a custom image by calling the CreateImage operation.
     * *   When a snapshot is being created for a disk that is attached to an RDS Custom instance, do not change the instance state.
     * *   You can create snapshots for a disk that is in the **Expired** state. If the release time scheduled for a disk arrives when a snapshot is being created for the disk, the snapshot in the Creating state is deleted when the disk is released.
     *
     * @param request - CreateRCSnapshotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRCSnapshotResponse
     *
     * @param CreateRCSnapshotRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateRCSnapshotResponse
     */
    public function createRCSnapshotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->diskId) {
            @$query['DiskId'] = $request->diskId;
        }

        if (null !== $request->instantAccess) {
            @$query['InstantAccess'] = $request->instantAccess;
        }

        if (null !== $request->instantAccessRetentionDays) {
            @$query['InstantAccessRetentionDays'] = $request->instantAccessRetentionDays;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->retentionDays) {
            @$query['RetentionDays'] = $request->retentionDays;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateRCSnapshot',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRCSnapshotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a snapshot for a cloud disk.
     *
     * @remarks
     * In the following scenarios, you cannot create snapshots for a specific disk:
     * *   The number of manual snapshots of the disk has reached 256.
     * *   A snapshot is being created for the disk.
     * *   The instance to which the disk is attached has never been started.
     * *   The instance to which the disk is attached is not in the **Stopped** or **Running** state.
     * When you create a snapshot, take note of the following items:
     * *   If a snapshot is being created, the snapshot cannot be used to create a custom image by calling the CreateImage operation.
     * *   When a snapshot is being created for a disk that is attached to an RDS Custom instance, do not change the instance state.
     * *   You can create snapshots for a disk that is in the **Expired** state. If the release time scheduled for a disk arrives when a snapshot is being created for the disk, the snapshot in the Creating state is deleted when the disk is released.
     *
     * @param request - CreateRCSnapshotRequest
     *
     * @returns CreateRCSnapshotResponse
     *
     * @param CreateRCSnapshotRequest $request
     *
     * @return CreateRCSnapshotResponse
     */
    public function createRCSnapshot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRCSnapshotWithOptions($request, $runtime);
    }

    /**
     * Creates a read-only instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Create a read-only ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/56991.html)
     * *   [Create a read-only ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/108959.html)
     * *   [Create a read-only ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/99005.html)
     *
     * @param request - CreateReadOnlyDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateReadOnlyDBInstanceResponse
     *
     * @param CreateReadOnlyDBInstanceRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return CreateReadOnlyDBInstanceResponse
     */
    public function createReadOnlyDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoCreateProxy) {
            @$query['AutoCreateProxy'] = $request->autoCreateProxy;
        }

        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->bpeEnabled) {
            @$query['BpeEnabled'] = $request->bpeEnabled;
        }

        if (null !== $request->burstingEnabled) {
            @$query['BurstingEnabled'] = $request->burstingEnabled;
        }

        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceDescription) {
            @$query['DBInstanceDescription'] = $request->DBInstanceDescription;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->deletionProtection) {
            @$query['DeletionProtection'] = $request->deletionProtection;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->gdnInstanceName) {
            @$query['GdnInstanceName'] = $request->gdnInstanceName;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->instructionSetArch) {
            @$query['InstructionSetArch'] = $request->instructionSetArch;
        }

        if (null !== $request->ioAccelerationEnabled) {
            @$query['IoAccelerationEnabled'] = $request->ioAccelerationEnabled;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->promotionCode) {
            @$query['PromotionCode'] = $request->promotionCode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->targetDedicatedHostIdForMaster) {
            @$query['TargetDedicatedHostIdForMaster'] = $request->targetDedicatedHostIdForMaster;
        }

        if (null !== $request->tddlBizType) {
            @$query['TddlBizType'] = $request->tddlBizType;
        }

        if (null !== $request->tddlRegionConfig) {
            @$query['TddlRegionConfig'] = $request->tddlRegionConfig;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateReadOnlyDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateReadOnlyDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a read-only instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Create a read-only ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/56991.html)
     * *   [Create a read-only ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/108959.html)
     * *   [Create a read-only ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/99005.html)
     *
     * @param request - CreateReadOnlyDBInstanceRequest
     *
     * @returns CreateReadOnlyDBInstanceResponse
     *
     * @param CreateReadOnlyDBInstanceRequest $request
     *
     * @return CreateReadOnlyDBInstanceResponse
     */
    public function createReadOnlyDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createReadOnlyDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Creates a data synchronization task for a disaster recovery (DR) ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * *   SQL Server
     * >  The parameters vary based on database engines.
     *
     * @param request - CreateReplicationLinkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateReplicationLinkResponse
     *
     * @param CreateReplicationLinkRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateReplicationLinkResponse
     */
    public function createReplicationLinkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->replicatorAccount) {
            @$query['ReplicatorAccount'] = $request->replicatorAccount;
        }

        if (null !== $request->replicatorPassword) {
            @$query['ReplicatorPassword'] = $request->replicatorPassword;
        }

        if (null !== $request->sourceAddress) {
            @$query['SourceAddress'] = $request->sourceAddress;
        }

        if (null !== $request->sourceCategory) {
            @$query['SourceCategory'] = $request->sourceCategory;
        }

        if (null !== $request->sourceInstanceName) {
            @$query['SourceInstanceName'] = $request->sourceInstanceName;
        }

        if (null !== $request->sourceInstanceRegionId) {
            @$query['SourceInstanceRegionId'] = $request->sourceInstanceRegionId;
        }

        if (null !== $request->sourcePort) {
            @$query['SourcePort'] = $request->sourcePort;
        }

        if (null !== $request->targetAddress) {
            @$query['TargetAddress'] = $request->targetAddress;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateReplicationLink',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateReplicationLinkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a data synchronization task for a disaster recovery (DR) ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * *   SQL Server
     * >  The parameters vary based on database engines.
     *
     * @param request - CreateReplicationLinkRequest
     *
     * @returns CreateReplicationLinkResponse
     *
     * @param CreateReplicationLinkRequest $request
     *
     * @return CreateReplicationLinkResponse
     */
    public function createReplicationLink($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createReplicationLinkWithOptions($request, $runtime);
    }

    /**
     * Creates a credential for a user who uses the Data API feature.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     *
     * @param request - CreateSecretRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateSecretResponse
     *
     * @param CreateSecretRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CreateSecretResponse
     */
    public function createSecretWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dbInstanceId) {
            @$query['DbInstanceId'] = $request->dbInstanceId;
        }

        if (null !== $request->dbNames) {
            @$query['DbNames'] = $request->dbNames;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->secretName) {
            @$query['SecretName'] = $request->secretName;
        }

        if (null !== $request->username) {
            @$query['Username'] = $request->username;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateSecret',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateSecretResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a credential for a user who uses the Data API feature.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     *
     * @param request - CreateSecretRequest
     *
     * @returns CreateSecretResponse
     *
     * @param CreateSecretRequest $request
     *
     * @return CreateSecretResponse
     */
    public function createSecret($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createSecretWithOptions($request, $runtime);
    }

    /**
     * Creates a service-linked role.
     *
     * @remarks
     * ### Supported database engine
     * PostgreSQL
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Service-linked roles](https://help.aliyun.com/document_detail/342840.html)
     *
     * @param request - CreateServiceLinkedRoleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateServiceLinkedRoleResponse
     *
     * @param CreateServiceLinkedRoleRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateServiceLinkedRoleResponse
     */
    public function createServiceLinkedRoleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serviceLinkedRole) {
            @$query['ServiceLinkedRole'] = $request->serviceLinkedRole;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateServiceLinkedRole',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateServiceLinkedRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a service-linked role.
     *
     * @remarks
     * ### Supported database engine
     * PostgreSQL
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Service-linked roles](https://help.aliyun.com/document_detail/342840.html)
     *
     * @param request - CreateServiceLinkedRoleRequest
     *
     * @returns CreateServiceLinkedRoleResponse
     *
     * @param CreateServiceLinkedRoleRequest $request
     *
     * @return CreateServiceLinkedRoleResponse
     */
    public function createServiceLinkedRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createServiceLinkedRoleWithOptions($request, $runtime);
    }

    /**
     * Creates a temporary instance for an RDS instance that runs SQL Server 2008 R2 and uses local disks.
     *
     * @remarks
     * ### [](#)Supported database engines
     * Your RDS instance runs SQL Server 2008 R2 with local disks.
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Restore the data of an ApsaraDB RDS for SQL Server instance by using a temporary RDS instance](https://help.aliyun.com/document_detail/95724.html)
     *
     * @param request - CreateTempDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateTempDBInstanceResponse
     *
     * @param CreateTempDBInstanceRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateTempDBInstanceResponse
     */
    public function createTempDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreTime) {
            @$query['RestoreTime'] = $request->restoreTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateTempDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateTempDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a temporary instance for an RDS instance that runs SQL Server 2008 R2 and uses local disks.
     *
     * @remarks
     * ### [](#)Supported database engines
     * Your RDS instance runs SQL Server 2008 R2 with local disks.
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Restore the data of an ApsaraDB RDS for SQL Server instance by using a temporary RDS instance](https://help.aliyun.com/document_detail/95724.html)
     *
     * @param request - CreateTempDBInstanceRequest
     *
     * @returns CreateTempDBInstanceResponse
     *
     * @param CreateTempDBInstanceRequest $request
     *
     * @return CreateTempDBInstanceResponse
     */
    public function createTempDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTempDBInstanceWithOptions($request, $runtime);
    }

    /**
     * 下单领券接口.
     *
     * @param request - CreateYouhuiForOrderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateYouhuiForOrderResponse
     *
     * @param CreateYouhuiForOrderRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateYouhuiForOrderResponse
     */
    public function createYouhuiForOrderWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->activityId) {
            @$query['ActivityId'] = $request->activityId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->promotionId) {
            @$query['PromotionId'] = $request->promotionId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateYouhuiForOrder',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateYouhuiForOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 下单领券接口.
     *
     * @param request - CreateYouhuiForOrderRequest
     *
     * @returns CreateYouhuiForOrderResponse
     *
     * @param CreateYouhuiForOrderRequest $request
     *
     * @return CreateYouhuiForOrderResponse
     */
    public function createYouhuiForOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createYouhuiForOrderWithOptions($request, $runtime);
    }

    /**
     * Deletes an ApsaraDB RDS for SQL Server instance from an Active Directory (AD) domain.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     *
     * @param request - DeleteADSettingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteADSettingResponse
     *
     * @param DeleteADSettingRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DeleteADSettingResponse
     */
    public function deleteADSettingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteADSetting',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteADSettingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an ApsaraDB RDS for SQL Server instance from an Active Directory (AD) domain.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     *
     * @param request - DeleteADSettingRequest
     *
     * @returns DeleteADSettingResponse
     *
     * @param DeleteADSettingRequest $request
     *
     * @return DeleteADSettingResponse
     */
    public function deleteADSetting($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteADSettingWithOptions($request, $runtime);
    }

    /**
     * Deletes an account from an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Delete a database account from an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96104.html)
     * *   [Delete a database account from an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/147649.html)
     * *   [Delete a database account from an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95694.html)
     * *   [Delete a database account from an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97135.html)
     *
     * @param request - DeleteAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteAccountResponse
     *
     * @param DeleteAccountRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DeleteAccountResponse
     */
    public function deleteAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteAccount',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an account from an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Delete a database account from an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96104.html)
     * *   [Delete a database account from an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/147649.html)
     * *   [Delete a database account from an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95694.html)
     * *   [Delete a database account from an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97135.html)
     *
     * @param request - DeleteAccountRequest
     *
     * @returns DeleteAccountResponse
     *
     * @param DeleteAccountRequest $request
     *
     * @return DeleteAccountResponse
     */
    public function deleteAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteAccountWithOptions($request, $runtime);
    }

    /**
     * Deletes the data backup files of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * > Only instances that run RDS High-availability Edition are supported.
     * ### Description
     * You can call this operation to delete backup sets of the instance itself. Backup sets of the associated instances such as read-only, disaster recovery, and cloned instances are not deleted.
     * ### Precautions
     * Before you call this operation, make sure that the following requirements are met:
     * *   The instance is in the Running state.
     * *   If the log backup feature is disabled, instances cannot be restored by point in time. You can delete data backup sets that are retained for more than seven days.
     * *   If the log backup feature is enabled and the log backup retention period is shorter than the data backup retention period, you can delete the data backup files that are retained for a period longer than the log backup retention period.
     *
     * @param request - DeleteBackupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBackupResponse
     *
     * @param DeleteBackupRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DeleteBackupResponse
     */
    public function deleteBackupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBackup',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBackupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the data backup files of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * > Only instances that run RDS High-availability Edition are supported.
     * ### Description
     * You can call this operation to delete backup sets of the instance itself. Backup sets of the associated instances such as read-only, disaster recovery, and cloned instances are not deleted.
     * ### Precautions
     * Before you call this operation, make sure that the following requirements are met:
     * *   The instance is in the Running state.
     * *   If the log backup feature is disabled, instances cannot be restored by point in time. You can delete data backup sets that are retained for more than seven days.
     * *   If the log backup feature is enabled and the log backup retention period is shorter than the data backup retention period, you can delete the data backup files that are retained for a period longer than the log backup retention period.
     *
     * @param request - DeleteBackupRequest
     *
     * @returns DeleteBackupResponse
     *
     * @param DeleteBackupRequest $request
     *
     * @return DeleteBackupResponse
     */
    public function deleteBackup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupWithOptions($request, $runtime);
    }

    /**
     * Deletes the backup files of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS SQL Server
     * >  This operation is available only for users that are added to the whitelist.
     *
     * @param request - DeleteBackupFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBackupFileResponse
     *
     * @param DeleteBackupFileRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteBackupFileResponse
     */
    public function deleteBackupFileWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->backupTime) {
            @$query['BackupTime'] = $request->backupTime;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteBackupFile',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBackupFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the backup files of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS SQL Server
     * >  This operation is available only for users that are added to the whitelist.
     *
     * @param request - DeleteBackupFileRequest
     *
     * @returns DeleteBackupFileResponse
     *
     * @param DeleteBackupFileRequest $request
     *
     * @return DeleteBackupFileResponse
     */
    public function deleteBackupFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBackupFileWithOptions($request, $runtime);
    }

    /**
     * Releases an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Note Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Release an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96057.html)
     * *   [Release an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96749.html)
     * *   [Release an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95662.html)
     * *   [Release an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97128.html)
     *
     * @param request - DeleteDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDBInstanceResponse
     *
     * @param DeleteDBInstanceRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteDBInstanceResponse
     */
    public function deleteDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->releasedKeepPolicy) {
            @$query['ReleasedKeepPolicy'] = $request->releasedKeepPolicy;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Note Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Release an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96057.html)
     * *   [Release an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96749.html)
     * *   [Release an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95662.html)
     * *   [Release an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97128.html)
     *
     * @param request - DeleteDBInstanceRequest
     *
     * @returns DeleteDBInstanceResponse
     *
     * @param DeleteDBInstanceRequest $request
     *
     * @return DeleteDBInstanceResponse
     */
    public function deleteDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Deletes an endpoint for an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Delete the read-only endpoint of an ApsaraDB RDS for MySQL cluster](https://help.aliyun.com/document_detail/464133.html)
     *
     * @param request - DeleteDBInstanceEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDBInstanceEndpointResponse
     *
     * @param DeleteDBInstanceEndpointRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeleteDBInstanceEndpointResponse
     */
    public function deleteDBInstanceEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceEndpointId) {
            @$query['DBInstanceEndpointId'] = $request->DBInstanceEndpointId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDBInstanceEndpoint',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDBInstanceEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an endpoint for an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Delete the read-only endpoint of an ApsaraDB RDS for MySQL cluster](https://help.aliyun.com/document_detail/464133.html)
     *
     * @param request - DeleteDBInstanceEndpointRequest
     *
     * @returns DeleteDBInstanceEndpointResponse
     *
     * @param DeleteDBInstanceEndpointRequest $request
     *
     * @return DeleteDBInstanceEndpointResponse
     */
    public function deleteDBInstanceEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDBInstanceEndpointWithOptions($request, $runtime);
    }

    /**
     * Releases the public endpoint of an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)Precautions
     * You can delete only the public endpoint of each endpoint type from the instance. If you want to delete an internal endpoint of any endpoint type, you can directly delete the type of endpoint.
     *
     * @param request - DeleteDBInstanceEndpointAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDBInstanceEndpointAddressResponse
     *
     * @param DeleteDBInstanceEndpointAddressRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DeleteDBInstanceEndpointAddressResponse
     */
    public function deleteDBInstanceEndpointAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $body = [];
        if (null !== $request->connectionString) {
            @$body['ConnectionString'] = $request->connectionString;
        }

        if (null !== $request->DBInstanceEndpointId) {
            @$body['DBInstanceEndpointId'] = $request->DBInstanceEndpointId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteDBInstanceEndpointAddress',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDBInstanceEndpointAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases the public endpoint of an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)Precautions
     * You can delete only the public endpoint of each endpoint type from the instance. If you want to delete an internal endpoint of any endpoint type, you can directly delete the type of endpoint.
     *
     * @param request - DeleteDBInstanceEndpointAddressRequest
     *
     * @returns DeleteDBInstanceEndpointAddressResponse
     *
     * @param DeleteDBInstanceEndpointAddressRequest $request
     *
     * @return DeleteDBInstanceEndpointAddressResponse
     */
    public function deleteDBInstanceEndpointAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDBInstanceEndpointAddressWithOptions($request, $runtime);
    }

    /**
     * Deletes a security group rule that is configured for an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Configure security group settings for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - DeleteDBInstanceSecurityGroupRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDBInstanceSecurityGroupRuleResponse
     *
     * @param DeleteDBInstanceSecurityGroupRuleRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DeleteDBInstanceSecurityGroupRuleResponse
     */
    public function deleteDBInstanceSecurityGroupRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityGroupRuleIds) {
            @$query['SecurityGroupRuleIds'] = $request->securityGroupRuleIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDBInstanceSecurityGroupRule',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDBInstanceSecurityGroupRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a security group rule that is configured for an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Configure security group settings for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - DeleteDBInstanceSecurityGroupRuleRequest
     *
     * @returns DeleteDBInstanceSecurityGroupRuleResponse
     *
     * @param DeleteDBInstanceSecurityGroupRuleRequest $request
     *
     * @return DeleteDBInstanceSecurityGroupRuleResponse
     */
    public function deleteDBInstanceSecurityGroupRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDBInstanceSecurityGroupRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes a node from an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * MySQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Delete a node from an ApsaraDB RDS for MySQL cluster](https://help.aliyun.com/document_detail/464130.html)
     *
     * @param tmpReq - DeleteDBNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDBNodesResponse
     *
     * @param DeleteDBNodesRequest $tmpReq
     * @param RuntimeOptions       $runtime
     *
     * @return DeleteDBNodesResponse
     */
    public function deleteDBNodesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DeleteDBNodesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->DBNodeId) {
            $request->DBNodeIdShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->DBNodeId, 'DBNodeId', 'json');
        }

        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBNodeIdShrink) {
            @$query['DBNodeId'] = $request->DBNodeIdShrink;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDBNodes',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDBNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a node from an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * MySQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Delete a node from an ApsaraDB RDS for MySQL cluster](https://help.aliyun.com/document_detail/464130.html)
     *
     * @param request - DeleteDBNodesRequest
     *
     * @returns DeleteDBNodesResponse
     *
     * @param DeleteDBNodesRequest $request
     *
     * @return DeleteDBNodesResponse
     */
    public function deleteDBNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDBNodesWithOptions($request, $runtime);
    }

    /**
     * Deletes the endpoint that is used to connect to the dedicated proxy of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/184921.html)
     * *   [Configure the dedicated proxy endpoint for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418274.html)
     *
     * @param request - DeleteDBProxyEndpointAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDBProxyEndpointAddressResponse
     *
     * @param DeleteDBProxyEndpointAddressRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DeleteDBProxyEndpointAddressResponse
     */
    public function deleteDBProxyEndpointAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyConnectStringNetType) {
            @$query['DBProxyConnectStringNetType'] = $request->DBProxyConnectStringNetType;
        }

        if (null !== $request->DBProxyEndpointId) {
            @$query['DBProxyEndpointId'] = $request->DBProxyEndpointId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDBProxyEndpointAddress',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDBProxyEndpointAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the endpoint that is used to connect to the dedicated proxy of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/184921.html)
     * *   [Configure the dedicated proxy endpoint for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418274.html)
     *
     * @param request - DeleteDBProxyEndpointAddressRequest
     *
     * @returns DeleteDBProxyEndpointAddressResponse
     *
     * @param DeleteDBProxyEndpointAddressRequest $request
     *
     * @return DeleteDBProxyEndpointAddressResponse
     */
    public function deleteDBProxyEndpointAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDBProxyEndpointAddressWithOptions($request, $runtime);
    }

    /**
     * Deletes a database from an RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * ### [](#)References
     * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Delete a database from an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96106.html)
     * *   [Delete a database from an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96759.html)
     * *   [Delete a database from an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95699.html)
     * *   [Delete a database from an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97137.html)
     *
     * @param request - DeleteDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDatabaseResponse
     *
     * @param DeleteDatabaseRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteDatabaseResponse
     */
    public function deleteDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDatabase',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a database from an RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * ### [](#)References
     * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Delete a database from an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96106.html)
     * *   [Delete a database from an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96759.html)
     * *   [Delete a database from an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95699.html)
     * *   [Delete a database from an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97137.html)
     *
     * @param request - DeleteDatabaseRequest
     *
     * @returns DeleteDatabaseResponse
     *
     * @param DeleteDatabaseRequest $request
     *
     * @return DeleteDatabaseResponse
     */
    public function deleteDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDatabaseWithOptions($request, $runtime);
    }

    /**
     * Deletes a global active database cluster.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [Usage notes](#)
     * *   A global active database cluster cannot be restored after it is deleted. Proceed with caution.
     * *   If you delete a global active database cluster, the system removes all nodes and Data Transmission Service (DTS) synchronization tasks from the cluster. However, the system does not release the ApsaraDB RDS for MySQL instances that run as nodes in the cluster. If you no longer need the ApsaraDB RDS for MySQL instances, you can call the [DeleteDBInstance](https://help.aliyun.com/document_detail/26229.html) to release the instances one after another.
     *
     * @param request - DeleteGadInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteGadInstanceResponse
     *
     * @param DeleteGadInstanceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteGadInstanceResponse
     */
    public function deleteGadInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->gadInstanceName) {
            @$query['GadInstanceName'] = $request->gadInstanceName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteGadInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteGadInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a global active database cluster.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [Usage notes](#)
     * *   A global active database cluster cannot be restored after it is deleted. Proceed with caution.
     * *   If you delete a global active database cluster, the system removes all nodes and Data Transmission Service (DTS) synchronization tasks from the cluster. However, the system does not release the ApsaraDB RDS for MySQL instances that run as nodes in the cluster. If you no longer need the ApsaraDB RDS for MySQL instances, you can call the [DeleteDBInstance](https://help.aliyun.com/document_detail/26229.html) to release the instances one after another.
     *
     * @param request - DeleteGadInstanceRequest
     *
     * @returns DeleteGadInstanceResponse
     *
     * @param DeleteGadInstanceRequest $request
     *
     * @return DeleteGadInstanceResponse
     */
    public function deleteGadInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteGadInstanceWithOptions($request, $runtime);
    }

    /**
     * 删除全密态规则.
     *
     * @param request - DeleteMaskingRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteMaskingRulesResponse
     *
     * @param DeleteMaskingRulesRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteMaskingRulesResponse
     */
    public function deleteMaskingRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteMaskingRules',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMaskingRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 删除全密态规则.
     *
     * @param request - DeleteMaskingRulesRequest
     *
     * @returns DeleteMaskingRulesResponse
     *
     * @param DeleteMaskingRulesRequest $request
     *
     * @return DeleteMaskingRulesResponse
     */
    public function deleteMaskingRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMaskingRulesWithOptions($request, $runtime);
    }

    /**
     * Deletes a parameter template from an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - DeleteParameterGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteParameterGroupResponse
     *
     * @param DeleteParameterGroupRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteParameterGroupResponse
     */
    public function deleteParameterGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->parameterGroupId) {
            @$query['ParameterGroupId'] = $request->parameterGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteParameterGroup',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteParameterGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a parameter template from an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - DeleteParameterGroupRequest
     *
     * @returns DeleteParameterGroupResponse
     *
     * @param DeleteParameterGroupRequest $request
     *
     * @return DeleteParameterGroupResponse
     */
    public function deleteParameterGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteParameterGroupWithOptions($request, $runtime);
    }

    /**
     * Deletes an extension from a database.
     *
     * @remarks
     * ### Supported database engines
     * RDS PostgreSQL
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Manage extensions](https://help.aliyun.com/document_detail/2402409.html)
     *
     * @param request - DeletePostgresExtensionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeletePostgresExtensionsResponse
     *
     * @param DeletePostgresExtensionsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DeletePostgresExtensionsResponse
     */
    public function deletePostgresExtensionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBNames) {
            @$query['DBNames'] = $request->DBNames;
        }

        if (null !== $request->extensions) {
            @$query['Extensions'] = $request->extensions;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeletePostgresExtensions',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeletePostgresExtensionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an extension from a database.
     *
     * @remarks
     * ### Supported database engines
     * RDS PostgreSQL
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Manage extensions](https://help.aliyun.com/document_detail/2402409.html)
     *
     * @param request - DeletePostgresExtensionsRequest
     *
     * @returns DeletePostgresExtensionsResponse
     *
     * @param DeletePostgresExtensionsRequest $request
     *
     * @return DeletePostgresExtensionsResponse
     */
    public function deletePostgresExtensions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deletePostgresExtensionsWithOptions($request, $runtime);
    }

    /**
     * Deletes a RDS Custom node from a Container Service for Kubernetes (ACK) cluster.
     *
     * @param tmpReq - DeleteRCClusterNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRCClusterNodesResponse
     *
     * @param DeleteRCClusterNodesRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteRCClusterNodesResponse
     */
    public function deleteRCClusterNodesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DeleteRCClusterNodesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->instanceIds) {
            $request->instanceIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->instanceIds, 'InstanceIds', 'simple');
        }

        if (null !== $tmpReq->nodes) {
            $request->nodesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->nodes, 'Nodes', 'simple');
        }

        $query = [];
        if (null !== $request->instanceIdsShrink) {
            @$query['InstanceIds'] = $request->instanceIdsShrink;
        }

        if (null !== $request->nodesShrink) {
            @$query['Nodes'] = $request->nodesShrink;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRCClusterNodes',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRCClusterNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a RDS Custom node from a Container Service for Kubernetes (ACK) cluster.
     *
     * @param request - DeleteRCClusterNodesRequest
     *
     * @returns DeleteRCClusterNodesResponse
     *
     * @param DeleteRCClusterNodesRequest $request
     *
     * @return DeleteRCClusterNodesResponse
     */
    public function deleteRCClusterNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRCClusterNodesWithOptions($request, $runtime);
    }

    /**
     * Deletes a deployment set for an RDS Custom instance. Before you call this operation, you must specify parameters such as RegionId and DeploymentSetId.
     *
     * @param request - DeleteRCDeploymentSetRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRCDeploymentSetResponse
     *
     * @param DeleteRCDeploymentSetRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteRCDeploymentSetResponse
     */
    public function deleteRCDeploymentSetWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->deploymentSetId) {
            @$query['DeploymentSetId'] = $request->deploymentSetId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRCDeploymentSet',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRCDeploymentSetResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a deployment set for an RDS Custom instance. Before you call this operation, you must specify parameters such as RegionId and DeploymentSetId.
     *
     * @param request - DeleteRCDeploymentSetRequest
     *
     * @returns DeleteRCDeploymentSetResponse
     *
     * @param DeleteRCDeploymentSetRequest $request
     *
     * @return DeleteRCDeploymentSetResponse
     */
    public function deleteRCDeploymentSet($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRCDeploymentSetWithOptions($request, $runtime);
    }

    /**
     * Releases a pay-as-you-go data disk. The data disk can be a basic disk, an ultra disk, a standard SSD, or an Enterprise SSD (ESSD).
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   Manual snapshots of the disk are retained.
     * *   The disk must be in the Unattached (Available) state.
     * *   If no disk with the specified disk ID exists, the request will be ignored.
     *
     * @param request - DeleteRCDiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRCDiskResponse
     *
     * @param DeleteRCDiskRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DeleteRCDiskResponse
     */
    public function deleteRCDiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->diskId) {
            @$query['DiskId'] = $request->diskId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRCDisk',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRCDiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases a pay-as-you-go data disk. The data disk can be a basic disk, an ultra disk, a standard SSD, or an Enterprise SSD (ESSD).
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   Manual snapshots of the disk are retained.
     * *   The disk must be in the Unattached (Available) state.
     * *   If no disk with the specified disk ID exists, the request will be ignored.
     *
     * @param request - DeleteRCDiskRequest
     *
     * @returns DeleteRCDiskResponse
     *
     * @param DeleteRCDiskRequest $request
     *
     * @return DeleteRCDiskResponse
     */
    public function deleteRCDisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRCDiskWithOptions($request, $runtime);
    }

    /**
     * 删除RDS用户专属主机实例.
     *
     * @param request - DeleteRCInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRCInstanceResponse
     *
     * @param DeleteRCInstanceRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteRCInstanceResponse
     */
    public function deleteRCInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->force) {
            @$query['Force'] = $request->force;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRCInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRCInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 删除RDS用户专属主机实例.
     *
     * @param request - DeleteRCInstanceRequest
     *
     * @returns DeleteRCInstanceResponse
     *
     * @param DeleteRCInstanceRequest $request
     *
     * @return DeleteRCInstanceResponse
     */
    public function deleteRCInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRCInstanceWithOptions($request, $runtime);
    }

    /**
     * Releases a subscription RDS Custom instance.
     *
     * @remarks
     * After an instance is released, all physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
     *
     * @param tmpReq - DeleteRCInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRCInstancesResponse
     *
     * @param DeleteRCInstancesRequest $tmpReq
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteRCInstancesResponse
     */
    public function deleteRCInstancesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DeleteRCInstancesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->instanceId) {
            $request->instanceIdShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->instanceId, 'InstanceId', 'json');
        }

        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->force) {
            @$query['Force'] = $request->force;
        }

        if (null !== $request->instanceIdShrink) {
            @$query['InstanceId'] = $request->instanceIdShrink;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->terminateSubscription) {
            @$query['TerminateSubscription'] = $request->terminateSubscription;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRCInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRCInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases a subscription RDS Custom instance.
     *
     * @remarks
     * After an instance is released, all physical resources used by the instance are recycled. Relevant data is erased and cannot be restored.
     *
     * @param request - DeleteRCInstancesRequest
     *
     * @returns DeleteRCInstancesResponse
     *
     * @param DeleteRCInstancesRequest $request
     *
     * @return DeleteRCInstancesResponse
     */
    public function deleteRCInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRCInstancesWithOptions($request, $runtime);
    }

    /**
     * Deletes the edge node pool of an RDS Custom instance.
     *
     * @param request - DeleteRCNodePoolRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRCNodePoolResponse
     *
     * @param DeleteRCNodePoolRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteRCNodePoolResponse
     */
    public function deleteRCNodePoolWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->nodePoolId) {
            @$query['NodePoolId'] = $request->nodePoolId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRCNodePool',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRCNodePoolResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the edge node pool of an RDS Custom instance.
     *
     * @param request - DeleteRCNodePoolRequest
     *
     * @returns DeleteRCNodePoolResponse
     *
     * @param DeleteRCNodePoolRequest $request
     *
     * @return DeleteRCNodePoolResponse
     */
    public function deleteRCNodePool($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRCNodePoolWithOptions($request, $runtime);
    }

    /**
     * Deletes a cloud disk snapshot.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   If the specified snapshot ID does not exist, the request will be ignored.
     * *   If the snapshot is used to create custom images, the snapshot cannot be deleted. You must delete the created custom images before you can delete the snapshot.
     * *   If the snapshot is used to create cloud disks and `Force` is not specified or is set to `false`, the snapshot cannot be directly deleted. If you want to delete the snapshot, set `Force` to true to forcefully delete the snapshot. The cloud disks created from the snapshot cannot be re-initialized after the snapshot is forcefully deleted.
     *
     * @param request - DeleteRCSnapshotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRCSnapshotResponse
     *
     * @param DeleteRCSnapshotRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteRCSnapshotResponse
     */
    public function deleteRCSnapshotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->force) {
            @$query['Force'] = $request->force;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->snapshotId) {
            @$query['SnapshotId'] = $request->snapshotId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteRCSnapshot',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRCSnapshotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a cloud disk snapshot.
     *
     * @remarks
     * Before you call this operation, take note of the following items:
     * *   If the specified snapshot ID does not exist, the request will be ignored.
     * *   If the snapshot is used to create custom images, the snapshot cannot be deleted. You must delete the created custom images before you can delete the snapshot.
     * *   If the snapshot is used to create cloud disks and `Force` is not specified or is set to `false`, the snapshot cannot be directly deleted. If you want to delete the snapshot, set `Force` to true to forcefully delete the snapshot. The cloud disks created from the snapshot cannot be re-initialized after the snapshot is forcefully deleted.
     *
     * @param request - DeleteRCSnapshotRequest
     *
     * @returns DeleteRCSnapshotResponse
     *
     * @param DeleteRCSnapshotRequest $request
     *
     * @return DeleteRCSnapshotResponse
     */
    public function deleteRCSnapshot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRCSnapshotWithOptions($request, $runtime);
    }

    /**
     * Deletes the data synchronization link for a disaster recovery (DR) ApsaraDB RDS instance and promotes the DR instance to the primary instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DeleteReplicationLinkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteReplicationLinkResponse
     *
     * @param DeleteReplicationLinkRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteReplicationLinkResponse
     */
    public function deleteReplicationLinkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->promoteToMaster) {
            @$query['PromoteToMaster'] = $request->promoteToMaster;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteReplicationLink',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteReplicationLinkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the data synchronization link for a disaster recovery (DR) ApsaraDB RDS instance and promotes the DR instance to the primary instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DeleteReplicationLinkRequest
     *
     * @returns DeleteReplicationLinkResponse
     *
     * @param DeleteReplicationLinkRequest $request
     *
     * @return DeleteReplicationLinkResponse
     */
    public function deleteReplicationLink($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteReplicationLinkWithOptions($request, $runtime);
    }

    /**
     * Deletes the credential of a user who uses the Data API feature.
     *
     * @param request - DeleteSecretRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSecretResponse
     *
     * @param DeleteSecretRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DeleteSecretResponse
     */
    public function deleteSecretWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dbInstanceId) {
            @$query['DbInstanceId'] = $request->dbInstanceId;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->secretArn) {
            @$query['SecretArn'] = $request->secretArn;
        }

        if (null !== $request->secretName) {
            @$query['SecretName'] = $request->secretName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSecret',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSecretResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the credential of a user who uses the Data API feature.
     *
     * @param request - DeleteSecretRequest
     *
     * @returns DeleteSecretResponse
     *
     * @param DeleteSecretRequest $request
     *
     * @return DeleteSecretResponse
     */
    public function deleteSecret($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSecretWithOptions($request, $runtime);
    }

    /**
     * Deletes a replication slot of an instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   PostgreSQL
     * ### [](#)Precautions
     * You can delete a replication slot only when the status of the slot is **INACTIVE**. You can call the DescribeSlots operation to query the status of a replication slot.
     *
     * @param request - DeleteSlotRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteSlotResponse
     *
     * @param DeleteSlotRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return DeleteSlotResponse
     */
    public function deleteSlotWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->slotName) {
            @$query['SlotName'] = $request->slotName;
        }

        if (null !== $request->slotStatus) {
            @$query['SlotStatus'] = $request->slotStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteSlot',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteSlotResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a replication slot of an instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   PostgreSQL
     * ### [](#)Precautions
     * You can delete a replication slot only when the status of the slot is **INACTIVE**. You can call the DescribeSlots operation to query the status of a replication slot.
     *
     * @param request - DeleteSlotRequest
     *
     * @returns DeleteSlotResponse
     *
     * @param DeleteSlotRequest $request
     *
     * @return DeleteSlotResponse
     */
    public function deleteSlot($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteSlotWithOptions($request, $runtime);
    }

    /**
     * Deletes the backup files of an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   MySQL
     * ### [](#)Usage notes
     * *   A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](https://help.aliyun.com/document_detail/251779.html).
     * *   This operation deletes full backup files only from the ApsaraDB RDS console. This operation does not affect the full backup files that are stored as objects in Object Storage Service (OSS) buckets. After you call this operation to delete a full backup file, you can call the ImportUserBackupFile operation to reimport the full backup file.
     *
     * @param request - DeleteUserBackupFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteUserBackupFileResponse
     *
     * @param DeleteUserBackupFileRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteUserBackupFileResponse
     */
    public function deleteUserBackupFileWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteUserBackupFile',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteUserBackupFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes the backup files of an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   MySQL
     * ### [](#)Usage notes
     * *   A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](https://help.aliyun.com/document_detail/251779.html).
     * *   This operation deletes full backup files only from the ApsaraDB RDS console. This operation does not affect the full backup files that are stored as objects in Object Storage Service (OSS) buckets. After you call this operation to delete a full backup file, you can call the ImportUserBackupFile operation to reimport the full backup file.
     *
     * @param request - DeleteUserBackupFileRequest
     *
     * @returns DeleteUserBackupFileResponse
     *
     * @param DeleteUserBackupFileRequest $request
     *
     * @return DeleteUserBackupFileResponse
     */
    public function deleteUserBackupFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteUserBackupFileWithOptions($request, $runtime);
    }

    /**
     * Queries the migration tasks of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     *
     * @param request - DescibeImportsFromDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescibeImportsFromDatabaseResponse
     *
     * @param DescibeImportsFromDatabaseRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescibeImportsFromDatabaseResponse
     */
    public function descibeImportsFromDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->importId) {
            @$query['ImportId'] = $request->importId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescibeImportsFromDatabase',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescibeImportsFromDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the migration tasks of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     *
     * @param request - DescibeImportsFromDatabaseRequest
     *
     * @returns DescibeImportsFromDatabaseResponse
     *
     * @param DescibeImportsFromDatabaseRequest $request
     *
     * @return DescibeImportsFromDatabaseResponse
     */
    public function descibeImportsFromDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->descibeImportsFromDatabaseWithOptions($request, $runtime);
    }

    /**
     * Queries information about the AD domain of an instance. The information includes whether the instance is added to the AD domain, the name of the AD domain, and the account.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     *
     * @param request - DescribeADInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeADInfoResponse
     *
     * @param DescribeADInfoRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DescribeADInfoResponse
     */
    public function describeADInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeADInfo',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeADInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the AD domain of an instance. The information includes whether the instance is added to the AD domain, the name of the AD domain, and the account.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     *
     * @param request - DescribeADInfoRequest
     *
     * @returns DescribeADInfoResponse
     *
     * @param DescribeADInfoRequest $request
     *
     * @return DescribeADInfoResponse
     */
    public function describeADInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeADInfoWithOptions($request, $runtime);
    }

    /**
     * 查询全密态用户权限.
     *
     * @param request - DescribeAccountMaskingPrivilegeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAccountMaskingPrivilegeResponse
     *
     * @param DescribeAccountMaskingPrivilegeRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeAccountMaskingPrivilegeResponse
     */
    public function describeAccountMaskingPrivilegeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->userName) {
            @$query['UserName'] = $request->userName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAccountMaskingPrivilege',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAccountMaskingPrivilegeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 查询全密态用户权限.
     *
     * @param request - DescribeAccountMaskingPrivilegeRequest
     *
     * @returns DescribeAccountMaskingPrivilegeResponse
     *
     * @param DescribeAccountMaskingPrivilegeRequest $request
     *
     * @return DescribeAccountMaskingPrivilegeResponse
     */
    public function describeAccountMaskingPrivilege($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccountMaskingPrivilegeWithOptions($request, $runtime);
    }

    /**
     * Queries the details about the accounts that are created on an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeAccountsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAccountsResponse
     *
     * @param DescribeAccountsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeAccountsResponse
     */
    public function describeAccountsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAccounts',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAccountsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the accounts that are created on an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeAccountsRequest
     *
     * @returns DescribeAccountsResponse
     *
     * @param DescribeAccountsRequest $request
     *
     * @return DescribeAccountsResponse
     */
    public function describeAccounts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAccountsWithOptions($request, $runtime);
    }

    /**
     * Queries whether the historical events feature is enabled.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeActionEventPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeActionEventPolicyResponse
     *
     * @param DescribeActionEventPolicyRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeActionEventPolicyResponse
     */
    public function describeActionEventPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeActionEventPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeActionEventPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whether the historical events feature is enabled.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeActionEventPolicyRequest
     *
     * @returns DescribeActionEventPolicyResponse
     *
     * @param DescribeActionEventPolicyRequest $request
     *
     * @return DescribeActionEventPolicyResponse
     */
    public function describeActionEventPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeActionEventPolicyWithOptions($request, $runtime);
    }

    /**
     * Queries the details about scheduled O\\\\\\\\\\\\\\\\\\\\&M tasks for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeActiveOperationTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeActiveOperationTasksResponse
     *
     * @param DescribeActiveOperationTasksRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeActiveOperationTasksResponse
     */
    public function describeActiveOperationTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allowCancel) {
            @$query['AllowCancel'] = $request->allowCancel;
        }

        if (null !== $request->allowChange) {
            @$query['AllowChange'] = $request->allowChange;
        }

        if (null !== $request->changeLevel) {
            @$query['ChangeLevel'] = $request->changeLevel;
        }

        if (null !== $request->dbType) {
            @$query['DbType'] = $request->dbType;
        }

        if (null !== $request->insName) {
            @$query['InsName'] = $request->insName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->productId) {
            @$query['ProductId'] = $request->productId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeActiveOperationTasks',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeActiveOperationTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about scheduled O\\\\\\\\\\\\\\\\\\\\&M tasks for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeActiveOperationTasksRequest
     *
     * @returns DescribeActiveOperationTasksResponse
     *
     * @param DescribeActiveOperationTasksRequest $request
     *
     * @return DescribeActiveOperationTasksResponse
     */
    public function describeActiveOperationTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeActiveOperationTasksWithOptions($request, $runtime);
    }

    /**
     * Queries whitelist templates at a time by using fuzzy search.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeAllWhitelistTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAllWhitelistTemplateResponse
     *
     * @param DescribeAllWhitelistTemplateRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeAllWhitelistTemplateResponse
     */
    public function describeAllWhitelistTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fuzzySearch) {
            @$query['FuzzySearch'] = $request->fuzzySearch;
        }

        if (null !== $request->maxRecordsPerPage) {
            @$query['MaxRecordsPerPage'] = $request->maxRecordsPerPage;
        }

        if (null !== $request->pageNumbers) {
            @$query['PageNumbers'] = $request->pageNumbers;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->templateName) {
            @$query['TemplateName'] = $request->templateName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAllWhitelistTemplate',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAllWhitelistTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries whitelist templates at a time by using fuzzy search.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeAllWhitelistTemplateRequest
     *
     * @returns DescribeAllWhitelistTemplateResponse
     *
     * @param DescribeAllWhitelistTemplateRequest $request
     *
     * @return DescribeAllWhitelistTemplateResponse
     */
    public function describeAllWhitelistTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAllWhitelistTemplateWithOptions($request, $runtime);
    }

    /**
     * Queries the number of analytic instances that are associated with an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * [Create and view an analytic instance](https://help.aliyun.com/document_detail/155180.html)
     *
     * @param request - DescribeAnalyticdbByPrimaryDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAnalyticdbByPrimaryDBInstanceResponse
     *
     * @param DescribeAnalyticdbByPrimaryDBInstanceRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return DescribeAnalyticdbByPrimaryDBInstanceResponse
     */
    public function describeAnalyticdbByPrimaryDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAnalyticdbByPrimaryDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAnalyticdbByPrimaryDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of analytic instances that are associated with an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * [Create and view an analytic instance](https://help.aliyun.com/document_detail/155180.html)
     *
     * @param request - DescribeAnalyticdbByPrimaryDBInstanceRequest
     *
     * @returns DescribeAnalyticdbByPrimaryDBInstanceResponse
     *
     * @param DescribeAnalyticdbByPrimaryDBInstanceRequest $request
     *
     * @return DescribeAnalyticdbByPrimaryDBInstanceResponse
     */
    public function describeAnalyticdbByPrimaryDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAnalyticdbByPrimaryDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Queries the specifications that are supported for an instance. The specifications include the instance type and the storage capacity.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeAvailableClassesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAvailableClassesResponse
     *
     * @param DescribeAvailableClassesRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeAvailableClassesResponse
     */
    public function describeAvailableClassesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->orderType) {
            @$query['OrderType'] = $request->orderType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAvailableClasses',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAvailableClassesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the specifications that are supported for an instance. The specifications include the instance type and the storage capacity.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeAvailableClassesRequest
     *
     * @returns DescribeAvailableClassesResponse
     *
     * @param DescribeAvailableClassesRequest $request
     *
     * @return DescribeAvailableClassesResponse
     */
    public function describeAvailableClasses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAvailableClassesWithOptions($request, $runtime);
    }

    /**
     * Queries the available destination regions to which the cross-region backup files from a specific source region can be replicated.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - DescribeAvailableCrossRegionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAvailableCrossRegionResponse
     *
     * @param DescribeAvailableCrossRegionRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeAvailableCrossRegionResponse
     */
    public function describeAvailableCrossRegionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAvailableCrossRegion',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAvailableCrossRegionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the available destination regions to which the cross-region backup files from a specific source region can be replicated.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - DescribeAvailableCrossRegionRequest
     *
     * @returns DescribeAvailableCrossRegionResponse
     *
     * @param DescribeAvailableCrossRegionRequest $request
     *
     * @return DescribeAvailableCrossRegionResponse
     */
    public function describeAvailableCrossRegion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAvailableCrossRegionWithOptions($request, $runtime);
    }

    /**
     * Queries all Enhanced Monitoring metrics that are supported by an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [View the Enhanced Monitoring metrics](https://help.aliyun.com/document_detail/299200.html)
     *
     * @param request - DescribeAvailableMetricsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAvailableMetricsResponse
     *
     * @param DescribeAvailableMetricsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeAvailableMetricsResponse
     */
    public function describeAvailableMetricsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAvailableMetrics',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAvailableMetricsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all Enhanced Monitoring metrics that are supported by an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [View the Enhanced Monitoring metrics](https://help.aliyun.com/document_detail/299200.html)
     *
     * @param request - DescribeAvailableMetricsRequest
     *
     * @returns DescribeAvailableMetricsResponse
     *
     * @param DescribeAvailableMetricsRequest $request
     *
     * @return DescribeAvailableMetricsResponse
     */
    public function describeAvailableMetrics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAvailableMetricsWithOptions($request, $runtime);
    }

    /**
     * Queries the time range within which data can be restored from a cross-region backup file.
     *
     * @remarks
     * >  To view the time range within which you can restore data from a standard backup set, see DescribeBackups.
     * ### [](#)Supported database engines
     * ApsaraDB RDS for MySQL instances with local disks
     * ### [](#)References
     * >  Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the cross-region backup feature](https://help.aliyun.com/document_detail/120824.html)
     *
     * @param request - DescribeAvailableRecoveryTimeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAvailableRecoveryTimeResponse
     *
     * @param DescribeAvailableRecoveryTimeRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeAvailableRecoveryTimeResponse
     */
    public function describeAvailableRecoveryTimeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->crossBackupId) {
            @$query['CrossBackupId'] = $request->crossBackupId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAvailableRecoveryTime',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAvailableRecoveryTimeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the time range within which data can be restored from a cross-region backup file.
     *
     * @remarks
     * >  To view the time range within which you can restore data from a standard backup set, see DescribeBackups.
     * ### [](#)Supported database engines
     * ApsaraDB RDS for MySQL instances with local disks
     * ### [](#)References
     * >  Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the cross-region backup feature](https://help.aliyun.com/document_detail/120824.html)
     *
     * @param request - DescribeAvailableRecoveryTimeRequest
     *
     * @returns DescribeAvailableRecoveryTimeResponse
     *
     * @param DescribeAvailableRecoveryTimeRequest $request
     *
     * @return DescribeAvailableRecoveryTimeResponse
     */
    public function describeAvailableRecoveryTime($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAvailableRecoveryTimeWithOptions($request, $runtime);
    }

    /**
     * Queries the available zones for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * > You can call this operation to query the available zones for an instance. The query result may be different from the zones available on the buy page of the ApsaraDB RDS console. The values of some parameters on the buy page vary based on the actual sales policy. The actual information on the [buy page](https://rdsbuy.console.aliyun.com/create/rds/PostgreSQL) prevails.
     *
     * @param request - DescribeAvailableZonesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeAvailableZonesResponse
     *
     * @param DescribeAvailableZonesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeAvailableZonesResponse
     */
    public function describeAvailableZonesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->dispenseMode) {
            @$query['DispenseMode'] = $request->dispenseMode;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeAvailableZones',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeAvailableZonesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the available zones for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * > You can call this operation to query the available zones for an instance. The query result may be different from the zones available on the buy page of the ApsaraDB RDS console. The values of some parameters on the buy page vary based on the actual sales policy. The actual information on the [buy page](https://rdsbuy.console.aliyun.com/create/rds/PostgreSQL) prevails.
     *
     * @param request - DescribeAvailableZonesRequest
     *
     * @returns DescribeAvailableZonesResponse
     *
     * @param DescribeAvailableZonesRequest $request
     *
     * @return DescribeAvailableZonesResponse
     */
    public function describeAvailableZones($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeAvailableZonesWithOptions($request, $runtime);
    }

    /**
     * Queries the databases that are involved in a backup file.
     *
     * @remarks
     * > This operation is phased out.
     *
     * @param request - DescribeBackupDatabaseRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupDatabaseResponse
     *
     * @param DescribeBackupDatabaseRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeBackupDatabaseResponse
     */
    public function describeBackupDatabaseWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackupDatabase',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupDatabaseResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the databases that are involved in a backup file.
     *
     * @remarks
     * > This operation is phased out.
     *
     * @param request - DescribeBackupDatabaseRequest
     *
     * @returns DescribeBackupDatabaseResponse
     *
     * @param DescribeBackupDatabaseRequest $request
     *
     * @return DescribeBackupDatabaseResponse
     */
    public function describeBackupDatabase($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupDatabaseWithOptions($request, $runtime);
    }

    /**
     * Queries the backup settings of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupPolicyResponse
     *
     * @param DescribeBackupPolicyRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeBackupPolicyResponse
     */
    public function describeBackupPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupPolicyMode) {
            @$query['BackupPolicyMode'] = $request->backupPolicyMode;
        }

        if (null !== $request->compressType) {
            @$query['CompressType'] = $request->compressType;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->releasedKeepPolicy) {
            @$query['ReleasedKeepPolicy'] = $request->releasedKeepPolicy;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackupPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the backup settings of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeBackupPolicyRequest
     *
     * @returns DescribeBackupPolicyResponse
     *
     * @param DescribeBackupPolicyRequest $request
     *
     * @return DescribeBackupPolicyResponse
     */
    public function describeBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Queries the backup tasks of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeBackupTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupTasksResponse
     *
     * @param DescribeBackupTasksRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeBackupTasksResponse
     */
    public function describeBackupTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupJobId) {
            @$query['BackupJobId'] = $request->backupJobId;
        }

        if (null !== $request->backupJobStatus) {
            @$query['BackupJobStatus'] = $request->backupJobStatus;
        }

        if (null !== $request->backupMode) {
            @$query['BackupMode'] = $request->backupMode;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->flag) {
            @$query['Flag'] = $request->flag;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackupTasks',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the backup tasks of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeBackupTasksRequest
     *
     * @returns DescribeBackupTasksResponse
     *
     * @param DescribeBackupTasksRequest $request
     *
     * @return DescribeBackupTasksResponse
     */
    public function describeBackupTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupTasksWithOptions($request, $runtime);
    }

    /**
     * Queries the data backup files of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeBackupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBackupsResponse
     *
     * @param DescribeBackupsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeBackupsResponse
     */
    public function describeBackupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->backupMode) {
            @$query['BackupMode'] = $request->backupMode;
        }

        if (null !== $request->backupStatus) {
            @$query['BackupStatus'] = $request->backupStatus;
        }

        if (null !== $request->backupType) {
            @$query['BackupType'] = $request->backupType;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBackups',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBackupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the data backup files of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeBackupsRequest
     *
     * @returns DescribeBackupsResponse
     *
     * @param DescribeBackupsRequest $request
     *
     * @return DescribeBackupsResponse
     */
    public function describeBackups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBackupsWithOptions($request, $runtime);
    }

    /**
     * Queries the binary log files of an instance that runs MySQL or MariaDB or the write-ahead logging (WAL) files of an instance that runs PostgreSQL.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   MariaDB
     * ### Usage notes
     * *   If the return value of the **DownloadLink** parameter is NULL, ApsaraDB RDS does not provide a download URL.
     * *   If the return value of the **DownloadLink** parameter is not NULL, ApsaraDB RDS provides a URL for you to download backup files. The expiration time of the URL is specified by the **LinkExpiredTime** parameter. You must download the backup files before the expiration time.
     * *   If you use a RAM user to download backup files, you must grant permissions to the RAM user. For more information, see [Grant backup file download permissions to a RAM user with read-only permissions](https://help.aliyun.com/document_detail/100043.html).
     * *   Each log file that is returned by this operation contains the log entries that are generated over the time range that is specified by the StartTime and EndTime parameters.
     *
     * @param request - DescribeBinlogFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeBinlogFilesResponse
     *
     * @param DescribeBinlogFilesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeBinlogFilesResponse
     */
    public function describeBinlogFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeBinlogFiles',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeBinlogFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the binary log files of an instance that runs MySQL or MariaDB or the write-ahead logging (WAL) files of an instance that runs PostgreSQL.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   MariaDB
     * ### Usage notes
     * *   If the return value of the **DownloadLink** parameter is NULL, ApsaraDB RDS does not provide a download URL.
     * *   If the return value of the **DownloadLink** parameter is not NULL, ApsaraDB RDS provides a URL for you to download backup files. The expiration time of the URL is specified by the **LinkExpiredTime** parameter. You must download the backup files before the expiration time.
     * *   If you use a RAM user to download backup files, you must grant permissions to the RAM user. For more information, see [Grant backup file download permissions to a RAM user with read-only permissions](https://help.aliyun.com/document_detail/100043.html).
     * *   Each log file that is returned by this operation contains the log entries that are generated over the time range that is specified by the StartTime and EndTime parameters.
     *
     * @param request - DescribeBinlogFilesRequest
     *
     * @returns DescribeBinlogFilesResponse
     *
     * @param DescribeBinlogFilesRequest $request
     *
     * @return DescribeBinlogFilesResponse
     */
    public function describeBinlogFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeBinlogFilesWithOptions($request, $runtime);
    }

    /**
     * Queries the character sets that are supported by an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeCharacterSetNameRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCharacterSetNameResponse
     *
     * @param DescribeCharacterSetNameRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeCharacterSetNameResponse
     */
    public function describeCharacterSetNameWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCharacterSetName',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCharacterSetNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the character sets that are supported by an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeCharacterSetNameRequest
     *
     * @returns DescribeCharacterSetNameResponse
     *
     * @param DescribeCharacterSetNameRequest $request
     *
     * @return DescribeCharacterSetNameResponse
     */
    public function describeCharacterSetName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCharacterSetNameWithOptions($request, $runtime);
    }

    /**
     * Queries the details about the instance types of an instance by using the code of the instance types.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeClassDetailsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeClassDetailsResponse
     *
     * @param DescribeClassDetailsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeClassDetailsResponse
     */
    public function describeClassDetailsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->classCode) {
            @$query['ClassCode'] = $request->classCode;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeClassDetails',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeClassDetailsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the instance types of an instance by using the code of the instance types.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeClassDetailsRequest
     *
     * @returns DescribeClassDetailsResponse
     *
     * @param DescribeClassDetailsRequest $request
     *
     * @return DescribeClassDetailsResponse
     */
    public function describeClassDetails($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeClassDetailsWithOptions($request, $runtime);
    }

    /**
     * Query the details about the assessment report for cloud migration to an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     *
     * @param request - DescribeCloudMigrationPrecheckResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCloudMigrationPrecheckResultResponse
     *
     * @param DescribeCloudMigrationPrecheckResultRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DescribeCloudMigrationPrecheckResultResponse
     */
    public function describeCloudMigrationPrecheckResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIpAddress) {
            @$query['SourceIpAddress'] = $request->sourceIpAddress;
        }

        if (null !== $request->sourcePort) {
            @$query['SourcePort'] = $request->sourcePort;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCloudMigrationPrecheckResult',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCloudMigrationPrecheckResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Query the details about the assessment report for cloud migration to an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     *
     * @param request - DescribeCloudMigrationPrecheckResultRequest
     *
     * @returns DescribeCloudMigrationPrecheckResultResponse
     *
     * @param DescribeCloudMigrationPrecheckResultRequest $request
     *
     * @return DescribeCloudMigrationPrecheckResultResponse
     */
    public function describeCloudMigrationPrecheckResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudMigrationPrecheckResultWithOptions($request, $runtime);
    }

    /**
     * Queries the details about the cloud migration task of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     *
     * @param request - DescribeCloudMigrationResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCloudMigrationResultResponse
     *
     * @param DescribeCloudMigrationResultRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeCloudMigrationResultResponse
     */
    public function describeCloudMigrationResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sourceIpAddress) {
            @$query['SourceIpAddress'] = $request->sourceIpAddress;
        }

        if (null !== $request->sourcePort) {
            @$query['SourcePort'] = $request->sourcePort;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCloudMigrationResult',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCloudMigrationResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the cloud migration task of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     *
     * @param request - DescribeCloudMigrationResultRequest
     *
     * @returns DescribeCloudMigrationResultResponse
     *
     * @param DescribeCloudMigrationResultRequest $request
     *
     * @return DescribeCloudMigrationResultResponse
     */
    public function describeCloudMigrationResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCloudMigrationResultWithOptions($request, $runtime);
    }

    /**
     * Queries the character set collations and time zones that are available for use in ApsaraDB RDS for SQL Server.
     *
     * @remarks
     * ### Supported database engine
     * SQL Server
     *
     * @param request - DescribeCollationTimeZonesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCollationTimeZonesResponse
     *
     * @param DescribeCollationTimeZonesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeCollationTimeZonesResponse
     */
    public function describeCollationTimeZonesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCollationTimeZones',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCollationTimeZonesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the character set collations and time zones that are available for use in ApsaraDB RDS for SQL Server.
     *
     * @remarks
     * ### Supported database engine
     * SQL Server
     *
     * @param request - DescribeCollationTimeZonesRequest
     *
     * @returns DescribeCollationTimeZonesResponse
     *
     * @param DescribeCollationTimeZonesRequest $request
     *
     * @return DescribeCollationTimeZonesResponse
     */
    public function describeCollationTimeZones($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCollationTimeZonesWithOptions($request, $runtime);
    }

    /**
     * Queries the databases and tables whose data is included in a cross-region backup file of an instance.
     *
     * @remarks
     * ApsaraDB RDS for MySQL instances support cross-region backup and restoration. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120824.html) and [Restore the data of an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120875.html).
     * Before you call this operation, make sure that the instance runs one of the following database engines:
     * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120824.html).
     * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](https://help.aliyun.com/document_detail/187923.html).
     * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html).
     *
     * @param request - DescribeCrossBackupMetaListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCrossBackupMetaListResponse
     *
     * @param DescribeCrossBackupMetaListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeCrossBackupMetaListResponse
     */
    public function describeCrossBackupMetaListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupSetId) {
            @$query['BackupSetId'] = $request->backupSetId;
        }

        if (null !== $request->getDbName) {
            @$query['GetDbName'] = $request->getDbName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageIndex) {
            @$query['PageIndex'] = $request->pageIndex;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pattern) {
            @$query['Pattern'] = $request->pattern;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCrossBackupMetaList',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCrossBackupMetaListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the databases and tables whose data is included in a cross-region backup file of an instance.
     *
     * @remarks
     * ApsaraDB RDS for MySQL instances support cross-region backup and restoration. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120824.html) and [Restore the data of an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120875.html).
     * Before you call this operation, make sure that the instance runs one of the following database engines:
     * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120824.html).
     * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](https://help.aliyun.com/document_detail/187923.html).
     * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html).
     *
     * @param request - DescribeCrossBackupMetaListRequest
     *
     * @returns DescribeCrossBackupMetaListResponse
     *
     * @param DescribeCrossBackupMetaListRequest $request
     *
     * @return DescribeCrossBackupMetaListResponse
     */
    public function describeCrossBackupMetaList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCrossBackupMetaListWithOptions($request, $runtime);
    }

    /**
     * Queries the instances for which the cross-region backup feature is enabled in a region and the cross-region backup settings of these instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - DescribeCrossRegionBackupDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCrossRegionBackupDBInstanceResponse
     *
     * @param DescribeCrossRegionBackupDBInstanceRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeCrossRegionBackupDBInstanceResponse
     */
    public function describeCrossRegionBackupDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCrossRegionBackupDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCrossRegionBackupDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the instances for which the cross-region backup feature is enabled in a region and the cross-region backup settings of these instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - DescribeCrossRegionBackupDBInstanceRequest
     *
     * @returns DescribeCrossRegionBackupDBInstanceResponse
     *
     * @param DescribeCrossRegionBackupDBInstanceRequest $request
     *
     * @return DescribeCrossRegionBackupDBInstanceResponse
     */
    public function describeCrossRegionBackupDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCrossRegionBackupDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Queries the cross-region data backup files of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   ApsaraDB RDS for MySQL instances with local disks
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * ### [](#)References
     * >  Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * >  For more information about how to query cross-region log backup files, see DescribeCrossRegionLogBackupFiles.
     *
     * @param request - DescribeCrossRegionBackupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCrossRegionBackupsResponse
     *
     * @param DescribeCrossRegionBackupsRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeCrossRegionBackupsResponse
     */
    public function describeCrossRegionBackupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->crossBackupId) {
            @$query['CrossBackupId'] = $request->crossBackupId;
        }

        if (null !== $request->crossBackupRegion) {
            @$query['CrossBackupRegion'] = $request->crossBackupRegion;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCrossRegionBackups',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCrossRegionBackupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the cross-region data backup files of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   ApsaraDB RDS for MySQL instances with local disks
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * ### [](#)References
     * >  Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * >  For more information about how to query cross-region log backup files, see DescribeCrossRegionLogBackupFiles.
     *
     * @param request - DescribeCrossRegionBackupsRequest
     *
     * @returns DescribeCrossRegionBackupsResponse
     *
     * @param DescribeCrossRegionBackupsRequest $request
     *
     * @return DescribeCrossRegionBackupsResponse
     */
    public function describeCrossRegionBackups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCrossRegionBackupsWithOptions($request, $runtime);
    }

    /**
     * Queries the cross-region log backup files of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * >  For more information about how to query cross-region data backup files, see [DescribeCrossRegionBackups](https://help.aliyun.com/document_detail/121733.html).
     *
     * @param request - DescribeCrossRegionLogBackupFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCrossRegionLogBackupFilesResponse
     *
     * @param DescribeCrossRegionLogBackupFilesRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeCrossRegionLogBackupFilesResponse
     */
    public function describeCrossRegionLogBackupFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->crossBackupRegion) {
            @$query['CrossBackupRegion'] = $request->crossBackupRegion;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCrossRegionLogBackupFiles',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCrossRegionLogBackupFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the cross-region log backup files of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * >  For more information about how to query cross-region data backup files, see [DescribeCrossRegionBackups](https://help.aliyun.com/document_detail/121733.html).
     *
     * @param request - DescribeCrossRegionLogBackupFilesRequest
     *
     * @returns DescribeCrossRegionLogBackupFilesResponse
     *
     * @param DescribeCrossRegionLogBackupFilesRequest $request
     *
     * @return DescribeCrossRegionLogBackupFilesResponse
     */
    public function describeCrossRegionLogBackupFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCrossRegionLogBackupFilesWithOptions($request, $runtime);
    }

    /**
     * 查询实例最新变配订单.
     *
     * @param request - DescribeCurrentModifyOrderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCurrentModifyOrderResponse
     *
     * @param DescribeCurrentModifyOrderRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeCurrentModifyOrderResponse
     */
    public function describeCurrentModifyOrderWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dbInstanceId) {
            @$query['DbInstanceId'] = $request->dbInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCurrentModifyOrder',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCurrentModifyOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 查询实例最新变配订单.
     *
     * @param request - DescribeCurrentModifyOrderRequest
     *
     * @returns DescribeCurrentModifyOrderResponse
     *
     * @param DescribeCurrentModifyOrderRequest $request
     *
     * @return DescribeCurrentModifyOrderResponse
     */
    public function describeCurrentModifyOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCurrentModifyOrderWithOptions($request, $runtime);
    }

    /**
     * 查询实例资源使用情况.
     *
     * @param request - DescribeCustinsResourceInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeCustinsResourceInfoResponse
     *
     * @param DescribeCustinsResourceInfoRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeCustinsResourceInfoResponse
     */
    public function describeCustinsResourceInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceIds) {
            @$query['DBInstanceIds'] = $request->DBInstanceIds;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeCustinsResourceInfo',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeCustinsResourceInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 查询实例资源使用情况.
     *
     * @param request - DescribeCustinsResourceInfoRequest
     *
     * @returns DescribeCustinsResourceInfoResponse
     *
     * @param DescribeCustinsResourceInfoRequest $request
     *
     * @return DescribeCustinsResourceInfoResponse
     */
    public function describeCustinsResourceInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeCustinsResourceInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeDBInstanceAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceAttributeResponse
     *
     * @param DescribeDBInstanceAttributeRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeDBInstanceAttributeResponse
     */
    public function describeDBInstanceAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->expired) {
            @$query['Expired'] = $request->expired;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceAttribute',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeDBInstanceAttributeRequest
     *
     * @returns DescribeDBInstanceAttributeResponse
     *
     * @param DescribeDBInstanceAttributeRequest $request
     *
     * @return DescribeDBInstanceAttributeResponse
     */
    public function describeDBInstanceAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries information about the tags that are added to an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstanceByTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceByTagsResponse
     *
     * @param DescribeDBInstanceByTagsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeDBInstanceByTagsResponse
     */
    public function describeDBInstanceByTagsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->proxyId) {
            @$query['proxyId'] = $request->proxyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceByTags',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceByTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the tags that are added to an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstanceByTagsRequest
     *
     * @returns DescribeDBInstanceByTagsResponse
     *
     * @param DescribeDBInstanceByTagsRequest $request
     *
     * @return DescribeDBInstanceByTagsResponse
     */
    public function describeDBInstanceByTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceByTagsWithOptions($request, $runtime);
    }

    /**
     * 获取实例链路诊断信息.
     *
     * @param request - DescribeDBInstanceConnectivityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceConnectivityResponse
     *
     * @param DescribeDBInstanceConnectivityRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeDBInstanceConnectivityResponse
     */
    public function describeDBInstanceConnectivityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceConnectivity',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceConnectivityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 获取实例链路诊断信息.
     *
     * @param request - DescribeDBInstanceConnectivityRequest
     *
     * @returns DescribeDBInstanceConnectivityResponse
     *
     * @param DescribeDBInstanceConnectivityRequest $request
     *
     * @return DescribeDBInstanceConnectivityResponse
     */
    public function describeDBInstanceConnectivity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceConnectivityWithOptions($request, $runtime);
    }

    /**
     * You can call the DescribeDBInstanceDetail operation to query the details of an instance.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - DescribeDBInstanceDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceDetailResponse
     *
     * @param DescribeDBInstanceDetailRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeDBInstanceDetailResponse
     */
    public function describeDBInstanceDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceDetail',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can call the DescribeDBInstanceDetail operation to query the details of an instance.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - DescribeDBInstanceDetailRequest
     *
     * @returns DescribeDBInstanceDetailResponse
     *
     * @param DescribeDBInstanceDetailRequest $request
     *
     * @return DescribeDBInstanceDetailResponse
     */
    public function describeDBInstanceDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceDetailWithOptions($request, $runtime);
    }

    /**
     * You can call the DescribeDBInstanceEncryptionKey operation to check whether disk encryption is enabled for an instance. You can also query details about the keys that are used for disk encryption. This operation is supported for instances that run MySQL, SQL Server, or PostgreSQL.
     *
     * @param request - DescribeDBInstanceEncryptionKeyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceEncryptionKeyResponse
     *
     * @param DescribeDBInstanceEncryptionKeyRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeDBInstanceEncryptionKeyResponse
     */
    public function describeDBInstanceEncryptionKeyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->encryptionKey) {
            @$query['EncryptionKey'] = $request->encryptionKey;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->targetRegionId) {
            @$query['TargetRegionId'] = $request->targetRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceEncryptionKey',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceEncryptionKeyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can call the DescribeDBInstanceEncryptionKey operation to check whether disk encryption is enabled for an instance. You can also query details about the keys that are used for disk encryption. This operation is supported for instances that run MySQL, SQL Server, or PostgreSQL.
     *
     * @param request - DescribeDBInstanceEncryptionKeyRequest
     *
     * @returns DescribeDBInstanceEncryptionKeyResponse
     *
     * @param DescribeDBInstanceEncryptionKeyRequest $request
     *
     * @return DescribeDBInstanceEncryptionKeyResponse
     */
    public function describeDBInstanceEncryptionKey($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceEncryptionKeyWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the endpoints of an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * MySQL
     *
     * @param request - DescribeDBInstanceEndpointsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceEndpointsResponse
     *
     * @param DescribeDBInstanceEndpointsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeDBInstanceEndpointsResponse
     */
    public function describeDBInstanceEndpointsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceEndpointId) {
            @$query['DBInstanceEndpointId'] = $request->DBInstanceEndpointId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceEndpoints',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceEndpointsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the endpoints of an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * MySQL
     *
     * @param request - DescribeDBInstanceEndpointsRequest
     *
     * @returns DescribeDBInstanceEndpointsResponse
     *
     * @param DescribeDBInstanceEndpointsRequest $request
     *
     * @return DescribeDBInstanceEndpointsResponse
     */
    public function describeDBInstanceEndpoints($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceEndpointsWithOptions($request, $runtime);
    }

    /**
     * Queries the high availability mode and data replication mode of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Query the data replication mode of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96055.html)
     * *   [Query the data replication mode of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/151265.html)
     * *   [Query the data replication mode of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/415433.html)
     *
     * @param request - DescribeDBInstanceHAConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceHAConfigResponse
     *
     * @param DescribeDBInstanceHAConfigRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeDBInstanceHAConfigResponse
     */
    public function describeDBInstanceHAConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceHAConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceHAConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the high availability mode and data replication mode of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Query the data replication mode of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96055.html)
     * *   [Query the data replication mode of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/151265.html)
     * *   [Query the data replication mode of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/415433.html)
     *
     * @param request - DescribeDBInstanceHAConfigRequest
     *
     * @returns DescribeDBInstanceHAConfigResponse
     *
     * @param DescribeDBInstanceHAConfigRequest $request
     *
     * @return DescribeDBInstanceHAConfigResponse
     */
    public function describeDBInstanceHAConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceHAConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the IP address whitelist of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeDBInstanceIPArrayListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceIPArrayListResponse
     *
     * @param DescribeDBInstanceIPArrayListRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeDBInstanceIPArrayListResponse
     */
    public function describeDBInstanceIPArrayListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->whitelistNetworkType) {
            @$query['WhitelistNetworkType'] = $request->whitelistNetworkType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceIPArrayList',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceIPArrayListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the IP address whitelist of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeDBInstanceIPArrayListRequest
     *
     * @returns DescribeDBInstanceIPArrayListResponse
     *
     * @param DescribeDBInstanceIPArrayListRequest $request
     *
     * @return DescribeDBInstanceIPArrayListResponse
     */
    public function describeDBInstanceIPArrayList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceIPArrayListWithOptions($request, $runtime);
    }

    /**
     * Queries the internal IP address and hostname of the Elastic Compute Service (ECS) instance on which the ApsaraDB RDS for SQL Server instance runs.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server
     * ### [](#)Prerequisites
     * *   The RDS instance runs RDS Basic Edition, RDS High-availability Edition, or RDS Cluster Edition. If your RDS instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
     * *   The RDS instance belongs to a general-purpose or dedicated instance family. The shared instance family is not supported.
     * *   If the RDS instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the Creation Time parameter of an instance in the Status section of the Basic Information page in the ApsaraDB RDS console.
     * ### [](#)References
     * >  Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure a distributed transaction whitelist](https://help.aliyun.com/document_detail/124321.html)
     * *   [Connect Kingdee K/3 WISE to an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/124188.html)
     *
     * @param request - DescribeDBInstanceIpHostnameRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceIpHostnameResponse
     *
     * @param DescribeDBInstanceIpHostnameRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeDBInstanceIpHostnameResponse
     */
    public function describeDBInstanceIpHostnameWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceIpHostname',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceIpHostnameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the internal IP address and hostname of the Elastic Compute Service (ECS) instance on which the ApsaraDB RDS for SQL Server instance runs.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server
     * ### [](#)Prerequisites
     * *   The RDS instance runs RDS Basic Edition, RDS High-availability Edition, or RDS Cluster Edition. If your RDS instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
     * *   The RDS instance belongs to a general-purpose or dedicated instance family. The shared instance family is not supported.
     * *   If the RDS instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the Creation Time parameter of an instance in the Status section of the Basic Information page in the ApsaraDB RDS console.
     * ### [](#)References
     * >  Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure a distributed transaction whitelist](https://help.aliyun.com/document_detail/124321.html)
     * *   [Connect Kingdee K/3 WISE to an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/124188.html)
     *
     * @param request - DescribeDBInstanceIpHostnameRequest
     *
     * @returns DescribeDBInstanceIpHostnameResponse
     *
     * @param DescribeDBInstanceIpHostnameRequest $request
     *
     * @return DescribeDBInstanceIpHostnameResponse
     */
    public function describeDBInstanceIpHostname($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceIpHostnameWithOptions($request, $runtime);
    }

    /**
     * Queries the Enhanced Monitoring metrics that are displayed for an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [View the Enhanced Monitoring metrics](https://help.aliyun.com/document_detail/299200.html)
     *
     * @param request - DescribeDBInstanceMetricsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceMetricsResponse
     *
     * @param DescribeDBInstanceMetricsRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeDBInstanceMetricsResponse
     */
    public function describeDBInstanceMetricsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceMetrics',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceMetricsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the Enhanced Monitoring metrics that are displayed for an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [View the Enhanced Monitoring metrics](https://help.aliyun.com/document_detail/299200.html)
     *
     * @param request - DescribeDBInstanceMetricsRequest
     *
     * @returns DescribeDBInstanceMetricsResponse
     *
     * @param DescribeDBInstanceMetricsRequest $request
     *
     * @return DescribeDBInstanceMetricsResponse
     */
    public function describeDBInstanceMetrics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceMetricsWithOptions($request, $runtime);
    }

    /**
     * Queries the monitoring frequency of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstanceMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceMonitorResponse
     *
     * @param DescribeDBInstanceMonitorRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeDBInstanceMonitorResponse
     */
    public function describeDBInstanceMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceMonitor',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the monitoring frequency of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstanceMonitorRequest
     *
     * @returns DescribeDBInstanceMonitorResponse
     *
     * @param DescribeDBInstanceMonitorRequest $request
     *
     * @return DescribeDBInstanceMonitorResponse
     */
    public function describeDBInstanceMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceMonitorWithOptions($request, $runtime);
    }

    /**
     * Queries all endpoints of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstanceNetInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceNetInfoResponse
     *
     * @param DescribeDBInstanceNetInfoRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeDBInstanceNetInfoResponse
     */
    public function describeDBInstanceNetInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceNetRWSplitType) {
            @$query['DBInstanceNetRWSplitType'] = $request->DBInstanceNetRWSplitType;
        }

        if (null !== $request->flag) {
            @$query['Flag'] = $request->flag;
        }

        if (null !== $request->generalGroupName) {
            @$query['GeneralGroupName'] = $request->generalGroupName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceNetInfo',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceNetInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all endpoints of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstanceNetInfoRequest
     *
     * @returns DescribeDBInstanceNetInfoResponse
     *
     * @param DescribeDBInstanceNetInfoRequest $request
     *
     * @return DescribeDBInstanceNetInfoResponse
     */
    public function describeDBInstanceNetInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceNetInfoWithOptions($request, $runtime);
    }

    /**
     * Queries all endpoints of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstanceNetInfoForChannelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceNetInfoForChannelResponse
     *
     * @param DescribeDBInstanceNetInfoForChannelRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeDBInstanceNetInfoForChannelResponse
     */
    public function describeDBInstanceNetInfoForChannelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceNetRWSplitType) {
            @$query['DBInstanceNetRWSplitType'] = $request->DBInstanceNetRWSplitType;
        }

        if (null !== $request->flag) {
            @$query['Flag'] = $request->flag;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceNetInfoForChannel',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceNetInfoForChannelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all endpoints of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstanceNetInfoForChannelRequest
     *
     * @returns DescribeDBInstanceNetInfoForChannelResponse
     *
     * @param DescribeDBInstanceNetInfoForChannelRequest $request
     *
     * @return DescribeDBInstanceNetInfoForChannelResponse
     */
    public function describeDBInstanceNetInfoForChannel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceNetInfoForChannelWithOptions($request, $runtime);
    }

    /**
     * Queries the performance metrics of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstancePerformanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstancePerformanceResponse
     *
     * @param DescribeDBInstancePerformanceRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeDBInstancePerformanceResponse
     */
    public function describeDBInstancePerformanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->key) {
            @$query['Key'] = $request->key;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstancePerformance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstancePerformanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the performance metrics of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstancePerformanceRequest
     *
     * @returns DescribeDBInstancePerformanceResponse
     *
     * @param DescribeDBInstancePerformanceRequest $request
     *
     * @return DescribeDBInstancePerformanceResponse
     */
    public function describeDBInstancePerformance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstancePerformanceWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * The operation is phased out.
     *
     * @deprecated OpenAPI DescribeDBInstancePromoteActivity is deprecated
     *
     * @param request - DescribeDBInstancePromoteActivityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstancePromoteActivityResponse
     *
     * @param DescribeDBInstancePromoteActivityRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeDBInstancePromoteActivityResponse
     */
    public function describeDBInstancePromoteActivityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliUid) {
            @$query['AliUid'] = $request->aliUid;
        }

        if (null !== $request->dbInstanceName) {
            @$query['DbInstanceName'] = $request->dbInstanceName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstancePromoteActivity',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstancePromoteActivityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * The operation is phased out.
     *
     * @deprecated OpenAPI DescribeDBInstancePromoteActivity is deprecated
     *
     * @param request - DescribeDBInstancePromoteActivityRequest
     *
     * @returns DescribeDBInstancePromoteActivityResponse
     *
     * @param DescribeDBInstancePromoteActivityRequest $request
     *
     * @return DescribeDBInstancePromoteActivityResponse
     */
    public function describeDBInstancePromoteActivity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstancePromoteActivityWithOptions($request, $runtime);
    }

    /**
     * Queries the settings of shared proxies that are enabled on an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Feature description
     * This operation is used to query the shared proxy settings of an instance that runs MySQL or the read/write splitting settings of an instance that runs SQL Server. For more information about how to query the dedicated proxy settings of an ApsaraDB RDS for MySQL instance, see [DescribeDBProxy](https://help.aliyun.com/document_detail/610506.html).
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The shared proxy feature must be enabled for the primary instance.
     * *   The read/write splitting feature must be enabled for the primary instance.
     *
     * @param request - DescribeDBInstanceProxyConfigurationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceProxyConfigurationResponse
     *
     * @param DescribeDBInstanceProxyConfigurationRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DescribeDBInstanceProxyConfigurationResponse
     */
    public function describeDBInstanceProxyConfigurationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceProxyConfiguration',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceProxyConfigurationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the settings of shared proxies that are enabled on an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Feature description
     * This operation is used to query the shared proxy settings of an instance that runs MySQL or the read/write splitting settings of an instance that runs SQL Server. For more information about how to query the dedicated proxy settings of an ApsaraDB RDS for MySQL instance, see [DescribeDBProxy](https://help.aliyun.com/document_detail/610506.html).
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The shared proxy feature must be enabled for the primary instance.
     * *   The read/write splitting feature must be enabled for the primary instance.
     *
     * @param request - DescribeDBInstanceProxyConfigurationRequest
     *
     * @returns DescribeDBInstanceProxyConfigurationResponse
     *
     * @param DescribeDBInstanceProxyConfigurationRequest $request
     *
     * @return DescribeDBInstanceProxyConfigurationResponse
     */
    public function describeDBInstanceProxyConfiguration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceProxyConfigurationWithOptions($request, $runtime);
    }

    /**
     * Queries the status and configurations of a native replication instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [ApsaraDB RDS for MySQL native replication instances](https://help.aliyun.com/document_detail/2856487.html)
     *
     * @param request - DescribeDBInstanceReplicationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceReplicationResponse
     *
     * @param DescribeDBInstanceReplicationRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeDBInstanceReplicationResponse
     */
    public function describeDBInstanceReplicationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceReplication',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceReplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status and configurations of a native replication instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [ApsaraDB RDS for MySQL native replication instances](https://help.aliyun.com/document_detail/2856487.html)
     *
     * @param request - DescribeDBInstanceReplicationRequest
     *
     * @returns DescribeDBInstanceReplicationResponse
     *
     * @param DescribeDBInstanceReplicationRequest $request
     *
     * @return DescribeDBInstanceReplicationResponse
     */
    public function describeDBInstanceReplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceReplicationWithOptions($request, $runtime);
    }

    /**
     * Queries the SSL configurations of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeDBInstanceSSLRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceSSLResponse
     *
     * @param DescribeDBInstanceSSLRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeDBInstanceSSLResponse
     */
    public function describeDBInstanceSSLWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceSSL',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceSSLResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the SSL configurations of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeDBInstanceSSLRequest
     *
     * @returns DescribeDBInstanceSSLResponse
     *
     * @param DescribeDBInstanceSSLRequest $request
     *
     * @return DescribeDBInstanceSSLResponse
     */
    public function describeDBInstanceSSL($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceSSLWithOptions($request, $runtime);
    }

    /**
     * Queries the security group rules that are configured for an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Configure security group settings for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - DescribeDBInstanceSecurityGroupRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceSecurityGroupRuleResponse
     *
     * @param DescribeDBInstanceSecurityGroupRuleRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return DescribeDBInstanceSecurityGroupRuleResponse
     */
    public function describeDBInstanceSecurityGroupRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceSecurityGroupRule',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceSecurityGroupRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the security group rules that are configured for an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Configure security group settings for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - DescribeDBInstanceSecurityGroupRuleRequest
     *
     * @returns DescribeDBInstanceSecurityGroupRuleResponse
     *
     * @param DescribeDBInstanceSecurityGroupRuleRequest $request
     *
     * @return DescribeDBInstanceSecurityGroupRuleResponse
     */
    public function describeDBInstanceSecurityGroupRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceSecurityGroupRuleWithOptions($request, $runtime);
    }

    /**
     * Queries the status of the Transparent Data Encryption (TDE) feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DescribeDBInstanceTDERequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstanceTDEResponse
     *
     * @param DescribeDBInstanceTDERequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeDBInstanceTDEResponse
     */
    public function describeDBInstanceTDEWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstanceTDE',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstanceTDEResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of the Transparent Data Encryption (TDE) feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DescribeDBInstanceTDERequest
     *
     * @returns DescribeDBInstanceTDEResponse
     *
     * @param DescribeDBInstanceTDERequest $request
     *
     * @return DescribeDBInstanceTDEResponse
     */
    public function describeDBInstanceTDE($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstanceTDEWithOptions($request, $runtime);
    }

    /**
     * Queries instances.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstancesResponse
     *
     * @param DescribeDBInstancesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeDBInstancesResponse
     */
    public function describeDBInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->connectionMode) {
            @$query['ConnectionMode'] = $request->connectionMode;
        }

        if (null !== $request->connectionString) {
            @$query['ConnectionString'] = $request->connectionString;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStatus) {
            @$query['DBInstanceStatus'] = $request->DBInstanceStatus;
        }

        if (null !== $request->DBInstanceType) {
            @$query['DBInstanceType'] = $request->DBInstanceType;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->dedicatedHostId) {
            @$query['DedicatedHostId'] = $request->dedicatedHostId;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->expired) {
            @$query['Expired'] = $request->expired;
        }

        if (null !== $request->filter) {
            @$query['Filter'] = $request->filter;
        }

        if (null !== $request->instanceLevel) {
            @$query['InstanceLevel'] = $request->instanceLevel;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->maxResults) {
            @$query['MaxResults'] = $request->maxResults;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->searchKey) {
            @$query['SearchKey'] = $request->searchKey;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        if (null !== $request->proxyId) {
            @$query['proxyId'] = $request->proxyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries instances.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDBInstancesRequest
     *
     * @returns DescribeDBInstancesResponse
     *
     * @param DescribeDBInstancesRequest $request
     *
     * @return DescribeDBInstancesResponse
     */
    public function describeDBInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstancesWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the instances.
     *
     * @remarks
     * >  The DescribeDBInstancesAsCsv operation is phased out. You can call the DescribeDBInstances operation.
     *
     * @deprecated openAPI DescribeDBInstancesAsCsv is deprecated, please use Rds::2014-08-15::DescribeDBInstances instead
     *
     * @param request - DescribeDBInstancesAsCsvRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstancesAsCsvResponse
     *
     * @param DescribeDBInstancesAsCsvRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeDBInstancesAsCsvResponse
     */
    public function describeDBInstancesAsCsvWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->cachedAsync) {
            @$query['CachedAsync'] = $request->cachedAsync;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->exportKey) {
            @$query['ExportKey'] = $request->exportKey;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstancesAsCsv',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstancesAsCsvResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the instances.
     *
     * @remarks
     * >  The DescribeDBInstancesAsCsv operation is phased out. You can call the DescribeDBInstances operation.
     *
     * @deprecated openAPI DescribeDBInstancesAsCsv is deprecated, please use Rds::2014-08-15::DescribeDBInstances instead
     *
     * @param request - DescribeDBInstancesAsCsvRequest
     *
     * @returns DescribeDBInstancesAsCsvResponse
     *
     * @param DescribeDBInstancesAsCsvRequest $request
     *
     * @return DescribeDBInstancesAsCsvResponse
     */
    public function describeDBInstancesAsCsv($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstancesAsCsvWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an ApsaraDB RDS instance based on the remaining subscription duration of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeDBInstancesByExpireTimeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstancesByExpireTimeResponse
     *
     * @param DescribeDBInstancesByExpireTimeRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeDBInstancesByExpireTimeResponse
     */
    public function describeDBInstancesByExpireTimeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->expirePeriod) {
            @$query['ExpirePeriod'] = $request->expirePeriod;
        }

        if (null !== $request->expired) {
            @$query['Expired'] = $request->expired;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->proxyId) {
            @$query['proxyId'] = $request->proxyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstancesByExpireTime',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstancesByExpireTimeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an ApsaraDB RDS instance based on the remaining subscription duration of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeDBInstancesByExpireTimeRequest
     *
     * @returns DescribeDBInstancesByExpireTimeResponse
     *
     * @param DescribeDBInstancesByExpireTimeRequest $request
     *
     * @return DescribeDBInstancesByExpireTimeResponse
     */
    public function describeDBInstancesByExpireTime($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstancesByExpireTimeWithOptions($request, $runtime);
    }

    /**
     * You can call the DescribeDBInstancePerformance operation to query the performance of instances.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - DescribeDBInstancesByPerformanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstancesByPerformanceResponse
     *
     * @param DescribeDBInstancesByPerformanceRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeDBInstancesByPerformanceResponse
     */
    public function describeDBInstancesByPerformanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sortKey) {
            @$query['SortKey'] = $request->sortKey;
        }

        if (null !== $request->sortMethod) {
            @$query['SortMethod'] = $request->sortMethod;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->proxyId) {
            @$query['proxyId'] = $request->proxyId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstancesByPerformance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstancesByPerformanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can call the DescribeDBInstancePerformance operation to query the performance of instances.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - DescribeDBInstancesByPerformanceRequest
     *
     * @returns DescribeDBInstancesByPerformanceResponse
     *
     * @param DescribeDBInstancesByPerformanceRequest $request
     *
     * @return DescribeDBInstancesByPerformanceResponse
     */
    public function describeDBInstancesByPerformance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstancesByPerformanceWithOptions($request, $runtime);
    }

    /**
     * Queries a list of instances.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - DescribeDBInstancesForCloneRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBInstancesForCloneResponse
     *
     * @param DescribeDBInstancesForCloneRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeDBInstancesForCloneResponse
     */
    public function describeDBInstancesForCloneWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->connectionMode) {
            @$query['ConnectionMode'] = $request->connectionMode;
        }

        if (null !== $request->currentInstanceId) {
            @$query['CurrentInstanceId'] = $request->currentInstanceId;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStatus) {
            @$query['DBInstanceStatus'] = $request->DBInstanceStatus;
        }

        if (null !== $request->DBInstanceType) {
            @$query['DBInstanceType'] = $request->DBInstanceType;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->expired) {
            @$query['Expired'] = $request->expired;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->nodeType) {
            @$query['NodeType'] = $request->nodeType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->searchKey) {
            @$query['SearchKey'] = $request->searchKey;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        if (null !== $request->proxyId) {
            @$query['proxyId'] = $request->proxyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBInstancesForClone',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBInstancesForCloneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of instances.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - DescribeDBInstancesForCloneRequest
     *
     * @returns DescribeDBInstancesForCloneResponse
     *
     * @param DescribeDBInstancesForCloneRequest $request
     *
     * @return DescribeDBInstancesForCloneResponse
     */
    public function describeDBInstancesForClone($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBInstancesForCloneWithOptions($request, $runtime);
    }

    /**
     * Queries minor engine versions that are available for an ApsaraDB RDS for MySQL instance or an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)Usage notes
     * Before you purchase or upgrade an instance that runs MySQL or PostgreSQL, you can call the DescribeDBMiniEngineVersions operation to query the minor engine versions that are available for the instance.
     *
     * @param request - DescribeDBMiniEngineVersionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBMiniEngineVersionsResponse
     *
     * @param DescribeDBMiniEngineVersionsRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeDBMiniEngineVersionsResponse
     */
    public function describeDBMiniEngineVersionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->minorVersionTag) {
            @$query['MinorVersionTag'] = $request->minorVersionTag;
        }

        if (null !== $request->nodeType) {
            @$query['NodeType'] = $request->nodeType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->storageType) {
            @$query['StorageType'] = $request->storageType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBMiniEngineVersions',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBMiniEngineVersionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries minor engine versions that are available for an ApsaraDB RDS for MySQL instance or an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)Usage notes
     * Before you purchase or upgrade an instance that runs MySQL or PostgreSQL, you can call the DescribeDBMiniEngineVersions operation to query the minor engine versions that are available for the instance.
     *
     * @param request - DescribeDBMiniEngineVersionsRequest
     *
     * @returns DescribeDBMiniEngineVersionsResponse
     *
     * @param DescribeDBMiniEngineVersionsRequest $request
     *
     * @return DescribeDBMiniEngineVersionsResponse
     */
    public function describeDBMiniEngineVersions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBMiniEngineVersionsWithOptions($request, $runtime);
    }

    /**
     * Queries the settings of the database proxy feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     *
     * @param request - DescribeDBProxyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBProxyResponse
     *
     * @param DescribeDBProxyRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeDBProxyResponse
     */
    public function describeDBProxyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBProxy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the settings of the database proxy feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     *
     * @param request - DescribeDBProxyRequest
     *
     * @returns DescribeDBProxyResponse
     *
     * @param DescribeDBProxyRequest $request
     *
     * @return DescribeDBProxyResponse
     */
    public function describeDBProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBProxyWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the database proxy endpoints of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     *
     * @param request - DescribeDBProxyEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBProxyEndpointResponse
     *
     * @param DescribeDBProxyEndpointRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeDBProxyEndpointResponse
     */
    public function describeDBProxyEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyConnectString) {
            @$query['DBProxyConnectString'] = $request->DBProxyConnectString;
        }

        if (null !== $request->DBProxyEndpointId) {
            @$query['DBProxyEndpointId'] = $request->DBProxyEndpointId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBProxyEndpoint',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBProxyEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the database proxy endpoints of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     *
     * @param request - DescribeDBProxyEndpointRequest
     *
     * @returns DescribeDBProxyEndpointResponse
     *
     * @param DescribeDBProxyEndpointRequest $request
     *
     * @return DescribeDBProxyEndpointResponse
     */
    public function describeDBProxyEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBProxyEndpointWithOptions($request, $runtime);
    }

    /**
     * Queries the performance data of the database proxy for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [View the monitoring data of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/194241.html)
     * *   [View the monitoring data of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418275.html)
     *
     * @param request - DescribeDBProxyPerformanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDBProxyPerformanceResponse
     *
     * @param DescribeDBProxyPerformanceRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeDBProxyPerformanceResponse
     */
    public function describeDBProxyPerformanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->DBProxyInstanceType) {
            @$query['DBProxyInstanceType'] = $request->DBProxyInstanceType;
        }

        if (null !== $request->dimension) {
            @$query['Dimension'] = $request->dimension;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->metricsName) {
            @$query['MetricsName'] = $request->metricsName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDBProxyPerformance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDBProxyPerformanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the performance data of the database proxy for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [View the monitoring data of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/194241.html)
     * *   [View the monitoring data of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418275.html)
     *
     * @param request - DescribeDBProxyPerformanceRequest
     *
     * @returns DescribeDBProxyPerformanceResponse
     *
     * @param DescribeDBProxyPerformanceRequest $request
     *
     * @return DescribeDBProxyPerformanceResponse
     */
    public function describeDBProxyPerformance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDBProxyPerformanceWithOptions($request, $runtime);
    }

    /**
     * Queries the distributed transaction whitelists of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Configures a distributed transaction whitelist for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/124321.html)
     *
     * @param request - DescribeDTCSecurityIpHostsForSQLServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDTCSecurityIpHostsForSQLServerResponse
     *
     * @param DescribeDTCSecurityIpHostsForSQLServerRequest $request
     * @param RuntimeOptions                                $runtime
     *
     * @return DescribeDTCSecurityIpHostsForSQLServerResponse
     */
    public function describeDTCSecurityIpHostsForSQLServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDTCSecurityIpHostsForSQLServer',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDTCSecurityIpHostsForSQLServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the distributed transaction whitelists of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Configures a distributed transaction whitelist for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/124321.html)
     *
     * @param request - DescribeDTCSecurityIpHostsForSQLServerRequest
     *
     * @returns DescribeDTCSecurityIpHostsForSQLServerResponse
     *
     * @param DescribeDTCSecurityIpHostsForSQLServerRequest $request
     *
     * @return DescribeDTCSecurityIpHostsForSQLServerResponse
     */
    public function describeDTCSecurityIpHostsForSQLServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDTCSecurityIpHostsForSQLServerWithOptions($request, $runtime);
    }

    /**
     * Queries the details about the databases on an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDatabasesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDatabasesResponse
     *
     * @param DescribeDatabasesRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeDatabasesResponse
     */
    public function describeDatabasesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->DBStatus) {
            @$query['DBStatus'] = $request->DBStatus;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDatabases',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDatabasesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the databases on an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeDatabasesRequest
     *
     * @returns DescribeDatabasesResponse
     *
     * @param DescribeDatabasesRequest $request
     *
     * @return DescribeDatabasesResponse
     */
    public function describeDatabases($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDatabasesWithOptions($request, $runtime);
    }

    /**
     * Queries information about an ApsaraDB MyBase dedicated cluster.
     *
     * @remarks
     * Dedicated clusters allow you to manage a number of instances in a cluster at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](https://help.aliyun.com/document_detail/141455.html)
     *
     * @param request - DescribeDedicatedHostGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDedicatedHostGroupsResponse
     *
     * @param DescribeDedicatedHostGroupsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeDedicatedHostGroupsResponse
     */
    public function describeDedicatedHostGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->imageCategory) {
            @$query['ImageCategory'] = $request->imageCategory;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDedicatedHostGroups',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDedicatedHostGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about an ApsaraDB MyBase dedicated cluster.
     *
     * @remarks
     * Dedicated clusters allow you to manage a number of instances in a cluster at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](https://help.aliyun.com/document_detail/141455.html)
     *
     * @param request - DescribeDedicatedHostGroupsRequest
     *
     * @returns DescribeDedicatedHostGroupsResponse
     *
     * @param DescribeDedicatedHostGroupsRequest $request
     *
     * @return DescribeDedicatedHostGroupsResponse
     */
    public function describeDedicatedHostGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDedicatedHostGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the hosts in a dedicated cluster.
     *
     * @remarks
     * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](https://help.aliyun.com/document_detail/141455.html)
     *
     * @param request - DescribeDedicatedHostsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDedicatedHostsResponse
     *
     * @param DescribeDedicatedHostsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeDedicatedHostsResponse
     */
    public function describeDedicatedHostsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocationStatus) {
            @$query['AllocationStatus'] = $request->allocationStatus;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->dedicatedHostId) {
            @$query['DedicatedHostId'] = $request->dedicatedHostId;
        }

        if (null !== $request->hostStatus) {
            @$query['HostStatus'] = $request->hostStatus;
        }

        if (null !== $request->hostType) {
            @$query['HostType'] = $request->hostType;
        }

        if (null !== $request->orderId) {
            @$query['OrderId'] = $request->orderId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDedicatedHosts',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDedicatedHostsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the hosts in a dedicated cluster.
     *
     * @remarks
     * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](https://help.aliyun.com/document_detail/141455.html)
     *
     * @param request - DescribeDedicatedHostsRequest
     *
     * @returns DescribeDedicatedHostsResponse
     *
     * @param DescribeDedicatedHostsRequest $request
     *
     * @return DescribeDedicatedHostsResponse
     */
    public function describeDedicatedHosts($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDedicatedHostsWithOptions($request, $runtime);
    }

    /**
     * Queries the data backup files of an ApsaraDB RDS instance that is released.
     *
     * @remarks
     * ### Supported database engine
     * MySQL
     * > This operation is available only for instances that use local disks.
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * For more information about how to retain the data backup files of an instance after the instance is released, see [Configure automatic backup](https://help.aliyun.com/document_detail/98818.html).
     *
     * @param request - DescribeDetachedBackupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeDetachedBackupsResponse
     *
     * @param DescribeDetachedBackupsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeDetachedBackupsResponse
     */
    public function describeDetachedBackupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->backupMode) {
            @$query['BackupMode'] = $request->backupMode;
        }

        if (null !== $request->backupStatus) {
            @$query['BackupStatus'] = $request->backupStatus;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeDetachedBackups',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeDetachedBackupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the data backup files of an ApsaraDB RDS instance that is released.
     *
     * @remarks
     * ### Supported database engine
     * MySQL
     * > This operation is available only for instances that use local disks.
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * For more information about how to retain the data backup files of an instance after the instance is released, see [Configure automatic backup](https://help.aliyun.com/document_detail/98818.html).
     *
     * @param request - DescribeDetachedBackupsRequest
     *
     * @returns DescribeDetachedBackupsResponse
     *
     * @param DescribeDetachedBackupsRequest $request
     *
     * @return DescribeDetachedBackupsResponse
     */
    public function describeDetachedBackups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeDetachedBackupsWithOptions($request, $runtime);
    }

    /**
     * Queries the error logs of an instance over a specific time range.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeErrorLogsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeErrorLogsResponse
     *
     * @param DescribeErrorLogsRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeErrorLogsResponse
     */
    public function describeErrorLogsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeErrorLogs',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeErrorLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the error logs of an instance over a specific time range.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeErrorLogsRequest
     *
     * @returns DescribeErrorLogsResponse
     *
     * @param DescribeErrorLogsRequest $request
     *
     * @return DescribeErrorLogsResponse
     */
    public function describeErrorLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeErrorLogsWithOptions($request, $runtime);
    }

    /**
     * Queries historical events of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Historical events of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/129759.html)
     * *   [Historical events of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/131008.html)
     * *   [Historical events of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/131013.html)
     * *   [Historical events of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/131010.html)
     *
     * @param request - DescribeEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeEventsResponse
     *
     * @param DescribeEventsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DescribeEventsResponse
     */
    public function describeEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeEvents',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries historical events of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Historical events of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/129759.html)
     * *   [Historical events of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/131008.html)
     * *   [Historical events of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/131013.html)
     * *   [Historical events of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/131010.html)
     *
     * @param request - DescribeEventsRequest
     *
     * @returns DescribeEventsResponse
     *
     * @param DescribeEventsRequest $request
     *
     * @return DescribeEventsResponse
     */
    public function describeEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeEventsWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a global active database cluster or information about all global active database clusters in a region.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     *
     * @param request - DescribeGadInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeGadInstancesResponse
     *
     * @param DescribeGadInstancesRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeGadInstancesResponse
     */
    public function describeGadInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->gadInstanceName) {
            @$query['GadInstanceName'] = $request->gadInstanceName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeGadInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeGadInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a global active database cluster or information about all global active database clusters in a region.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     *
     * @param request - DescribeGadInstancesRequest
     *
     * @returns DescribeGadInstancesResponse
     *
     * @param DescribeGadInstancesRequest $request
     *
     * @return DescribeGadInstancesResponse
     */
    public function describeGadInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeGadInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries the availability check method of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * [What is availability detection?](https://help.aliyun.com/document_detail/207467.html)
     *
     * @param request - DescribeHADiagnoseConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHADiagnoseConfigResponse
     *
     * @param DescribeHADiagnoseConfigRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeHADiagnoseConfigResponse
     */
    public function describeHADiagnoseConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHADiagnoseConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHADiagnoseConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the availability check method of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * [What is availability detection?](https://help.aliyun.com/document_detail/207467.html)
     *
     * @param request - DescribeHADiagnoseConfigRequest
     *
     * @returns DescribeHADiagnoseConfigResponse
     *
     * @param DescribeHADiagnoseConfigRequest $request
     *
     * @return DescribeHADiagnoseConfigResponse
     */
    public function describeHADiagnoseConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHADiagnoseConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the settings of the automatic primary/secondary switchover feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeHASwitchConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHASwitchConfigResponse
     *
     * @param DescribeHASwitchConfigRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeHASwitchConfigResponse
     */
    public function describeHASwitchConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHASwitchConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHASwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the settings of the automatic primary/secondary switchover feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeHASwitchConfigRequest
     *
     * @returns DescribeHASwitchConfigResponse
     *
     * @param DescribeHASwitchConfigRequest $request
     *
     * @return DescribeHASwitchConfigResponse
     */
    public function describeHASwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHASwitchConfigWithOptions($request, $runtime);
    }

    /**
     * Queries historical events in the event center.
     *
     * @param request - DescribeHistoryEventsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHistoryEventsResponse
     *
     * @param DescribeHistoryEventsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeHistoryEventsResponse
     */
    public function describeHistoryEventsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->archiveStatus) {
            @$query['ArchiveStatus'] = $request->archiveStatus;
        }

        if (null !== $request->eventCategory) {
            @$query['EventCategory'] = $request->eventCategory;
        }

        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->eventLevel) {
            @$query['EventLevel'] = $request->eventLevel;
        }

        if (null !== $request->eventStatus) {
            @$query['EventStatus'] = $request->eventStatus;
        }

        if (null !== $request->eventType) {
            @$query['EventType'] = $request->eventType;
        }

        if (null !== $request->fromStartTime) {
            @$query['FromStartTime'] = $request->fromStartTime;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->toStartTime) {
            @$query['ToStartTime'] = $request->toStartTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHistoryEvents',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHistoryEventsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries historical events in the event center.
     *
     * @param request - DescribeHistoryEventsRequest
     *
     * @returns DescribeHistoryEventsResponse
     *
     * @param DescribeHistoryEventsRequest $request
     *
     * @return DescribeHistoryEventsResponse
     */
    public function describeHistoryEvents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHistoryEventsWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics of historical events in the event center.
     *
     * @param request - DescribeHistoryEventsStatRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHistoryEventsStatResponse
     *
     * @param DescribeHistoryEventsStatRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeHistoryEventsStatResponse
     */
    public function describeHistoryEventsStatWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->archiveStatus) {
            @$query['ArchiveStatus'] = $request->archiveStatus;
        }

        if (null !== $request->fromStartTime) {
            @$query['FromStartTime'] = $request->fromStartTime;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->toStartTime) {
            @$query['ToStartTime'] = $request->toStartTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHistoryEventsStat',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHistoryEventsStatResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics of historical events in the event center.
     *
     * @param request - DescribeHistoryEventsStatRequest
     *
     * @returns DescribeHistoryEventsStatResponse
     *
     * @param DescribeHistoryEventsStatRequest $request
     *
     * @return DescribeHistoryEventsStatResponse
     */
    public function describeHistoryEventsStat($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHistoryEventsStatWithOptions($request, $runtime);
    }

    /**
     * Queries the historical tasks that are created within 30 days.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Tasks of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/474275.html)
     * *   [Tasks of an ApsaraDB RDS for PostrgreSQL instance](https://help.aliyun.com/document_detail/474537.html)
     * *   [Tasks of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/614826.html)
     *
     * @param request - DescribeHistoryTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHistoryTasksResponse
     *
     * @param DescribeHistoryTasksRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeHistoryTasksResponse
     */
    public function describeHistoryTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fromExecTime) {
            @$query['FromExecTime'] = $request->fromExecTime;
        }

        if (null !== $request->fromStartTime) {
            @$query['FromStartTime'] = $request->fromStartTime;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        if (null !== $request->toExecTime) {
            @$query['ToExecTime'] = $request->toExecTime;
        }

        if (null !== $request->toStartTime) {
            @$query['ToStartTime'] = $request->toStartTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHistoryTasks',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHistoryTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the historical tasks that are created within 30 days.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Tasks of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/474275.html)
     * *   [Tasks of an ApsaraDB RDS for PostrgreSQL instance](https://help.aliyun.com/document_detail/474537.html)
     * *   [Tasks of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/614826.html)
     *
     * @param request - DescribeHistoryTasksRequest
     *
     * @returns DescribeHistoryTasksResponse
     *
     * @param DescribeHistoryTasksRequest $request
     *
     * @return DescribeHistoryTasksResponse
     */
    public function describeHistoryTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHistoryTasksWithOptions($request, $runtime);
    }

    /**
     * Collects tasks in the task center.
     *
     * @param request - DescribeHistoryTasksStatRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHistoryTasksStatResponse
     *
     * @param DescribeHistoryTasksStatRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeHistoryTasksStatResponse
     */
    public function describeHistoryTasksStatWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fromExecTime) {
            @$query['FromExecTime'] = $request->fromExecTime;
        }

        if (null !== $request->fromStartTime) {
            @$query['FromStartTime'] = $request->fromStartTime;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        if (null !== $request->toExecTime) {
            @$query['ToExecTime'] = $request->toExecTime;
        }

        if (null !== $request->toStartTime) {
            @$query['ToStartTime'] = $request->toStartTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHistoryTasksStat',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHistoryTasksStatResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Collects tasks in the task center.
     *
     * @param request - DescribeHistoryTasksStatRequest
     *
     * @returns DescribeHistoryTasksStatResponse
     *
     * @param DescribeHistoryTasksStatRequest $request
     *
     * @return DescribeHistoryTasksStatResponse
     */
    public function describeHistoryTasksStat($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHistoryTasksStatWithOptions($request, $runtime);
    }

    /**
     * 查询主机组弹性策略参数.
     *
     * @param request - DescribeHostGroupElasticStrategyParametersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHostGroupElasticStrategyParametersResponse
     *
     * @param DescribeHostGroupElasticStrategyParametersRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return DescribeHostGroupElasticStrategyParametersResponse
     */
    public function describeHostGroupElasticStrategyParametersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dedicatedHostGroupName) {
            @$query['DedicatedHostGroupName'] = $request->dedicatedHostGroupName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHostGroupElasticStrategyParameters',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHostGroupElasticStrategyParametersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 查询主机组弹性策略参数.
     *
     * @param request - DescribeHostGroupElasticStrategyParametersRequest
     *
     * @returns DescribeHostGroupElasticStrategyParametersResponse
     *
     * @param DescribeHostGroupElasticStrategyParametersRequest $request
     *
     * @return DescribeHostGroupElasticStrategyParametersResponse
     */
    public function describeHostGroupElasticStrategyParameters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHostGroupElasticStrategyParametersWithOptions($request, $runtime);
    }

    /**
     * Queries the webshell URL that is used to connect to the host of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     * ### [](#)Prerequisite
     * *   The instance meets the following requirements:
     *     *   The instance resides in a region other than the China (Zhangjiakou) region.
     *     *   The instance runs RDS Basic Edition, RDS Cluster Edition, or RDS High-availability Edition. If your instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
     *     *   The instance belongs to the general-purpose or dedicated instance family. The shared instance family is not supported.
     *     *   The instance resides in a virtual private cloud (VPC). For more information about how to change the network type of an RDS instance, see [Change the network type](https://help.aliyun.com/document_detail/95707.html).
     *     *   If the instance runs RDS High-availability Edition or RDS Cluster Edition, the instance is created on or after January 1, 2021. If the instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the **Creation Time** parameter of an instance in the **Status** section of the **Basic Information** page in the ApsaraDB RDS console.
     * *   Your **Alibaba Cloud account** is used for logons.
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Create a host account and use the host account for logons](https://help.aliyun.com/document_detail/354862.html)
     *
     * @param request - DescribeHostWebShellRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeHostWebShellResponse
     *
     * @param DescribeHostWebShellRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeHostWebShellResponse
     */
    public function describeHostWebShellWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->accountPassword) {
            @$query['AccountPassword'] = $request->accountPassword;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionID) {
            @$query['RegionID'] = $request->regionID;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeHostWebShell',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeHostWebShellResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the webshell URL that is used to connect to the host of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     * ### [](#)Prerequisite
     * *   The instance meets the following requirements:
     *     *   The instance resides in a region other than the China (Zhangjiakou) region.
     *     *   The instance runs RDS Basic Edition, RDS Cluster Edition, or RDS High-availability Edition. If your instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
     *     *   The instance belongs to the general-purpose or dedicated instance family. The shared instance family is not supported.
     *     *   The instance resides in a virtual private cloud (VPC). For more information about how to change the network type of an RDS instance, see [Change the network type](https://help.aliyun.com/document_detail/95707.html).
     *     *   If the instance runs RDS High-availability Edition or RDS Cluster Edition, the instance is created on or after January 1, 2021. If the instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the **Creation Time** parameter of an instance in the **Status** section of the **Basic Information** page in the ApsaraDB RDS console.
     * *   Your **Alibaba Cloud account** is used for logons.
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Create a host account and use the host account for logons](https://help.aliyun.com/document_detail/354862.html)
     *
     * @param request - DescribeHostWebShellRequest
     *
     * @returns DescribeHostWebShellResponse
     *
     * @param DescribeHostWebShellRequest $request
     *
     * @return DescribeHostWebShellResponse
     */
    public function describeHostWebShell($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeHostWebShellWithOptions($request, $runtime);
    }

    /**
     * Queries the automatic renewal status of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeInstanceAutoRenewalAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstanceAutoRenewalAttributeResponse
     *
     * @param DescribeInstanceAutoRenewalAttributeRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return DescribeInstanceAutoRenewalAttributeResponse
     */
    public function describeInstanceAutoRenewalAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->proxyId) {
            @$query['proxyId'] = $request->proxyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstanceAutoRenewalAttribute',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstanceAutoRenewalAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the automatic renewal status of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeInstanceAutoRenewalAttributeRequest
     *
     * @returns DescribeInstanceAutoRenewalAttributeResponse
     *
     * @param DescribeInstanceAutoRenewalAttributeRequest $request
     *
     * @return DescribeInstanceAutoRenewalAttributeResponse
     */
    public function describeInstanceAutoRenewalAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceAutoRenewalAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries the cross-region backup settings of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - DescribeInstanceCrossBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstanceCrossBackupPolicyResponse
     *
     * @param DescribeInstanceCrossBackupPolicyRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeInstanceCrossBackupPolicyResponse
     */
    public function describeInstanceCrossBackupPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstanceCrossBackupPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstanceCrossBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the cross-region backup settings of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - DescribeInstanceCrossBackupPolicyRequest
     *
     * @returns DescribeInstanceCrossBackupPolicyResponse
     *
     * @param DescribeInstanceCrossBackupPolicyRequest $request
     *
     * @return DescribeInstanceCrossBackupPolicyResponse
     */
    public function describeInstanceCrossBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceCrossBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Queries the reserved keywords of an instance. The reserved keywords cannot be used for the usernames of accounts or the names of databases.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeInstanceKeywordsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstanceKeywordsResponse
     *
     * @param DescribeInstanceKeywordsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeInstanceKeywordsResponse
     */
    public function describeInstanceKeywordsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->key) {
            @$query['Key'] = $request->key;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstanceKeywords',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstanceKeywordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the reserved keywords of an instance. The reserved keywords cannot be used for the usernames of accounts or the names of databases.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - DescribeInstanceKeywordsRequest
     *
     * @returns DescribeInstanceKeywordsResponse
     *
     * @param DescribeInstanceKeywordsRequest $request
     *
     * @return DescribeInstanceKeywordsResponse
     */
    public function describeInstanceKeywords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceKeywordsWithOptions($request, $runtime);
    }

    /**
     * Queries associated whitelists by instance name.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeInstanceLinkedWhitelistTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeInstanceLinkedWhitelistTemplateResponse
     *
     * @param DescribeInstanceLinkedWhitelistTemplateRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return DescribeInstanceLinkedWhitelistTemplateResponse
     */
    public function describeInstanceLinkedWhitelistTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->insName) {
            @$query['InsName'] = $request->insName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeInstanceLinkedWhitelistTemplate',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeInstanceLinkedWhitelistTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries associated whitelists by instance name.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeInstanceLinkedWhitelistTemplateRequest
     *
     * @returns DescribeInstanceLinkedWhitelistTemplateResponse
     *
     * @param DescribeInstanceLinkedWhitelistTemplateRequest $request
     *
     * @return DescribeInstanceLinkedWhitelistTemplateResponse
     */
    public function describeInstanceLinkedWhitelistTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeInstanceLinkedWhitelistTemplateWithOptions($request, $runtime);
    }

    /**
     * Checks whether the specified resource of Key Management Service (KMS) is associated with an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DescribeKmsAssociateResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeKmsAssociateResourcesResponse
     *
     * @param DescribeKmsAssociateResourcesRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeKmsAssociateResourcesResponse
     */
    public function describeKmsAssociateResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->kmsResourceId) {
            @$query['KmsResourceId'] = $request->kmsResourceId;
        }

        if (null !== $request->kmsResourceRegionId) {
            @$query['KmsResourceRegionId'] = $request->kmsResourceRegionId;
        }

        if (null !== $request->kmsResourceType) {
            @$query['KmsResourceType'] = $request->kmsResourceType;
        }

        if (null !== $request->kmsResourceUser) {
            @$query['KmsResourceUser'] = $request->kmsResourceUser;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeKmsAssociateResources',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeKmsAssociateResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether the specified resource of Key Management Service (KMS) is associated with an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DescribeKmsAssociateResourcesRequest
     *
     * @returns DescribeKmsAssociateResourcesResponse
     *
     * @param DescribeKmsAssociateResourcesRequest $request
     *
     * @return DescribeKmsAssociateResourcesResponse
     */
    public function describeKmsAssociateResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeKmsAssociateResourcesWithOptions($request, $runtime);
    }

    /**
     * Queries the time range to which an RDS instance can be restored.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   MariaDB
     *
     * @param request - DescribeLocalAvailableRecoveryTimeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLocalAvailableRecoveryTimeResponse
     *
     * @param DescribeLocalAvailableRecoveryTimeRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeLocalAvailableRecoveryTimeResponse
     */
    public function describeLocalAvailableRecoveryTimeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->region) {
            @$query['Region'] = $request->region;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLocalAvailableRecoveryTime',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLocalAvailableRecoveryTimeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the time range to which an RDS instance can be restored.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   MariaDB
     *
     * @param request - DescribeLocalAvailableRecoveryTimeRequest
     *
     * @returns DescribeLocalAvailableRecoveryTimeResponse
     *
     * @param DescribeLocalAvailableRecoveryTimeRequest $request
     *
     * @return DescribeLocalAvailableRecoveryTimeResponse
     */
    public function describeLocalAvailableRecoveryTime($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLocalAvailableRecoveryTimeWithOptions($request, $runtime);
    }

    /**
     * Queries the log backup files of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server
     * >  You can call the DescribeBinlogFiles operation to query the log files of instances that run different database engines.
     *
     * @param request - DescribeLogBackupFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeLogBackupFilesResponse
     *
     * @param DescribeLogBackupFilesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeLogBackupFilesResponse
     */
    public function describeLogBackupFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeLogBackupFiles',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeLogBackupFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the log backup files of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server
     * >  You can call the DescribeBinlogFiles operation to query the log files of instances that run different database engines.
     *
     * @param request - DescribeLogBackupFilesRequest
     *
     * @returns DescribeLogBackupFilesResponse
     *
     * @param DescribeLogBackupFilesRequest $request
     *
     * @return DescribeLogBackupFilesResponse
     */
    public function describeLogBackupFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeLogBackupFilesWithOptions($request, $runtime);
    }

    /**
     * 获取RDS营销项目中待升级实例信息.
     *
     * @param request - DescribeMarketingActivityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMarketingActivityResponse
     *
     * @param DescribeMarketingActivityRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeMarketingActivityResponse
     */
    public function describeMarketingActivityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->aliUid) {
            @$query['AliUid'] = $request->aliUid;
        }

        if (null !== $request->bid) {
            @$query['Bid'] = $request->bid;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->upgradeCode) {
            @$query['UpgradeCode'] = $request->upgradeCode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMarketingActivity',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMarketingActivityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 获取RDS营销项目中待升级实例信息.
     *
     * @param request - DescribeMarketingActivityRequest
     *
     * @returns DescribeMarketingActivityResponse
     *
     * @param DescribeMarketingActivityRequest $request
     *
     * @return DescribeMarketingActivityResponse
     */
    public function describeMarketingActivity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMarketingActivityWithOptions($request, $runtime);
    }

    /**
     * 查询全密态规则.
     *
     * @param request - DescribeMaskingRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMaskingRulesResponse
     *
     * @param DescribeMaskingRulesRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeMaskingRulesResponse
     */
    public function describeMaskingRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMaskingRules',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMaskingRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 查询全密态规则.
     *
     * @param request - DescribeMaskingRulesRequest
     *
     * @returns DescribeMaskingRulesResponse
     *
     * @param DescribeMaskingRulesRequest $request
     *
     * @return DescribeMaskingRulesResponse
     */
    public function describeMaskingRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMaskingRulesWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the databases and tables that can be restored from a specified backup set.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * > This operation is available for RDS instances that run MySQL 8.0, MySQL 5.7, and MySQL 5.6 on RDS High-availability Edition with local disks.
     * ### [](#)Description
     * Before you call the [RestoreTable](https://help.aliyun.com/document_detail/131510.html) operation to restore individual databases or tables of an ApsaraDB RDS for MySQL instance, you can call this operation to query the information about the databases and tables that can be restored. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/103175.html).
     *
     * @param request - DescribeMetaListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMetaListResponse
     *
     * @param DescribeMetaListRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeMetaListResponse
     */
    public function describeMetaListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupSetID) {
            @$query['BackupSetID'] = $request->backupSetID;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->getDbName) {
            @$query['GetDbName'] = $request->getDbName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageIndex) {
            @$query['PageIndex'] = $request->pageIndex;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->pattern) {
            @$query['Pattern'] = $request->pattern;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreTime) {
            @$query['RestoreTime'] = $request->restoreTime;
        }

        if (null !== $request->restoreType) {
            @$query['RestoreType'] = $request->restoreType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMetaList',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMetaListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the databases and tables that can be restored from a specified backup set.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * > This operation is available for RDS instances that run MySQL 8.0, MySQL 5.7, and MySQL 5.6 on RDS High-availability Edition with local disks.
     * ### [](#)Description
     * Before you call the [RestoreTable](https://help.aliyun.com/document_detail/131510.html) operation to restore individual databases or tables of an ApsaraDB RDS for MySQL instance, you can call this operation to query the information about the databases and tables that can be restored. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/103175.html).
     *
     * @param request - DescribeMetaListRequest
     *
     * @returns DescribeMetaListResponse
     *
     * @param DescribeMetaListRequest $request
     *
     * @return DescribeMetaListResponse
     */
    public function describeMetaList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMetaListWithOptions($request, $runtime);
    }

    /**
     * Queries a task that is used to import the backup data of an ApsaraDB RDS for SQL Server instance to an Object Storage Service (OSS) bucket.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     *
     * @param request - DescribeMigrateTaskByIdRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMigrateTaskByIdResponse
     *
     * @param DescribeMigrateTaskByIdRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeMigrateTaskByIdResponse
     */
    public function describeMigrateTaskByIdWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->migrateTaskId) {
            @$query['MigrateTaskId'] = $request->migrateTaskId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMigrateTaskById',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMigrateTaskByIdResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a task that is used to import the backup data of an ApsaraDB RDS for SQL Server instance to an Object Storage Service (OSS) bucket.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     *
     * @param request - DescribeMigrateTaskByIdRequest
     *
     * @returns DescribeMigrateTaskByIdResponse
     *
     * @param DescribeMigrateTaskByIdRequest $request
     *
     * @return DescribeMigrateTaskByIdResponse
     */
    public function describeMigrateTaskById($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMigrateTaskByIdWithOptions($request, $runtime);
    }

    /**
     * Queries the tasks that are created to migrate the backup data of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     * ### [](#)Usage notes
     * This operation allows you to query the migration tasks that are created for the instance over the last week.
     * ### [](#)Precautions
     * *   This operation is supported only for migration tasks that are created to migrate full backup files.
     * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
     *
     * @param request - DescribeMigrateTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeMigrateTasksResponse
     *
     * @param DescribeMigrateTasksRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeMigrateTasksResponse
     */
    public function describeMigrateTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeMigrateTasks',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeMigrateTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the tasks that are created to migrate the backup data of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     * ### [](#)Usage notes
     * This operation allows you to query the migration tasks that are created for the instance over the last week.
     * ### [](#)Precautions
     * *   This operation is supported only for migration tasks that are created to migrate full backup files.
     * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
     *
     * @param request - DescribeMigrateTasksRequest
     *
     * @returns DescribeMigrateTasksResponse
     *
     * @param DescribeMigrateTasksRequest $request
     *
     * @return DescribeMigrateTasksResponse
     */
    public function describeMigrateTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeMigrateTasksWithOptions($request, $runtime);
    }

    /**
     * Queries the details about the modifications to the pg_hba.conf file of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS PostgreSQL
     *
     * @param request - DescribeModifyPGHbaConfigLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeModifyPGHbaConfigLogResponse
     *
     * @param DescribeModifyPGHbaConfigLogRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DescribeModifyPGHbaConfigLogResponse
     */
    public function describeModifyPGHbaConfigLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeModifyPGHbaConfigLog',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeModifyPGHbaConfigLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the modifications to the pg_hba.conf file of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS PostgreSQL
     *
     * @param request - DescribeModifyPGHbaConfigLogRequest
     *
     * @returns DescribeModifyPGHbaConfigLogResponse
     *
     * @param DescribeModifyPGHbaConfigLogRequest $request
     *
     * @return DescribeModifyPGHbaConfigLogResponse
     */
    public function describeModifyPGHbaConfigLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeModifyPGHbaConfigLogWithOptions($request, $runtime);
    }

    /**
     * Queries the parameter modification logs of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeModifyParameterLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeModifyParameterLogResponse
     *
     * @param DescribeModifyParameterLogRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeModifyParameterLogResponse
     */
    public function describeModifyParameterLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeModifyParameterLog',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeModifyParameterLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the parameter modification logs of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeModifyParameterLogRequest
     *
     * @returns DescribeModifyParameterLogResponse
     *
     * @param DescribeModifyParameterLogRequest $request
     *
     * @return DescribeModifyParameterLogResponse
     */
    public function describeModifyParameterLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeModifyParameterLogWithOptions($request, $runtime);
    }

    /**
     * Queries the backup files that are included in a backup data migration task of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     * ### [Usage notes](#)
     * This operation is not supported for instances that run SQL Server 2017 EE or SQL Server 2019 EE.
     *
     * @param request - DescribeOssDownloadsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeOssDownloadsResponse
     *
     * @param DescribeOssDownloadsRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeOssDownloadsResponse
     */
    public function describeOssDownloadsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->migrateTaskId) {
            @$query['MigrateTaskId'] = $request->migrateTaskId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeOssDownloads',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeOssDownloadsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the backup files that are included in a backup data migration task of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     * ### [Usage notes](#)
     * This operation is not supported for instances that run SQL Server 2017 EE or SQL Server 2019 EE.
     *
     * @param request - DescribeOssDownloadsRequest
     *
     * @returns DescribeOssDownloadsResponse
     *
     * @param DescribeOssDownloadsRequest $request
     *
     * @return DescribeOssDownloadsResponse
     */
    public function describeOssDownloads($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeOssDownloadsWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration of the pg_hba.conf file of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS PostgreSQL
     *
     * @param request - DescribePGHbaConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePGHbaConfigResponse
     *
     * @param DescribePGHbaConfigRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribePGHbaConfigResponse
     */
    public function describePGHbaConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePGHbaConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePGHbaConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration of the pg_hba.conf file of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS PostgreSQL
     *
     * @param request - DescribePGHbaConfigRequest
     *
     * @returns DescribePGHbaConfigResponse
     *
     * @param DescribePGHbaConfigRequest $request
     *
     * @return DescribePGHbaConfigResponse
     */
    public function describePGHbaConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePGHbaConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a parameter template.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - DescribeParameterGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeParameterGroupResponse
     *
     * @param DescribeParameterGroupRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeParameterGroupResponse
     */
    public function describeParameterGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->parameterGroupId) {
            @$query['ParameterGroupId'] = $request->parameterGroupId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeParameterGroup',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeParameterGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a parameter template.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - DescribeParameterGroupRequest
     *
     * @returns DescribeParameterGroupResponse
     *
     * @param DescribeParameterGroupRequest $request
     *
     * @return DescribeParameterGroupResponse
     */
    public function describeParameterGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeParameterGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the parameter templates that are available in a region.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - DescribeParameterGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeParameterGroupsResponse
     *
     * @param DescribeParameterGroupsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeParameterGroupsResponse
     */
    public function describeParameterGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->enableDetail) {
            @$query['EnableDetail'] = $request->enableDetail;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeParameterGroups',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeParameterGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the parameter templates that are available in a region.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - DescribeParameterGroupsRequest
     *
     * @returns DescribeParameterGroupsResponse
     *
     * @param DescribeParameterGroupsRequest $request
     *
     * @return DescribeParameterGroupsResponse
     */
    public function describeParameterGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeParameterGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries parameter templates.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeParameterTemplatesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeParameterTemplatesResponse
     *
     * @param DescribeParameterTemplatesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeParameterTemplatesResponse
     */
    public function describeParameterTemplatesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeParameterTemplates',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeParameterTemplatesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries parameter templates.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeParameterTemplatesRequest
     *
     * @returns DescribeParameterTemplatesResponse
     *
     * @param DescribeParameterTemplatesRequest $request
     *
     * @return DescribeParameterTemplatesResponse
     */
    public function describeParameterTemplates($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeParameterTemplatesWithOptions($request, $runtime);
    }

    /**
     * Queries the parameter settings of an instance.
     *
     * @remarks
     * ### Applicable engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeParametersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeParametersResponse
     *
     * @param DescribeParametersRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeParametersResponse
     */
    public function describeParametersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeParameters',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeParametersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the parameter settings of an instance.
     *
     * @remarks
     * ### Applicable engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeParametersRequest
     *
     * @returns DescribeParametersResponse
     *
     * @param DescribeParametersRequest $request
     *
     * @return DescribeParametersResponse
     */
    public function describeParameters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeParametersWithOptions($request, $runtime);
    }

    /**
     * Queries extensions that are installed on a database.
     *
     * @remarks
     * ### Supported database engines
     * RDS PostgreSQL
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Manage extensions](https://help.aliyun.com/document_detail/2402409.html)
     *
     * @param request - DescribePostgresExtensionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePostgresExtensionsResponse
     *
     * @param DescribePostgresExtensionsRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribePostgresExtensionsResponse
     */
    public function describePostgresExtensionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePostgresExtensions',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePostgresExtensionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries extensions that are installed on a database.
     *
     * @remarks
     * ### Supported database engines
     * RDS PostgreSQL
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Manage extensions](https://help.aliyun.com/document_detail/2402409.html)
     *
     * @param request - DescribePostgresExtensionsRequest
     *
     * @returns DescribePostgresExtensionsResponse
     *
     * @param DescribePostgresExtensionsRequest $request
     *
     * @return DescribePostgresExtensionsResponse
     */
    public function describePostgresExtensions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePostgresExtensionsWithOptions($request, $runtime);
    }

    /**
     * Queries the price of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param tmpReq - DescribePriceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribePriceResponse
     *
     * @param DescribePriceRequest $tmpReq
     * @param RuntimeOptions       $runtime
     *
     * @return DescribePriceResponse
     */
    public function describePriceWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribePriceShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->DBNode) {
            $request->DBNodeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->DBNode, 'DBNode', 'json');
        }

        if (null !== $tmpReq->serverlessConfig) {
            $request->serverlessConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->serverlessConfig, 'ServerlessConfig', 'json');
        }

        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->DBNodeShrink) {
            @$query['DBNode'] = $request->DBNodeShrink;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->instanceUsedType) {
            @$query['InstanceUsedType'] = $request->instanceUsedType;
        }

        if (null !== $request->orderType) {
            @$query['OrderType'] = $request->orderType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->quantity) {
            @$query['Quantity'] = $request->quantity;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serverlessConfigShrink) {
            @$query['ServerlessConfig'] = $request->serverlessConfigShrink;
        }

        if (null !== $request->timeType) {
            @$query['TimeType'] = $request->timeType;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribePrice',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribePriceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the price of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribePriceRequest
     *
     * @returns DescribePriceResponse
     *
     * @param DescribePriceRequest $request
     *
     * @return DescribePriceResponse
     */
    public function describePrice($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describePriceWithOptions($request, $runtime);
    }

    /**
     * 查询RDS快捷售卖配置.
     *
     * @param request - DescribeQuickSaleConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeQuickSaleConfigResponse
     *
     * @param DescribeQuickSaleConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeQuickSaleConfigResponse
     */
    public function describeQuickSaleConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->commodity) {
            @$query['Commodity'] = $request->commodity;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeQuickSaleConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeQuickSaleConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 查询RDS快捷售卖配置.
     *
     * @param request - DescribeQuickSaleConfigRequest
     *
     * @returns DescribeQuickSaleConfigResponse
     *
     * @param DescribeQuickSaleConfigRequest $request
     *
     * @return DescribeQuickSaleConfigResponse
     */
    public function describeQuickSaleConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeQuickSaleConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the kubeconfig file of a Container Service for Kubernetes (ACK) cluster in which an RDS Custom instance resides.
     *
     * @remarks
     * Kubeconfig files store identity and authentication information that is used by clients to access ACK clusters. To use kubectl to manage an ACK cluster, you must use the kubeconfig file to connect to the ACK cluster. We recommend that you keep kubeconfig files confidential and revoke kubeconfig files that are not in use. This helps prevent data leaks caused by the disclosure of kubeconfig files.
     *
     * @param request - DescribeRCClusterConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCClusterConfigResponse
     *
     * @param DescribeRCClusterConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeRCClusterConfigResponse
     */
    public function describeRCClusterConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->temporaryDurationMinutes) {
            @$query['TemporaryDurationMinutes'] = $request->temporaryDurationMinutes;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCClusterConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCClusterConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the kubeconfig file of a Container Service for Kubernetes (ACK) cluster in which an RDS Custom instance resides.
     *
     * @remarks
     * Kubeconfig files store identity and authentication information that is used by clients to access ACK clusters. To use kubectl to manage an ACK cluster, you must use the kubeconfig file to connect to the ACK cluster. We recommend that you keep kubeconfig files confidential and revoke kubeconfig files that are not in use. This helps prevent data leaks caused by the disclosure of kubeconfig files.
     *
     * @param request - DescribeRCClusterConfigRequest
     *
     * @returns DescribeRCClusterConfigResponse
     *
     * @param DescribeRCClusterConfigRequest $request
     *
     * @return DescribeRCClusterConfigResponse
     */
    public function describeRCClusterConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCClusterConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the RDS custom nodes in a Container Service for Kubernetes (ACK) cluster.
     *
     * @param request - DescribeRCClusterNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCClusterNodesResponse
     *
     * @param DescribeRCClusterNodesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeRCClusterNodesResponse
     */
    public function describeRCClusterNodesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCClusterNodes',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCClusterNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the RDS custom nodes in a Container Service for Kubernetes (ACK) cluster.
     *
     * @param request - DescribeRCClusterNodesRequest
     *
     * @returns DescribeRCClusterNodesResponse
     *
     * @param DescribeRCClusterNodesRequest $request
     *
     * @return DescribeRCClusterNodesResponse
     */
    public function describeRCClusterNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCClusterNodesWithOptions($request, $runtime);
    }

    /**
     * Queries Container Service for Kubernetes (ACK) clusters to which RDS Custom nodes reside in a specific region.
     *
     * @param request - DescribeRCClustersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCClustersResponse
     *
     * @param DescribeRCClustersRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeRCClustersResponse
     */
    public function describeRCClustersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->profile) {
            @$query['Profile'] = $request->profile;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCClusters',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCClustersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries Container Service for Kubernetes (ACK) clusters to which RDS Custom nodes reside in a specific region.
     *
     * @param request - DescribeRCClustersRequest
     *
     * @returns DescribeRCClustersResponse
     *
     * @param DescribeRCClustersRequest $request
     *
     * @return DescribeRCClustersResponse
     */
    public function describeRCClusters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCClustersWithOptions($request, $runtime);
    }

    /**
     * Queries the details of one or more deployment sets for RDS Custom instances. Before you call this operation, you must specify parameters such as DeploymentSetIds, Strategy, and DeploymentSetName.
     *
     * @param request - DescribeRCDeploymentSetsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCDeploymentSetsResponse
     *
     * @param DescribeRCDeploymentSetsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeRCDeploymentSetsResponse
     */
    public function describeRCDeploymentSetsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCDeploymentSets',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCDeploymentSetsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of one or more deployment sets for RDS Custom instances. Before you call this operation, you must specify parameters such as DeploymentSetIds, Strategy, and DeploymentSetName.
     *
     * @param request - DescribeRCDeploymentSetsRequest
     *
     * @returns DescribeRCDeploymentSetsResponse
     *
     * @param DescribeRCDeploymentSetsRequest $request
     *
     * @return DescribeRCDeploymentSetsResponse
     */
    public function describeRCDeploymentSets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCDeploymentSetsWithOptions($request, $runtime);
    }

    /**
     * Queries the disk information about an RDS Custom instance.
     *
     * @param request - DescribeRCDisksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCDisksResponse
     *
     * @param DescribeRCDisksRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeRCDisksResponse
     */
    public function describeRCDisksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCDisks',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCDisksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the disk information about an RDS Custom instance.
     *
     * @param request - DescribeRCDisksRequest
     *
     * @returns DescribeRCDisksResponse
     *
     * @param DescribeRCDisksRequest $request
     *
     * @return DescribeRCDisksResponse
     */
    public function describeRCDisks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCDisksWithOptions($request, $runtime);
    }

    /**
     * Queries custom images that can be used to create an RDS Custom instance. Before you call this operation, you must specify parameters such as RegionId.
     *
     * @param request - DescribeRCImageListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCImageListResponse
     *
     * @param DescribeRCImageListRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeRCImageListResponse
     */
    public function describeRCImageListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCImageList',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCImageListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries custom images that can be used to create an RDS Custom instance. Before you call this operation, you must specify parameters such as RegionId.
     *
     * @param request - DescribeRCImageListRequest
     *
     * @returns DescribeRCImageListResponse
     *
     * @param DescribeRCImageListRequest $request
     *
     * @return DescribeRCImageListResponse
     */
    public function describeRCImageList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCImageListWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an RDS Custom instance.
     *
     * @param request - DescribeRCInstanceAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCInstanceAttributeResponse
     *
     * @param DescribeRCInstanceAttributeRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeRCInstanceAttributeResponse
     */
    public function describeRCInstanceAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCInstanceAttribute',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCInstanceAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an RDS Custom instance.
     *
     * @param request - DescribeRCInstanceAttributeRequest
     *
     * @returns DescribeRCInstanceAttributeResponse
     *
     * @param DescribeRCInstanceAttributeRequest $request
     *
     * @return DescribeRCInstanceAttributeResponse
     */
    public function describeRCInstanceAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCInstanceAttributeWithOptions($request, $runtime);
    }

    /**
     * Queries the instance families of RDS Custom instances.
     *
     * @param request - DescribeRCInstanceTypeFamiliesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCInstanceTypeFamiliesResponse
     *
     * @param DescribeRCInstanceTypeFamiliesRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return DescribeRCInstanceTypeFamiliesResponse
     */
    public function describeRCInstanceTypeFamiliesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCInstanceTypeFamilies',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCInstanceTypeFamiliesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the instance families of RDS Custom instances.
     *
     * @param request - DescribeRCInstanceTypeFamiliesRequest
     *
     * @returns DescribeRCInstanceTypeFamiliesResponse
     *
     * @param DescribeRCInstanceTypeFamiliesRequest $request
     *
     * @return DescribeRCInstanceTypeFamiliesResponse
     */
    public function describeRCInstanceTypeFamilies($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCInstanceTypeFamiliesWithOptions($request, $runtime);
    }

    /**
     * Queries the instance types of RDS Custom instances.
     *
     * @param tmpReq - DescribeRCInstanceTypesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCInstanceTypesResponse
     *
     * @param DescribeRCInstanceTypesRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeRCInstanceTypesResponse
     */
    public function describeRCInstanceTypesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DescribeRCInstanceTypesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->instanceType) {
            $request->instanceTypeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->instanceType, 'InstanceType', 'simple');
        }

        $query = [];
        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->instanceTypeShrink) {
            @$query['InstanceType'] = $request->instanceTypeShrink;
        }

        if (null !== $request->instanceTypeFamily) {
            @$query['InstanceTypeFamily'] = $request->instanceTypeFamily;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCInstanceTypes',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCInstanceTypesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the instance types of RDS Custom instances.
     *
     * @param request - DescribeRCInstanceTypesRequest
     *
     * @returns DescribeRCInstanceTypesResponse
     *
     * @param DescribeRCInstanceTypesRequest $request
     *
     * @return DescribeRCInstanceTypesResponse
     */
    public function describeRCInstanceTypes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCInstanceTypesWithOptions($request, $runtime);
    }

    /**
     * Queries the Virtual Network Computing (VNC) logon address of an RDS Custom instance.
     *
     * @remarks
     * The address returned is valid only for 15 seconds. If you do not use the returned address to establish a connection within 15 seconds, the address expires and you must call the operation again to obtain a new address.
     *
     * @param request - DescribeRCInstanceVncUrlRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCInstanceVncUrlResponse
     *
     * @param DescribeRCInstanceVncUrlRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeRCInstanceVncUrlResponse
     */
    public function describeRCInstanceVncUrlWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dbType) {
            @$query['DbType'] = $request->dbType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCInstanceVncUrl',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCInstanceVncUrlResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the Virtual Network Computing (VNC) logon address of an RDS Custom instance.
     *
     * @remarks
     * The address returned is valid only for 15 seconds. If you do not use the returned address to establish a connection within 15 seconds, the address expires and you must call the operation again to obtain a new address.
     *
     * @param request - DescribeRCInstanceVncUrlRequest
     *
     * @returns DescribeRCInstanceVncUrlResponse
     *
     * @param DescribeRCInstanceVncUrlRequest $request
     *
     * @return DescribeRCInstanceVncUrlResponse
     */
    public function describeRCInstanceVncUrl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCInstanceVncUrlWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an RDS Custom instance.
     *
     * @param request - DescribeRCInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCInstancesResponse
     *
     * @param DescribeRCInstancesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeRCInstancesResponse
     */
    public function describeRCInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostIp) {
            @$query['HostIp'] = $request->hostIp;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->publicIp) {
            @$query['PublicIp'] = $request->publicIp;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an RDS Custom instance.
     *
     * @param request - DescribeRCInstancesRequest
     *
     * @returns DescribeRCInstancesResponse
     *
     * @param DescribeRCInstancesRequest $request
     *
     * @return DescribeRCInstancesResponse
     */
    public function describeRCInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries the monitoring data of a metric for an RDS Custom instance.
     *
     * @param request - DescribeRCMetricListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCMetricListResponse
     *
     * @param DescribeRCMetricListRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeRCMetricListResponse
     */
    public function describeRCMetricListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCMetricList',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCMetricListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the monitoring data of a metric for an RDS Custom instance.
     *
     * @param request - DescribeRCMetricListRequest
     *
     * @returns DescribeRCMetricListResponse
     *
     * @param DescribeRCMetricListRequest $request
     *
     * @return DescribeRCMetricListResponse
     */
    public function describeRCMetricList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCMetricListWithOptions($request, $runtime);
    }

    /**
     * Queries the configuration information about the edge node pool of an RDS Custom instance.
     *
     * @param request - DescribeRCNodePoolRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCNodePoolResponse
     *
     * @param DescribeRCNodePoolRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DescribeRCNodePoolResponse
     */
    public function describeRCNodePoolWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCNodePool',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCNodePoolResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configuration information about the edge node pool of an RDS Custom instance.
     *
     * @param request - DescribeRCNodePoolRequest
     *
     * @returns DescribeRCNodePoolResponse
     *
     * @param DescribeRCNodePoolRequest $request
     *
     * @return DescribeRCNodePoolResponse
     */
    public function describeRCNodePool($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCNodePoolWithOptions($request, $runtime);
    }

    /**
     * 查询RC安全组.
     *
     * @param request - DescribeRCSecurityGroupListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCSecurityGroupListResponse
     *
     * @param DescribeRCSecurityGroupListRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeRCSecurityGroupListResponse
     */
    public function describeRCSecurityGroupListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCSecurityGroupList',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCSecurityGroupListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 查询RC安全组.
     *
     * @param request - DescribeRCSecurityGroupListRequest
     *
     * @returns DescribeRCSecurityGroupListResponse
     *
     * @param DescribeRCSecurityGroupListRequest $request
     *
     * @return DescribeRCSecurityGroupListResponse
     */
    public function describeRCSecurityGroupList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCSecurityGroupListWithOptions($request, $runtime);
    }

    /**
     * 描述RC安全组规则.
     *
     * @param request - DescribeRCSecurityGroupPermissionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCSecurityGroupPermissionResponse
     *
     * @param DescribeRCSecurityGroupPermissionRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DescribeRCSecurityGroupPermissionResponse
     */
    public function describeRCSecurityGroupPermissionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCSecurityGroupPermission',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCSecurityGroupPermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 描述RC安全组规则.
     *
     * @param request - DescribeRCSecurityGroupPermissionRequest
     *
     * @returns DescribeRCSecurityGroupPermissionResponse
     *
     * @param DescribeRCSecurityGroupPermissionRequest $request
     *
     * @return DescribeRCSecurityGroupPermissionResponse
     */
    public function describeRCSecurityGroupPermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCSecurityGroupPermissionWithOptions($request, $runtime);
    }

    /**
     * Queries the details of snapshots. The details include the status of the snapshots, the amount of remaining time required to create the snapshots, and the retention period of the automatic snapshots in days.
     *
     * @param request - DescribeRCSnapshotsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRCSnapshotsResponse
     *
     * @param DescribeRCSnapshotsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeRCSnapshotsResponse
     */
    public function describeRCSnapshotsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->diskId) {
            @$query['DiskId'] = $request->diskId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->snapshotIds) {
            @$query['SnapshotIds'] = $request->snapshotIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRCSnapshots',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRCSnapshotsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of snapshots. The details include the status of the snapshots, the amount of remaining time required to create the snapshots, and the retention period of the automatic snapshots in days.
     *
     * @param request - DescribeRCSnapshotsRequest
     *
     * @returns DescribeRCSnapshotsResponse
     *
     * @param DescribeRCSnapshotsRequest $request
     *
     * @return DescribeRCSnapshotsResponse
     */
    public function describeRCSnapshots($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRCSnapshotsWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * This operation is deprecated.
     *
     * @deprecated OpenAPI DescribeRdsResourceSettings is deprecated
     *
     * @param request - DescribeRdsResourceSettingsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRdsResourceSettingsResponse
     *
     * @param DescribeRdsResourceSettingsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeRdsResourceSettingsResponse
     */
    public function describeRdsResourceSettingsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceNiche) {
            @$query['ResourceNiche'] = $request->resourceNiche;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRdsResourceSettings',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRdsResourceSettingsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * This operation is deprecated.
     *
     * @deprecated OpenAPI DescribeRdsResourceSettings is deprecated
     *
     * @param request - DescribeRdsResourceSettingsRequest
     *
     * @returns DescribeRdsResourceSettingsResponse
     *
     * @param DescribeRdsResourceSettingsRequest $request
     *
     * @return DescribeRdsResourceSettingsResponse
     */
    public function describeRdsResourceSettings($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRdsResourceSettingsWithOptions($request, $runtime);
    }

    /**
     * Queries the latency of data replication between a primary instance and its read-only instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     *
     * @param request - DescribeReadDBInstanceDelayRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeReadDBInstanceDelayResponse
     *
     * @param DescribeReadDBInstanceDelayRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeReadDBInstanceDelayResponse
     */
    public function describeReadDBInstanceDelayWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->readInstanceId) {
            @$query['ReadInstanceId'] = $request->readInstanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeReadDBInstanceDelay',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeReadDBInstanceDelayResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the latency of data replication between a primary instance and its read-only instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     *
     * @param request - DescribeReadDBInstanceDelayRequest
     *
     * @returns DescribeReadDBInstanceDelayResponse
     *
     * @param DescribeReadDBInstanceDelayRequest $request
     *
     * @return DescribeReadDBInstanceDelayResponse
     */
    public function describeReadDBInstanceDelay($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeReadDBInstanceDelayWithOptions($request, $runtime);
    }

    /**
     * Queries the regions.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeRegionInfosRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRegionInfosResponse
     *
     * @param DescribeRegionInfosRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeRegionInfosResponse
     */
    public function describeRegionInfosWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRegionInfos',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRegionInfosResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the regions.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeRegionInfosRequest
     *
     * @returns DescribeRegionInfosResponse
     *
     * @param DescribeRegionInfosRequest $request
     *
     * @return DescribeRegionInfosResponse
     */
    public function describeRegionInfos($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRegionInfosWithOptions($request, $runtime);
    }

    /**
     * Queries the details of all regions and zones for ApsaraDB RDS. The regions that are no longer supported are also queried. Exercise caution when you call this operation.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeRegionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRegionsResponse
     *
     * @param DescribeRegionsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeRegionsResponse
     */
    public function describeRegionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceptLanguage) {
            @$query['AcceptLanguage'] = $request->acceptLanguage;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRegions',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRegionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of all regions and zones for ApsaraDB RDS. The regions that are no longer supported are also queried. Exercise caution when you call this operation.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeRegionsRequest
     *
     * @returns DescribeRegionsResponse
     *
     * @param DescribeRegionsRequest $request
     *
     * @return DescribeRegionsResponse
     */
    public function describeRegions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRegionsWithOptions($request, $runtime);
    }

    /**
     * Queries the renewal fees for a subscription instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeRenewalPriceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeRenewalPriceResponse
     *
     * @param DescribeRenewalPriceRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DescribeRenewalPriceResponse
     */
    public function describeRenewalPriceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->businessInfo) {
            @$query['BusinessInfo'] = $request->businessInfo;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->orderType) {
            @$query['OrderType'] = $request->orderType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->quantity) {
            @$query['Quantity'] = $request->quantity;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->timeType) {
            @$query['TimeType'] = $request->timeType;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeRenewalPrice',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeRenewalPriceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the renewal fees for a subscription instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeRenewalPriceRequest
     *
     * @returns DescribeRenewalPriceResponse
     *
     * @param DescribeRenewalPriceRequest $request
     *
     * @return DescribeRenewalPriceResponse
     */
    public function describeRenewalPrice($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeRenewalPriceWithOptions($request, $runtime);
    }

    /**
     * Queries the operation logs of the data synchronization task for a specified ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   PostgreSQL
     *
     * @param request - DescribeReplicationLinkLogsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeReplicationLinkLogsResponse
     *
     * @param DescribeReplicationLinkLogsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return DescribeReplicationLinkLogsResponse
     */
    public function describeReplicationLinkLogsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeReplicationLinkLogs',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeReplicationLinkLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the operation logs of the data synchronization task for a specified ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   PostgreSQL
     *
     * @param request - DescribeReplicationLinkLogsRequest
     *
     * @returns DescribeReplicationLinkLogsResponse
     *
     * @param DescribeReplicationLinkLogsRequest $request
     *
     * @return DescribeReplicationLinkLogsResponse
     */
    public function describeReplicationLinkLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeReplicationLinkLogsWithOptions($request, $runtime);
    }

    /**
     * 概览页资源详情.
     *
     * @param request - DescribeResourceDetailsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeResourceDetailsResponse
     *
     * @param DescribeResourceDetailsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DescribeResourceDetailsResponse
     */
    public function describeResourceDetailsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeResourceDetails',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeResourceDetailsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 概览页资源详情.
     *
     * @param request - DescribeResourceDetailsRequest
     *
     * @returns DescribeResourceDetailsResponse
     *
     * @param DescribeResourceDetailsRequest $request
     *
     * @return DescribeResourceDetailsResponse
     */
    public function describeResourceDetails($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeResourceDetailsWithOptions($request, $runtime);
    }

    /**
     * Queries the storage usage of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeResourceUsageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeResourceUsageResponse
     *
     * @param DescribeResourceUsageRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeResourceUsageResponse
     */
    public function describeResourceUsageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeResourceUsage',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeResourceUsageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the storage usage of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeResourceUsageRequest
     *
     * @returns DescribeResourceUsageResponse
     *
     * @param DescribeResourceUsageRequest $request
     *
     * @return DescribeResourceUsageResponse
     */
    public function describeResourceUsage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeResourceUsageWithOptions($request, $runtime);
    }

    /**
     * Queries the status of the SQL Explorer (SQL Audit) feature for an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DescribeSQLCollectorPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSQLCollectorPolicyResponse
     *
     * @param DescribeSQLCollectorPolicyRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DescribeSQLCollectorPolicyResponse
     */
    public function describeSQLCollectorPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSQLCollectorPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSQLCollectorPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of the SQL Explorer (SQL Audit) feature for an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DescribeSQLCollectorPolicyRequest
     *
     * @returns DescribeSQLCollectorPolicyResponse
     *
     * @param DescribeSQLCollectorPolicyRequest $request
     *
     * @return DescribeSQLCollectorPolicyResponse
     */
    public function describeSQLCollectorPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSQLCollectorPolicyWithOptions($request, $runtime);
    }

    /**
     * Queries the retention period of the log files that are generated by the SQL Explorer feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DescribeSQLCollectorRetentionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSQLCollectorRetentionResponse
     *
     * @param DescribeSQLCollectorRetentionRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DescribeSQLCollectorRetentionResponse
     */
    public function describeSQLCollectorRetentionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSQLCollectorRetention',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSQLCollectorRetentionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the retention period of the log files that are generated by the SQL Explorer feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *
     * @param request - DescribeSQLCollectorRetentionRequest
     *
     * @returns DescribeSQLCollectorRetentionResponse
     *
     * @param DescribeSQLCollectorRetentionRequest $request
     *
     * @return DescribeSQLCollectorRetentionResponse
     */
    public function describeSQLCollectorRetention($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSQLCollectorRetentionWithOptions($request, $runtime);
    }

    /**
     * Queries the log files that are generated by the SQL Explorer (SQL Audit) feature for an instance. The DescribeSQLLogFiles operation does not return the log files that are generated by the SQL Explorer feature and manually exported from the ApsaraDB RDS console. The DescribeSQLLogFiles operation returns the SQL Explorer log files that are generated by calling the DescribeSQLLogRecords operation with the request parameter Form set to File.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *     **
     *     **Note** If your instance runs SQL Server, only SQL Server 2008 R2 is supported.
     * ### [](#)Precautions
     * *   The DescribeSQLLogFiles operation does not return the log files that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
     * *   The DescribeSQLLogFiles operation does not return the log files that are generated by the SQL Explorer feature and manually exported from the ApsaraDB RDS console. The DescribeSQLLogFiles operation returns the SQL Explorer log files that are generated by calling the [DescribeSQLLogRecords](https://help.aliyun.com/document_detail/610533.html) operation with the request parameter **Form** set to **File**.
     * *   The exported files are retained for only two days.
     *     **
     *     **Note** If you have enabled Database Autonomy Service (DAS) Enterprise Edition V2 or V3 and have enabled the SQL Explorer and Audit feature, the exported files are retained for seven days. You can call the [DescribeSqlLogConfig](https://help.aliyun.com/document_detail/2778837.html) operation to query the information about the enabled DAS Enterprise Edition.
     *
     * @param request - DescribeSQLLogFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSQLLogFilesResponse
     *
     * @param DescribeSQLLogFilesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DescribeSQLLogFilesResponse
     */
    public function describeSQLLogFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->fileName) {
            @$query['FileName'] = $request->fileName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSQLLogFiles',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSQLLogFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the log files that are generated by the SQL Explorer (SQL Audit) feature for an instance. The DescribeSQLLogFiles operation does not return the log files that are generated by the SQL Explorer feature and manually exported from the ApsaraDB RDS console. The DescribeSQLLogFiles operation returns the SQL Explorer log files that are generated by calling the DescribeSQLLogRecords operation with the request parameter Form set to File.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     *     **
     *     **Note** If your instance runs SQL Server, only SQL Server 2008 R2 is supported.
     * ### [](#)Precautions
     * *   The DescribeSQLLogFiles operation does not return the log files that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
     * *   The DescribeSQLLogFiles operation does not return the log files that are generated by the SQL Explorer feature and manually exported from the ApsaraDB RDS console. The DescribeSQLLogFiles operation returns the SQL Explorer log files that are generated by calling the [DescribeSQLLogRecords](https://help.aliyun.com/document_detail/610533.html) operation with the request parameter **Form** set to **File**.
     * *   The exported files are retained for only two days.
     *     **
     *     **Note** If you have enabled Database Autonomy Service (DAS) Enterprise Edition V2 or V3 and have enabled the SQL Explorer and Audit feature, the exported files are retained for seven days. You can call the [DescribeSqlLogConfig](https://help.aliyun.com/document_detail/2778837.html) operation to query the information about the enabled DAS Enterprise Edition.
     *
     * @param request - DescribeSQLLogFilesRequest
     *
     * @returns DescribeSQLLogFilesResponse
     *
     * @param DescribeSQLLogFilesRequest $request
     *
     * @return DescribeSQLLogFilesResponse
     */
    public function describeSQLLogFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSQLLogFilesWithOptions($request, $runtime);
    }

    /**
     * Queries the logs that are generated by the SQL Explorer (SQL Audit) feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [Usage notes](#)
     * *   You can call this operation up to 1,000 times per minute per account. The calls initiated by using both your Alibaba Cloud account and RAM users within your Alibaba Cloud account are counted.
     * *   This operation cannot be used to query the logs that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
     * *   When you call this operation and set the **Form** parameter to **File** to generate an audit file, a maximum of 1 million log entries can be recorded in the audit file, and you cannot filter log entries by keyword.
     *
     * @param request - DescribeSQLLogRecordsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSQLLogRecordsResponse
     *
     * @param DescribeSQLLogRecordsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DescribeSQLLogRecordsResponse
     */
    public function describeSQLLogRecordsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->database) {
            @$query['Database'] = $request->database;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->form) {
            @$query['Form'] = $request->form;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->queryKeywords) {
            @$query['QueryKeywords'] = $request->queryKeywords;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->SQLId) {
            @$query['SQLId'] = $request->SQLId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->user) {
            @$query['User'] = $request->user;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSQLLogRecords',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSQLLogRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the logs that are generated by the SQL Explorer (SQL Audit) feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [Usage notes](#)
     * *   You can call this operation up to 1,000 times per minute per account. The calls initiated by using both your Alibaba Cloud account and RAM users within your Alibaba Cloud account are counted.
     * *   This operation cannot be used to query the logs that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
     * *   When you call this operation and set the **Form** parameter to **File** to generate an audit file, a maximum of 1 million log entries can be recorded in the audit file, and you cannot filter log entries by keyword.
     *
     * @param request - DescribeSQLLogRecordsRequest
     *
     * @returns DescribeSQLLogRecordsResponse
     *
     * @param DescribeSQLLogRecordsRequest $request
     *
     * @return DescribeSQLLogRecordsResponse
     */
    public function describeSQLLogRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSQLLogRecordsWithOptions($request, $runtime);
    }

    /**
     * Queries SQL log reports.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeSQLLogReportListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSQLLogReportListResponse
     *
     * @param DescribeSQLLogReportListRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DescribeSQLLogReportListResponse
     */
    public function describeSQLLogReportListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSQLLogReportList',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSQLLogReportListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries SQL log reports.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeSQLLogReportListRequest
     *
     * @returns DescribeSQLLogReportListResponse
     *
     * @param DescribeSQLLogReportListRequest $request
     *
     * @return DescribeSQLLogReportListResponse
     */
    public function describeSQLLogReportList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSQLLogReportListWithOptions($request, $runtime);
    }

    /**
     * Queries the credential of a user who uses the Data API feature.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   MySQL
     *
     * @param request - DescribeSecretsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSecretsResponse
     *
     * @param DescribeSecretsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DescribeSecretsResponse
     */
    public function describeSecretsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->acceptLanguage) {
            @$query['AcceptLanguage'] = $request->acceptLanguage;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dbInstanceId) {
            @$query['DbInstanceId'] = $request->dbInstanceId;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSecrets',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSecretsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the credential of a user who uses the Data API feature.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   MySQL
     *
     * @param request - DescribeSecretsRequest
     *
     * @returns DescribeSecretsResponse
     *
     * @param DescribeSecretsRequest $request
     *
     * @return DescribeSecretsResponse
     */
    public function describeSecrets($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecretsWithOptions($request, $runtime);
    }

    /**
     * Queries ECS security groups to which an instance is added.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure a security group for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/201042.html)
     * *   [Configure a security group for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206310.html)
     * *   [Configure a security group for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - DescribeSecurityGroupConfigurationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSecurityGroupConfigurationResponse
     *
     * @param DescribeSecurityGroupConfigurationRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return DescribeSecurityGroupConfigurationResponse
     */
    public function describeSecurityGroupConfigurationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSecurityGroupConfiguration',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSecurityGroupConfigurationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries ECS security groups to which an instance is added.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure a security group for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/201042.html)
     * *   [Configure a security group for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206310.html)
     * *   [Configure a security group for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - DescribeSecurityGroupConfigurationRequest
     *
     * @returns DescribeSecurityGroupConfigurationResponse
     *
     * @param DescribeSecurityGroupConfigurationRequest $request
     *
     * @return DescribeSecurityGroupConfigurationResponse
     */
    public function describeSecurityGroupConfiguration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSecurityGroupConfigurationWithOptions($request, $runtime);
    }

    /**
     * Queries all replication slots of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     *
     * @param request - DescribeSlotsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSlotsResponse
     *
     * @param DescribeSlotsRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DescribeSlotsResponse
     */
    public function describeSlotsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSlots',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSlotsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries all replication slots of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     *
     * @param request - DescribeSlotsRequest
     *
     * @returns DescribeSlotsResponse
     *
     * @param DescribeSlotsRequest $request
     *
     * @return DescribeSlotsResponse
     */
    public function describeSlots($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSlotsWithOptions($request, $runtime);
    }

    /**
     * Queries the slow log details of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### Precautions
     * The response parameters returned by this operation are updated every minute.
     *
     * @param request - DescribeSlowLogRecordsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSlowLogRecordsResponse
     *
     * @param DescribeSlowLogRecordsRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DescribeSlowLogRecordsResponse
     */
    public function describeSlowLogRecordsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->SQLHASH) {
            @$query['SQLHASH'] = $request->SQLHASH;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSlowLogRecords',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSlowLogRecordsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the slow log details of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### Precautions
     * The response parameters returned by this operation are updated every minute.
     *
     * @param request - DescribeSlowLogRecordsRequest
     *
     * @returns DescribeSlowLogRecordsResponse
     *
     * @param DescribeSlowLogRecordsRequest $request
     *
     * @return DescribeSlowLogRecordsResponse
     */
    public function describeSlowLogRecords($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSlowLogRecordsWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics on slow query logs.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     *     **
     *     **Note** This operation is not supported for RDS instances that run MySQL 5.7 on RDS Basic Edition.
     * *   SQL Server
     *     **
     *     **Note** This operation is supported only for RDS instances that run SQL Server 2008 R2.
     * *   MariaDB
     * ### [](#)Prerequisites
     * *   Slow query logs are not collected in real time and may show a latency of 6 to 8 hours.
     * *   If the return result is empty, check whether the StartTime and EndTime parameters are in UTC. If yes, no slow logs are generated within the specified time range.
     * *   Starting from September 01, 2024, the template algorithm for slow queries is optimized. When you call the operation, you must change the value of the **SQLHASH** parameter. For more information, see [[Notice\\] Optimization of the template algorithm for slow queries](~~2845725~~).
     *
     * @param request - DescribeSlowLogsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSlowLogsResponse
     *
     * @param DescribeSlowLogsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DescribeSlowLogsResponse
     */
    public function describeSlowLogsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->sortKey) {
            @$query['SortKey'] = $request->sortKey;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSlowLogs',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSlowLogsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on slow query logs.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     *     **
     *     **Note** This operation is not supported for RDS instances that run MySQL 5.7 on RDS Basic Edition.
     * *   SQL Server
     *     **
     *     **Note** This operation is supported only for RDS instances that run SQL Server 2008 R2.
     * *   MariaDB
     * ### [](#)Prerequisites
     * *   Slow query logs are not collected in real time and may show a latency of 6 to 8 hours.
     * *   If the return result is empty, check whether the StartTime and EndTime parameters are in UTC. If yes, no slow logs are generated within the specified time range.
     * *   Starting from September 01, 2024, the template algorithm for slow queries is optimized. When you call the operation, you must change the value of the **SQLHASH** parameter. For more information, see [[Notice\\] Optimization of the template algorithm for slow queries](~~2845725~~).
     *
     * @param request - DescribeSlowLogsRequest
     *
     * @returns DescribeSlowLogsResponse
     *
     * @param DescribeSlowLogsRequest $request
     *
     * @return DescribeSlowLogsResponse
     */
    public function describeSlowLogs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSlowLogsWithOptions($request, $runtime);
    }

    /**
     * Checks whether the disk of an ApsaraDB RDS for SQL Server instance can be resized online.
     *
     * @remarks
     * ### Supported database engine
     * SQL Server
     *
     * @param request - DescribeSupportOnlineResizeDiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeSupportOnlineResizeDiskResponse
     *
     * @param DescribeSupportOnlineResizeDiskRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return DescribeSupportOnlineResizeDiskResponse
     */
    public function describeSupportOnlineResizeDiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeSupportOnlineResizeDisk',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeSupportOnlineResizeDiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether the disk of an ApsaraDB RDS for SQL Server instance can be resized online.
     *
     * @remarks
     * ### Supported database engine
     * SQL Server
     *
     * @param request - DescribeSupportOnlineResizeDiskRequest
     *
     * @returns DescribeSupportOnlineResizeDiskResponse
     *
     * @param DescribeSupportOnlineResizeDiskRequest $request
     *
     * @return DescribeSupportOnlineResizeDiskResponse
     */
    public function describeSupportOnlineResizeDisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeSupportOnlineResizeDiskWithOptions($request, $runtime);
    }

    /**
     * Queries tags of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [Usage notes](#)
     * *   If an instance ID is specified, all tags that are added to this instance are queried, and other filter conditions are invalid.
     * *   If you specify only TagKey, the results that match the specified TagKey are returned. If you specify both TagKey and TagValue, the results that match both the specified TagKey and TagValue are returned.
     *
     * @param request - DescribeTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTagsResponse
     *
     * @param DescribeTagsRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DescribeTagsResponse
     */
    public function describeTagsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->proxyId) {
            @$query['proxyId'] = $request->proxyId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTags',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries tags of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [Usage notes](#)
     * *   If an instance ID is specified, all tags that are added to this instance are queried, and other filter conditions are invalid.
     * *   If you specify only TagKey, the results that match the specified TagKey are returned. If you specify both TagKey and TagValue, the results that match both the specified TagKey and TagValue are returned.
     *
     * @param request - DescribeTagsRequest
     *
     * @returns DescribeTagsResponse
     *
     * @param DescribeTagsRequest $request
     *
     * @return DescribeTagsResponse
     */
    public function describeTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTagsWithOptions($request, $runtime);
    }

    /**
     * You can call the DescribeTasks operation to query the tasks that are running on an instance.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - DescribeTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeTasksResponse
     *
     * @param DescribeTasksRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return DescribeTasksResponse
     */
    public function describeTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->taskAction) {
            @$query['TaskAction'] = $request->taskAction;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeTasks',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can call the DescribeTasks operation to query the tasks that are running on an instance.
     *
     * @remarks
     * This operation is phased out.
     *
     * @param request - DescribeTasksRequest
     *
     * @returns DescribeTasksResponse
     *
     * @param DescribeTasksRequest $request
     *
     * @return DescribeTasksResponse
     */
    public function describeTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeTasksWithOptions($request, $runtime);
    }

    /**
     * Queries the check report for a major engine version upgrade of an ApsaraDB RDS for MySQL instance or ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * PostgreSQL
     * ### [](#)References
     * > Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Check report for the major engine version upgrade of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/2794383.html)
     * *   [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/203309.html)
     * *   [Introduction to the check report of a major engine version upgrade for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/218391.html)
     *
     * @param request - DescribeUpgradeMajorVersionPrecheckTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUpgradeMajorVersionPrecheckTaskResponse
     *
     * @param DescribeUpgradeMajorVersionPrecheckTaskRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return DescribeUpgradeMajorVersionPrecheckTaskResponse
     */
    public function describeUpgradeMajorVersionPrecheckTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->targetMajorVersion) {
            @$query['TargetMajorVersion'] = $request->targetMajorVersion;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUpgradeMajorVersionPrecheckTask',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUpgradeMajorVersionPrecheckTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the check report for a major engine version upgrade of an ApsaraDB RDS for MySQL instance or ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * PostgreSQL
     * ### [](#)References
     * > Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Check report for the major engine version upgrade of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/2794383.html)
     * *   [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/203309.html)
     * *   [Introduction to the check report of a major engine version upgrade for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/218391.html)
     *
     * @param request - DescribeUpgradeMajorVersionPrecheckTaskRequest
     *
     * @returns DescribeUpgradeMajorVersionPrecheckTaskResponse
     *
     * @param DescribeUpgradeMajorVersionPrecheckTaskRequest $request
     *
     * @return DescribeUpgradeMajorVersionPrecheckTaskResponse
     */
    public function describeUpgradeMajorVersionPrecheckTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUpgradeMajorVersionPrecheckTaskWithOptions($request, $runtime);
    }

    /**
     * Queries the historical tasks for major engine version upgrades of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * PostgreSQL
     *
     * @param request - DescribeUpgradeMajorVersionTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeUpgradeMajorVersionTasksResponse
     *
     * @param DescribeUpgradeMajorVersionTasksRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return DescribeUpgradeMajorVersionTasksResponse
     */
    public function describeUpgradeMajorVersionTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->targetMajorVersion) {
            @$query['TargetMajorVersion'] = $request->targetMajorVersion;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeUpgradeMajorVersionTasks',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeUpgradeMajorVersionTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the historical tasks for major engine version upgrades of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * PostgreSQL
     *
     * @param request - DescribeUpgradeMajorVersionTasksRequest
     *
     * @returns DescribeUpgradeMajorVersionTasksResponse
     *
     * @param DescribeUpgradeMajorVersionTasksRequest $request
     *
     * @return DescribeUpgradeMajorVersionTasksResponse
     */
    public function describeUpgradeMajorVersionTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeUpgradeMajorVersionTasksWithOptions($request, $runtime);
    }

    /**
     * Queries the details of vSwitch that are available in a virtual private cloud (VPC).
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeVSwitchesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeVSwitchesResponse
     *
     * @param DescribeVSwitchesRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DescribeVSwitchesResponse
     */
    public function describeVSwitchesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeVSwitches',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeVSwitchesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of vSwitch that are available in a virtual private cloud (VPC).
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - DescribeVSwitchesRequest
     *
     * @returns DescribeVSwitchesResponse
     *
     * @param DescribeVSwitchesRequest $request
     *
     * @return DescribeVSwitchesResponse
     */
    public function describeVSwitches($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeVSwitchesWithOptions($request, $runtime);
    }

    /**
     * Queries information about the specified IP whitelist.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeWhitelistTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWhitelistTemplateResponse
     *
     * @param DescribeWhitelistTemplateRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DescribeWhitelistTemplateResponse
     */
    public function describeWhitelistTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DescribeWhitelistTemplate',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWhitelistTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the specified IP whitelist.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeWhitelistTemplateRequest
     *
     * @returns DescribeWhitelistTemplateResponse
     *
     * @param DescribeWhitelistTemplateRequest $request
     *
     * @return DescribeWhitelistTemplateResponse
     */
    public function describeWhitelistTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhitelistTemplateWithOptions($request, $runtime);
    }

    /**
     * Queries associated instances by whitelist template.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeWhitelistTemplateLinkedInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DescribeWhitelistTemplateLinkedInstanceResponse
     *
     * @param DescribeWhitelistTemplateLinkedInstanceRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return DescribeWhitelistTemplateLinkedInstanceResponse
     */
    public function describeWhitelistTemplateLinkedInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $body = [];
        if (null !== $request->templateId) {
            @$body['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DescribeWhitelistTemplateLinkedInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DescribeWhitelistTemplateLinkedInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries associated instances by whitelist template.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DescribeWhitelistTemplateLinkedInstanceRequest
     *
     * @returns DescribeWhitelistTemplateLinkedInstanceResponse
     *
     * @param DescribeWhitelistTemplateLinkedInstanceRequest $request
     *
     * @return DescribeWhitelistTemplateLinkedInstanceResponse
     */
    public function describeWhitelistTemplateLinkedInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->describeWhitelistTemplateLinkedInstanceWithOptions($request, $runtime);
    }

    /**
     * You can call the DestroyDBInstance operation to destroy an instance. The instance is in the Locked state.
     *
     * @remarks
     * The DestroyDBInstance operation is phased out.
     *
     * @param request - DestroyDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DestroyDBInstanceResponse
     *
     * @param DestroyDBInstanceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DestroyDBInstanceResponse
     */
    public function destroyDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DestroyDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DestroyDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can call the DestroyDBInstance operation to destroy an instance. The instance is in the Locked state.
     *
     * @remarks
     * The DestroyDBInstance operation is phased out.
     *
     * @param request - DestroyDBInstanceRequest
     *
     * @returns DestroyDBInstanceResponse
     *
     * @param DestroyDBInstanceRequest $request
     *
     * @return DestroyDBInstanceResponse
     */
    public function destroyDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->destroyDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Removes a unit node from a global active database cluster.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [Usage notes](#)
     * This operation can be used to remove only unit nodes.
     *
     * @param request - DetachGadInstanceMemberRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachGadInstanceMemberResponse
     *
     * @param DetachGadInstanceMemberRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return DetachGadInstanceMemberResponse
     */
    public function detachGadInstanceMemberWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->gadInstanceName) {
            @$query['GadInstanceName'] = $request->gadInstanceName;
        }

        if (null !== $request->memberInstanceName) {
            @$query['MemberInstanceName'] = $request->memberInstanceName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachGadInstanceMember',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachGadInstanceMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a unit node from a global active database cluster.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [Usage notes](#)
     * This operation can be used to remove only unit nodes.
     *
     * @param request - DetachGadInstanceMemberRequest
     *
     * @returns DetachGadInstanceMemberResponse
     *
     * @param DetachGadInstanceMemberRequest $request
     *
     * @return DetachGadInstanceMemberResponse
     */
    public function detachGadInstanceMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachGadInstanceMemberWithOptions($request, $runtime);
    }

    /**
     * Detaches a pay-as-you-go data disk or a system disk from an RDS Custom instance.
     *
     * @param request - DetachRCDiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachRCDiskResponse
     *
     * @param DetachRCDiskRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DetachRCDiskResponse
     */
    public function detachRCDiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->deleteWithInstance) {
            @$query['DeleteWithInstance'] = $request->deleteWithInstance;
        }

        if (null !== $request->diskId) {
            @$query['DiskId'] = $request->diskId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachRCDisk',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachRCDiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Detaches a pay-as-you-go data disk or a system disk from an RDS Custom instance.
     *
     * @param request - DetachRCDiskRequest
     *
     * @returns DetachRCDiskResponse
     *
     * @param DetachRCDiskRequest $request
     *
     * @return DetachRCDiskResponse
     */
    public function detachRCDisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachRCDiskWithOptions($request, $runtime);
    }

    /**
     * Disassociates a whitelist template from an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DetachWhitelistTemplateToInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DetachWhitelistTemplateToInstanceResponse
     *
     * @param DetachWhitelistTemplateToInstanceRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return DetachWhitelistTemplateToInstanceResponse
     */
    public function detachWhitelistTemplateToInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->insName) {
            @$query['InsName'] = $request->insName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DetachWhitelistTemplateToInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DetachWhitelistTemplateToInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Disassociates a whitelist template from an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - DetachWhitelistTemplateToInstanceRequest
     *
     * @returns DetachWhitelistTemplateToInstanceResponse
     *
     * @param DetachWhitelistTemplateToInstanceRequest $request
     *
     * @return DetachWhitelistTemplateToInstanceResponse
     */
    public function detachWhitelistTemplateToInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->detachWhitelistTemplateToInstanceWithOptions($request, $runtime);
    }

    /**
     * 评估紧急本地扩容磁盘解锁可使用的磁盘空间.
     *
     * @param request - EvaluateLocalExtendDiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EvaluateLocalExtendDiskResponse
     *
     * @param EvaluateLocalExtendDiskRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return EvaluateLocalExtendDiskResponse
     */
    public function evaluateLocalExtendDiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->storage) {
            @$query['Storage'] = $request->storage;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'EvaluateLocalExtendDisk',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EvaluateLocalExtendDiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 评估紧急本地扩容磁盘解锁可使用的磁盘空间.
     *
     * @param request - EvaluateLocalExtendDiskRequest
     *
     * @returns EvaluateLocalExtendDiskResponse
     *
     * @param EvaluateLocalExtendDiskRequest $request
     *
     * @return EvaluateLocalExtendDiskResponse
     */
    public function evaluateLocalExtendDisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->evaluateLocalExtendDiskWithOptions($request, $runtime);
    }

    /**
     * Queries the topology of an instance.
     *
     * @remarks
     * ### Supported database engines
     * RDS MySQL
     *
     * @param request - GetDBInstanceTopologyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDBInstanceTopologyResponse
     *
     * @param GetDBInstanceTopologyRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetDBInstanceTopologyResponse
     */
    public function getDBInstanceTopologyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDBInstanceTopology',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDBInstanceTopologyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the topology of an instance.
     *
     * @remarks
     * ### Supported database engines
     * RDS MySQL
     *
     * @param request - GetDBInstanceTopologyRequest
     *
     * @returns GetDBInstanceTopologyResponse
     *
     * @param GetDBInstanceTopologyRequest $request
     *
     * @return GetDBInstanceTopologyResponse
     */
    public function getDBInstanceTopology($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDBInstanceTopologyWithOptions($request, $runtime);
    }

    /**
     * Queries the SSL encryption settings for a dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS MySQL
     *
     * @param request - GetDbProxyInstanceSslRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDbProxyInstanceSslResponse
     *
     * @param GetDbProxyInstanceSslRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetDbProxyInstanceSslResponse
     */
    public function getDbProxyInstanceSslWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->dbInstanceId) {
            @$query['DbInstanceId'] = $request->dbInstanceId;
        }

        if (null !== $request->dbInstanceId) {
            @$query['DbInstanceId'] = $request->dbInstanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDbProxyInstanceSsl',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDbProxyInstanceSslResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the SSL encryption settings for a dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS MySQL
     *
     * @param request - GetDbProxyInstanceSslRequest
     *
     * @returns GetDbProxyInstanceSslResponse
     *
     * @param GetDbProxyInstanceSslRequest $request
     *
     * @return GetDbProxyInstanceSslResponse
     */
    public function getDbProxyInstanceSsl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDbProxyInstanceSslWithOptions($request, $runtime);
    }

    /**
     * Grants an account the permissions on a database of an instance.
     *
     * @remarks
     * Each account can be granted permissions on one or more databases. Before you call this operation, make sure that the instance is in the Running state.
     * > This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition or run PostgreSQL with local disks.
     *
     * @param request - GrantAccountPrivilegeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GrantAccountPrivilegeResponse
     *
     * @param GrantAccountPrivilegeRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GrantAccountPrivilegeResponse
     */
    public function grantAccountPrivilegeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->accountPrivilege) {
            @$query['AccountPrivilege'] = $request->accountPrivilege;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GrantAccountPrivilege',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GrantAccountPrivilegeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Grants an account the permissions on a database of an instance.
     *
     * @remarks
     * Each account can be granted permissions on one or more databases. Before you call this operation, make sure that the instance is in the Running state.
     * > This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition or run PostgreSQL with local disks.
     *
     * @param request - GrantAccountPrivilegeRequest
     *
     * @returns GrantAccountPrivilegeResponse
     *
     * @param GrantAccountPrivilegeRequest $request
     *
     * @return GrantAccountPrivilegeResponse
     */
    public function grantAccountPrivilege($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->grantAccountPrivilegeWithOptions($request, $runtime);
    }

    /**
     * Grant permissions to a service account.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96102.html)
     * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95693.html)
     *
     * @param request - GrantOperatorPermissionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GrantOperatorPermissionResponse
     *
     * @param GrantOperatorPermissionRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GrantOperatorPermissionResponse
     */
    public function grantOperatorPermissionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->expiredTime) {
            @$query['ExpiredTime'] = $request->expiredTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->privileges) {
            @$query['Privileges'] = $request->privileges;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GrantOperatorPermission',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GrantOperatorPermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Grant permissions to a service account.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96102.html)
     * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95693.html)
     *
     * @param request - GrantOperatorPermissionRequest
     *
     * @returns GrantOperatorPermissionResponse
     *
     * @param GrantOperatorPermissionRequest $request
     *
     * @return GrantOperatorPermissionResponse
     */
    public function grantOperatorPermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->grantOperatorPermissionWithOptions($request, $runtime);
    }

    /**
     * Imports the backup data of a self-managed instance that runs MySQL 5.7 to an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [](#)Description
     * A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance.
     * ### [](#)Usage notes
     * Before you call this operation, make sure that the following requirements are met:
     * *   The self-managed MySQL instance runs MySQL 5.7 and is backed up by using XtraBackup. The name of the backup file ends with `_qp.xb`. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](https://help.aliyun.com/document_detail/251779.html).
     * *   The full backup file of the self-managed MySQL instance is uploaded to an Object Storage Service (OSS) bucket in the region of the ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](https://help.aliyun.com/document_detail/251779.html).
     * >  This operation is supported only for MySQL 5.7.
     *
     * @param request - ImportUserBackupFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ImportUserBackupFileResponse
     *
     * @param ImportUserBackupFileRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ImportUserBackupFileResponse
     */
    public function importUserBackupFileWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupFile) {
            @$query['BackupFile'] = $request->backupFile;
        }

        if (null !== $request->bucketRegion) {
            @$query['BucketRegion'] = $request->bucketRegion;
        }

        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreSize) {
            @$query['RestoreSize'] = $request->restoreSize;
        }

        if (null !== $request->retention) {
            @$query['Retention'] = $request->retention;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ImportUserBackupFile',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ImportUserBackupFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Imports the backup data of a self-managed instance that runs MySQL 5.7 to an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [](#)Description
     * A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance.
     * ### [](#)Usage notes
     * Before you call this operation, make sure that the following requirements are met:
     * *   The self-managed MySQL instance runs MySQL 5.7 and is backed up by using XtraBackup. The name of the backup file ends with `_qp.xb`. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](https://help.aliyun.com/document_detail/251779.html).
     * *   The full backup file of the self-managed MySQL instance is uploaded to an Object Storage Service (OSS) bucket in the region of the ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](https://help.aliyun.com/document_detail/251779.html).
     * >  This operation is supported only for MySQL 5.7.
     *
     * @param request - ImportUserBackupFileRequest
     *
     * @returns ImportUserBackupFileResponse
     *
     * @param ImportUserBackupFileRequest $request
     *
     * @return ImportUserBackupFileResponse
     */
    public function importUserBackupFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->importUserBackupFileWithOptions($request, $runtime);
    }

    /**
     * Queries the specification details of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - ListClassesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListClassesResponse
     *
     * @param ListClassesRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return ListClassesResponse
     */
    public function listClassesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->engine) {
            @$query['Engine'] = $request->engine;
        }

        if (null !== $request->orderType) {
            @$query['OrderType'] = $request->orderType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListClasses',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListClassesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the specification details of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - ListClassesRequest
     *
     * @returns ListClassesResponse
     *
     * @param ListClassesRequest $request
     *
     * @return ListClassesResponse
     */
    public function listClasses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClassesWithOptions($request, $runtime);
    }

    /**
     * Queries the tags that are added to one or more instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - ListTagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTagResourcesResponse
     *
     * @param ListTagResourcesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListTagResourcesResponse
     */
    public function listTagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTagResources',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the tags that are added to one or more instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     *
     * @param request - ListTagResourcesRequest
     *
     * @returns ListTagResourcesResponse
     *
     * @param ListTagResourcesRequest $request
     *
     * @return ListTagResourcesResponse
     */
    public function listTagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTagResourcesWithOptions($request, $runtime);
    }

    /**
     * Queries the details about the full backup files that are imported into an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [](#)Feature description
     * *   A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](https://help.aliyun.com/document_detail/251779.html).
     * *   Before you call the [CreateDBInstance](https://help.aliyun.com/document_detail/26228.html) operation to create an ApsaraDB RDS for MySQL instance into which you want to import full backup files, you can call this operation to query the IDs of full backup files.
     * *   You can call the [ImportUserBackupFile](https://help.aliyun.com/document_detail/260266.html) operation to import a full backup file into an ApsaraDB RDS for MySQL instance.
     *
     * @param request - ListUserBackupFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListUserBackupFilesResponse
     *
     * @param ListUserBackupFilesRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListUserBackupFilesResponse
     */
    public function listUserBackupFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->ossUrl) {
            @$query['OssUrl'] = $request->ossUrl;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListUserBackupFiles',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListUserBackupFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details about the full backup files that are imported into an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [](#)Feature description
     * *   A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](https://help.aliyun.com/document_detail/251779.html).
     * *   Before you call the [CreateDBInstance](https://help.aliyun.com/document_detail/26228.html) operation to create an ApsaraDB RDS for MySQL instance into which you want to import full backup files, you can call this operation to query the IDs of full backup files.
     * *   You can call the [ImportUserBackupFile](https://help.aliyun.com/document_detail/260266.html) operation to import a full backup file into an ApsaraDB RDS for MySQL instance.
     *
     * @param request - ListUserBackupFilesRequest
     *
     * @returns ListUserBackupFilesResponse
     *
     * @param ListUserBackupFilesRequest $request
     *
     * @return ListUserBackupFilesResponse
     */
    public function listUserBackupFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listUserBackupFilesWithOptions($request, $runtime);
    }

    /**
     * Locks an account of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/147649.html)
     *
     * @param request - LockAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns LockAccountResponse
     *
     * @param LockAccountRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return LockAccountResponse
     */
    public function lockAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'LockAccount',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return LockAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Locks an account of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/147649.html)
     *
     * @param request - LockAccountRequest
     *
     * @returns LockAccountResponse
     *
     * @param LockAccountRequest $request
     *
     * @return LockAccountResponse
     */
    public function lockAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->lockAccountWithOptions($request, $runtime);
    }

    /**
     * Migrates an instance to a different zone.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](https://help.aliyun.com/document_detail/96746.html)
     * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](https://help.aliyun.com/document_detail/96746.html)
     * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](https://help.aliyun.com/document_detail/95658.html)
     *
     * @param request - MigrateConnectionToOtherZoneRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MigrateConnectionToOtherZoneResponse
     *
     * @param MigrateConnectionToOtherZoneRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return MigrateConnectionToOtherZoneResponse
     */
    public function migrateConnectionToOtherZoneWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->connectionString) {
            @$query['ConnectionString'] = $request->connectionString;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MigrateConnectionToOtherZone',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MigrateConnectionToOtherZoneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Migrates an instance to a different zone.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](https://help.aliyun.com/document_detail/96746.html)
     * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](https://help.aliyun.com/document_detail/96746.html)
     * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](https://help.aliyun.com/document_detail/95658.html)
     *
     * @param request - MigrateConnectionToOtherZoneRequest
     *
     * @returns MigrateConnectionToOtherZoneResponse
     *
     * @param MigrateConnectionToOtherZoneRequest $request
     *
     * @return MigrateConnectionToOtherZoneResponse
     */
    public function migrateConnectionToOtherZone($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->migrateConnectionToOtherZoneWithOptions($request, $runtime);
    }

    /**
     * Migrates an instance across hosts in a dedicated cluster.
     *
     * @remarks
     * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](https://help.aliyun.com/document_detail/141455.html)
     *
     * @param request - MigrateDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MigrateDBInstanceResponse
     *
     * @param MigrateDBInstanceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return MigrateDBInstanceResponse
     */
    public function migrateDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->specifiedTime) {
            @$query['SpecifiedTime'] = $request->specifiedTime;
        }

        if (null !== $request->targetDedicatedHostIdForMaster) {
            @$query['TargetDedicatedHostIdForMaster'] = $request->targetDedicatedHostIdForMaster;
        }

        if (null !== $request->targetDedicatedHostIdForSlave) {
            @$query['TargetDedicatedHostIdForSlave'] = $request->targetDedicatedHostIdForSlave;
        }

        if (null !== $request->zoneIdForFollower) {
            @$query['ZoneIdForFollower'] = $request->zoneIdForFollower;
        }

        if (null !== $request->zoneIdForLog) {
            @$query['ZoneIdForLog'] = $request->zoneIdForLog;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MigrateDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MigrateDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Migrates an instance across hosts in a dedicated cluster.
     *
     * @remarks
     * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](https://help.aliyun.com/document_detail/141455.html)
     *
     * @param request - MigrateDBInstanceRequest
     *
     * @returns MigrateDBInstanceResponse
     *
     * @param MigrateDBInstanceRequest $request
     *
     * @return MigrateDBInstanceResponse
     */
    public function migrateDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->migrateDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Changes the zone of a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition.
     *
     * @param tmpReq - MigrateDBNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MigrateDBNodesResponse
     *
     * @param MigrateDBNodesRequest $tmpReq
     * @param RuntimeOptions        $runtime
     *
     * @return MigrateDBNodesResponse
     */
    public function migrateDBNodesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new MigrateDBNodesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->DBNode) {
            $request->DBNodeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->DBNode, 'DBNode', 'json');
        }

        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBNodeShrink) {
            @$query['DBNode'] = $request->DBNodeShrink;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MigrateDBNodes',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MigrateDBNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the zone of a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition.
     *
     * @param request - MigrateDBNodesRequest
     *
     * @returns MigrateDBNodesResponse
     *
     * @param MigrateDBNodesRequest $request
     *
     * @return MigrateDBNodesResponse
     */
    public function migrateDBNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->migrateDBNodesWithOptions($request, $runtime);
    }

    /**
     * Changes the whitelist mode of an instance from the standard whitelist mode to the enhanced whitelist mode.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Change the whitelist mode of an ApsaraDB RDS for MySQL instance to the enhanced whitelist mode](https://help.aliyun.com/document_detail/96117.html)
     * *   [Change the whitelist mode of an ApsaraDB RDS for PostgreSQL instance to the enhanced whitelist mode](https://help.aliyun.com/document_detail/96767.html)
     *
     * @param request - MigrateSecurityIPModeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MigrateSecurityIPModeResponse
     *
     * @param MigrateSecurityIPModeRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return MigrateSecurityIPModeResponse
     */
    public function migrateSecurityIPModeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MigrateSecurityIPMode',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MigrateSecurityIPModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the whitelist mode of an instance from the standard whitelist mode to the enhanced whitelist mode.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Change the whitelist mode of an ApsaraDB RDS for MySQL instance to the enhanced whitelist mode](https://help.aliyun.com/document_detail/96117.html)
     * *   [Change the whitelist mode of an ApsaraDB RDS for PostgreSQL instance to the enhanced whitelist mode](https://help.aliyun.com/document_detail/96767.html)
     *
     * @param request - MigrateSecurityIPModeRequest
     *
     * @returns MigrateSecurityIPModeResponse
     *
     * @param MigrateSecurityIPModeRequest $request
     *
     * @return MigrateSecurityIPModeResponse
     */
    public function migrateSecurityIPMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->migrateSecurityIPModeWithOptions($request, $runtime);
    }

    /**
     * Migrates an instance across zones in the same region.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](https://help.aliyun.com/document_detail/96053.html)
     * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](https://help.aliyun.com/document_detail/96746.html)
     * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](https://help.aliyun.com/document_detail/95658.html)
     *
     * @param request - MigrateToOtherZoneRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns MigrateToOtherZoneResponse
     *
     * @param MigrateToOtherZoneRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return MigrateToOtherZoneResponse
     */
    public function migrateToOtherZoneWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->ioAccelerationEnabled) {
            @$query['IoAccelerationEnabled'] = $request->ioAccelerationEnabled;
        }

        if (null !== $request->isModifySpec) {
            @$query['IsModifySpec'] = $request->isModifySpec;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        if (null !== $request->zoneIdSlave1) {
            @$query['ZoneIdSlave1'] = $request->zoneIdSlave1;
        }

        if (null !== $request->zoneIdSlave2) {
            @$query['ZoneIdSlave2'] = $request->zoneIdSlave2;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'MigrateToOtherZone',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return MigrateToOtherZoneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Migrates an instance across zones in the same region.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](https://help.aliyun.com/document_detail/96053.html)
     * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](https://help.aliyun.com/document_detail/96746.html)
     * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](https://help.aliyun.com/document_detail/95658.html)
     *
     * @param request - MigrateToOtherZoneRequest
     *
     * @returns MigrateToOtherZoneResponse
     *
     * @param MigrateToOtherZoneRequest $request
     *
     * @return MigrateToOtherZoneResponse
     */
    public function migrateToOtherZone($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->migrateToOtherZoneWithOptions($request, $runtime);
    }

    /**
     * Modifies the AD domain information about an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Connect an RDS instance to a self-managed domain](https://help.aliyun.com/document_detail/170734.html)
     *
     * @param request - ModifyADInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyADInfoResponse
     *
     * @param ModifyADInfoRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ModifyADInfoResponse
     */
    public function modifyADInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ADAccountName) {
            @$query['ADAccountName'] = $request->ADAccountName;
        }

        if (null !== $request->ADDNS) {
            @$query['ADDNS'] = $request->ADDNS;
        }

        if (null !== $request->ADPassword) {
            @$query['ADPassword'] = $request->ADPassword;
        }

        if (null !== $request->ADServerIpAddress) {
            @$query['ADServerIpAddress'] = $request->ADServerIpAddress;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyADInfo',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyADInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the AD domain information about an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Connect an RDS instance to a self-managed domain](https://help.aliyun.com/document_detail/170734.html)
     *
     * @param request - ModifyADInfoRequest
     *
     * @returns ModifyADInfoResponse
     *
     * @param ModifyADInfoRequest $request
     *
     * @return ModifyADInfoResponse
     */
    public function modifyADInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyADInfoWithOptions($request, $runtime);
    }

    /**
     * Checks whether a password policy is applied to an account.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     *
     * @param request - ModifyAccountCheckPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAccountCheckPolicyResponse
     *
     * @param ModifyAccountCheckPolicyRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyAccountCheckPolicyResponse
     */
    public function modifyAccountCheckPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->checkPolicy) {
            @$query['CheckPolicy'] = $request->checkPolicy;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAccountCheckPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAccountCheckPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether a password policy is applied to an account.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     *
     * @param request - ModifyAccountCheckPolicyRequest
     *
     * @returns ModifyAccountCheckPolicyResponse
     *
     * @param ModifyAccountCheckPolicyRequest $request
     *
     * @return ModifyAccountCheckPolicyResponse
     */
    public function modifyAccountCheckPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAccountCheckPolicyWithOptions($request, $runtime);
    }

    /**
     * Modifies the description of a database account.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - ModifyAccountDescriptionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAccountDescriptionResponse
     *
     * @param ModifyAccountDescriptionRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyAccountDescriptionResponse
     */
    public function modifyAccountDescriptionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountDescription) {
            @$query['AccountDescription'] = $request->accountDescription;
        }

        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAccountDescription',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAccountDescriptionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the description of a database account.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - ModifyAccountDescriptionRequest
     *
     * @returns ModifyAccountDescriptionResponse
     *
     * @param ModifyAccountDescriptionRequest $request
     *
     * @return ModifyAccountDescriptionResponse
     */
    public function modifyAccountDescription($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAccountDescriptionWithOptions($request, $runtime);
    }

    /**
     * 修改全密态用户权限.
     *
     * @param request - ModifyAccountMaskingPrivilegeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAccountMaskingPrivilegeResponse
     *
     * @param ModifyAccountMaskingPrivilegeRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ModifyAccountMaskingPrivilegeResponse
     */
    public function modifyAccountMaskingPrivilegeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->expireTime) {
            @$query['ExpireTime'] = $request->expireTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->privilege) {
            @$query['Privilege'] = $request->privilege;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->userName) {
            @$query['UserName'] = $request->userName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAccountMaskingPrivilege',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAccountMaskingPrivilegeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 修改全密态用户权限.
     *
     * @param request - ModifyAccountMaskingPrivilegeRequest
     *
     * @returns ModifyAccountMaskingPrivilegeResponse
     *
     * @param ModifyAccountMaskingPrivilegeRequest $request
     *
     * @return ModifyAccountMaskingPrivilegeResponse
     */
    public function modifyAccountMaskingPrivilege($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAccountMaskingPrivilegeWithOptions($request, $runtime);
    }

    /**
     * Modifies the password policy for an account of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server (This parameter is unavailable for ApsaraDB RDS for SQL Server instances that belong to the shared instance family and run SQL Server 2008 R2.)
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Create a custom password policy for an account of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95640.html)
     *
     * @param request - ModifyAccountSecurityPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyAccountSecurityPolicyResponse
     *
     * @param ModifyAccountSecurityPolicyRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifyAccountSecurityPolicyResponse
     */
    public function modifyAccountSecurityPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->groupPolicy) {
            @$query['GroupPolicy'] = $request->groupPolicy;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyAccountSecurityPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyAccountSecurityPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the password policy for an account of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server (This parameter is unavailable for ApsaraDB RDS for SQL Server instances that belong to the shared instance family and run SQL Server 2008 R2.)
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Create a custom password policy for an account of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95640.html)
     *
     * @param request - ModifyAccountSecurityPolicyRequest
     *
     * @returns ModifyAccountSecurityPolicyResponse
     *
     * @param ModifyAccountSecurityPolicyRequest $request
     *
     * @return ModifyAccountSecurityPolicyResponse
     */
    public function modifyAccountSecurityPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyAccountSecurityPolicyWithOptions($request, $runtime);
    }

    /**
     * Enables or disables the event history feature of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [View the event history of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/129759.html)
     * *   [View the event history of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/131008.html)
     * *   [View the event history of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/131013.html)
     * *   [View the event history of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/131010.html)
     *
     * @param request - ModifyActionEventPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyActionEventPolicyResponse
     *
     * @param ModifyActionEventPolicyRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyActionEventPolicyResponse
     */
    public function modifyActionEventPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->enableEventLog) {
            @$query['EnableEventLog'] = $request->enableEventLog;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyActionEventPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyActionEventPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables the event history feature of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [View the event history of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/129759.html)
     * *   [View the event history of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/131008.html)
     * *   [View the event history of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/131013.html)
     * *   [View the event history of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/131010.html)
     *
     * @param request - ModifyActionEventPolicyRequest
     *
     * @returns ModifyActionEventPolicyResponse
     *
     * @param ModifyActionEventPolicyRequest $request
     *
     * @return ModifyActionEventPolicyResponse
     */
    public function modifyActionEventPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyActionEventPolicyWithOptions($request, $runtime);
    }

    /**
     * Changes the switching time of scheduled O\\\\\\&M tasks for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Scheduled events for ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/104183.html)
     * *   [Scheduled events for ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/104452.html)
     * *   [Scheduled events for ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/104451.html)
     * *   [Scheduled events for ApsaraDB RDS for MariaDB instances](https://help.aliyun.com/document_detail/104454.html)
     *
     * @param request - ModifyActiveOperationTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyActiveOperationTasksResponse
     *
     * @param ModifyActiveOperationTasksRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyActiveOperationTasksResponse
     */
    public function modifyActiveOperationTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ids) {
            @$query['Ids'] = $request->ids;
        }

        if (null !== $request->immediateStart) {
            @$query['ImmediateStart'] = $request->immediateStart;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyActiveOperationTasks',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyActiveOperationTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the switching time of scheduled O\\\\\\&M tasks for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Scheduled events for ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/104183.html)
     * *   [Scheduled events for ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/104452.html)
     * *   [Scheduled events for ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/104451.html)
     * *   [Scheduled events for ApsaraDB RDS for MariaDB instances](https://help.aliyun.com/document_detail/104454.html)
     *
     * @param request - ModifyActiveOperationTasksRequest
     *
     * @returns ModifyActiveOperationTasksResponse
     *
     * @param ModifyActiveOperationTasksRequest $request
     *
     * @return ModifyActiveOperationTasksResponse
     */
    public function modifyActiveOperationTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyActiveOperationTasksWithOptions($request, $runtime);
    }

    /**
     * Modifies the backup policy settings of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure an automatic backup policy for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/98818.html)
     * *   [Configure an automatic backup policy for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96772.html)
     * *   [Configure an automatic backup policy for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95717.html)
     * *   [Configure an automatic backup policy for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97147.html)
     *
     * @param request - ModifyBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyBackupPolicyResponse
     *
     * @param ModifyBackupPolicyRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyBackupPolicyResponse
     */
    public function modifyBackupPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->archiveBackupKeepCount) {
            @$query['ArchiveBackupKeepCount'] = $request->archiveBackupKeepCount;
        }

        if (null !== $request->archiveBackupKeepPolicy) {
            @$query['ArchiveBackupKeepPolicy'] = $request->archiveBackupKeepPolicy;
        }

        if (null !== $request->archiveBackupRetentionPeriod) {
            @$query['ArchiveBackupRetentionPeriod'] = $request->archiveBackupRetentionPeriod;
        }

        if (null !== $request->backupInterval) {
            @$query['BackupInterval'] = $request->backupInterval;
        }

        if (null !== $request->backupLog) {
            @$query['BackupLog'] = $request->backupLog;
        }

        if (null !== $request->backupMethod) {
            @$query['BackupMethod'] = $request->backupMethod;
        }

        if (null !== $request->backupPolicyMode) {
            @$query['BackupPolicyMode'] = $request->backupPolicyMode;
        }

        if (null !== $request->backupPriority) {
            @$query['BackupPriority'] = $request->backupPriority;
        }

        if (null !== $request->backupRetentionPeriod) {
            @$query['BackupRetentionPeriod'] = $request->backupRetentionPeriod;
        }

        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->compressType) {
            @$query['CompressType'] = $request->compressType;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->enableBackupLog) {
            @$query['EnableBackupLog'] = $request->enableBackupLog;
        }

        if (null !== $request->enableIncrementDataBackup) {
            @$query['EnableIncrementDataBackup'] = $request->enableIncrementDataBackup;
        }

        if (null !== $request->highSpaceUsageProtection) {
            @$query['HighSpaceUsageProtection'] = $request->highSpaceUsageProtection;
        }

        if (null !== $request->localLogRetentionHours) {
            @$query['LocalLogRetentionHours'] = $request->localLogRetentionHours;
        }

        if (null !== $request->localLogRetentionSpace) {
            @$query['LocalLogRetentionSpace'] = $request->localLogRetentionSpace;
        }

        if (null !== $request->logBackupFrequency) {
            @$query['LogBackupFrequency'] = $request->logBackupFrequency;
        }

        if (null !== $request->logBackupLocalRetentionNumber) {
            @$query['LogBackupLocalRetentionNumber'] = $request->logBackupLocalRetentionNumber;
        }

        if (null !== $request->logBackupRetentionPeriod) {
            @$query['LogBackupRetentionPeriod'] = $request->logBackupRetentionPeriod;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->preferredBackupPeriod) {
            @$query['PreferredBackupPeriod'] = $request->preferredBackupPeriod;
        }

        if (null !== $request->preferredBackupTime) {
            @$query['PreferredBackupTime'] = $request->preferredBackupTime;
        }

        if (null !== $request->releasedKeepPolicy) {
            @$query['ReleasedKeepPolicy'] = $request->releasedKeepPolicy;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyBackupPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the backup policy settings of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure an automatic backup policy for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/98818.html)
     * *   [Configure an automatic backup policy for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96772.html)
     * *   [Configure an automatic backup policy for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95717.html)
     * *   [Configure an automatic backup policy for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97147.html)
     *
     * @param request - ModifyBackupPolicyRequest
     *
     * @returns ModifyBackupPolicyResponse
     *
     * @param ModifyBackupPolicyRequest $request
     *
     * @return ModifyBackupPolicyResponse
     */
    public function modifyBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * Modifies the character set collation and time zone of system databases on an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS SQL Server
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Change the character set collation and the time zone of system databases](https://help.aliyun.com/document_detail/95700.html)
     *
     * @param request - ModifyCollationTimeZoneRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCollationTimeZoneResponse
     *
     * @param ModifyCollationTimeZoneRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyCollationTimeZoneResponse
     */
    public function modifyCollationTimeZoneWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->collation) {
            @$query['Collation'] = $request->collation;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->timezone) {
            @$query['Timezone'] = $request->timezone;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCollationTimeZone',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCollationTimeZoneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the character set collation and time zone of system databases on an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS SQL Server
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Change the character set collation and the time zone of system databases](https://help.aliyun.com/document_detail/95700.html)
     *
     * @param request - ModifyCollationTimeZoneRequest
     *
     * @returns ModifyCollationTimeZoneResponse
     *
     * @param ModifyCollationTimeZoneRequest $request
     *
     * @return ModifyCollationTimeZoneResponse
     */
    public function modifyCollationTimeZone($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCollationTimeZoneWithOptions($request, $runtime);
    }

    /**
     * 修改实例资源.
     *
     * @param request - ModifyCustinsResourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyCustinsResourceResponse
     *
     * @param ModifyCustinsResourceRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyCustinsResourceResponse
     */
    public function modifyCustinsResourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->adjustDeadline) {
            @$query['AdjustDeadline'] = $request->adjustDeadline;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->increaseRatio) {
            @$query['IncreaseRatio'] = $request->increaseRatio;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->restoreOriginalSpecification) {
            @$query['RestoreOriginalSpecification'] = $request->restoreOriginalSpecification;
        }

        if (null !== $request->targetValue) {
            @$query['TargetValue'] = $request->targetValue;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyCustinsResource',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyCustinsResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 修改实例资源.
     *
     * @param request - ModifyCustinsResourceRequest
     *
     * @returns ModifyCustinsResourceResponse
     *
     * @param ModifyCustinsResourceRequest $request
     *
     * @return ModifyCustinsResourceResponse
     */
    public function modifyCustinsResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyCustinsResourceWithOptions($request, $runtime);
    }

    /**
     * Modifies the description of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - ModifyDBDescriptionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBDescriptionResponse
     *
     * @param ModifyDBDescriptionRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyDBDescriptionResponse
     */
    public function modifyDBDescriptionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBDescription) {
            @$query['DBDescription'] = $request->DBDescription;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBDescription',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBDescriptionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the description of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     *
     * @param request - ModifyDBDescriptionRequest
     *
     * @returns ModifyDBDescriptionResponse
     *
     * @param ModifyDBDescriptionRequest $request
     *
     * @return ModifyDBDescriptionResponse
     */
    public function modifyDBDescription($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBDescriptionWithOptions($request, $runtime);
    }

    /**
     * Changes the method that is used to update the minor engine version of an ApsaraDB RDS for MySQL instance or an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Modify automatic update settings for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96059.html)
     * *   [Modify automatic update settings for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/146895.html)
     *
     * @param request - ModifyDBInstanceAutoUpgradeMinorVersionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceAutoUpgradeMinorVersionResponse
     *
     * @param ModifyDBInstanceAutoUpgradeMinorVersionRequest $request
     * @param RuntimeOptions                                 $runtime
     *
     * @return ModifyDBInstanceAutoUpgradeMinorVersionResponse
     */
    public function modifyDBInstanceAutoUpgradeMinorVersionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoUpgradeMinorVersion) {
            @$query['AutoUpgradeMinorVersion'] = $request->autoUpgradeMinorVersion;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceAutoUpgradeMinorVersion',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceAutoUpgradeMinorVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the method that is used to update the minor engine version of an ApsaraDB RDS for MySQL instance or an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Modify automatic update settings for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96059.html)
     * *   [Modify automatic update settings for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/146895.html)
     *
     * @param request - ModifyDBInstanceAutoUpgradeMinorVersionRequest
     *
     * @returns ModifyDBInstanceAutoUpgradeMinorVersionResponse
     *
     * @param ModifyDBInstanceAutoUpgradeMinorVersionRequest $request
     *
     * @return ModifyDBInstanceAutoUpgradeMinorVersionResponse
     */
    public function modifyDBInstanceAutoUpgradeMinorVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceAutoUpgradeMinorVersionWithOptions($request, $runtime);
    }

    /**
     * Modifies the configuration item of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * *   SQL Server
     * >  The configuration items that are supported are pgbouncer and clear_errorlog. For more information, see [PgBouncer of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/2398301.html) and [Error log cleanup of ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/95645.html).
     *
     * @param request - ModifyDBInstanceConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceConfigResponse
     *
     * @param ModifyDBInstanceConfigRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyDBInstanceConfigResponse
     */
    public function modifyDBInstanceConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->configName) {
            @$query['ConfigName'] = $request->configName;
        }

        if (null !== $request->configValue) {
            @$query['ConfigValue'] = $request->configValue;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        if (null !== $request->switchTimeMode) {
            @$query['SwitchTimeMode'] = $request->switchTimeMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the configuration item of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * *   SQL Server
     * >  The configuration items that are supported are pgbouncer and clear_errorlog. For more information, see [PgBouncer of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/2398301.html) and [Error log cleanup of ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/95645.html).
     *
     * @param request - ModifyDBInstanceConfigRequest
     *
     * @returns ModifyDBInstanceConfigResponse
     *
     * @param ModifyDBInstanceConfigRequest $request
     *
     * @return ModifyDBInstanceConfigResponse
     */
    public function modifyDBInstanceConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the endpoint and port of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
     * *   [Change the endpoint and port number of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96163.html)
     * *   [Change the endpoint and port number of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96788.html)
     * *   [Change the endpoint and port number of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95740.html)
     * *   [Change the endpoint and port number of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97157.html)
     *
     * @param request - ModifyDBInstanceConnectionStringRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceConnectionStringResponse
     *
     * @param ModifyDBInstanceConnectionStringRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ModifyDBInstanceConnectionStringResponse
     */
    public function modifyDBInstanceConnectionStringWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->babelfishPort) {
            @$query['BabelfishPort'] = $request->babelfishPort;
        }

        if (null !== $request->connectionStringPrefix) {
            @$query['ConnectionStringPrefix'] = $request->connectionStringPrefix;
        }

        if (null !== $request->currentConnectionString) {
            @$query['CurrentConnectionString'] = $request->currentConnectionString;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->generalGroupName) {
            @$query['GeneralGroupName'] = $request->generalGroupName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->PGBouncerPort) {
            @$query['PGBouncerPort'] = $request->PGBouncerPort;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceConnectionString',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceConnectionStringResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the endpoint and port of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
     * *   [Change the endpoint and port number of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96163.html)
     * *   [Change the endpoint and port number of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96788.html)
     * *   [Change the endpoint and port number of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95740.html)
     * *   [Change the endpoint and port number of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97157.html)
     *
     * @param request - ModifyDBInstanceConnectionStringRequest
     *
     * @returns ModifyDBInstanceConnectionStringResponse
     *
     * @param ModifyDBInstanceConnectionStringRequest $request
     *
     * @return ModifyDBInstanceConnectionStringResponse
     */
    public function modifyDBInstanceConnectionString($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceConnectionStringWithOptions($request, $runtime);
    }

    /**
     * Configures the replication latency for a read-only ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure a data replication latency for a read-only ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96056.html)
     *
     * @param request - ModifyDBInstanceDelayedReplicationTimeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceDelayedReplicationTimeResponse
     *
     * @param ModifyDBInstanceDelayedReplicationTimeRequest $request
     * @param RuntimeOptions                                $runtime
     *
     * @return ModifyDBInstanceDelayedReplicationTimeResponse
     */
    public function modifyDBInstanceDelayedReplicationTimeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->readSQLReplicationTime) {
            @$query['ReadSQLReplicationTime'] = $request->readSQLReplicationTime;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceDelayedReplicationTime',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceDelayedReplicationTimeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures the replication latency for a read-only ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure a data replication latency for a read-only ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96056.html)
     *
     * @param request - ModifyDBInstanceDelayedReplicationTimeRequest
     *
     * @returns ModifyDBInstanceDelayedReplicationTimeResponse
     *
     * @param ModifyDBInstanceDelayedReplicationTimeRequest $request
     *
     * @return ModifyDBInstanceDelayedReplicationTimeResponse
     */
    public function modifyDBInstanceDelayedReplicationTime($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceDelayedReplicationTimeWithOptions($request, $runtime);
    }

    /**
     * Enable or disable the release protection feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Enable and disable instance release protection for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/414512.html)
     * *   [Enable and disable instance release protection for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/471512.html)
     * *   [Enable and disable instance release protection for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/416209.html)
     * *   [Enable and disable release protection for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/414512.html)
     *
     * @param request - ModifyDBInstanceDeletionProtectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceDeletionProtectionResponse
     *
     * @param ModifyDBInstanceDeletionProtectionRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ModifyDBInstanceDeletionProtectionResponse
     */
    public function modifyDBInstanceDeletionProtectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->deletionProtection) {
            @$query['DeletionProtection'] = $request->deletionProtection;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceDeletionProtection',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceDeletionProtectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enable or disable the release protection feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Enable and disable instance release protection for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/414512.html)
     * *   [Enable and disable instance release protection for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/471512.html)
     * *   [Enable and disable instance release protection for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/416209.html)
     * *   [Enable and disable release protection for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/414512.html)
     *
     * @param request - ModifyDBInstanceDeletionProtectionRequest
     *
     * @returns ModifyDBInstanceDeletionProtectionResponse
     *
     * @param ModifyDBInstanceDeletionProtectionRequest $request
     *
     * @return ModifyDBInstanceDeletionProtectionResponse
     */
    public function modifyDBInstanceDeletionProtection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceDeletionProtectionWithOptions($request, $runtime);
    }

    /**
     * You can call the ModifyDBInstanceDescription operation to modify the name of an instance.
     *
     * @param request - ModifyDBInstanceDescriptionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceDescriptionResponse
     *
     * @param ModifyDBInstanceDescriptionRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifyDBInstanceDescriptionResponse
     */
    public function modifyDBInstanceDescriptionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceDescription) {
            @$query['DBInstanceDescription'] = $request->DBInstanceDescription;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceDescription',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceDescriptionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * You can call the ModifyDBInstanceDescription operation to modify the name of an instance.
     *
     * @param request - ModifyDBInstanceDescriptionRequest
     *
     * @returns ModifyDBInstanceDescriptionResponse
     *
     * @param ModifyDBInstanceDescriptionRequest $request
     *
     * @return ModifyDBInstanceDescriptionResponse
     */
    public function modifyDBInstanceDescription($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceDescriptionWithOptions($request, $runtime);
    }

    /**
     * Modifies the weight of an endpoint for an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * MySQL
     *
     * @param tmpReq - ModifyDBInstanceEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceEndpointResponse
     *
     * @param ModifyDBInstanceEndpointRequest $tmpReq
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyDBInstanceEndpointResponse
     */
    public function modifyDBInstanceEndpointWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyDBInstanceEndpointShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->nodeItems) {
            $request->nodeItemsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->nodeItems, 'NodeItems', 'json');
        }

        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceEndpointDescription) {
            @$query['DBInstanceEndpointDescription'] = $request->DBInstanceEndpointDescription;
        }

        if (null !== $request->DBInstanceEndpointId) {
            @$query['DBInstanceEndpointId'] = $request->DBInstanceEndpointId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->nodeItemsShrink) {
            @$query['NodeItems'] = $request->nodeItemsShrink;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceEndpoint',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the weight of an endpoint for an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * MySQL
     *
     * @param request - ModifyDBInstanceEndpointRequest
     *
     * @returns ModifyDBInstanceEndpointResponse
     *
     * @param ModifyDBInstanceEndpointRequest $request
     *
     * @return ModifyDBInstanceEndpointResponse
     */
    public function modifyDBInstanceEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceEndpointWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about the endpoint of an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)Precautions
     * *   You can modify the following information about the endpoint of an instance: the public and internal endpoints, the public and internal ports, and the virtual private cloud (VPC), vSwitch, and IP address of the internal endpoint.
     * *   The VPC and vSwitch must be modified at the same time. If you specify the VPC, vSwitch, and IP address of the internal endpoint, you do not need to specify the endpoint and port. If you specify the endpoint and port, you do not need to specify the VPC, vSwitch, and IP address of the internal endpoint.
     *
     * @param request - ModifyDBInstanceEndpointAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceEndpointAddressResponse
     *
     * @param ModifyDBInstanceEndpointAddressRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ModifyDBInstanceEndpointAddressResponse
     */
    public function modifyDBInstanceEndpointAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->connectionString) {
            @$query['ConnectionString'] = $request->connectionString;
        }

        if (null !== $request->connectionStringPrefix) {
            @$query['ConnectionStringPrefix'] = $request->connectionStringPrefix;
        }

        if (null !== $request->DBInstanceEndpointId) {
            @$query['DBInstanceEndpointId'] = $request->DBInstanceEndpointId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceEndpointAddress',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceEndpointAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about the endpoint of an instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)Precautions
     * *   You can modify the following information about the endpoint of an instance: the public and internal endpoints, the public and internal ports, and the virtual private cloud (VPC), vSwitch, and IP address of the internal endpoint.
     * *   The VPC and vSwitch must be modified at the same time. If you specify the VPC, vSwitch, and IP address of the internal endpoint, you do not need to specify the endpoint and port. If you specify the endpoint and port, you do not need to specify the VPC, vSwitch, and IP address of the internal endpoint.
     *
     * @param request - ModifyDBInstanceEndpointAddressRequest
     *
     * @returns ModifyDBInstanceEndpointAddressResponse
     *
     * @param ModifyDBInstanceEndpointAddressRequest $request
     *
     * @return ModifyDBInstanceEndpointAddressResponse
     */
    public function modifyDBInstanceEndpointAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceEndpointAddressWithOptions($request, $runtime);
    }

    /**
     * Changes the high availability (HA) and data replication mode of an instance.
     *
     * @param request - ModifyDBInstanceHAConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceHAConfigResponse
     *
     * @param ModifyDBInstanceHAConfigRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyDBInstanceHAConfigResponse
     */
    public function modifyDBInstanceHAConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dbInstanceId) {
            @$query['DbInstanceId'] = $request->dbInstanceId;
        }

        if (null !== $request->HAMode) {
            @$query['HAMode'] = $request->HAMode;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->syncMode) {
            @$query['SyncMode'] = $request->syncMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceHAConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceHAConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the high availability (HA) and data replication mode of an instance.
     *
     * @param request - ModifyDBInstanceHAConfigRequest
     *
     * @returns ModifyDBInstanceHAConfigResponse
     *
     * @param ModifyDBInstanceHAConfigRequest $request
     *
     * @return ModifyDBInstanceHAConfigResponse
     */
    public function modifyDBInstanceHAConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceHAConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the maintenance window of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Set a maintenance window for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96052.html)
     * *   [Set a maintenance window for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96799.html)
     * *   [Set a maintenance window for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95657.html)
     * *   [Set a maintenance window for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97473.html)
     *
     * @param request - ModifyDBInstanceMaintainTimeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceMaintainTimeResponse
     *
     * @param ModifyDBInstanceMaintainTimeRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyDBInstanceMaintainTimeResponse
     */
    public function modifyDBInstanceMaintainTimeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->maintainTime) {
            @$query['MaintainTime'] = $request->maintainTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceMaintainTime',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceMaintainTimeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the maintenance window of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Set a maintenance window for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96052.html)
     * *   [Set a maintenance window for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96799.html)
     * *   [Set a maintenance window for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95657.html)
     * *   [Set a maintenance window for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97473.html)
     *
     * @param request - ModifyDBInstanceMaintainTimeRequest
     *
     * @returns ModifyDBInstanceMaintainTimeResponse
     *
     * @param ModifyDBInstanceMaintainTimeRequest $request
     *
     * @return ModifyDBInstanceMaintainTimeResponse
     */
    public function modifyDBInstanceMaintainTime($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceMaintainTimeWithOptions($request, $runtime);
    }

    /**
     * Modifies the Enhanced Monitoring metrics that are displayed for an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [View the Enhanced Monitoring metrics](https://help.aliyun.com/document_detail/299200.html)
     *
     * @param request - ModifyDBInstanceMetricsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceMetricsResponse
     *
     * @param ModifyDBInstanceMetricsRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyDBInstanceMetricsResponse
     */
    public function modifyDBInstanceMetricsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->metricsConfig) {
            @$query['MetricsConfig'] = $request->metricsConfig;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->scope) {
            @$query['Scope'] = $request->scope;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceMetrics',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceMetricsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the Enhanced Monitoring metrics that are displayed for an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [View the Enhanced Monitoring metrics](https://help.aliyun.com/document_detail/299200.html)
     *
     * @param request - ModifyDBInstanceMetricsRequest
     *
     * @returns ModifyDBInstanceMetricsResponse
     *
     * @param ModifyDBInstanceMetricsRequest $request
     *
     * @return ModifyDBInstanceMetricsResponse
     */
    public function modifyDBInstanceMetrics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceMetricsWithOptions($request, $runtime);
    }

    /**
     * Modifies a monitoring frequency.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Usage notes
     * If you use the Every 5 Seconds monitoring frequency, you are charged additional fees. Before you call this operation, make sure that you understand the [billing methods and pricing](https://help.aliyun.com/document_detail/45020.html) of ApsaraDB RDS.
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure the monitoring frequency for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96112.html)
     * *   [Configure the monitoring frequency for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95710.html)
     *
     * @param request - ModifyDBInstanceMonitorRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceMonitorResponse
     *
     * @param ModifyDBInstanceMonitorRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyDBInstanceMonitorResponse
     */
    public function modifyDBInstanceMonitorWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceMonitor',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceMonitorResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a monitoring frequency.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Usage notes
     * If you use the Every 5 Seconds monitoring frequency, you are charged additional fees. Before you call this operation, make sure that you understand the [billing methods and pricing](https://help.aliyun.com/document_detail/45020.html) of ApsaraDB RDS.
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure the monitoring frequency for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96112.html)
     * *   [Configure the monitoring frequency for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95710.html)
     *
     * @param request - ModifyDBInstanceMonitorRequest
     *
     * @returns ModifyDBInstanceMonitorResponse
     *
     * @param ModifyDBInstanceMonitorRequest $request
     *
     * @return ModifyDBInstanceMonitorResponse
     */
    public function modifyDBInstanceMonitor($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceMonitorWithOptions($request, $runtime);
    }

    /**
     * Changes the expiration time of the classic network endpoint of an instance in hybrid access mode.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)References
     * *   [Configure the hybrid access solution for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96110.html)
     * *   [Configure the hybrid access solution for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95708.html)
     *
     * @param request - ModifyDBInstanceNetworkExpireTimeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceNetworkExpireTimeResponse
     *
     * @param ModifyDBInstanceNetworkExpireTimeRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return ModifyDBInstanceNetworkExpireTimeResponse
     */
    public function modifyDBInstanceNetworkExpireTimeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->classicExpiredDays) {
            @$query['ClassicExpiredDays'] = $request->classicExpiredDays;
        }

        if (null !== $request->connectionString) {
            @$query['ConnectionString'] = $request->connectionString;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceNetworkExpireTime',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceNetworkExpireTimeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the expiration time of the classic network endpoint of an instance in hybrid access mode.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)References
     * *   [Configure the hybrid access solution for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96110.html)
     * *   [Configure the hybrid access solution for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95708.html)
     *
     * @param request - ModifyDBInstanceNetworkExpireTimeRequest
     *
     * @returns ModifyDBInstanceNetworkExpireTimeResponse
     *
     * @param ModifyDBInstanceNetworkExpireTimeRequest $request
     *
     * @return ModifyDBInstanceNetworkExpireTimeResponse
     */
    public function modifyDBInstanceNetworkExpireTime($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceNetworkExpireTimeWithOptions($request, $runtime);
    }

    /**
     * Changes the network type of an ApsaraDB RDS instance from classic network to VPC.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Change the network type of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96109.html)
     * *   [Change the network type of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96761.html)
     * *   [Change the network type of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95707.html)
     *
     * @param request - ModifyDBInstanceNetworkTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceNetworkTypeResponse
     *
     * @param ModifyDBInstanceNetworkTypeRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifyDBInstanceNetworkTypeResponse
     */
    public function modifyDBInstanceNetworkTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->classicExpiredDays) {
            @$query['ClassicExpiredDays'] = $request->classicExpiredDays;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->readWriteSplittingClassicExpiredDays) {
            @$query['ReadWriteSplittingClassicExpiredDays'] = $request->readWriteSplittingClassicExpiredDays;
        }

        if (null !== $request->readWriteSplittingPrivateIpAddress) {
            @$query['ReadWriteSplittingPrivateIpAddress'] = $request->readWriteSplittingPrivateIpAddress;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->retainClassic) {
            @$query['RetainClassic'] = $request->retainClassic;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceNetworkType',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceNetworkTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the network type of an ApsaraDB RDS instance from classic network to VPC.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Change the network type of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96109.html)
     * *   [Change the network type of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96761.html)
     * *   [Change the network type of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95707.html)
     *
     * @param request - ModifyDBInstanceNetworkTypeRequest
     *
     * @returns ModifyDBInstanceNetworkTypeResponse
     *
     * @param ModifyDBInstanceNetworkTypeRequest $request
     *
     * @return ModifyDBInstanceNetworkTypeResponse
     */
    public function modifyDBInstanceNetworkType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceNetworkTypeWithOptions($request, $runtime);
    }

    /**
     * Changes the billing method of an instance from pay-as-you-go to subscription.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the following topics:
     * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/96048.html)
     * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/96743.html)
     * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/95631.html)
     * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/97120.html)
     *
     * @param request - ModifyDBInstancePayTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstancePayTypeResponse
     *
     * @param ModifyDBInstancePayTypeRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyDBInstancePayTypeResponse
     */
    public function modifyDBInstancePayTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstancePayType',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstancePayTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the billing method of an instance from pay-as-you-go to subscription.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the following topics:
     * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/96048.html)
     * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/96743.html)
     * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/95631.html)
     * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/97120.html)
     *
     * @param request - ModifyDBInstancePayTypeRequest
     *
     * @returns ModifyDBInstancePayTypeResponse
     *
     * @param ModifyDBInstancePayTypeRequest $request
     *
     * @return ModifyDBInstancePayTypeResponse
     */
    public function modifyDBInstancePayType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstancePayTypeWithOptions($request, $runtime);
    }

    /**
     * Enables or disables the native replication feature of ApsaraDB RDS for MySQL.
     *
     * @remarks
     * If you want to enable the native replication feature for an ApsaraDB RDS for MySQL instance, the following requirements must be met:
     * *   The RDS instance runs MySQL 5.7.
     * *   The RDS instance runs RDS Basic Edition.
     * *   The RDS instance uses the pay-as-you-go or subscription billing method.
     * *   The RDS instance runs a minor engine version of 20240930 or later.
     * For more information, see [Enable the native replication feature](https://help.aliyun.com/document_detail/2856530.html).
     *
     * @param request - ModifyDBInstanceReplicationSwitchRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceReplicationSwitchResponse
     *
     * @param ModifyDBInstanceReplicationSwitchRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return ModifyDBInstanceReplicationSwitchResponse
     */
    public function modifyDBInstanceReplicationSwitchWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->externalReplication) {
            @$query['ExternalReplication'] = $request->externalReplication;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceReplicationSwitch',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceReplicationSwitchResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables the native replication feature of ApsaraDB RDS for MySQL.
     *
     * @remarks
     * If you want to enable the native replication feature for an ApsaraDB RDS for MySQL instance, the following requirements must be met:
     * *   The RDS instance runs MySQL 5.7.
     * *   The RDS instance runs RDS Basic Edition.
     * *   The RDS instance uses the pay-as-you-go or subscription billing method.
     * *   The RDS instance runs a minor engine version of 20240930 or later.
     * For more information, see [Enable the native replication feature](https://help.aliyun.com/document_detail/2856530.html).
     *
     * @param request - ModifyDBInstanceReplicationSwitchRequest
     *
     * @returns ModifyDBInstanceReplicationSwitchResponse
     *
     * @param ModifyDBInstanceReplicationSwitchRequest $request
     *
     * @return ModifyDBInstanceReplicationSwitchResponse
     */
    public function modifyDBInstanceReplicationSwitch($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceReplicationSwitchWithOptions($request, $runtime);
    }

    /**
     * Modifies the SSL encryption settings of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the SSL encryption feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96120.html)
     * *   [Use the SSL encryption feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/229517.html)
     * *   [Use the SSL encryption feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95715.html)
     *
     * @param request - ModifyDBInstanceSSLRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceSSLResponse
     *
     * @param ModifyDBInstanceSSLRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyDBInstanceSSLResponse
     */
    public function modifyDBInstanceSSLWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ACL) {
            @$query['ACL'] = $request->ACL;
        }

        if (null !== $request->CAType) {
            @$query['CAType'] = $request->CAType;
        }

        if (null !== $request->certificate) {
            @$query['Certificate'] = $request->certificate;
        }

        if (null !== $request->clientCACert) {
            @$query['ClientCACert'] = $request->clientCACert;
        }

        if (null !== $request->clientCAEnabled) {
            @$query['ClientCAEnabled'] = $request->clientCAEnabled;
        }

        if (null !== $request->clientCertRevocationList) {
            @$query['ClientCertRevocationList'] = $request->clientCertRevocationList;
        }

        if (null !== $request->clientCrlEnabled) {
            @$query['ClientCrlEnabled'] = $request->clientCrlEnabled;
        }

        if (null !== $request->connectionString) {
            @$query['ConnectionString'] = $request->connectionString;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->forceEncryption) {
            @$query['ForceEncryption'] = $request->forceEncryption;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->passWord) {
            @$query['PassWord'] = $request->passWord;
        }

        if (null !== $request->replicationACL) {
            @$query['ReplicationACL'] = $request->replicationACL;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->SSLEnabled) {
            @$query['SSLEnabled'] = $request->SSLEnabled;
        }

        if (null !== $request->serverCert) {
            @$query['ServerCert'] = $request->serverCert;
        }

        if (null !== $request->serverKey) {
            @$query['ServerKey'] = $request->serverKey;
        }

        if (null !== $request->tlsVersion) {
            @$query['TlsVersion'] = $request->tlsVersion;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceSSL',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceSSLResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the SSL encryption settings of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the SSL encryption feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96120.html)
     * *   [Use the SSL encryption feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/229517.html)
     * *   [Use the SSL encryption feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95715.html)
     *
     * @param request - ModifyDBInstanceSSLRequest
     *
     * @returns ModifyDBInstanceSSLResponse
     *
     * @param ModifyDBInstanceSSLRequest $request
     *
     * @return ModifyDBInstanceSSLResponse
     */
    public function modifyDBInstanceSSL($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceSSLWithOptions($request, $runtime);
    }

    /**
     * Modifies a security group rule that is configured for an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Configure security group settings for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - ModifyDBInstanceSecurityGroupRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceSecurityGroupRuleResponse
     *
     * @param ModifyDBInstanceSecurityGroupRuleRequest $request
     * @param RuntimeOptions                           $runtime
     *
     * @return ModifyDBInstanceSecurityGroupRuleResponse
     */
    public function modifyDBInstanceSecurityGroupRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->ipProtocol) {
            @$query['IpProtocol'] = $request->ipProtocol;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->portRange) {
            @$query['PortRange'] = $request->portRange;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityGroupRuleId) {
            @$query['SecurityGroupRuleId'] = $request->securityGroupRuleId;
        }

        if (null !== $request->sourceCidrIp) {
            @$query['SourceCidrIp'] = $request->sourceCidrIp;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceSecurityGroupRule',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceSecurityGroupRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a security group rule that is configured for an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Configure security group settings for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - ModifyDBInstanceSecurityGroupRuleRequest
     *
     * @returns ModifyDBInstanceSecurityGroupRuleResponse
     *
     * @param ModifyDBInstanceSecurityGroupRuleRequest $request
     *
     * @return ModifyDBInstanceSecurityGroupRuleResponse
     */
    public function modifyDBInstanceSecurityGroupRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceSecurityGroupRuleWithOptions($request, $runtime);
    }

    /**
     * Changes the instance type and storage capacity of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Billing details
     * [Fees for specification changes](https://help.aliyun.com/document_detail/57178.html) are generated if the call is successful. Before you call this operation, carefully read the following topics.
     * ### [](#)References
     * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96061.html)
     * *   [Change the specifications of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96750.html)
     * *   [Change the specifications of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95665.html)
     * *   [Change the specifications of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97129.html)
     *
     * @param tmpReq - ModifyDBInstanceSpecRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceSpecResponse
     *
     * @param ModifyDBInstanceSpecRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyDBInstanceSpecResponse
     */
    public function modifyDBInstanceSpecWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyDBInstanceSpecShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->serverlessConfiguration) {
            $request->serverlessConfigurationShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->serverlessConfiguration, 'ServerlessConfiguration', 'json');
        }

        $query = [];
        if (null !== $request->allowMajorVersionUpgrade) {
            @$query['AllowMajorVersionUpgrade'] = $request->allowMajorVersionUpgrade;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->burstingEnabled) {
            @$query['BurstingEnabled'] = $request->burstingEnabled;
        }

        if (null !== $request->category) {
            @$query['Category'] = $request->category;
        }

        if (null !== $request->coldDataEnabled) {
            @$query['ColdDataEnabled'] = $request->coldDataEnabled;
        }

        if (null !== $request->compressionMode) {
            @$query['CompressionMode'] = $request->compressionMode;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->direction) {
            @$query['Direction'] = $request->direction;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->ioAccelerationEnabled) {
            @$query['IoAccelerationEnabled'] = $request->ioAccelerationEnabled;
        }

        if (null !== $request->optimizedWrites) {
            @$query['OptimizedWrites'] = $request->optimizedWrites;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->promotionCode) {
            @$query['PromotionCode'] = $request->promotionCode;
        }

        if (null !== $request->readOnlyDBInstanceClass) {
            @$query['ReadOnlyDBInstanceClass'] = $request->readOnlyDBInstanceClass;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->serverlessConfigurationShrink) {
            @$query['ServerlessConfiguration'] = $request->serverlessConfigurationShrink;
        }

        if (null !== $request->sourceBiz) {
            @$query['SourceBiz'] = $request->sourceBiz;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        if (null !== $request->targetMinorVersion) {
            @$query['TargetMinorVersion'] = $request->targetMinorVersion;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        if (null !== $request->zoneIdSlave1) {
            @$query['ZoneIdSlave1'] = $request->zoneIdSlave1;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceSpec',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceSpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the instance type and storage capacity of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Billing details
     * [Fees for specification changes](https://help.aliyun.com/document_detail/57178.html) are generated if the call is successful. Before you call this operation, carefully read the following topics.
     * ### [](#)References
     * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96061.html)
     * *   [Change the specifications of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96750.html)
     * *   [Change the specifications of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95665.html)
     * *   [Change the specifications of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97129.html)
     *
     * @param request - ModifyDBInstanceSpecRequest
     *
     * @returns ModifyDBInstanceSpecResponse
     *
     * @param ModifyDBInstanceSpecRequest $request
     *
     * @return ModifyDBInstanceSpecResponse
     */
    public function modifyDBInstanceSpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceSpecWithOptions($request, $runtime);
    }

    /**
     * Enables the Transparent Data Encryption (TDE) feature for an ApsaraDB RDS instance and modifies the TDE status for the instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure TDE for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96121.html)
     * *   [Configure TDE for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/465652.html)
     * *   [Configure TDE for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95716.html)
     *
     * @param request - ModifyDBInstanceTDERequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBInstanceTDEResponse
     *
     * @param ModifyDBInstanceTDERequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyDBInstanceTDEResponse
     */
    public function modifyDBInstanceTDEWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->certificate) {
            @$query['Certificate'] = $request->certificate;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->encryptionKey) {
            @$query['EncryptionKey'] = $request->encryptionKey;
        }

        if (null !== $request->isRotate) {
            @$query['IsRotate'] = $request->isRotate;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->passWord) {
            @$query['PassWord'] = $request->passWord;
        }

        if (null !== $request->privateKey) {
            @$query['PrivateKey'] = $request->privateKey;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->roleArn) {
            @$query['RoleArn'] = $request->roleArn;
        }

        if (null !== $request->TDEStatus) {
            @$query['TDEStatus'] = $request->TDEStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBInstanceTDE',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBInstanceTDEResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables the Transparent Data Encryption (TDE) feature for an ApsaraDB RDS instance and modifies the TDE status for the instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure TDE for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96121.html)
     * *   [Configure TDE for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/465652.html)
     * *   [Configure TDE for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95716.html)
     *
     * @param request - ModifyDBInstanceTDERequest
     *
     * @returns ModifyDBInstanceTDEResponse
     *
     * @param ModifyDBInstanceTDERequest $request
     *
     * @return ModifyDBInstanceTDEResponse
     */
    public function modifyDBInstanceTDE($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBInstanceTDEWithOptions($request, $runtime);
    }

    /**
     * Changes the specifications, storage type, and storage capacity of an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   MySQL
     * ### [](#)References
     * [Change instance specifications](https://help.aliyun.com/document_detail/2627998.html)
     * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the related topics.
     *
     * @param tmpReq - ModifyDBNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBNodeResponse
     *
     * @param ModifyDBNodeRequest $tmpReq
     * @param RuntimeOptions      $runtime
     *
     * @return ModifyDBNodeResponse
     */
    public function modifyDBNodeWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyDBNodeShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->DBNode) {
            $request->DBNodeShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->DBNode, 'DBNode', 'json');
        }

        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->DBNodeShrink) {
            @$query['DBNode'] = $request->DBNodeShrink;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->produceAsync) {
            @$query['ProduceAsync'] = $request->produceAsync;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBNode',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the specifications, storage type, and storage capacity of an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   MySQL
     * ### [](#)References
     * [Change instance specifications](https://help.aliyun.com/document_detail/2627998.html)
     * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the related topics.
     *
     * @param request - ModifyDBNodeRequest
     *
     * @returns ModifyDBNodeResponse
     *
     * @param ModifyDBNodeRequest $request
     *
     * @return ModifyDBNodeResponse
     */
    public function modifyDBNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBNodeWithOptions($request, $runtime);
    }

    /**
     * Enables or modifies the database proxy feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * >  Starting October 17, 2023, ApsaraDB RDS for MySQL instances that run RDS Cluster Edition offer one free-of-charge dedicated database proxy for each unit in phases. For more information, see [[Special offers/Price changes\\] One dedicated proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Enable the database proxy feature of ApsaraDB RDS for MySQL](https://help.aliyun.com/document_detail/197456.html)
     * *   [Enable the database proxy feature of ApsaraDB RDS for PostgreSQL](https://help.aliyun.com/document_detail/418272.html)
     *
     * @param tmpReq - ModifyDBProxyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBProxyResponse
     *
     * @param ModifyDBProxyRequest $tmpReq
     * @param RuntimeOptions       $runtime
     *
     * @return ModifyDBProxyResponse
     */
    public function modifyDBProxyWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyDBProxyShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->DBProxyNodes) {
            $request->DBProxyNodesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->DBProxyNodes, 'DBProxyNodes', 'json');
        }

        $query = [];
        if (null !== $request->configDBProxyService) {
            @$query['ConfigDBProxyService'] = $request->configDBProxyService;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->DBProxyInstanceNum) {
            @$query['DBProxyInstanceNum'] = $request->DBProxyInstanceNum;
        }

        if (null !== $request->DBProxyInstanceType) {
            @$query['DBProxyInstanceType'] = $request->DBProxyInstanceType;
        }

        if (null !== $request->DBProxyNodesShrink) {
            @$query['DBProxyNodes'] = $request->DBProxyNodesShrink;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->persistentConnectionStatus) {
            @$query['PersistentConnectionStatus'] = $request->persistentConnectionStatus;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBProxy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBProxyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or modifies the database proxy feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * >  Starting October 17, 2023, ApsaraDB RDS for MySQL instances that run RDS Cluster Edition offer one free-of-charge dedicated database proxy for each unit in phases. For more information, see [[Special offers/Price changes\\] One dedicated proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Enable the database proxy feature of ApsaraDB RDS for MySQL](https://help.aliyun.com/document_detail/197456.html)
     * *   [Enable the database proxy feature of ApsaraDB RDS for PostgreSQL](https://help.aliyun.com/document_detail/418272.html)
     *
     * @param request - ModifyDBProxyRequest
     *
     * @returns ModifyDBProxyResponse
     *
     * @param ModifyDBProxyRequest $request
     *
     * @return ModifyDBProxyResponse
     */
    public function modifyDBProxy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBProxyWithOptions($request, $runtime);
    }

    /**
     * Modifies the connection settings for a database proxy endpoint.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure the connection settings for a database proxy endpoint for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/2621331.html)
     * *   [Configure the connection settings for a database proxy endpoint for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418273.html)
     *
     * @param request - ModifyDBProxyEndpointRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBProxyEndpointResponse
     *
     * @param ModifyDBProxyEndpointRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyDBProxyEndpointResponse
     */
    public function modifyDBProxyEndpointWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->causalConsistReadTimeout) {
            @$query['CausalConsistReadTimeout'] = $request->causalConsistReadTimeout;
        }

        if (null !== $request->configDBProxyFeatures) {
            @$query['ConfigDBProxyFeatures'] = $request->configDBProxyFeatures;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyEndpointId) {
            @$query['DBProxyEndpointId'] = $request->DBProxyEndpointId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->dbEndpointAliases) {
            @$query['DbEndpointAliases'] = $request->dbEndpointAliases;
        }

        if (null !== $request->dbEndpointMinSlaveCount) {
            @$query['DbEndpointMinSlaveCount'] = $request->dbEndpointMinSlaveCount;
        }

        if (null !== $request->dbEndpointOperator) {
            @$query['DbEndpointOperator'] = $request->dbEndpointOperator;
        }

        if (null !== $request->dbEndpointReadWriteMode) {
            @$query['DbEndpointReadWriteMode'] = $request->dbEndpointReadWriteMode;
        }

        if (null !== $request->dbEndpointType) {
            @$query['DbEndpointType'] = $request->dbEndpointType;
        }

        if (null !== $request->effectiveSpecificTime) {
            @$query['EffectiveSpecificTime'] = $request->effectiveSpecificTime;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->readOnlyInstanceDistributionType) {
            @$query['ReadOnlyInstanceDistributionType'] = $request->readOnlyInstanceDistributionType;
        }

        if (null !== $request->readOnlyInstanceMaxDelayTime) {
            @$query['ReadOnlyInstanceMaxDelayTime'] = $request->readOnlyInstanceMaxDelayTime;
        }

        if (null !== $request->readOnlyInstanceWeight) {
            @$query['ReadOnlyInstanceWeight'] = $request->readOnlyInstanceWeight;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->vpcId) {
            @$query['VpcId'] = $request->vpcId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBProxyEndpoint',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBProxyEndpointResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the connection settings for a database proxy endpoint.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure the connection settings for a database proxy endpoint for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/2621331.html)
     * *   [Configure the connection settings for a database proxy endpoint for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418273.html)
     *
     * @param request - ModifyDBProxyEndpointRequest
     *
     * @returns ModifyDBProxyEndpointResponse
     *
     * @param ModifyDBProxyEndpointRequest $request
     *
     * @return ModifyDBProxyEndpointResponse
     */
    public function modifyDBProxyEndpoint($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBProxyEndpointWithOptions($request, $runtime);
    }

    /**
     * Modifies the database proxy endpoint of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure the database proxy endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/184921.html)
     * *   [Configure the database proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418274.html)
     *
     * @param request - ModifyDBProxyEndpointAddressRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBProxyEndpointAddressResponse
     *
     * @param ModifyDBProxyEndpointAddressRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ModifyDBProxyEndpointAddressResponse
     */
    public function modifyDBProxyEndpointAddressWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyConnectStringNetType) {
            @$query['DBProxyConnectStringNetType'] = $request->DBProxyConnectStringNetType;
        }

        if (null !== $request->DBProxyEndpointId) {
            @$query['DBProxyEndpointId'] = $request->DBProxyEndpointId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->DBProxyNewConnectString) {
            @$query['DBProxyNewConnectString'] = $request->DBProxyNewConnectString;
        }

        if (null !== $request->DBProxyNewConnectStringPort) {
            @$query['DBProxyNewConnectStringPort'] = $request->DBProxyNewConnectStringPort;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBProxyEndpointAddress',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBProxyEndpointAddressResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the database proxy endpoint of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure the database proxy endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/184921.html)
     * *   [Configure the database proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418274.html)
     *
     * @param request - ModifyDBProxyEndpointAddressRequest
     *
     * @returns ModifyDBProxyEndpointAddressResponse
     *
     * @param ModifyDBProxyEndpointAddressRequest $request
     *
     * @return ModifyDBProxyEndpointAddressResponse
     */
    public function modifyDBProxyEndpointAddress($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBProxyEndpointAddressWithOptions($request, $runtime);
    }

    /**
     * Changes the configuration of a database proxy for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * >  Starting October 17, 2023, ApsaraDB RDS for MySQL instances that run RDS Cluster Edition offer one free-of-charge dedicated database proxy for each unit in phases. For more information, see [[Special offers/Price changes\\] One dedicated proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
     *
     * @param tmpReq - ModifyDBProxyInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDBProxyInstanceResponse
     *
     * @param ModifyDBProxyInstanceRequest $tmpReq
     * @param RuntimeOptions               $runtime
     *
     * @return ModifyDBProxyInstanceResponse
     */
    public function modifyDBProxyInstanceWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyDBProxyInstanceShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->DBProxyNodes) {
            $request->DBProxyNodesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->DBProxyNodes, 'DBProxyNodes', 'json');
        }

        if (null !== $tmpReq->migrateAZ) {
            $request->migrateAZShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->migrateAZ, 'MigrateAZ', 'json');
        }

        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->DBProxyInstanceNum) {
            @$query['DBProxyInstanceNum'] = $request->DBProxyInstanceNum;
        }

        if (null !== $request->DBProxyInstanceType) {
            @$query['DBProxyInstanceType'] = $request->DBProxyInstanceType;
        }

        if (null !== $request->DBProxyNodesShrink) {
            @$query['DBProxyNodes'] = $request->DBProxyNodesShrink;
        }

        if (null !== $request->effectiveSpecificTime) {
            @$query['EffectiveSpecificTime'] = $request->effectiveSpecificTime;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->migrateAZShrink) {
            @$query['MigrateAZ'] = $request->migrateAZShrink;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->vSwitchIds) {
            @$query['VSwitchIds'] = $request->vSwitchIds;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDBProxyInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDBProxyInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the configuration of a database proxy for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * >  Starting October 17, 2023, ApsaraDB RDS for MySQL instances that run RDS Cluster Edition offer one free-of-charge dedicated database proxy for each unit in phases. For more information, see [[Special offers/Price changes\\] One dedicated proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
     *
     * @param request - ModifyDBProxyInstanceRequest
     *
     * @returns ModifyDBProxyInstanceResponse
     *
     * @param ModifyDBProxyInstanceRequest $request
     *
     * @return ModifyDBProxyInstanceResponse
     */
    public function modifyDBProxyInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDBProxyInstanceWithOptions($request, $runtime);
    }

    /**
     * Configures a distributed transaction whitelist for an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Configure a distributed transaction whitelist](https://help.aliyun.com/document_detail/124321.html)
     *
     * @param request - ModifyDTCSecurityIpHostsForSQLServerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDTCSecurityIpHostsForSQLServerResponse
     *
     * @param ModifyDTCSecurityIpHostsForSQLServerRequest $request
     * @param RuntimeOptions                              $runtime
     *
     * @return ModifyDTCSecurityIpHostsForSQLServerResponse
     */
    public function modifyDTCSecurityIpHostsForSQLServerWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityIpHosts) {
            @$query['SecurityIpHosts'] = $request->securityIpHosts;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->whiteListGroupName) {
            @$query['WhiteListGroupName'] = $request->whiteListGroupName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDTCSecurityIpHostsForSQLServer',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDTCSecurityIpHostsForSQLServerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures a distributed transaction whitelist for an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Configure a distributed transaction whitelist](https://help.aliyun.com/document_detail/124321.html)
     *
     * @param request - ModifyDTCSecurityIpHostsForSQLServerRequest
     *
     * @returns ModifyDTCSecurityIpHostsForSQLServerResponse
     *
     * @param ModifyDTCSecurityIpHostsForSQLServerRequest $request
     *
     * @return ModifyDTCSecurityIpHostsForSQLServerResponse
     */
    public function modifyDTCSecurityIpHostsForSQLServer($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDTCSecurityIpHostsForSQLServerWithOptions($request, $runtime);
    }

    /**
     * Configures automatic storage expansion for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure automatic storage expansion for ApsaraDB RDS for MySQL](https://help.aliyun.com/document_detail/173826.html)
     * *   [Configure automatic storage expansion for ApsaraDB RDS for PostgreSQL](https://help.aliyun.com/document_detail/432496.html)
     *
     * @param request - ModifyDasInstanceConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDasInstanceConfigResponse
     *
     * @param ModifyDasInstanceConfigRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyDasInstanceConfigResponse
     */
    public function modifyDasInstanceConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->storageAutoScale) {
            @$query['StorageAutoScale'] = $request->storageAutoScale;
        }

        if (null !== $request->storageThreshold) {
            @$query['StorageThreshold'] = $request->storageThreshold;
        }

        if (null !== $request->storageUpperBound) {
            @$query['StorageUpperBound'] = $request->storageUpperBound;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDasInstanceConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDasInstanceConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures automatic storage expansion for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure automatic storage expansion for ApsaraDB RDS for MySQL](https://help.aliyun.com/document_detail/173826.html)
     * *   [Configure automatic storage expansion for ApsaraDB RDS for PostgreSQL](https://help.aliyun.com/document_detail/432496.html)
     *
     * @param request - ModifyDasInstanceConfigRequest
     *
     * @returns ModifyDasInstanceConfigResponse
     *
     * @param ModifyDasInstanceConfigRequest $request
     *
     * @return ModifyDasInstanceConfigResponse
     */
    public function modifyDasInstanceConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDasInstanceConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the property settings of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     * ### [](#)References
     * You can call this operation to modify the database properties of an ApsaraDB RDS for SQL Server instance and archive data from an instance that uses cloud disks to an Object Storage Service (OSS) bucket. Before you call this operation to archive data to an OSS bucket, you must enable the data archiving feature in the ApsaraDB RDS console. For more information, see [Modify database properties](https://help.aliyun.com/document_detail/2401398.html) and [Archive cloud disk data to an OSS bucket](https://help.aliyun.com/document_detail/2767189.html).
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     *
     * @param request - ModifyDatabaseConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDatabaseConfigResponse
     *
     * @param ModifyDatabaseConfigRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyDatabaseConfigResponse
     */
    public function modifyDatabaseConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->databasePropertyName) {
            @$query['DatabasePropertyName'] = $request->databasePropertyName;
        }

        if (null !== $request->databasePropertyValue) {
            @$query['DatabasePropertyValue'] = $request->databasePropertyValue;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDatabaseConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDatabaseConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the property settings of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   SQL Server
     * ### [](#)References
     * You can call this operation to modify the database properties of an ApsaraDB RDS for SQL Server instance and archive data from an instance that uses cloud disks to an Object Storage Service (OSS) bucket. Before you call this operation to archive data to an OSS bucket, you must enable the data archiving feature in the ApsaraDB RDS console. For more information, see [Modify database properties](https://help.aliyun.com/document_detail/2401398.html) and [Archive cloud disk data to an OSS bucket](https://help.aliyun.com/document_detail/2767189.html).
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     *
     * @param request - ModifyDatabaseConfigRequest
     *
     * @returns ModifyDatabaseConfigResponse
     *
     * @param ModifyDatabaseConfigRequest $request
     *
     * @return ModifyDatabaseConfigResponse
     */
    public function modifyDatabaseConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDatabaseConfigWithOptions($request, $runtime);
    }

    /**
     * Configures SSL encryption for an dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS MySQL
     * ### [](#)References
     * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
     * [Configure SSL encryption for a proxy endpoint](https://help.aliyun.com/document_detail/188164.html)
     *
     * @param request - ModifyDbProxyInstanceSslRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyDbProxyInstanceSslResponse
     *
     * @param ModifyDbProxyInstanceSslRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifyDbProxyInstanceSslResponse
     */
    public function modifyDbProxyInstanceSslWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->dbInstanceId) {
            @$query['DbInstanceId'] = $request->dbInstanceId;
        }

        if (null !== $request->dbInstanceId) {
            @$query['DbInstanceId'] = $request->dbInstanceId;
        }

        if (null !== $request->dbProxyConnectString) {
            @$query['DbProxyConnectString'] = $request->dbProxyConnectString;
        }

        if (null !== $request->dbProxyEndpointId) {
            @$query['DbProxyEndpointId'] = $request->dbProxyEndpointId;
        }

        if (null !== $request->dbProxySslEnabled) {
            @$query['DbProxySslEnabled'] = $request->dbProxySslEnabled;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyDbProxyInstanceSsl',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyDbProxyInstanceSslResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures SSL encryption for an dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS MySQL
     * ### [](#)References
     * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
     * [Configure SSL encryption for a proxy endpoint](https://help.aliyun.com/document_detail/188164.html)
     *
     * @param request - ModifyDbProxyInstanceSslRequest
     *
     * @returns ModifyDbProxyInstanceSslResponse
     *
     * @param ModifyDbProxyInstanceSslRequest $request
     *
     * @return ModifyDbProxyInstanceSslResponse
     */
    public function modifyDbProxyInstanceSsl($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyDbProxyInstanceSslWithOptions($request, $runtime);
    }

    /**
     * Modifies information about the events in the event center.
     *
     * @param request - ModifyEventInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyEventInfoResponse
     *
     * @param ModifyEventInfoRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifyEventInfoResponse
     */
    public function modifyEventInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->actionParams) {
            @$query['ActionParams'] = $request->actionParams;
        }

        if (null !== $request->eventAction) {
            @$query['EventAction'] = $request->eventAction;
        }

        if (null !== $request->eventId) {
            @$query['EventId'] = $request->eventId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyEventInfo',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyEventInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies information about the events in the event center.
     *
     * @param request - ModifyEventInfoRequest
     *
     * @returns ModifyEventInfoResponse
     *
     * @param ModifyEventInfoRequest $request
     *
     * @return ModifyEventInfoResponse
     */
    public function modifyEventInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyEventInfoWithOptions($request, $runtime);
    }

    /**
     * Change the availability check method of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [What is availability check?](https://help.aliyun.com/document_detail/207467.html)
     *
     * @param request - ModifyHADiagnoseConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHADiagnoseConfigResponse
     *
     * @param ModifyHADiagnoseConfigRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ModifyHADiagnoseConfigResponse
     */
    public function modifyHADiagnoseConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tcpConnectionType) {
            @$query['TcpConnectionType'] = $request->tcpConnectionType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHADiagnoseConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHADiagnoseConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Change the availability check method of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [What is availability check?](https://help.aliyun.com/document_detail/207467.html)
     *
     * @param request - ModifyHADiagnoseConfigRequest
     *
     * @returns ModifyHADiagnoseConfigResponse
     *
     * @param ModifyHADiagnoseConfigRequest $request
     *
     * @return ModifyHADiagnoseConfigResponse
     */
    public function modifyHADiagnoseConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHADiagnoseConfigWithOptions($request, $runtime);
    }

    /**
     * Enables or disables the automatic primary/secondary switchover feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96054.html)
     * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96747.html)
     * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95659.html)
     * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97127.html)
     *
     * @param request - ModifyHASwitchConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyHASwitchConfigResponse
     *
     * @param ModifyHASwitchConfigRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyHASwitchConfigResponse
     */
    public function modifyHASwitchConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->HAConfig) {
            @$query['HAConfig'] = $request->HAConfig;
        }

        if (null !== $request->manualHATime) {
            @$query['ManualHATime'] = $request->manualHATime;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyHASwitchConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyHASwitchConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables the automatic primary/secondary switchover feature for an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96054.html)
     * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96747.html)
     * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95659.html)
     * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97127.html)
     *
     * @param request - ModifyHASwitchConfigRequest
     *
     * @returns ModifyHASwitchConfigResponse
     *
     * @param ModifyHASwitchConfigRequest $request
     *
     * @return ModifyHASwitchConfigResponse
     */
    public function modifyHASwitchConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyHASwitchConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the auto-renewal settings of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * >Notice: Fees are generated if the call is successful. Before you call this operation, carefully read the following topics:
     * *   [Use the auto-renewal feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96049.html)
     * *   [Use the auto-renewal feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96740.html)
     * *   [Use the auto-renewal feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95635.html)
     * *   [Use the auto-renewal feature for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97121.html)
     *
     * @param request - ModifyInstanceAutoRenewalAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInstanceAutoRenewalAttributeResponse
     *
     * @param ModifyInstanceAutoRenewalAttributeRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ModifyInstanceAutoRenewalAttributeResponse
     */
    public function modifyInstanceAutoRenewalAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->duration) {
            @$query['Duration'] = $request->duration;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInstanceAutoRenewalAttribute',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInstanceAutoRenewalAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the auto-renewal settings of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * >Notice: Fees are generated if the call is successful. Before you call this operation, carefully read the following topics:
     * *   [Use the auto-renewal feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96049.html)
     * *   [Use the auto-renewal feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96740.html)
     * *   [Use the auto-renewal feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95635.html)
     * *   [Use the auto-renewal feature for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97121.html)
     *
     * @param request - ModifyInstanceAutoRenewalAttributeRequest
     *
     * @returns ModifyInstanceAutoRenewalAttributeResponse
     *
     * @param ModifyInstanceAutoRenewalAttributeRequest $request
     *
     * @return ModifyInstanceAutoRenewalAttributeResponse
     */
    public function modifyInstanceAutoRenewalAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInstanceAutoRenewalAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the cross-region backup settings of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - ModifyInstanceCrossBackupPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyInstanceCrossBackupPolicyResponse
     *
     * @param ModifyInstanceCrossBackupPolicyRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ModifyInstanceCrossBackupPolicyResponse
     */
    public function modifyInstanceCrossBackupPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupEnabled) {
            @$query['BackupEnabled'] = $request->backupEnabled;
        }

        if (null !== $request->crossBackupRegion) {
            @$query['CrossBackupRegion'] = $request->crossBackupRegion;
        }

        if (null !== $request->crossBackupType) {
            @$query['CrossBackupType'] = $request->crossBackupType;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->logBackupEnabled) {
            @$query['LogBackupEnabled'] = $request->logBackupEnabled;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->retentType) {
            @$query['RetentType'] = $request->retentType;
        }

        if (null !== $request->retention) {
            @$query['Retention'] = $request->retention;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyInstanceCrossBackupPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyInstanceCrossBackupPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the cross-region backup settings of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206671.html)
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/187923.html)
     *
     * @param request - ModifyInstanceCrossBackupPolicyRequest
     *
     * @returns ModifyInstanceCrossBackupPolicyResponse
     *
     * @param ModifyInstanceCrossBackupPolicyRequest $request
     *
     * @return ModifyInstanceCrossBackupPolicyResponse
     */
    public function modifyInstanceCrossBackupPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyInstanceCrossBackupPolicyWithOptions($request, $runtime);
    }

    /**
     * 修改全密态规则.
     *
     * @param tmpReq - ModifyMaskingRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyMaskingRulesResponse
     *
     * @param ModifyMaskingRulesRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return ModifyMaskingRulesResponse
     */
    public function modifyMaskingRulesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ModifyMaskingRulesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->ruleConfig) {
            $request->ruleConfigShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->ruleConfig, 'RuleConfig', 'json');
        }

        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->defaultAlgo) {
            @$query['DefaultAlgo'] = $request->defaultAlgo;
        }

        if (null !== $request->enabled) {
            @$query['Enabled'] = $request->enabled;
        }

        if (null !== $request->maskingAlgo) {
            @$query['MaskingAlgo'] = $request->maskingAlgo;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->ruleConfigShrink) {
            @$query['RuleConfig'] = $request->ruleConfigShrink;
        }

        if (null !== $request->ruleName) {
            @$query['RuleName'] = $request->ruleName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyMaskingRules',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyMaskingRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 修改全密态规则.
     *
     * @param request - ModifyMaskingRulesRequest
     *
     * @returns ModifyMaskingRulesResponse
     *
     * @param ModifyMaskingRulesRequest $request
     *
     * @return ModifyMaskingRulesResponse
     */
    public function modifyMaskingRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyMaskingRulesWithOptions($request, $runtime);
    }

    /**
     * Modifies the pg_hba.conf file of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS PostgreSQL
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Connect an ApsaraDB RDS for PostgreSQL instance to a self-managed AD domain](https://help.aliyun.com/document_detail/349288.html)
     * *   [The pg_hba.conf File](https://www.postgresql.org/docs/11/auth-pg-hba-conf.html)
     *
     * @param request - ModifyPGHbaConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyPGHbaConfigResponse
     *
     * @param ModifyPGHbaConfigRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ModifyPGHbaConfigResponse
     */
    public function modifyPGHbaConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->hbaItem) {
            @$query['HbaItem'] = $request->hbaItem;
        }

        if (null !== $request->opsType) {
            @$query['OpsType'] = $request->opsType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyPGHbaConfig',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyPGHbaConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the pg_hba.conf file of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * RDS PostgreSQL
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Connect an ApsaraDB RDS for PostgreSQL instance to a self-managed AD domain](https://help.aliyun.com/document_detail/349288.html)
     * *   [The pg_hba.conf File](https://www.postgresql.org/docs/11/auth-pg-hba-conf.html)
     *
     * @param request - ModifyPGHbaConfigRequest
     *
     * @returns ModifyPGHbaConfigResponse
     *
     * @param ModifyPGHbaConfigRequest $request
     *
     * @return ModifyPGHbaConfigResponse
     */
    public function modifyPGHbaConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyPGHbaConfigWithOptions($request, $runtime);
    }

    /**
     * Modifies the parameter values of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Modify the parameters of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96063.html)
     * *   [Modify the parameters of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96751.html)
     * *   [Modify the parameters of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95667.html)
     * *   [Modify the parameters of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97130.html)
     *
     * @param request - ModifyParameterRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyParameterResponse
     *
     * @param ModifyParameterRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ModifyParameterResponse
     */
    public function modifyParameterWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->forcerestart) {
            @$query['Forcerestart'] = $request->forcerestart;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->parameterGroupId) {
            @$query['ParameterGroupId'] = $request->parameterGroupId;
        }

        if (null !== $request->parameters) {
            @$query['Parameters'] = $request->parameters;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        if (null !== $request->switchTimeMode) {
            @$query['SwitchTimeMode'] = $request->switchTimeMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyParameter',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyParameterResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the parameter values of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Modify the parameters of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96063.html)
     * *   [Modify the parameters of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96751.html)
     * *   [Modify the parameters of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95667.html)
     * *   [Modify the parameters of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97130.html)
     *
     * @param request - ModifyParameterRequest
     *
     * @returns ModifyParameterResponse
     *
     * @param ModifyParameterRequest $request
     *
     * @return ModifyParameterResponse
     */
    public function modifyParameter($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyParameterWithOptions($request, $runtime);
    }

    /**
     * Modifies the parameter template of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - ModifyParameterGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyParameterGroupResponse
     *
     * @param ModifyParameterGroupRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ModifyParameterGroupResponse
     */
    public function modifyParameterGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->modifyMode) {
            @$query['ModifyMode'] = $request->modifyMode;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->parameterGroupDesc) {
            @$query['ParameterGroupDesc'] = $request->parameterGroupDesc;
        }

        if (null !== $request->parameterGroupId) {
            @$query['ParameterGroupId'] = $request->parameterGroupId;
        }

        if (null !== $request->parameterGroupName) {
            @$query['ParameterGroupName'] = $request->parameterGroupName;
        }

        if (null !== $request->parameters) {
            @$query['Parameters'] = $request->parameters;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyParameterGroup',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyParameterGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the parameter template of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/130565.html)
     * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/457176.html)
     *
     * @param request - ModifyParameterGroupRequest
     *
     * @returns ModifyParameterGroupResponse
     *
     * @param ModifyParameterGroupRequest $request
     *
     * @return ModifyParameterGroupResponse
     */
    public function modifyParameterGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyParameterGroupWithOptions($request, $runtime);
    }

    /**
     * Modifies the disk type or performance level (PL) of the cloud disks of an RDS Custom instance.
     *
     * @remarks
     * >  To minimize the impacts on your business, we recommend that you change specifications during off-peak hours.
     * Take note of the following items:
     * *   For a pay-as-you-go Enterprise SSD (ESSD), you can upgrade or downgrade its PL. However, you cannot downgrade the performance level to PL0.
     * *   The ESSD must be in the In Use (In_Use) or Unattached (Available) state.
     * *   If the ESSD is attached to an instance, the instance must be in the Running or Stopped state. The instance cannot be in the Expired state or stopped due to overdue payments.
     * *   The performance level of an ESSD is limited by the capacity of the ESSD. If you cannot upgrade the PL of an ESSD, you can expand the capacity of the ESSD.
     *
     * @param request - ModifyRCDiskSpecRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRCDiskSpecResponse
     *
     * @param ModifyRCDiskSpecRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ModifyRCDiskSpecResponse
     */
    public function modifyRCDiskSpecWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->diskCategory) {
            @$query['DiskCategory'] = $request->diskCategory;
        }

        if (null !== $request->diskId) {
            @$query['DiskId'] = $request->diskId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->performanceLevel) {
            @$query['PerformanceLevel'] = $request->performanceLevel;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRCDiskSpec',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRCDiskSpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the disk type or performance level (PL) of the cloud disks of an RDS Custom instance.
     *
     * @remarks
     * >  To minimize the impacts on your business, we recommend that you change specifications during off-peak hours.
     * Take note of the following items:
     * *   For a pay-as-you-go Enterprise SSD (ESSD), you can upgrade or downgrade its PL. However, you cannot downgrade the performance level to PL0.
     * *   The ESSD must be in the In Use (In_Use) or Unattached (Available) state.
     * *   If the ESSD is attached to an instance, the instance must be in the Running or Stopped state. The instance cannot be in the Expired state or stopped due to overdue payments.
     * *   The performance level of an ESSD is limited by the capacity of the ESSD. If you cannot upgrade the PL of an ESSD, you can expand the capacity of the ESSD.
     *
     * @param request - ModifyRCDiskSpecRequest
     *
     * @returns ModifyRCDiskSpecResponse
     *
     * @param ModifyRCDiskSpecRequest $request
     *
     * @return ModifyRCDiskSpecResponse
     */
    public function modifyRCDiskSpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRCDiskSpecWithOptions($request, $runtime);
    }

    /**
     * Upgrades or downgrades the instance type of a subscription RDS Custom instance. The new instance type takes effect for the remaining lifecycle of the instance.
     *
     * @remarks
     * Before you call this operation, make sure that you are familiar with the billing methods, pricing, and refund rules of RDS Custom.
     * Before you call this operation, take note of the following items:
     * *   You cannot change the instance type of an expired instance. You can renew the instance and try again.
     * *   When you downgrade the instance type of an instance, take note of the following items:
     *     *   The instance must be in the Stopped state.
     *     *   The price difference is refunded to the payment account you used. Vouchers that have been redeemed are not refundable.
     * *   The operation is asynchronous. Wait 5 to 10 seconds for the instance type change to complete. Then, restart the instance by calling the RebootInstance operation or by using the console for the instance type change to take effect. If you restart only the operating system of the instance, the instance type change does not take effect. If the instance is in the Stopped state, you need only to start the instance. You do not need to restart the instance after it enters the Running state.
     *
     * @param request - ModifyRCInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRCInstanceResponse
     *
     * @param ModifyRCInstanceRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ModifyRCInstanceResponse
     */
    public function modifyRCInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->direction) {
            @$query['Direction'] = $request->direction;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->rebootTime) {
            @$query['RebootTime'] = $request->rebootTime;
        }

        if (null !== $request->rebootWhenFinished) {
            @$query['RebootWhenFinished'] = $request->rebootWhenFinished;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRCInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRCInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Upgrades or downgrades the instance type of a subscription RDS Custom instance. The new instance type takes effect for the remaining lifecycle of the instance.
     *
     * @remarks
     * Before you call this operation, make sure that you are familiar with the billing methods, pricing, and refund rules of RDS Custom.
     * Before you call this operation, take note of the following items:
     * *   You cannot change the instance type of an expired instance. You can renew the instance and try again.
     * *   When you downgrade the instance type of an instance, take note of the following items:
     *     *   The instance must be in the Stopped state.
     *     *   The price difference is refunded to the payment account you used. Vouchers that have been redeemed are not refundable.
     * *   The operation is asynchronous. Wait 5 to 10 seconds for the instance type change to complete. Then, restart the instance by calling the RebootInstance operation or by using the console for the instance type change to take effect. If you restart only the operating system of the instance, the instance type change does not take effect. If the instance is in the Stopped state, you need only to start the instance. You do not need to restart the instance after it enters the Running state.
     *
     * @param request - ModifyRCInstanceRequest
     *
     * @returns ModifyRCInstanceResponse
     *
     * @param ModifyRCInstanceRequest $request
     *
     * @return ModifyRCInstanceResponse
     */
    public function modifyRCInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRCInstanceWithOptions($request, $runtime);
    }

    /**
     * Modifies specific attributes of an RDS Custom instance, such as the password or hostname.
     *
     * @param request - ModifyRCInstanceAttributeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRCInstanceAttributeResponse
     *
     * @param ModifyRCInstanceAttributeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ModifyRCInstanceAttributeResponse
     */
    public function modifyRCInstanceAttributeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->reboot) {
            @$query['Reboot'] = $request->reboot;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRCInstanceAttribute',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRCInstanceAttributeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies specific attributes of an RDS Custom instance, such as the password or hostname.
     *
     * @param request - ModifyRCInstanceAttributeRequest
     *
     * @returns ModifyRCInstanceAttributeResponse
     *
     * @param ModifyRCInstanceAttributeRequest $request
     *
     * @return ModifyRCInstanceAttributeResponse
     */
    public function modifyRCInstanceAttribute($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRCInstanceAttributeWithOptions($request, $runtime);
    }

    /**
     * Modifies the billing method of an RDS Custom instance or cloud disks. You can call this operation to change the billing method of instances between pay-as-you-go and subscription.
     *
     * @param request - ModifyRCInstanceChargeTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRCInstanceChargeTypeResponse
     *
     * @param ModifyRCInstanceChargeTypeRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ModifyRCInstanceChargeTypeResponse
     */
    public function modifyRCInstanceChargeTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->businessInfo) {
            @$query['BusinessInfo'] = $request->businessInfo;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->includeDataDisks) {
            @$query['IncludeDataDisks'] = $request->includeDataDisks;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->instanceIds) {
            @$query['InstanceIds'] = $request->instanceIds;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->promotionCode) {
            @$query['PromotionCode'] = $request->promotionCode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRCInstanceChargeType',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRCInstanceChargeTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the billing method of an RDS Custom instance or cloud disks. You can call this operation to change the billing method of instances between pay-as-you-go and subscription.
     *
     * @param request - ModifyRCInstanceChargeTypeRequest
     *
     * @returns ModifyRCInstanceChargeTypeResponse
     *
     * @param ModifyRCInstanceChargeTypeRequest $request
     *
     * @return ModifyRCInstanceChargeTypeResponse
     */
    public function modifyRCInstanceChargeType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRCInstanceChargeTypeWithOptions($request, $runtime);
    }

    /**
     * Modifies the name of an RDS Custom instance.
     *
     * @param request - ModifyRCInstanceDescriptionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRCInstanceDescriptionResponse
     *
     * @param ModifyRCInstanceDescriptionRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifyRCInstanceDescriptionResponse
     */
    public function modifyRCInstanceDescriptionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceDescription) {
            @$query['InstanceDescription'] = $request->instanceDescription;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRCInstanceDescription',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRCInstanceDescriptionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the name of an RDS Custom instance.
     *
     * @param request - ModifyRCInstanceDescriptionRequest
     *
     * @returns ModifyRCInstanceDescriptionResponse
     *
     * @param ModifyRCInstanceDescriptionRequest $request
     *
     * @return ModifyRCInstanceDescriptionResponse
     */
    public function modifyRCInstanceDescription($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRCInstanceDescriptionWithOptions($request, $runtime);
    }

    /**
     * Modifies the key pair of an RDS Custom instance.
     *
     * @param request - ModifyRCInstanceKeyPairRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRCInstanceKeyPairResponse
     *
     * @param ModifyRCInstanceKeyPairRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyRCInstanceKeyPairResponse
     */
    public function modifyRCInstanceKeyPairWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->keyPairName) {
            @$query['KeyPairName'] = $request->keyPairName;
        }

        if (null !== $request->reboot) {
            @$query['Reboot'] = $request->reboot;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRCInstanceKeyPair',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRCInstanceKeyPairResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the key pair of an RDS Custom instance.
     *
     * @param request - ModifyRCInstanceKeyPairRequest
     *
     * @returns ModifyRCInstanceKeyPairResponse
     *
     * @param ModifyRCInstanceKeyPairRequest $request
     *
     * @return ModifyRCInstanceKeyPairResponse
     */
    public function modifyRCInstanceKeyPair($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRCInstanceKeyPairWithOptions($request, $runtime);
    }

    /**
     * Modifies the public bandwidth of an RDS Custom for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * Custom for SQL Server
     *
     * @param request - ModifyRCInstanceNetworkSpecRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRCInstanceNetworkSpecResponse
     *
     * @param ModifyRCInstanceNetworkSpecRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifyRCInstanceNetworkSpecResponse
     */
    public function modifyRCInstanceNetworkSpecWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->internetMaxBandwidthOut) {
            @$query['InternetMaxBandwidthOut'] = $request->internetMaxBandwidthOut;
        }

        if (null !== $request->networkChargeType) {
            @$query['NetworkChargeType'] = $request->networkChargeType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRCInstanceNetworkSpec',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRCInstanceNetworkSpecResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the public bandwidth of an RDS Custom for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * Custom for SQL Server
     *
     * @param request - ModifyRCInstanceNetworkSpecRequest
     *
     * @returns ModifyRCInstanceNetworkSpecResponse
     *
     * @param ModifyRCInstanceNetworkSpecRequest $request
     *
     * @return ModifyRCInstanceNetworkSpecResponse
     */
    public function modifyRCInstanceNetworkSpec($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRCInstanceNetworkSpecWithOptions($request, $runtime);
    }

    /**
     * 修改RC安全组规则.
     *
     * @param request - ModifyRCSecurityGroupPermissionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyRCSecurityGroupPermissionResponse
     *
     * @param ModifyRCSecurityGroupPermissionRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ModifyRCSecurityGroupPermissionResponse
     */
    public function modifyRCSecurityGroupPermissionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destCidrIp) {
            @$query['DestCidrIp'] = $request->destCidrIp;
        }

        if (null !== $request->direction) {
            @$query['Direction'] = $request->direction;
        }

        if (null !== $request->ipProtocol) {
            @$query['IpProtocol'] = $request->ipProtocol;
        }

        if (null !== $request->policy) {
            @$query['Policy'] = $request->policy;
        }

        if (null !== $request->portRange) {
            @$query['PortRange'] = $request->portRange;
        }

        if (null !== $request->priority) {
            @$query['Priority'] = $request->priority;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        if (null !== $request->securityGroupRuleId) {
            @$query['SecurityGroupRuleId'] = $request->securityGroupRuleId;
        }

        if (null !== $request->sourceCidrIp) {
            @$query['SourceCidrIp'] = $request->sourceCidrIp;
        }

        if (null !== $request->sourcePortRange) {
            @$query['SourcePortRange'] = $request->sourcePortRange;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyRCSecurityGroupPermission',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyRCSecurityGroupPermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 修改RC安全组规则.
     *
     * @param request - ModifyRCSecurityGroupPermissionRequest
     *
     * @returns ModifyRCSecurityGroupPermissionResponse
     *
     * @param ModifyRCSecurityGroupPermissionRequest $request
     *
     * @return ModifyRCSecurityGroupPermissionResponse
     */
    public function modifyRCSecurityGroupPermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyRCSecurityGroupPermissionWithOptions($request, $runtime);
    }

    /**
     * Modifies the latency threshold of the read/write splitting link and the read weights of a primary instance and its read-only instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
     * *   The read/write splitting feature is enabled for your ApsaraDB RDS for MySQL instance.
     * *   The instance must run one of the following database engine versions and RDS editions:
     *     *   MySQL 5.7 on RDS High-availability Edition with local disks
     *     *   MySQL 5.6
     *     *   SQL Server on RDS Cluster Edition
     *
     * @param request - ModifyReadWriteSplittingConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyReadWriteSplittingConnectionResponse
     *
     * @param ModifyReadWriteSplittingConnectionRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ModifyReadWriteSplittingConnectionResponse
     */
    public function modifyReadWriteSplittingConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->connectionStringPrefix) {
            @$query['ConnectionStringPrefix'] = $request->connectionStringPrefix;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->distributionType) {
            @$query['DistributionType'] = $request->distributionType;
        }

        if (null !== $request->maxDelayTime) {
            @$query['MaxDelayTime'] = $request->maxDelayTime;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->weight) {
            @$query['Weight'] = $request->weight;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyReadWriteSplittingConnection',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyReadWriteSplittingConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the latency threshold of the read/write splitting link and the read weights of a primary instance and its read-only instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### [](#)Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
     * *   The read/write splitting feature is enabled for your ApsaraDB RDS for MySQL instance.
     * *   The instance must run one of the following database engine versions and RDS editions:
     *     *   MySQL 5.7 on RDS High-availability Edition with local disks
     *     *   MySQL 5.6
     *     *   SQL Server on RDS Cluster Edition
     *
     * @param request - ModifyReadWriteSplittingConnectionRequest
     *
     * @returns ModifyReadWriteSplittingConnectionResponse
     *
     * @param ModifyReadWriteSplittingConnectionRequest $request
     *
     * @return ModifyReadWriteSplittingConnectionResponse
     */
    public function modifyReadWriteSplittingConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyReadWriteSplittingConnectionWithOptions($request, $runtime);
    }

    /**
     * Modifies the latency at which a read-only ApsaraDB RDS for MySQL instance replicates data from its primary instance.
     *
     * @remarks
     * ### Supported database engines
     * RDS MySQL
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Set the data replication latency of a read-only ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96056.html)
     *
     * @param request - ModifyReadonlyInstanceDelayReplicationTimeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyReadonlyInstanceDelayReplicationTimeResponse
     *
     * @param ModifyReadonlyInstanceDelayReplicationTimeRequest $request
     * @param RuntimeOptions                                    $runtime
     *
     * @return ModifyReadonlyInstanceDelayReplicationTimeResponse
     */
    public function modifyReadonlyInstanceDelayReplicationTimeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->readSQLReplicationTime) {
            @$query['ReadSQLReplicationTime'] = $request->readSQLReplicationTime;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyReadonlyInstanceDelayReplicationTime',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyReadonlyInstanceDelayReplicationTimeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the latency at which a read-only ApsaraDB RDS for MySQL instance replicates data from its primary instance.
     *
     * @remarks
     * ### Supported database engines
     * RDS MySQL
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Set the data replication latency of a read-only ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96056.html)
     *
     * @param request - ModifyReadonlyInstanceDelayReplicationTimeRequest
     *
     * @returns ModifyReadonlyInstanceDelayReplicationTimeResponse
     *
     * @param ModifyReadonlyInstanceDelayReplicationTimeRequest $request
     *
     * @return ModifyReadonlyInstanceDelayReplicationTimeResponse
     */
    public function modifyReadonlyInstanceDelayReplicationTime($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyReadonlyInstanceDelayReplicationTimeWithOptions($request, $runtime);
    }

    /**
     * Moves an ApsaraDB RDS instance to a specified resource group.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Transfer resources across resource groups](https://help.aliyun.com/document_detail/94487.html)
     *
     * @param request - ModifyResourceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyResourceGroupResponse
     *
     * @param ModifyResourceGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ModifyResourceGroupResponse
     */
    public function modifyResourceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyResourceGroup',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Moves an ApsaraDB RDS instance to a specified resource group.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Transfer resources across resource groups](https://help.aliyun.com/document_detail/94487.html)
     *
     * @param request - ModifyResourceGroupRequest
     *
     * @returns ModifyResourceGroupResponse
     *
     * @param ModifyResourceGroupRequest $request
     *
     * @return ModifyResourceGroupResponse
     */
    public function modifyResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyResourceGroupWithOptions($request, $runtime);
    }

    /**
     * Enables or disables the SQL Explorer (SQL Audit) feature for an instance.
     *
     * @remarks
     * ### [](#)Note:
     * This operation is no longer maintained. We recommend that you enable or configure Database Autonomy Service (DAS) Enterprise Edition. For more information, see [Enable or configure DAS Enterprise Edition](https://help.aliyun.com/document_detail/2778835.html).
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the SQL Explorer and Audit feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/476574.html)
     * *   [Use the SQL Audit feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96766.html)
     * *   [Use the SQL Audit feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95712.html)
     *
     * @param request - ModifySQLCollectorPolicyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySQLCollectorPolicyResponse
     *
     * @param ModifySQLCollectorPolicyRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ModifySQLCollectorPolicyResponse
     */
    public function modifySQLCollectorPolicyWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->SQLCollectorStatus) {
            @$query['SQLCollectorStatus'] = $request->SQLCollectorStatus;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySQLCollectorPolicy',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySQLCollectorPolicyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Enables or disables the SQL Explorer (SQL Audit) feature for an instance.
     *
     * @remarks
     * ### [](#)Note:
     * This operation is no longer maintained. We recommend that you enable or configure Database Autonomy Service (DAS) Enterprise Edition. For more information, see [Enable or configure DAS Enterprise Edition](https://help.aliyun.com/document_detail/2778835.html).
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the SQL Explorer and Audit feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/476574.html)
     * *   [Use the SQL Audit feature for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96766.html)
     * *   [Use the SQL Audit feature for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95712.html)
     *
     * @param request - ModifySQLCollectorPolicyRequest
     *
     * @returns ModifySQLCollectorPolicyResponse
     *
     * @param ModifySQLCollectorPolicyRequest $request
     *
     * @return ModifySQLCollectorPolicyResponse
     */
    public function modifySQLCollectorPolicy($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySQLCollectorPolicyWithOptions($request, $runtime);
    }

    /**
     * Changes the retention period of the log files that are generated by the SQL Explorer feature for an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * RDS MySQL
     * ### Precautions
     * After you shorten the log backup retention period, log backup files that are stored longer than the specified log backup retention period are immediately deleted.
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the SQL Explorer and Audit feature](https://help.aliyun.com/document_detail/476574.html)
     *
     * @param request - ModifySQLCollectorRetentionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySQLCollectorRetentionResponse
     *
     * @param ModifySQLCollectorRetentionRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ModifySQLCollectorRetentionResponse
     */
    public function modifySQLCollectorRetentionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->configValue) {
            @$query['ConfigValue'] = $request->configValue;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySQLCollectorRetention',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySQLCollectorRetentionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the retention period of the log files that are generated by the SQL Explorer feature for an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * RDS MySQL
     * ### Precautions
     * After you shorten the log backup retention period, log backup files that are stored longer than the specified log backup retention period are immediately deleted.
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Use the SQL Explorer and Audit feature](https://help.aliyun.com/document_detail/476574.html)
     *
     * @param request - ModifySQLCollectorRetentionRequest
     *
     * @returns ModifySQLCollectorRetentionResponse
     *
     * @param ModifySQLCollectorRetentionRequest $request
     *
     * @return ModifySQLCollectorRetentionResponse
     */
    public function modifySQLCollectorRetention($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySQLCollectorRetentionWithOptions($request, $runtime);
    }

    /**
     * Changes the ECS security groups to which an instance is added.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure a security group for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/201042.html)
     * *   [Configure a security group for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206310.html)
     * *   [Configure a security group for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - ModifySecurityGroupConfigurationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySecurityGroupConfigurationResponse
     *
     * @param ModifySecurityGroupConfigurationRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return ModifySecurityGroupConfigurationResponse
     */
    public function modifySecurityGroupConfigurationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySecurityGroupConfiguration',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySecurityGroupConfigurationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the ECS security groups to which an instance is added.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Configure a security group for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/201042.html)
     * *   [Configure a security group for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/206310.html)
     * *   [Configure a security group for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/2392322.html)
     *
     * @param request - ModifySecurityGroupConfigurationRequest
     *
     * @returns ModifySecurityGroupConfigurationResponse
     *
     * @param ModifySecurityGroupConfigurationRequest $request
     *
     * @return ModifySecurityGroupConfigurationResponse
     */
    public function modifySecurityGroupConfiguration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySecurityGroupConfigurationWithOptions($request, $runtime);
    }

    /**
     * Modifies the IP address whitelist of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure an IP address whitelist for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96118.html)
     * *   [Configure an IP address whitelist for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/43187.html)
     * *   [Configure an IP address whitelist for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/43186.html)
     * *   [Configure an IP address whitelist for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/90336.html)
     *
     * @param request - ModifySecurityIpsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifySecurityIpsResponse
     *
     * @param ModifySecurityIpsRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ModifySecurityIpsResponse
     */
    public function modifySecurityIpsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceIPArrayAttribute) {
            @$query['DBInstanceIPArrayAttribute'] = $request->DBInstanceIPArrayAttribute;
        }

        if (null !== $request->DBInstanceIPArrayName) {
            @$query['DBInstanceIPArrayName'] = $request->DBInstanceIPArrayName;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->freshWhiteListReadins) {
            @$query['FreshWhiteListReadins'] = $request->freshWhiteListReadins;
        }

        if (null !== $request->modifyMode) {
            @$query['ModifyMode'] = $request->modifyMode;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityIPType) {
            @$query['SecurityIPType'] = $request->securityIPType;
        }

        if (null !== $request->securityIps) {
            @$query['SecurityIps'] = $request->securityIps;
        }

        if (null !== $request->whitelistNetworkType) {
            @$query['WhitelistNetworkType'] = $request->whitelistNetworkType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifySecurityIps',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifySecurityIpsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the IP address whitelist of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Configure an IP address whitelist for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96118.html)
     * *   [Configure an IP address whitelist for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/43187.html)
     * *   [Configure an IP address whitelist for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/43186.html)
     * *   [Configure an IP address whitelist for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/90336.html)
     *
     * @param request - ModifySecurityIpsRequest
     *
     * @returns ModifySecurityIpsResponse
     *
     * @param ModifySecurityIpsRequest $request
     *
     * @return ModifySecurityIpsResponse
     */
    public function modifySecurityIps($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifySecurityIpsWithOptions($request, $runtime);
    }

    /**
     * Modifies information about the historical tasks in the task center.
     *
     * @param request - ModifyTaskInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyTaskInfoResponse
     *
     * @param ModifyTaskInfoRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ModifyTaskInfoResponse
     */
    public function modifyTaskInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->actionParams) {
            @$query['ActionParams'] = $request->actionParams;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->securityToken) {
            @$query['SecurityToken'] = $request->securityToken;
        }

        if (null !== $request->stepName) {
            @$query['StepName'] = $request->stepName;
        }

        if (null !== $request->taskAction) {
            @$query['TaskAction'] = $request->taskAction;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyTaskInfo',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyTaskInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies information about the historical tasks in the task center.
     *
     * @param request - ModifyTaskInfoRequest
     *
     * @returns ModifyTaskInfoResponse
     *
     * @param ModifyTaskInfoRequest $request
     *
     * @return ModifyTaskInfoResponse
     */
    public function modifyTaskInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyTaskInfoWithOptions($request, $runtime);
    }

    /**
     * Edits a whitelist. You can call this operation to create, modify, or delete a whitelist.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - ModifyWhitelistTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ModifyWhitelistTemplateResponse
     *
     * @param ModifyWhitelistTemplateRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return ModifyWhitelistTemplateResponse
     */
    public function modifyWhitelistTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ipWhitelist) {
            @$query['IpWhitelist'] = $request->ipWhitelist;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->templateId) {
            @$query['TemplateId'] = $request->templateId;
        }

        if (null !== $request->templateName) {
            @$query['TemplateName'] = $request->templateName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ModifyWhitelistTemplate',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ModifyWhitelistTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Edits a whitelist. You can call this operation to create, modify, or delete a whitelist.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     *
     * @param request - ModifyWhitelistTemplateRequest
     *
     * @returns ModifyWhitelistTemplateResponse
     *
     * @param ModifyWhitelistTemplateRequest $request
     *
     * @return ModifyWhitelistTemplateResponse
     */
    public function modifyWhitelistTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->modifyWhitelistTemplateWithOptions($request, $runtime);
    }

    /**
     * 删除节点创建订单预检查.
     *
     * @param tmpReq - PreCheckCreateOrderForDeleteDBNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PreCheckCreateOrderForDeleteDBNodesResponse
     *
     * @param PreCheckCreateOrderForDeleteDBNodesRequest $tmpReq
     * @param RuntimeOptions                             $runtime
     *
     * @return PreCheckCreateOrderForDeleteDBNodesResponse
     */
    public function preCheckCreateOrderForDeleteDBNodesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new PreCheckCreateOrderForDeleteDBNodesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->DBNodeId) {
            $request->DBNodeIdShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->DBNodeId, 'DBNodeId', 'json');
        }

        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->businessInfo) {
            @$query['BusinessInfo'] = $request->businessInfo;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBNodeIdShrink) {
            @$query['DBNodeId'] = $request->DBNodeIdShrink;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->nodeType) {
            @$query['NodeType'] = $request->nodeType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->promotionCode) {
            @$query['PromotionCode'] = $request->promotionCode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resource) {
            @$query['Resource'] = $request->resource;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PreCheckCreateOrderForDeleteDBNodes',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PreCheckCreateOrderForDeleteDBNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 删除节点创建订单预检查.
     *
     * @param request - PreCheckCreateOrderForDeleteDBNodesRequest
     *
     * @returns PreCheckCreateOrderForDeleteDBNodesResponse
     *
     * @param PreCheckCreateOrderForDeleteDBNodesRequest $request
     *
     * @return PreCheckCreateOrderForDeleteDBNodesResponse
     */
    public function preCheckCreateOrderForDeleteDBNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->preCheckCreateOrderForDeleteDBNodesWithOptions($request, $runtime);
    }

    /**
     * Clears the on-premises logs of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### Description
     * The system automatically uploads log backup files to Object Storage Service (OSS) buckets. If the remaining storage of an instance is insufficient, you can call this operation to upload the log backup files of the instance to OSS buckets. After the upload is complete, the system deletes these files from the instance to release storage. This operation is called to upload log backup files from an instance to OSS buckets and then delete these files from the instance. If the instance runs SQL Server, transaction log backup files are compressed before they are uploaded.
     * ### Precautions
     * *   When you upload log backup files, the data restoration feature is not affected.
     * *   This operation is called to release storage. The backup storage usage is not reduced.
     * *   The OSS buckets to which log backup files are uploaded are provided by the system. You do not need to purchase these OSS buckets. In addition, you cannot access these OSS buckets.
     *
     * @param request - PurgeDBInstanceLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PurgeDBInstanceLogResponse
     *
     * @param PurgeDBInstanceLogRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return PurgeDBInstanceLogResponse
     */
    public function purgeDBInstanceLogWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'PurgeDBInstanceLog',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PurgeDBInstanceLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Clears the on-premises logs of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### Description
     * The system automatically uploads log backup files to Object Storage Service (OSS) buckets. If the remaining storage of an instance is insufficient, you can call this operation to upload the log backup files of the instance to OSS buckets. After the upload is complete, the system deletes these files from the instance to release storage. This operation is called to upload log backup files from an instance to OSS buckets and then delete these files from the instance. If the instance runs SQL Server, transaction log backup files are compressed before they are uploaded.
     * ### Precautions
     * *   When you upload log backup files, the data restoration feature is not affected.
     * *   This operation is called to release storage. The backup storage usage is not reduced.
     * *   The OSS buckets to which log backup files are uploaded are provided by the system. You do not need to purchase these OSS buckets. In addition, you cannot access these OSS buckets.
     *
     * @param request - PurgeDBInstanceLogRequest
     *
     * @returns PurgeDBInstanceLogResponse
     *
     * @param PurgeDBInstanceLogRequest $request
     *
     * @return PurgeDBInstanceLogResponse
     */
    public function purgeDBInstanceLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->purgeDBInstanceLogWithOptions($request, $runtime);
    }

    /**
     * Queries the notifications of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### Feature description
     * The notifications are highlighted at the top of the ApsaraDB RDS console. The notifications include renewal reminders and reminders of instance creation failures.
     * After you call this operation to query notifications, you can call the [ConfirmNotify](https://help.aliyun.com/document_detail/610444.html) operation to mark the notifications as confirmed, which means that you understand the content of the notifications.
     *
     * @param request - QueryNotifyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryNotifyResponse
     *
     * @param QueryNotifyRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return QueryNotifyResponse
     */
    public function queryNotifyWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->from) {
            @$body['From'] = $request->from;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->to) {
            @$body['To'] = $request->to;
        }

        if (null !== $request->withConfirmed) {
            @$body['WithConfirmed'] = $request->withConfirmed;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QueryNotify',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryNotifyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the notifications of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### Feature description
     * The notifications are highlighted at the top of the ApsaraDB RDS console. The notifications include renewal reminders and reminders of instance creation failures.
     * After you call this operation to query notifications, you can call the [ConfirmNotify](https://help.aliyun.com/document_detail/610444.html) operation to mark the notifications as confirmed, which means that you understand the content of the notifications.
     *
     * @param request - QueryNotifyRequest
     *
     * @returns QueryNotifyResponse
     *
     * @param QueryNotifyRequest $request
     *
     * @return QueryNotifyResponse
     */
    public function queryNotify($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryNotifyWithOptions($request, $runtime);
    }

    /**
     * rds机器人热点问题.
     *
     * @param request - QueryRecommendByCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryRecommendByCodeResponse
     *
     * @param QueryRecommendByCodeRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return QueryRecommendByCodeResponse
     */
    public function queryRecommendByCodeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->code) {
            @$query['Code'] = $request->code;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryRecommendByCode',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryRecommendByCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * rds机器人热点问题.
     *
     * @param request - QueryRecommendByCodeRequest
     *
     * @returns QueryRecommendByCodeResponse
     *
     * @param QueryRecommendByCodeRequest $request
     *
     * @return QueryRecommendByCodeResponse
     */
    public function queryRecommendByCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecommendByCodeWithOptions($request, $runtime);
    }

    /**
     * Restarts an RDS Custom instance that is in the Running state.
     *
     * @param request - RebootRCInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RebootRCInstanceResponse
     *
     * @param RebootRCInstanceRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return RebootRCInstanceResponse
     */
    public function rebootRCInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->forceStop) {
            @$query['ForceStop'] = $request->forceStop;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RebootRCInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RebootRCInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restarts an RDS Custom instance that is in the Running state.
     *
     * @param request - RebootRCInstanceRequest
     *
     * @returns RebootRCInstanceResponse
     *
     * @param RebootRCInstanceRequest $request
     *
     * @return RebootRCInstanceResponse
     */
    public function rebootRCInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rebootRCInstanceWithOptions($request, $runtime);
    }

    /**
     * Restarts multiple RDS Custom instances at a time.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     *
     * @param tmpReq - RebootRCInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RebootRCInstancesResponse
     *
     * @param RebootRCInstancesRequest $tmpReq
     * @param RuntimeOptions           $runtime
     *
     * @return RebootRCInstancesResponse
     */
    public function rebootRCInstancesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new RebootRCInstancesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->instanceIds) {
            $request->instanceIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->instanceIds, 'InstanceIds', 'json');
        }

        $query = [];
        if (null !== $request->batchOptimization) {
            @$query['BatchOptimization'] = $request->batchOptimization;
        }

        if (null !== $request->forceReboot) {
            @$query['ForceReboot'] = $request->forceReboot;
        }

        if (null !== $request->instanceIdsShrink) {
            @$query['InstanceIds'] = $request->instanceIdsShrink;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RebootRCInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RebootRCInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restarts multiple RDS Custom instances at a time.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     *
     * @param request - RebootRCInstancesRequest
     *
     * @returns RebootRCInstancesResponse
     *
     * @param RebootRCInstancesRequest $request
     *
     * @return RebootRCInstancesResponse
     */
    public function rebootRCInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rebootRCInstancesWithOptions($request, $runtime);
    }

    /**
     * Rebuilds the secondary instance of a primary instance in a dedicated cluster.
     *
     * @remarks
     * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](https://help.aliyun.com/document_detail/141455.html)
     *
     * @param request - RebuildDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RebuildDBInstanceResponse
     *
     * @param RebuildDBInstanceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return RebuildDBInstanceResponse
     */
    public function rebuildDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->dedicatedHostId) {
            @$query['DedicatedHostId'] = $request->dedicatedHostId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->rebuildNodeType) {
            @$query['RebuildNodeType'] = $request->rebuildNodeType;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RebuildDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RebuildDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Rebuilds the secondary instance of a primary instance in a dedicated cluster.
     *
     * @remarks
     * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](https://help.aliyun.com/document_detail/141455.html)
     *
     * @param request - RebuildDBInstanceRequest
     *
     * @returns RebuildDBInstanceResponse
     *
     * @param RebuildDBInstanceRequest $request
     *
     * @return RebuildDBInstanceResponse
     */
    public function rebuildDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rebuildDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Re-creates a data synchronization link for a disaster recovery ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   PostgreSQL
     *
     * @param request - RebuildReplicationLinkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RebuildReplicationLinkResponse
     *
     * @param RebuildReplicationLinkRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return RebuildReplicationLinkResponse
     */
    public function rebuildReplicationLinkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RebuildReplicationLink',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RebuildReplicationLinkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Re-creates a data synchronization link for a disaster recovery ApsaraDB RDS instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * *   PostgreSQL
     *
     * @param request - RebuildReplicationLinkRequest
     *
     * @returns RebuildReplicationLinkResponse
     *
     * @param RebuildReplicationLinkRequest $request
     *
     * @return RebuildReplicationLinkResponse
     */
    public function rebuildReplicationLink($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->rebuildReplicationLinkWithOptions($request, $runtime);
    }

    /**
     * Switches a primary instance to a disaster recovery instance or a disaster recovery instance to a primary instance.
     *
     * @remarks
     * The operation is phased out.
     *
     * @param request - ReceiveDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReceiveDBInstanceResponse
     *
     * @param ReceiveDBInstanceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ReceiveDBInstanceResponse
     */
    public function receiveDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->guardDBInstanceId) {
            @$query['GuardDBInstanceId'] = $request->guardDBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReceiveDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReceiveDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Switches a primary instance to a disaster recovery instance or a disaster recovery instance to a primary instance.
     *
     * @remarks
     * The operation is phased out.
     *
     * @param request - ReceiveDBInstanceRequest
     *
     * @returns ReceiveDBInstanceResponse
     *
     * @param ReceiveDBInstanceRequest $request
     *
     * @return ReceiveDBInstanceResponse
     */
    public function receiveDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->receiveDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Restores backup data of an ApsaraDB RDS for SQL Server instance to an existing instance or a new instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server 2012 or later
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Restore the data of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95722.html)
     *
     * @param request - RecoveryDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RecoveryDBInstanceResponse
     *
     * @param RecoveryDBInstanceRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return RecoveryDBInstanceResponse
     */
    public function recoveryDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->dbNames) {
            @$query['DbNames'] = $request->dbNames;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreTime) {
            @$query['RestoreTime'] = $request->restoreTime;
        }

        if (null !== $request->targetDBInstanceId) {
            @$query['TargetDBInstanceId'] = $request->targetDBInstanceId;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RecoveryDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RecoveryDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restores backup data of an ApsaraDB RDS for SQL Server instance to an existing instance or a new instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * SQL Server 2012 or later
     * ### [](#)References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Restore the data of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95722.html)
     *
     * @param request - RecoveryDBInstanceRequest
     *
     * @returns RecoveryDBInstanceResponse
     *
     * @param RecoveryDBInstanceRequest $request
     *
     * @return RecoveryDBInstanceResponse
     */
    public function recoveryDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->recoveryDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Releases the public endpoint of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * *   [Release the public endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/26128.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/97738.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/97736.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97740.html)
     *
     * @param request - ReleaseInstanceConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReleaseInstanceConnectionResponse
     *
     * @param ReleaseInstanceConnectionRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ReleaseInstanceConnectionResponse
     */
    public function releaseInstanceConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentConnectionString) {
            @$query['CurrentConnectionString'] = $request->currentConnectionString;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReleaseInstanceConnection',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReleaseInstanceConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases the public endpoint of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * *   [Release the public endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/26128.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/97738.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/97736.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97740.html)
     *
     * @param request - ReleaseInstanceConnectionRequest
     *
     * @returns ReleaseInstanceConnectionResponse
     *
     * @param ReleaseInstanceConnectionRequest $request
     *
     * @return ReleaseInstanceConnectionResponse
     */
    public function releaseInstanceConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseInstanceConnectionWithOptions($request, $runtime);
    }

    /**
     * Releases the public endpoint of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Release the public endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/26128.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/97738.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/97736.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97740.html)
     *
     * @param request - ReleaseInstancePublicConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReleaseInstancePublicConnectionResponse
     *
     * @param ReleaseInstancePublicConnectionRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ReleaseInstancePublicConnectionResponse
     */
    public function releaseInstancePublicConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->currentConnectionString) {
            @$query['CurrentConnectionString'] = $request->currentConnectionString;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReleaseInstancePublicConnection',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReleaseInstancePublicConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases the public endpoint of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Release the public endpoint of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/26128.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/97738.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/97736.html)
     * *   [Release the public endpoint of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97740.html)
     *
     * @param request - ReleaseInstancePublicConnectionRequest
     *
     * @returns ReleaseInstancePublicConnectionResponse
     *
     * @param ReleaseInstancePublicConnectionRequest $request
     *
     * @return ReleaseInstancePublicConnectionResponse
     */
    public function releaseInstancePublicConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseInstancePublicConnectionWithOptions($request, $runtime);
    }

    /**
     * Releases the read/write splitting endpoint of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
     * *   The read/write splitting feature is enabled for the instance.
     * *   The instance must run one of the following database engine versions and RDS editions:
     *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
     *     *   MySQL 5.6
     *     *   SQL Server on RDS Cluster Edition
     *
     * @param request - ReleaseReadWriteSplittingConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReleaseReadWriteSplittingConnectionResponse
     *
     * @param ReleaseReadWriteSplittingConnectionRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return ReleaseReadWriteSplittingConnectionResponse
     */
    public function releaseReadWriteSplittingConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReleaseReadWriteSplittingConnection',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReleaseReadWriteSplittingConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Releases the read/write splitting endpoint of an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### Prerequisites
     * Before you call this operation, make sure that the following requirements are met:
     * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
     * *   The read/write splitting feature is enabled for the instance.
     * *   The instance must run one of the following database engine versions and RDS editions:
     *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
     *     *   MySQL 5.6
     *     *   SQL Server on RDS Cluster Edition
     *
     * @param request - ReleaseReadWriteSplittingConnectionRequest
     *
     * @returns ReleaseReadWriteSplittingConnectionResponse
     *
     * @param ReleaseReadWriteSplittingConnectionRequest $request
     *
     * @return ReleaseReadWriteSplittingConnectionResponse
     */
    public function releaseReadWriteSplittingConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->releaseReadWriteSplittingConnectionWithOptions($request, $runtime);
    }

    /**
     * Removes tags from an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Usage notes
     * *   A maximum of 10 tags can be removed in a single request.
     * *   If a tag is removed from all instances to which the tag is added, the tag is automatically deleted.
     * *   If you specify only TagKey, all tags that match the TagKey condition are removed.
     * *   You must specify at least TagKey or a pair of TagKey and TagValue.
     *
     * @param request - RemoveTagsFromResourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveTagsFromResourceResponse
     *
     * @param RemoveTagsFromResourceRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return RemoveTagsFromResourceResponse
     */
    public function removeTagsFromResourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->tags) {
            @$query['Tags'] = $request->tags;
        }

        if (null !== $request->proxyId) {
            @$query['proxyId'] = $request->proxyId;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveTagsFromResource',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveTagsFromResourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes tags from an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Usage notes
     * *   A maximum of 10 tags can be removed in a single request.
     * *   If a tag is removed from all instances to which the tag is added, the tag is automatically deleted.
     * *   If you specify only TagKey, all tags that match the TagKey condition are removed.
     * *   You must specify at least TagKey or a pair of TagKey and TagValue.
     *
     * @param request - RemoveTagsFromResourceRequest
     *
     * @returns RemoveTagsFromResourceResponse
     *
     * @param RemoveTagsFromResourceRequest $request
     *
     * @return RemoveTagsFromResourceResponse
     */
    public function removeTagsFromResource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeTagsFromResourceWithOptions($request, $runtime);
    }

    /**
     * Manually renews an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the following topics:
     * *   [Manually renew an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96050.html)
     * *   [Manually renew an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96741.html)
     * *   [Manually renew an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95637.html)
     * *   [Manually renew an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97122.html)
     *
     * @param request - RenewInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RenewInstanceResponse
     *
     * @param RenewInstanceRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return RenewInstanceResponse
     */
    public function renewInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->promotionCode) {
            @$query['PromotionCode'] = $request->promotionCode;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RenewInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RenewInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Manually renews an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the following topics:
     * *   [Manually renew an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96050.html)
     * *   [Manually renew an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96741.html)
     * *   [Manually renew an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95637.html)
     * *   [Manually renew an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97122.html)
     *
     * @param request - RenewInstanceRequest
     *
     * @returns RenewInstanceResponse
     *
     * @param RenewInstanceRequest $request
     *
     * @return RenewInstanceResponse
     */
    public function renewInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->renewInstanceWithOptions($request, $runtime);
    }

    /**
     * Renews a subscription RDS Custom instance.
     *
     * @param request - RenewRCInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RenewRCInstanceResponse
     *
     * @param RenewRCInstanceRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return RenewRCInstanceResponse
     */
    public function renewRCInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->businessInfo) {
            @$query['BusinessInfo'] = $request->businessInfo;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->commodityCode) {
            @$query['CommodityCode'] = $request->commodityCode;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->periodAlign) {
            @$query['PeriodAlign'] = $request->periodAlign;
        }

        if (null !== $request->promotionCode) {
            @$query['PromotionCode'] = $request->promotionCode;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resource) {
            @$query['Resource'] = $request->resource;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->timeType) {
            @$query['TimeType'] = $request->timeType;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RenewRCInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RenewRCInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Renews a subscription RDS Custom instance.
     *
     * @param request - RenewRCInstanceRequest
     *
     * @returns RenewRCInstanceResponse
     *
     * @param RenewRCInstanceRequest $request
     *
     * @return RenewRCInstanceResponse
     */
    public function renewRCInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->renewRCInstanceWithOptions($request, $runtime);
    }

    /**
     * Reinstalls the operating system (OS) of an RDS Custom instance.
     *
     * @remarks
     *   The instance must be in the Stopped state.
     * *   If you reinstall the system, the data on the original system disk is lost. Exercise caution when you perform this operation.
     *
     * @param request - ReplaceRCInstanceSystemDiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ReplaceRCInstanceSystemDiskResponse
     *
     * @param ReplaceRCInstanceSystemDiskRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ReplaceRCInstanceSystemDiskResponse
     */
    public function replaceRCInstanceSystemDiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->imageId) {
            @$query['ImageId'] = $request->imageId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->isLocalDisk) {
            @$query['IsLocalDisk'] = $request->isLocalDisk;
        }

        if (null !== $request->keyPairName) {
            @$query['KeyPairName'] = $request->keyPairName;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ReplaceRCInstanceSystemDisk',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ReplaceRCInstanceSystemDiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Reinstalls the operating system (OS) of an RDS Custom instance.
     *
     * @remarks
     *   The instance must be in the Stopped state.
     * *   If you reinstall the system, the data on the original system disk is lost. Exercise caution when you perform this operation.
     *
     * @param request - ReplaceRCInstanceSystemDiskRequest
     *
     * @returns ReplaceRCInstanceSystemDiskResponse
     *
     * @param ReplaceRCInstanceSystemDiskRequest $request
     *
     * @return ReplaceRCInstanceSystemDiskResponse
     */
    public function replaceRCInstanceSystemDisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->replaceRCInstanceSystemDiskWithOptions($request, $runtime);
    }

    /**
     * Resets the permissions of the privileged account.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Reset of the permissions of privileged accounts](https://help.aliyun.com/document_detail/140724.html)
     *
     * @param request - ResetAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ResetAccountResponse
     *
     * @param ResetAccountRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ResetAccountResponse
     */
    public function resetAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->accountPassword) {
            @$query['AccountPassword'] = $request->accountPassword;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ResetAccount',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ResetAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Resets the permissions of the privileged account.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Reset of the permissions of privileged accounts](https://help.aliyun.com/document_detail/140724.html)
     *
     * @param request - ResetAccountRequest
     *
     * @returns ResetAccountResponse
     *
     * @param ResetAccountRequest $request
     *
     * @return ResetAccountResponse
     */
    public function resetAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resetAccountWithOptions($request, $runtime);
    }

    /**
     * Resets the password of a database account.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Reset the password of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96100.html)
     * *   [Reset the password of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96814.html)
     * *   [Reset the password of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95691.html)
     * *   [Reset the password of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97133.html)
     *
     * @param request - ResetAccountPasswordRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ResetAccountPasswordResponse
     *
     * @param ResetAccountPasswordRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ResetAccountPasswordResponse
     */
    public function resetAccountPasswordWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->accountPassword) {
            @$query['AccountPassword'] = $request->accountPassword;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ResetAccountPassword',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ResetAccountPasswordResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Resets the password of a database account.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Reset the password of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96100.html)
     * *   [Reset the password of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96814.html)
     * *   [Reset the password of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95691.html)
     * *   [Reset the password of an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97133.html)
     *
     * @param request - ResetAccountPasswordRequest
     *
     * @returns ResetAccountPasswordResponse
     *
     * @param ResetAccountPasswordRequest $request
     *
     * @return ResetAccountPasswordResponse
     */
    public function resetAccountPassword($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resetAccountPasswordWithOptions($request, $runtime);
    }

    /**
     * Expand the storage capacity of an RDS Custom instance.
     *
     * @param request - ResizeRCInstanceDiskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ResizeRCInstanceDiskResponse
     *
     * @param ResizeRCInstanceDiskRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ResizeRCInstanceDiskResponse
     */
    public function resizeRCInstanceDiskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->diskId) {
            @$query['DiskId'] = $request->diskId;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->newSize) {
            @$query['NewSize'] = $request->newSize;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ResizeRCInstanceDisk',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ResizeRCInstanceDiskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Expand the storage capacity of an RDS Custom instance.
     *
     * @param request - ResizeRCInstanceDiskRequest
     *
     * @returns ResizeRCInstanceDiskResponse
     *
     * @param ResizeRCInstanceDiskRequest $request
     *
     * @return ResizeRCInstanceDiskResponse
     */
    public function resizeRCInstanceDisk($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resizeRCInstanceDiskWithOptions($request, $runtime);
    }

    /**
     * Restarts an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Restart an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96051.html)
     * *   [Restart an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96798.html)
     * *   [Restart an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95656.html)
     * *   [Restart an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97472.html)
     *
     * @param request - RestartDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RestartDBInstanceResponse
     *
     * @param RestartDBInstanceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return RestartDBInstanceResponse
     */
    public function restartDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RestartDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestartDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restarts an instance.
     *
     * @remarks
     * ### Supported database engines
     * *   RDS MySQL
     * *   RDS PostgreSQL
     * *   RDS SQL Server
     * *   RDS MariaDB
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Restart an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96051.html)
     * *   [Restart an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96798.html)
     * *   [Restart an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95656.html)
     * *   [Restart an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97472.html)
     *
     * @param request - RestartDBInstanceRequest
     *
     * @returns RestartDBInstanceResponse
     *
     * @param RestartDBInstanceRequest $request
     *
     * @return RestartDBInstanceResponse
     */
    public function restartDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Restores data to an existing instance across regions.
     *
     * @remarks
     * >  Before restoration, you can call the CheckCreateDdrDBInstance operation to check whether a cross-region backup set can be used for cross-region restoration.
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Restore the data of an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120875.html)
     *
     * @param request - RestoreDdrTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RestoreDdrTableResponse
     *
     * @param RestoreDdrTableRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return RestoreDdrTableResponse
     */
    public function restoreDdrTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreTime) {
            @$query['RestoreTime'] = $request->restoreTime;
        }

        if (null !== $request->restoreType) {
            @$query['RestoreType'] = $request->restoreType;
        }

        if (null !== $request->sourceDBInstanceName) {
            @$query['SourceDBInstanceName'] = $request->sourceDBInstanceName;
        }

        if (null !== $request->sourceRegion) {
            @$query['SourceRegion'] = $request->sourceRegion;
        }

        if (null !== $request->tableMeta) {
            @$query['TableMeta'] = $request->tableMeta;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RestoreDdrTable',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestoreDdrTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restores data to an existing instance across regions.
     *
     * @remarks
     * >  Before restoration, you can call the CheckCreateDdrDBInstance operation to check whether a cross-region backup set can be used for cross-region restoration.
     * ### [](#)Supported database engines
     * MySQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/120824.html)
     * *   [Restore the data of an ApsaraDB RDS for MySQL instance across regions](https://help.aliyun.com/document_detail/120875.html)
     *
     * @param request - RestoreDdrTableRequest
     *
     * @returns RestoreDdrTableResponse
     *
     * @param RestoreDdrTableRequest $request
     *
     * @return RestoreDdrTableResponse
     */
    public function restoreDdrTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restoreDdrTableWithOptions($request, $runtime);
    }

    /**
     * Restores individual databases or tables of an instance to the original instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/103175.html)
     * *   [Restore individual databases and tables of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/613672.html)
     *
     * @param request - RestoreTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RestoreTableResponse
     *
     * @param RestoreTableRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return RestoreTableResponse
     */
    public function restoreTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->instantRecovery) {
            @$query['InstantRecovery'] = $request->instantRecovery;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->restoreTime) {
            @$query['RestoreTime'] = $request->restoreTime;
        }

        if (null !== $request->tableMeta) {
            @$query['TableMeta'] = $request->tableMeta;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RestoreTable',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestoreTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restores individual databases or tables of an instance to the original instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/103175.html)
     * *   [Restore individual databases and tables of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/613672.html)
     *
     * @param request - RestoreTableRequest
     *
     * @returns RestoreTableResponse
     *
     * @param RestoreTableRequest $request
     *
     * @return RestoreTableResponse
     */
    public function restoreTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restoreTableWithOptions($request, $runtime);
    }

    /**
     * Removes the permissions on a database of an ApsaraDB RDS instance from an account.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Prerequisites
     * *   The instance is in the Running state.
     * *   The database is in the Running state.
     * ### [](#)Precautions
     * *   The permissions that can be revoked include SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, and TRIGGER.
     * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition and run PostgreSQL.
     *
     * @param request - RevokeAccountPrivilegeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RevokeAccountPrivilegeResponse
     *
     * @param RevokeAccountPrivilegeRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return RevokeAccountPrivilegeResponse
     */
    public function revokeAccountPrivilegeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBName) {
            @$query['DBName'] = $request->DBName;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RevokeAccountPrivilege',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RevokeAccountPrivilegeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes the permissions on a database of an ApsaraDB RDS instance from an account.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Prerequisites
     * *   The instance is in the Running state.
     * *   The database is in the Running state.
     * ### [](#)Precautions
     * *   The permissions that can be revoked include SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, and TRIGGER.
     * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition and run PostgreSQL.
     *
     * @param request - RevokeAccountPrivilegeRequest
     *
     * @returns RevokeAccountPrivilegeResponse
     *
     * @param RevokeAccountPrivilegeRequest $request
     *
     * @return RevokeAccountPrivilegeResponse
     */
    public function revokeAccountPrivilege($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeAccountPrivilegeWithOptions($request, $runtime);
    }

    /**
     * Revokes permissions from the service account of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96102.html)
     * *   [Grant permissions to the service account of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/146887.html)
     * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95693.html)
     *
     * @param request - RevokeOperatorPermissionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RevokeOperatorPermissionResponse
     *
     * @param RevokeOperatorPermissionRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return RevokeOperatorPermissionResponse
     */
    public function revokeOperatorPermissionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RevokeOperatorPermission',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RevokeOperatorPermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes permissions from the service account of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96102.html)
     * *   [Grant permissions to the service account of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/146887.html)
     * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95693.html)
     *
     * @param request - RevokeOperatorPermissionRequest
     *
     * @returns RevokeOperatorPermissionResponse
     *
     * @param RevokeOperatorPermissionRequest $request
     *
     * @return RevokeOperatorPermissionResponse
     */
    public function revokeOperatorPermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeOperatorPermissionWithOptions($request, $runtime);
    }

    /**
     * 删除RC安全组规则.
     *
     * @param tmpReq - RevokeRCSecurityGroupPermissionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RevokeRCSecurityGroupPermissionResponse
     *
     * @param RevokeRCSecurityGroupPermissionRequest $tmpReq
     * @param RuntimeOptions                         $runtime
     *
     * @return RevokeRCSecurityGroupPermissionResponse
     */
    public function revokeRCSecurityGroupPermissionWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new RevokeRCSecurityGroupPermissionShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->securityGroupRuleIdList) {
            $request->securityGroupRuleIdListShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->securityGroupRuleIdList, 'SecurityGroupRuleIdList', 'json');
        }

        $query = [];
        if (null !== $request->direction) {
            @$query['Direction'] = $request->direction;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        if (null !== $request->securityGroupRuleIdListShrink) {
            @$query['SecurityGroupRuleIdList'] = $request->securityGroupRuleIdListShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RevokeRCSecurityGroupPermission',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RevokeRCSecurityGroupPermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 删除RC安全组规则.
     *
     * @param request - RevokeRCSecurityGroupPermissionRequest
     *
     * @returns RevokeRCSecurityGroupPermissionResponse
     *
     * @param RevokeRCSecurityGroupPermissionRequest $request
     *
     * @return RevokeRCSecurityGroupPermissionResponse
     */
    public function revokeRCSecurityGroupPermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeRCSecurityGroupPermissionWithOptions($request, $runtime);
    }

    /**
     * Creates one or more subscription RDS Custom instances. Before you call this operation, you must specify parameters such as ImageId, InstanceType, VSwitchId, and SecurityGroupId.
     *
     * @remarks
     *   Before you create RDS Custom instances, you must submit a ticket to add your Alibaba Cloud account to a whitelist.
     * *   You can create only subscription RDS Custom instances.
     * *   Subscription RDS Custom instances are supported in the China (Shanghai), China (Shenzhen), China (Beijing), and China (Hangzhou) regions.
     *
     * @param tmpReq - RunRCInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RunRCInstancesResponse
     *
     * @param RunRCInstancesRequest $tmpReq
     * @param RuntimeOptions        $runtime
     *
     * @return RunRCInstancesResponse
     */
    public function runRCInstancesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new RunRCInstancesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->createAckEdgeParam) {
            $request->createAckEdgeParamShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->createAckEdgeParam, 'CreateAckEdgeParam', 'json');
        }

        if (null !== $tmpReq->dataDisk) {
            $request->dataDiskShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->dataDisk, 'DataDisk', 'json');
        }

        if (null !== $tmpReq->systemDisk) {
            $request->systemDiskShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->systemDisk, 'SystemDisk', 'json');
        }

        $query = [];
        if (null !== $request->amount) {
            @$query['Amount'] = $request->amount;
        }

        if (null !== $request->autoPay) {
            @$query['AutoPay'] = $request->autoPay;
        }

        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->createAckEdgeParamShrink) {
            @$query['CreateAckEdgeParam'] = $request->createAckEdgeParamShrink;
        }

        if (null !== $request->createExtraParam) {
            @$query['CreateExtraParam'] = $request->createExtraParam;
        }

        if (null !== $request->createMode) {
            @$query['CreateMode'] = $request->createMode;
        }

        if (null !== $request->dataDiskShrink) {
            @$query['DataDisk'] = $request->dataDiskShrink;
        }

        if (null !== $request->deploymentSetId) {
            @$query['DeploymentSetId'] = $request->deploymentSetId;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->dryRun) {
            @$query['DryRun'] = $request->dryRun;
        }

        if (null !== $request->hostName) {
            @$query['HostName'] = $request->hostName;
        }

        if (null !== $request->imageId) {
            @$query['ImageId'] = $request->imageId;
        }

        if (null !== $request->instanceChargeType) {
            @$query['InstanceChargeType'] = $request->instanceChargeType;
        }

        if (null !== $request->instanceName) {
            @$query['InstanceName'] = $request->instanceName;
        }

        if (null !== $request->instanceType) {
            @$query['InstanceType'] = $request->instanceType;
        }

        if (null !== $request->internetChargeType) {
            @$query['InternetChargeType'] = $request->internetChargeType;
        }

        if (null !== $request->internetMaxBandwidthOut) {
            @$query['InternetMaxBandwidthOut'] = $request->internetMaxBandwidthOut;
        }

        if (null !== $request->ioOptimized) {
            @$query['IoOptimized'] = $request->ioOptimized;
        }

        if (null !== $request->keyPairName) {
            @$query['KeyPairName'] = $request->keyPairName;
        }

        if (null !== $request->password) {
            @$query['Password'] = $request->password;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->periodUnit) {
            @$query['PeriodUnit'] = $request->periodUnit;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->securityEnhancementStrategy) {
            @$query['SecurityEnhancementStrategy'] = $request->securityEnhancementStrategy;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        if (null !== $request->spotStrategy) {
            @$query['SpotStrategy'] = $request->spotStrategy;
        }

        if (null !== $request->supportCase) {
            @$query['SupportCase'] = $request->supportCase;
        }

        if (null !== $request->systemDiskShrink) {
            @$query['SystemDisk'] = $request->systemDiskShrink;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        if (null !== $request->userData) {
            @$query['UserData'] = $request->userData;
        }

        if (null !== $request->userDataInBase64) {
            @$query['UserDataInBase64'] = $request->userDataInBase64;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RunRCInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RunRCInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates one or more subscription RDS Custom instances. Before you call this operation, you must specify parameters such as ImageId, InstanceType, VSwitchId, and SecurityGroupId.
     *
     * @remarks
     *   Before you create RDS Custom instances, you must submit a ticket to add your Alibaba Cloud account to a whitelist.
     * *   You can create only subscription RDS Custom instances.
     * *   Subscription RDS Custom instances are supported in the China (Shanghai), China (Shenzhen), China (Beijing), and China (Hangzhou) regions.
     *
     * @param request - RunRCInstancesRequest
     *
     * @returns RunRCInstancesResponse
     *
     * @param RunRCInstancesRequest $request
     *
     * @return RunRCInstancesResponse
     */
    public function runRCInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runRCInstancesWithOptions($request, $runtime);
    }

    /**
     * Resumes an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Start an ApsaraDB RDS for SQL instance](https://help.aliyun.com/document_detail/462504.html)
     *
     * @param request - StartDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartDBInstanceResponse
     *
     * @param StartDBInstanceRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return StartDBInstanceResponse
     */
    public function startDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceTransType) {
            @$query['DBInstanceTransType'] = $request->DBInstanceTransType;
        }

        if (null !== $request->dedicatedHostGroupId) {
            @$query['DedicatedHostGroupId'] = $request->dedicatedHostGroupId;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->specifiedTime) {
            @$query['SpecifiedTime'] = $request->specifiedTime;
        }

        if (null !== $request->storage) {
            @$query['Storage'] = $request->storage;
        }

        if (null !== $request->targetDBInstanceClass) {
            @$query['TargetDBInstanceClass'] = $request->targetDBInstanceClass;
        }

        if (null !== $request->targetDedicatedHostIdForLog) {
            @$query['TargetDedicatedHostIdForLog'] = $request->targetDedicatedHostIdForLog;
        }

        if (null !== $request->targetDedicatedHostIdForMaster) {
            @$query['TargetDedicatedHostIdForMaster'] = $request->targetDedicatedHostIdForMaster;
        }

        if (null !== $request->targetDedicatedHostIdForSlave) {
            @$query['TargetDedicatedHostIdForSlave'] = $request->targetDedicatedHostIdForSlave;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Resumes an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### [](#)References
     * >  Before you call this operation, read the following topics and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Start an ApsaraDB RDS for SQL instance](https://help.aliyun.com/document_detail/462504.html)
     *
     * @param request - StartDBInstanceRequest
     *
     * @returns StartDBInstanceResponse
     *
     * @param StartDBInstanceRequest $request
     *
     * @return StartDBInstanceResponse
     */
    public function startDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Starts RDS Custom instances that are in the Stopped state. After the operation is successfully called, the instances enter the Starting state.
     *
     * @param request - StartRCInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartRCInstanceResponse
     *
     * @param StartRCInstanceRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return StartRCInstanceResponse
     */
    public function startRCInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartRCInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartRCInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts RDS Custom instances that are in the Stopped state. After the operation is successfully called, the instances enter the Starting state.
     *
     * @param request - StartRCInstanceRequest
     *
     * @returns StartRCInstanceResponse
     *
     * @param StartRCInstanceRequest $request
     *
     * @return StartRCInstanceResponse
     */
    public function startRCInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startRCInstanceWithOptions($request, $runtime);
    }

    /**
     * Starts multiple RDS Custom instances at a time.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     *
     * @param tmpReq - StartRCInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartRCInstancesResponse
     *
     * @param StartRCInstancesRequest $tmpReq
     * @param RuntimeOptions          $runtime
     *
     * @return StartRCInstancesResponse
     */
    public function startRCInstancesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new StartRCInstancesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->instanceIds) {
            $request->instanceIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->instanceIds, 'InstanceIds', 'json');
        }

        $query = [];
        if (null !== $request->batchOptimization) {
            @$query['BatchOptimization'] = $request->batchOptimization;
        }

        if (null !== $request->instanceIdsShrink) {
            @$query['InstanceIds'] = $request->instanceIdsShrink;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartRCInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartRCInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts multiple RDS Custom instances at a time.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     *
     * @param request - StartRCInstancesRequest
     *
     * @returns StartRCInstancesResponse
     *
     * @param StartRCInstancesRequest $request
     *
     * @return StartRCInstancesResponse
     */
    public function startRCInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startRCInstancesWithOptions($request, $runtime);
    }

    /**
     * Suspends an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     *   [Suspend an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/462504.html)
     *
     * @param request - StopDBInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopDBInstanceResponse
     *
     * @param StopDBInstanceRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return StopDBInstanceResponse
     */
    public function stopDBInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopDBInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopDBInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Suspends an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     *   [Suspend an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/462504.html)
     *
     * @param request - StopDBInstanceRequest
     *
     * @returns StopDBInstanceResponse
     *
     * @param StopDBInstanceRequest $request
     *
     * @return StopDBInstanceResponse
     */
    public function stopDBInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopDBInstanceWithOptions($request, $runtime);
    }

    /**
     * Stops an RDS Custom instance that is in the Running state. After the operation is successfully called, the status of the RDS Custom instance changes from Stopping to Stopped.
     *
     * @param request - StopRCInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopRCInstanceResponse
     *
     * @param StopRCInstanceRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return StopRCInstanceResponse
     */
    public function stopRCInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->forceStop) {
            @$query['ForceStop'] = $request->forceStop;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopRCInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopRCInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops an RDS Custom instance that is in the Running state. After the operation is successfully called, the status of the RDS Custom instance changes from Stopping to Stopped.
     *
     * @param request - StopRCInstanceRequest
     *
     * @returns StopRCInstanceResponse
     *
     * @param StopRCInstanceRequest $request
     *
     * @return StopRCInstanceResponse
     */
    public function stopRCInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopRCInstanceWithOptions($request, $runtime);
    }

    /**
     * Stops multiple RDS Custom instances at a time.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     *
     * @param tmpReq - StopRCInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopRCInstancesResponse
     *
     * @param StopRCInstancesRequest $tmpReq
     * @param RuntimeOptions         $runtime
     *
     * @return StopRCInstancesResponse
     */
    public function stopRCInstancesWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new StopRCInstancesShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->instanceIds) {
            $request->instanceIdsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->instanceIds, 'InstanceIds', 'json');
        }

        $query = [];
        if (null !== $request->batchOptimization) {
            @$query['BatchOptimization'] = $request->batchOptimization;
        }

        if (null !== $request->forceStop) {
            @$query['ForceStop'] = $request->forceStop;
        }

        if (null !== $request->instanceIdsShrink) {
            @$query['InstanceIds'] = $request->instanceIdsShrink;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopRCInstances',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopRCInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops multiple RDS Custom instances at a time.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     *
     * @param request - StopRCInstancesRequest
     *
     * @returns StopRCInstancesResponse
     *
     * @param StopRCInstancesRequest $request
     *
     * @return StopRCInstancesResponse
     */
    public function stopRCInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopRCInstancesWithOptions($request, $runtime);
    }

    /**
     * Switches workloads between primary and secondary ApsaraDB RDS instances.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Switch workloads between primary and secondary ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/96054.html)
     * *   [Switch workloads between primary and secondary ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/96747.html)
     * *   [Switch workloads between primary and secondary ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/95659.html)
     * *   [Switch workloads between primary and secondary ApsaraDB RDS for MariaDB instances](https://help.aliyun.com/document_detail/97127.html)
     *
     * @param request - SwitchDBInstanceHARequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SwitchDBInstanceHAResponse
     *
     * @param SwitchDBInstanceHARequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return SwitchDBInstanceHAResponse
     */
    public function switchDBInstanceHAWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->force) {
            @$query['Force'] = $request->force;
        }

        if (null !== $request->nodeId) {
            @$query['NodeId'] = $request->nodeId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SwitchDBInstanceHA',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SwitchDBInstanceHAResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Switches workloads between primary and secondary ApsaraDB RDS instances.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Switch workloads between primary and secondary ApsaraDB RDS for MySQL instances](https://help.aliyun.com/document_detail/96054.html)
     * *   [Switch workloads between primary and secondary ApsaraDB RDS for PostgreSQL instances](https://help.aliyun.com/document_detail/96747.html)
     * *   [Switch workloads between primary and secondary ApsaraDB RDS for SQL Server instances](https://help.aliyun.com/document_detail/95659.html)
     * *   [Switch workloads between primary and secondary ApsaraDB RDS for MariaDB instances](https://help.aliyun.com/document_detail/97127.html)
     *
     * @param request - SwitchDBInstanceHARequest
     *
     * @returns SwitchDBInstanceHAResponse
     *
     * @param SwitchDBInstanceHARequest $request
     *
     * @return SwitchDBInstanceHAResponse
     */
    public function switchDBInstanceHA($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->switchDBInstanceHAWithOptions($request, $runtime);
    }

    /**
     * Switches between internal and public endpoints of an instance in the classic network.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### Prerequisites
     * *   The instance is connected by using its internal or public endpoint.
     * *   The instance is in the Running state.
     * *   The number of times that you have switched the instance between its internal and public endpoints within the last 24 hours does not reach 20.
     * *   The instance resides in the classic network.
     * ### Usage notes
     * After the endpoint that is used to connect to the instance is changed, you must update the endpoint information in the code of your application and restart the application.
     *
     * @param request - SwitchDBInstanceNetTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SwitchDBInstanceNetTypeResponse
     *
     * @param SwitchDBInstanceNetTypeRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return SwitchDBInstanceNetTypeResponse
     */
    public function switchDBInstanceNetTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->connectionStringPrefix) {
            @$query['ConnectionStringPrefix'] = $request->connectionStringPrefix;
        }

        if (null !== $request->connectionStringType) {
            @$query['ConnectionStringType'] = $request->connectionStringType;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->port) {
            @$query['Port'] = $request->port;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SwitchDBInstanceNetType',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SwitchDBInstanceNetTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Switches between internal and public endpoints of an instance in the classic network.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   SQL Server
     * ### Prerequisites
     * *   The instance is connected by using its internal or public endpoint.
     * *   The instance is in the Running state.
     * *   The number of times that you have switched the instance between its internal and public endpoints within the last 24 hours does not reach 20.
     * *   The instance resides in the classic network.
     * ### Usage notes
     * After the endpoint that is used to connect to the instance is changed, you must update the endpoint information in the code of your application and restart the application.
     *
     * @param request - SwitchDBInstanceNetTypeRequest
     *
     * @returns SwitchDBInstanceNetTypeResponse
     *
     * @param SwitchDBInstanceNetTypeRequest $request
     *
     * @return SwitchDBInstanceNetTypeResponse
     */
    public function switchDBInstanceNetType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->switchDBInstanceNetTypeWithOptions($request, $runtime);
    }

    /**
     * Changes the virtual private cloud (VPC) and vSwitch for an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Change the VPC and vSwitch for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/137567.html)
     * *   [Change the vSwitch for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/146885.html)
     * *   [Change the VPC and vSwitch for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/347675.html)
     *
     * @param request - SwitchDBInstanceVpcRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SwitchDBInstanceVpcResponse
     *
     * @param SwitchDBInstanceVpcRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return SwitchDBInstanceVpcResponse
     */
    public function switchDBInstanceVpcWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SwitchDBInstanceVpc',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SwitchDBInstanceVpcResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the virtual private cloud (VPC) and vSwitch for an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Change the VPC and vSwitch for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/137567.html)
     * *   [Change the vSwitch for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/146885.html)
     * *   [Change the VPC and vSwitch for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/347675.html)
     *
     * @param request - SwitchDBInstanceVpcRequest
     *
     * @returns SwitchDBInstanceVpcResponse
     *
     * @param SwitchDBInstanceVpcRequest $request
     *
     * @return SwitchDBInstanceVpcResponse
     */
    public function switchDBInstanceVpc($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->switchDBInstanceVpcWithOptions($request, $runtime);
    }

    /**
     * 流量切换.
     *
     * @param request - SwitchOverMajorVersionUpgradeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SwitchOverMajorVersionUpgradeResponse
     *
     * @param SwitchOverMajorVersionUpgradeRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return SwitchOverMajorVersionUpgradeResponse
     */
    public function switchOverMajorVersionUpgradeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceName) {
            @$query['DBInstanceName'] = $request->DBInstanceName;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->switchoverTimeout) {
            @$query['SwitchoverTimeout'] = $request->switchoverTimeout;
        }

        if (null !== $request->type) {
            @$query['Type'] = $request->type;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SwitchOverMajorVersionUpgrade',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SwitchOverMajorVersionUpgradeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * 流量切换.
     *
     * @param request - SwitchOverMajorVersionUpgradeRequest
     *
     * @returns SwitchOverMajorVersionUpgradeResponse
     *
     * @param SwitchOverMajorVersionUpgradeRequest $request
     *
     * @return SwitchOverMajorVersionUpgradeResponse
     */
    public function switchOverMajorVersionUpgrade($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->switchOverMajorVersionUpgradeWithOptions($request, $runtime);
    }

    /**
     * Switches the data synchronization link to synchronize data from a disaster recovery (DR) instance to the primary ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     *
     * @param request - SwitchReplicationLinkRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SwitchReplicationLinkResponse
     *
     * @param SwitchReplicationLinkRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return SwitchReplicationLinkResponse
     */
    public function switchReplicationLinkWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->targetInstanceName) {
            @$query['TargetInstanceName'] = $request->targetInstanceName;
        }

        if (null !== $request->targetInstanceRegionId) {
            @$query['TargetInstanceRegionId'] = $request->targetInstanceRegionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SwitchReplicationLink',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SwitchReplicationLinkResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Switches the data synchronization link to synchronize data from a disaster recovery (DR) instance to the primary ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     *
     * @param request - SwitchReplicationLinkRequest
     *
     * @returns SwitchReplicationLinkResponse
     *
     * @param SwitchReplicationLinkRequest $request
     *
     * @return SwitchReplicationLinkResponse
     */
    public function switchReplicationLink($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->switchReplicationLinkWithOptions($request, $runtime);
    }

    /**
     * Synchronizes a custom key pair to an RDS Custom instance. If you change the key pair that you created for your RDS Custom instance and you want the change to immediately take effect on the RDS Custom instance, you can call this operation to synchronize the new key pair to the RDS Custom instance. For example, you delete a key pair that has the same name as another key pair and recreate the key pair.
     *
     * @param request - SyncRCKeyPairRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SyncRCKeyPairResponse
     *
     * @param SyncRCKeyPairRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return SyncRCKeyPairResponse
     */
    public function syncRCKeyPairWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->keyPairName) {
            @$query['KeyPairName'] = $request->keyPairName;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->syncMode) {
            @$query['SyncMode'] = $request->syncMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SyncRCKeyPair',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SyncRCKeyPairResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Synchronizes a custom key pair to an RDS Custom instance. If you change the key pair that you created for your RDS Custom instance and you want the change to immediately take effect on the RDS Custom instance, you can call this operation to synchronize the new key pair to the RDS Custom instance. For example, you delete a key pair that has the same name as another key pair and recreate the key pair.
     *
     * @param request - SyncRCKeyPairRequest
     *
     * @returns SyncRCKeyPairResponse
     *
     * @param SyncRCKeyPairRequest $request
     *
     * @return SyncRCKeyPairResponse
     */
    public function syncRCKeyPair($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->syncRCKeyPairWithOptions($request, $runtime);
    }

    /**
     * Adds security group rules to an RDS Custom for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Introduction to ApsaraDB RDS Custom](https://help.aliyun.com/document_detail/2864363.html)
     *
     * @param request - SyncRCSecurityGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SyncRCSecurityGroupResponse
     *
     * @param SyncRCSecurityGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return SyncRCSecurityGroupResponse
     */
    public function syncRCSecurityGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->securityGroupId) {
            @$query['SecurityGroupId'] = $request->securityGroupId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SyncRCSecurityGroup',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SyncRCSecurityGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds security group rules to an RDS Custom for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Introduction to ApsaraDB RDS Custom](https://help.aliyun.com/document_detail/2864363.html)
     *
     * @param request - SyncRCSecurityGroupRequest
     *
     * @returns SyncRCSecurityGroupResponse
     *
     * @param SyncRCSecurityGroupRequest $request
     *
     * @return SyncRCSecurityGroupResponse
     */
    public function syncRCSecurityGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->syncRCSecurityGroupWithOptions($request, $runtime);
    }

    /**
     * Creates and adds tags to one or more instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Create tags for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96149.html)
     * *   [Create tags for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96777.html)
     * *   [Create tags for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95726.html)
     * *   [Create tags for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97152.html)
     *
     * @param request - TagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TagResourcesResponse
     *
     * @param TagResourcesRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return TagResourcesResponse
     */
    public function tagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tag) {
            @$query['Tag'] = $request->tag;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TagResources',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates and adds tags to one or more instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Create tags for an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96149.html)
     * *   [Create tags for an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/96777.html)
     * *   [Create tags for an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/95726.html)
     * *   [Create tags for an ApsaraDB RDS for MariaDB instance](https://help.aliyun.com/document_detail/97152.html)
     *
     * @param request - TagResourcesRequest
     *
     * @returns TagResourcesResponse
     *
     * @param TagResourcesRequest $request
     *
     * @return TagResourcesResponse
     */
    public function tagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->tagResourcesWithOptions($request, $runtime);
    }

    /**
     * Terminates an ongoing migration task of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     *
     * @param request - TerminateMigrateTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TerminateMigrateTaskResponse
     *
     * @param TerminateMigrateTaskRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return TerminateMigrateTaskResponse
     */
    public function terminateMigrateTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->migrateTaskId) {
            @$query['MigrateTaskId'] = $request->migrateTaskId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TerminateMigrateTask',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TerminateMigrateTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Terminates an ongoing migration task of an ApsaraDB RDS for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   SQL Server
     *
     * @param request - TerminateMigrateTaskRequest
     *
     * @returns TerminateMigrateTaskResponse
     *
     * @param TerminateMigrateTaskRequest $request
     *
     * @return TerminateMigrateTaskResponse
     */
    public function terminateMigrateTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->terminateMigrateTaskWithOptions($request, $runtime);
    }

    /**
     * Changes the billing method of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Fees are generated if the call is successful. Before you call this operation, you must read the following documentation.
     * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/96048.html) or [Change the billing method of an ApsaraDB RDS for MySQL instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/161875.html)
     * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/96743.html) or [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/162756.html)
     * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/95631.html) or [Change the billing method of an ApsaraDB RDS for SQL Server instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/162755.html)
     * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/97120.html) or [Change the billing method of an ApsaraDB RDS for MariaDB instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/169252.html)
     *
     * @param request - TransformDBInstancePayTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TransformDBInstancePayTypeResponse
     *
     * @param TransformDBInstancePayTypeRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return TransformDBInstancePayTypeResponse
     */
    public function transformDBInstancePayTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->autoRenew) {
            @$query['AutoRenew'] = $request->autoRenew;
        }

        if (null !== $request->autoUseCoupon) {
            @$query['AutoUseCoupon'] = $request->autoUseCoupon;
        }

        if (null !== $request->businessInfo) {
            @$query['BusinessInfo'] = $request->businessInfo;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->promotionCode) {
            @$query['PromotionCode'] = $request->promotionCode;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TransformDBInstancePayType',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TransformDBInstancePayTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the billing method of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### References
     * > Fees are generated if the call is successful. Before you call this operation, you must read the following documentation.
     * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/96048.html) or [Change the billing method of an ApsaraDB RDS for MySQL instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/161875.html)
     * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/96743.html) or [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/162756.html)
     * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/95631.html) or [Change the billing method of an ApsaraDB RDS for SQL Server instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/162755.html)
     * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/97120.html) or [Change the billing method of an ApsaraDB RDS for MariaDB instance from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/169252.html)
     *
     * @param request - TransformDBInstancePayTypeRequest
     *
     * @returns TransformDBInstancePayTypeResponse
     *
     * @param TransformDBInstancePayTypeRequest $request
     *
     * @return TransformDBInstancePayTypeResponse
     */
    public function transformDBInstancePayType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->transformDBInstancePayTypeWithOptions($request, $runtime);
    }

    /**
     * Unbinds a elastic IP address (EIP) from an RDS Custom for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Introduction to ApsaraDB RDS Custom](https://help.aliyun.com/document_detail/2864363.html)
     *
     * @param request - UnassociateEipAddressWithRCInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnassociateEipAddressWithRCInstanceResponse
     *
     * @param UnassociateEipAddressWithRCInstanceRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return UnassociateEipAddressWithRCInstanceResponse
     */
    public function unassociateEipAddressWithRCInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->allocationId) {
            @$query['AllocationId'] = $request->allocationId;
        }

        if (null !== $request->instanceId) {
            @$query['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnassociateEipAddressWithRCInstance',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnassociateEipAddressWithRCInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unbinds a elastic IP address (EIP) from an RDS Custom for SQL Server instance.
     *
     * @remarks
     * ### [](#)Supported database engine
     * SQL Server
     * ### [](#)References
     * [Introduction to ApsaraDB RDS Custom](https://help.aliyun.com/document_detail/2864363.html)
     *
     * @param request - UnassociateEipAddressWithRCInstanceRequest
     *
     * @returns UnassociateEipAddressWithRCInstanceResponse
     *
     * @param UnassociateEipAddressWithRCInstanceRequest $request
     *
     * @return UnassociateEipAddressWithRCInstanceResponse
     */
    public function unassociateEipAddressWithRCInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unassociateEipAddressWithRCInstanceWithOptions($request, $runtime);
    }

    /**
     * Unlocks a database account of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### Supported database engine
     * PostgreSQL
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/147649.html)
     *
     * @param request - UnlockAccountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UnlockAccountResponse
     *
     * @param UnlockAccountRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return UnlockAccountResponse
     */
    public function unlockAccountWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->accountName) {
            @$query['AccountName'] = $request->accountName;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UnlockAccount',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UnlockAccountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unlocks a database account of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### Supported database engine
     * PostgreSQL
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/147649.html)
     *
     * @param request - UnlockAccountRequest
     *
     * @returns UnlockAccountResponse
     *
     * @param UnlockAccountRequest $request
     *
     * @return UnlockAccountResponse
     */
    public function unlockAccount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->unlockAccountWithOptions($request, $runtime);
    }

    /**
     * Removes tags from one or more instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Usage notes
     * *   You can remove up to 20 tags at a time.
     * *   If a tag is removed from an instance and is not added to other instances, the tag is automatically deleted.
     *
     * @param request - UntagResourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UntagResourcesResponse
     *
     * @param UntagResourcesRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return UntagResourcesResponse
     */
    public function untagResourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->all) {
            @$query['All'] = $request->all;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        if (null !== $request->tagKey) {
            @$query['TagKey'] = $request->tagKey;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UntagResources',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UntagResourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes tags from one or more instances.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * *   MariaDB
     * ### [](#)Usage notes
     * *   You can remove up to 20 tags at a time.
     * *   If a tag is removed from an instance and is not added to other instances, the tag is automatically deleted.
     *
     * @param request - UntagResourcesRequest
     *
     * @returns UntagResourcesResponse
     *
     * @param UntagResourcesRequest $request
     *
     * @return UntagResourcesResponse
     */
    public function untagResources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->untagResourcesWithOptions($request, $runtime);
    }

    /**
     * Updates the version of an extension on a database.
     *
     * @remarks
     * ### Supported database engines
     * RDS PostgreSQL
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Manage extensions](https://help.aliyun.com/document_detail/2402409.html)
     *
     * @param request - UpdatePostgresExtensionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdatePostgresExtensionsResponse
     *
     * @param UpdatePostgresExtensionsRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdatePostgresExtensionsResponse
     */
    public function updatePostgresExtensionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBNames) {
            @$query['DBNames'] = $request->DBNames;
        }

        if (null !== $request->extensions) {
            @$query['Extensions'] = $request->extensions;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdatePostgresExtensions',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdatePostgresExtensionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the version of an extension on a database.
     *
     * @remarks
     * ### Supported database engines
     * RDS PostgreSQL
     * ### References
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Manage extensions](https://help.aliyun.com/document_detail/2402409.html)
     *
     * @param request - UpdatePostgresExtensionsRequest
     *
     * @returns UpdatePostgresExtensionsResponse
     *
     * @param UpdatePostgresExtensionsRequest $request
     *
     * @return UpdatePostgresExtensionsResponse
     */
    public function updatePostgresExtensions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updatePostgresExtensionsWithOptions($request, $runtime);
    }

    /**
     * Modifies the description and retention period of a full backup file.
     *
     * @remarks
     * ### Supported database engines
     * RDS MySQL
     * ### References
     * A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 or MySQL 8.0 instance to an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/251779.html).
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     *
     * @param request - UpdateUserBackupFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateUserBackupFileResponse
     *
     * @param UpdateUserBackupFileRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateUserBackupFileResponse
     */
    public function updateUserBackupFileWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->backupId) {
            @$query['BackupId'] = $request->backupId;
        }

        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->regionId) {
            @$query['RegionId'] = $request->regionId;
        }

        if (null !== $request->resourceGroupId) {
            @$query['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->retention) {
            @$query['Retention'] = $request->retention;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateUserBackupFile',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateUserBackupFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the description and retention period of a full backup file.
     *
     * @remarks
     * ### Supported database engines
     * RDS MySQL
     * ### References
     * A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 or MySQL 8.0 instance to an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/251779.html).
     * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     *
     * @param request - UpdateUserBackupFileRequest
     *
     * @returns UpdateUserBackupFileResponse
     *
     * @param UpdateUserBackupFileRequest $request
     *
     * @return UpdateUserBackupFileResponse
     */
    public function updateUserBackupFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateUserBackupFileWithOptions($request, $runtime);
    }

    /**
     * Upgrades the major engine version of an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### Supported database engine
     * MySQL
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Upgrade the major engine version of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96058.html)
     *
     * @param request - UpgradeDBInstanceEngineVersionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpgradeDBInstanceEngineVersionResponse
     *
     * @param UpgradeDBInstanceEngineVersionRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return UpgradeDBInstanceEngineVersionResponse
     */
    public function upgradeDBInstanceEngineVersionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->effectiveTime) {
            @$query['EffectiveTime'] = $request->effectiveTime;
        }

        if (null !== $request->engineVersion) {
            @$query['EngineVersion'] = $request->engineVersion;
        }

        if (null !== $request->ownerAccount) {
            @$query['OwnerAccount'] = $request->ownerAccount;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpgradeDBInstanceEngineVersion',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpgradeDBInstanceEngineVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Upgrades the major engine version of an ApsaraDB RDS for MySQL instance.
     *
     * @remarks
     * ### Supported database engine
     * MySQL
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * [Upgrade the major engine version of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96058.html)
     *
     * @param request - UpgradeDBInstanceEngineVersionRequest
     *
     * @returns UpgradeDBInstanceEngineVersionResponse
     *
     * @param UpgradeDBInstanceEngineVersionRequest $request
     *
     * @return UpgradeDBInstanceEngineVersionResponse
     */
    public function upgradeDBInstanceEngineVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeDBInstanceEngineVersionWithOptions($request, $runtime);
    }

    /**
     * Updates the minor engine version of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Update the minor engine version of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96059.html)
     * *   [Update the minor engine version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/146895.html)
     * *   [Update the minor engine version of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/213582.html)
     *
     * @param request - UpgradeDBInstanceKernelVersionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpgradeDBInstanceKernelVersionResponse
     *
     * @param UpgradeDBInstanceKernelVersionRequest $request
     * @param RuntimeOptions                        $runtime
     *
     * @return UpgradeDBInstanceKernelVersionResponse
     */
    public function upgradeDBInstanceKernelVersionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        if (null !== $request->targetMinorVersion) {
            @$query['TargetMinorVersion'] = $request->targetMinorVersion;
        }

        if (null !== $request->upgradeTime) {
            @$query['UpgradeTime'] = $request->upgradeTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpgradeDBInstanceKernelVersion',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpgradeDBInstanceKernelVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the minor engine version of an ApsaraDB RDS instance.
     *
     * @remarks
     * ### Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * *   SQL Server
     * ### References
     * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
     * *   [Update the minor engine version of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/96059.html)
     * *   [Update the minor engine version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/146895.html)
     * *   [Update the minor engine version of an ApsaraDB RDS for SQL Server instance](https://help.aliyun.com/document_detail/213582.html)
     *
     * @param request - UpgradeDBInstanceKernelVersionRequest
     *
     * @returns UpgradeDBInstanceKernelVersionResponse
     *
     * @param UpgradeDBInstanceKernelVersionRequest $request
     *
     * @return UpgradeDBInstanceKernelVersionResponse
     */
    public function upgradeDBInstanceKernelVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeDBInstanceKernelVersionWithOptions($request, $runtime);
    }

    /**
     * Initiates a task to upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### Supported database engine
     * PostgreSQL
     * ### References
     * Fees are generated if the call is successful. Before you call this operation, read the following documentation and make sure that you fully understand the billing rules, prerequisites, and impacts of this operation.
     * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/203309.html)
     *
     * @param request - UpgradeDBInstanceMajorVersionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpgradeDBInstanceMajorVersionResponse
     *
     * @param UpgradeDBInstanceMajorVersionRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return UpgradeDBInstanceMajorVersionResponse
     */
    public function upgradeDBInstanceMajorVersionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->collectStatMode) {
            @$query['CollectStatMode'] = $request->collectStatMode;
        }

        if (null !== $request->DBInstanceClass) {
            @$query['DBInstanceClass'] = $request->DBInstanceClass;
        }

        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBInstanceStorage) {
            @$query['DBInstanceStorage'] = $request->DBInstanceStorage;
        }

        if (null !== $request->DBInstanceStorageType) {
            @$query['DBInstanceStorageType'] = $request->DBInstanceStorageType;
        }

        if (null !== $request->instanceNetworkType) {
            @$query['InstanceNetworkType'] = $request->instanceNetworkType;
        }

        if (null !== $request->payType) {
            @$query['PayType'] = $request->payType;
        }

        if (null !== $request->period) {
            @$query['Period'] = $request->period;
        }

        if (null !== $request->privateIpAddress) {
            @$query['PrivateIpAddress'] = $request->privateIpAddress;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->switchOver) {
            @$query['SwitchOver'] = $request->switchOver;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        if (null !== $request->switchTimeMode) {
            @$query['SwitchTimeMode'] = $request->switchTimeMode;
        }

        if (null !== $request->targetMajorVersion) {
            @$query['TargetMajorVersion'] = $request->targetMajorVersion;
        }

        if (null !== $request->upgradeMode) {
            @$query['UpgradeMode'] = $request->upgradeMode;
        }

        if (null !== $request->usedTime) {
            @$query['UsedTime'] = $request->usedTime;
        }

        if (null !== $request->VPCId) {
            @$query['VPCId'] = $request->VPCId;
        }

        if (null !== $request->vSwitchId) {
            @$query['VSwitchId'] = $request->vSwitchId;
        }

        if (null !== $request->zoneId) {
            @$query['ZoneId'] = $request->zoneId;
        }

        if (null !== $request->zoneIdSlave1) {
            @$query['ZoneIdSlave1'] = $request->zoneIdSlave1;
        }

        if (null !== $request->zoneIdSlave2) {
            @$query['ZoneIdSlave2'] = $request->zoneIdSlave2;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpgradeDBInstanceMajorVersion',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpgradeDBInstanceMajorVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Initiates a task to upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### Supported database engine
     * PostgreSQL
     * ### References
     * Fees are generated if the call is successful. Before you call this operation, read the following documentation and make sure that you fully understand the billing rules, prerequisites, and impacts of this operation.
     * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/203309.html)
     *
     * @param request - UpgradeDBInstanceMajorVersionRequest
     *
     * @returns UpgradeDBInstanceMajorVersionResponse
     *
     * @param UpgradeDBInstanceMajorVersionRequest $request
     *
     * @return UpgradeDBInstanceMajorVersionResponse
     */
    public function upgradeDBInstanceMajorVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeDBInstanceMajorVersionWithOptions($request, $runtime);
    }

    /**
     * Performs a precheck before the upgrade of the major engine version of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### Supported database engine
     * PostgreSQL
     * ### References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/203309.html)
     *
     * @param request - UpgradeDBInstanceMajorVersionPrecheckRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpgradeDBInstanceMajorVersionPrecheckResponse
     *
     * @param UpgradeDBInstanceMajorVersionPrecheckRequest $request
     * @param RuntimeOptions                               $runtime
     *
     * @return UpgradeDBInstanceMajorVersionPrecheckResponse
     */
    public function upgradeDBInstanceMajorVersionPrecheckWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->targetMajorVersion) {
            @$query['TargetMajorVersion'] = $request->targetMajorVersion;
        }

        if (null !== $request->upgradeMode) {
            @$query['UpgradeMode'] = $request->upgradeMode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpgradeDBInstanceMajorVersionPrecheck',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpgradeDBInstanceMajorVersionPrecheckResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Performs a precheck before the upgrade of the major engine version of an ApsaraDB RDS for PostgreSQL instance.
     *
     * @remarks
     * ### Supported database engine
     * PostgreSQL
     * ### References
     * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/203309.html)
     *
     * @param request - UpgradeDBInstanceMajorVersionPrecheckRequest
     *
     * @returns UpgradeDBInstanceMajorVersionPrecheckResponse
     *
     * @param UpgradeDBInstanceMajorVersionPrecheckRequest $request
     *
     * @return UpgradeDBInstanceMajorVersionPrecheckResponse
     */
    public function upgradeDBInstanceMajorVersionPrecheck($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeDBInstanceMajorVersionPrecheckWithOptions($request, $runtime);
    }

    /**
     * Upgrades the database proxy version of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Upgrade the database proxy version of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/197465.html)
     * *   [Upgrade the database proxy version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418469.html)
     *
     * @param request - UpgradeDBProxyInstanceKernelVersionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpgradeDBProxyInstanceKernelVersionResponse
     *
     * @param UpgradeDBProxyInstanceKernelVersionRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return UpgradeDBProxyInstanceKernelVersionResponse
     */
    public function upgradeDBProxyInstanceKernelVersionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->DBInstanceId) {
            @$query['DBInstanceId'] = $request->DBInstanceId;
        }

        if (null !== $request->DBProxyEngineType) {
            @$query['DBProxyEngineType'] = $request->DBProxyEngineType;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->resourceOwnerAccount) {
            @$query['ResourceOwnerAccount'] = $request->resourceOwnerAccount;
        }

        if (null !== $request->resourceOwnerId) {
            @$query['ResourceOwnerId'] = $request->resourceOwnerId;
        }

        if (null !== $request->switchTime) {
            @$query['SwitchTime'] = $request->switchTime;
        }

        if (null !== $request->upgradeTime) {
            @$query['UpgradeTime'] = $request->upgradeTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpgradeDBProxyInstanceKernelVersion',
            'version' => '2014-08-15',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpgradeDBProxyInstanceKernelVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Upgrades the database proxy version of an instance.
     *
     * @remarks
     * ### [](#)Supported database engines
     * *   MySQL
     * *   PostgreSQL
     * ### [](#)References
     * >  Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
     * *   [Upgrade the database proxy version of an ApsaraDB RDS for MySQL instance](https://help.aliyun.com/document_detail/197465.html)
     * *   [Upgrade the database proxy version of an ApsaraDB RDS for PostgreSQL instance](https://help.aliyun.com/document_detail/418469.html)
     *
     * @param request - UpgradeDBProxyInstanceKernelVersionRequest
     *
     * @returns UpgradeDBProxyInstanceKernelVersionResponse
     *
     * @param UpgradeDBProxyInstanceKernelVersionRequest $request
     *
     * @return UpgradeDBProxyInstanceKernelVersionResponse
     */
    public function upgradeDBProxyInstanceKernelVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->upgradeDBProxyInstanceKernelVersionWithOptions($request, $runtime);
    }
}
