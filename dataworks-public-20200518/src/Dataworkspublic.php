<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Dataworkspublic\V20200518;

use AlibabaCloud\Endpoint\Endpoint;
use AlibabaCloud\OpenApiUtil\OpenApiUtilClient;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AbolishDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AbolishDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddMetaCollectionEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddMetaCollectionEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddProjectMemberToRoleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddProjectMemberToRoleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddRecognizeRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddRecognizeRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddToMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddToMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ApprovePermissionApplyOrderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ApprovePermissionApplyOrderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CallbackExtensionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CallbackExtensionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ChangeResourceManagerResourceGroupRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ChangeResourceManagerResourceGroupResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckFileDeploymentRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckFileDeploymentResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaPartitionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaPartitionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagComplementRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagComplementResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiAuthorityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiAuthorityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceGroupRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceGroupResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataSourceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataSourceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIAlarmRuleShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIJobShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateExportMigrationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateExportMigrationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateImportMigrationAdvanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateImportMigrationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateImportMigrationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateManualDagRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateManualDagResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCollectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCollectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreatePermissionApplyOrderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreatePermissionApplyOrderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectMemberRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectMemberResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRelativeNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRelativeNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateResourceFileAdvanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateResourceFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateResourceFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateUdfFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateUdfFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiAuthorityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiAuthorityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataSourceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataSourceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFromMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFromMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteLineageRelationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteLineageRelationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteProjectMemberRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteProjectMemberResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRelativeNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRelativeNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRecognizeRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRecognizeRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DesensitizeDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DesensitizeDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanAddOrUpdateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanAddOrUpdateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanAddOrUpdateShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanDeleteRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanDeleteResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanDeleteShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanQueryListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanQueryListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanUpdateStatusRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanUpdateStatusResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanUpdateStatusShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgPlatformQueryProjectsAndSchemaFromMetaRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgPlatformQueryProjectsAndSchemaFromMetaResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQueryDefaultTemplatesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQueryDefaultTemplatesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQuerySensResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQuerySensResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgRunSensIdentifyRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgRunSensIdentifyResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgRunSensIdentifyShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneAddOrUpdateSceneRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneAddOrUpdateSceneResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneAddOrUpdateSceneShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgScenedDeleteSceneRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgScenedDeleteSceneResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgScenedDeleteSceneShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneQuerySceneListByNameRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneQuerySceneListByNameResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgStopSensIdentifyRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgStopSensIdentifyResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupAddOrUpdateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupAddOrUpdateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupAddOrUpdateShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupDeleteRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupDeleteResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupDeleteShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupGetOdpsRoleGroupsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupGetOdpsRoleGroupsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupQueryListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupQueryListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupQueryUserListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListAddOrUpdateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListAddOrUpdateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListAddOrUpdateShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListDeleteListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListDeleteListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListDeleteListShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListQueryListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListQueryListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EditRecognizeRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EditRecognizeRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EstablishRelationTableToBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EstablishRelationTableToBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ExportDataSourcesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ExportDataSourcesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForCreatingRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForCreatingResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForUpdatingRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForUpdatingResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetAlertMessageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetAlertMessageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineConfigRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineConfigResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineKeyPathRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineKeyPathResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineStatusRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineStatusResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDagRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDagResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApplicationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApplicationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceGroupRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceGroupResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServicePublishedApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServicePublishedApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataSourceMetaRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataSourceMetaResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDDLJobStatusRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDDLJobStatusResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDeploymentRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDeploymentResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncInstanceInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncInstanceInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetExtensionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetExtensionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileTypeStatisticRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileTypeStatisticResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileVersionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileVersionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetIDEEventDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetIDEEventDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceConsumeTimeRankRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceConsumeTimeRankResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceCountTrendRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceCountTrendResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceErrorRankRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceErrorRankResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceLogRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceLogResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusCountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusCountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusStatisticRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusStatisticResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetManualDagInstancesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetManualDagInstancesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCollectionDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCollectionDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaColumnLineageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaColumnLineageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBTableListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBTableListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableBasicInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableBasicInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableChangeLogRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableChangeLogResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableColumnRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableColumnResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableFullInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableFullInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableIntroWikiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableIntroWikiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableLineageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableLineageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableListByCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableListByCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTablePartitionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTablePartitionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTablePartitionShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableProducingTasksRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableProducingTasksResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableThemeLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableThemeLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationProcessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationProcessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationSummaryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationSummaryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeChildrenRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeChildrenResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeCodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeCodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeOnBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeOnBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeParentsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeParentsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeTypeListInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeTypeListInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpRiskDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpRiskDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpSensitiveDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpSensitiveDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOptionValueForProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOptionValueForProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetPermissionApplyOrderDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetPermissionApplyOrderDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSensitiveDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSensitiveDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSuccessInstanceTrendRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSuccessInstanceTrendResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicInfluenceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicInfluenceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ImportDataSourcesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ImportDataSourcesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListAlertMessagesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListAlertMessagesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineConfigsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineConfigsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselinesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselinesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineStatusesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineStatusesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListCalcEnginesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListCalcEnginesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListClusterConfigsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListClusterConfigsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListClustersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListClustersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListConnectionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListConnectionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiAuthoritiesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiAuthoritiesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApisRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApisResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApplicationsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApplicationsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceAuthorizedApisRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceAuthorizedApisResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceFoldersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceFoldersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceGroupsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceGroupsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServicePublishedApisRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServicePublishedApisResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataSourcesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataSourcesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDeploymentsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDeploymentsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIAlarmRulesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIAlarmRulesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIJobsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIJobsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIProjectConfigRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIProjectConfigResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEnabledExtensionsForProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEnabledExtensionsForProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntitiesByTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntitiesByTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntitiesByTagsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntityTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntityTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListExtensionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListExtensionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFilesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFilesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileTypeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileTypeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileVersionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileVersionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFoldersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFoldersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInnerNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInnerNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceAmountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceAmountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceHistoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceHistoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstancesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstancesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListLineageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListLineageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListManualDagInstancesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListManualDagInstancesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMeasureDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMeasureDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionEntitiesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionEntitiesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaDBRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaDBResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMigrationsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMigrationsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeInputOrOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeInputOrOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeIORequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeIOResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListPermissionApplyOrdersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListPermissionApplyOrdersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProgramTypeCountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProgramTypeCountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectIdsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectIdsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectMembersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectMembersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectRolesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectRolesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityRulesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityRulesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRefDISyncTasksRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRefDISyncTasksResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRemindsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRemindsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListResourceGroupsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListResourceGroupsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListResourceGroupsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftPersonnelsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftPersonnelsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftSchedulesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftSchedulesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListSuccessInstanceAmountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListSuccessInstanceAmountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTablesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTablesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTopicsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTopicsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\MountDirectoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\MountDirectoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\OfflineNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\OfflineNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\PublishDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\PublishDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDefaultTemplateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDefaultTemplateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDISyncTaskConfigProcessResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDISyncTaskConfigProcessResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryPublicModelEngineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryPublicModelEngineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeDataByRuleTypeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeDataByRuleTypeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeRuleDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeRuleDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeRulesTypeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensClassificationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensClassificationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensNodeInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensNodeInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RegisterLineageRelationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RegisterLineageRelationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RegisterLineageRelationShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveEntityTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveEntityTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveEntityTagsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveProjectMemberFromRoleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveProjectMemberFromRoleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RestartInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RestartInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ResumeInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ResumeInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeColumnPermissionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeColumnPermissionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeTablePermissionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeTablePermissionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunCycleDagNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunCycleDagNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunManualDagNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunManualDagNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunSmokeTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunSmokeTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunTriggerNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunTriggerNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SaveDataServiceApiTestResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SaveDataServiceApiTestResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ScanSensitiveDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ScanSensitiveDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchMetaTablesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchMetaTablesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchNodesByOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchNodesByOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetDataSourceShareRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetDataSourceShareResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetEntityTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetEntityTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetEntityTagsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetSuccessInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetSuccessInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDIJobShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDISyncInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDISyncInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartMigrationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartMigrationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDISyncInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDISyncInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SuspendInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SuspendInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TerminateDISyncInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TerminateDISyncInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestNetworkConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestNetworkConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenElapsedTimeInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenElapsedTimeInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenErrorTimesInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenErrorTimesInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UmountDirectoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UmountDirectoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBaselineShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateClusterConfigsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateClusterConfigsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateClusterConfigsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataSourceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataSourceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIAlarmRuleShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIJobShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIProjectConfigRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIProjectConfigResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateIDEEventResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateIDEEventResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCollectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCollectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableIntroWikiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableIntroWikiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeOwnerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeOwnerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeRunModeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeRunModeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableAddColumnRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableAddColumnResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableModelInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableModelInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateUdfFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateUdfFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateWorkbenchEventResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateWorkbenchEventResultResponse;
use AlibabaCloud\SDK\OpenPlatform\V20191219\Models\AuthorizeFileUploadRequest;
use AlibabaCloud\SDK\OpenPlatform\V20191219\Models\AuthorizeFileUploadResponse;
use AlibabaCloud\SDK\OpenPlatform\V20191219\OpenPlatform;
use AlibabaCloud\SDK\OSS\OSS;
use AlibabaCloud\SDK\OSS\OSS\PostObjectRequest;
use AlibabaCloud\SDK\OSS\OSS\PostObjectRequest\header;
use AlibabaCloud\Tea\FileForm\FileForm\FileField;
use AlibabaCloud\Tea\Utils\Utils;
use AlibabaCloud\Tea\Utils\Utils\RuntimeOptions;
use Darabonba\OpenApi\Models\Config;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;

class Dataworkspublic extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap  = [
            'ap-northeast-1'        => 'dataworks.ap-northeast-1.aliyuncs.com',
            'ap-south-1'            => 'dataworks.ap-south-1.aliyuncs.com',
            'ap-southeast-1'        => 'dataworks.ap-southeast-1.aliyuncs.com',
            'ap-southeast-2'        => 'dataworks.ap-southeast-2.aliyuncs.com',
            'ap-southeast-3'        => 'dataworks.ap-southeast-3.aliyuncs.com',
            'ap-southeast-5'        => 'dataworks.ap-southeast-5.aliyuncs.com',
            'cn-beijing'            => 'dataworks.cn-beijing.aliyuncs.com',
            'cn-chengdu'            => 'dataworks.cn-chengdu.aliyuncs.com',
            'cn-hangzhou'           => 'dataworks.cn-hangzhou.aliyuncs.com',
            'cn-hongkong'           => 'dataworks.cn-hongkong.aliyuncs.com',
            'cn-huhehaote'          => 'dataworks.aliyuncs.com',
            'cn-qingdao'            => 'dataworks.aliyuncs.com',
            'cn-shanghai'           => 'dataworks.cn-shanghai.aliyuncs.com',
            'cn-shenzhen'           => 'dataworks.cn-shenzhen.aliyuncs.com',
            'cn-zhangjiakou'        => 'dataworks.aliyuncs.com',
            'eu-central-1'          => 'dataworks.eu-central-1.aliyuncs.com',
            'eu-west-1'             => 'dataworks.eu-west-1.aliyuncs.com',
            'me-east-1'             => 'dataworks.me-east-1.aliyuncs.com',
            'us-east-1'             => 'dataworks.us-east-1.aliyuncs.com',
            'us-west-1'             => 'dataworks.us-west-1.aliyuncs.com',
            'cn-hangzhou-finance'   => 'dataworks.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'dataworks.aliyuncs.com',
            'cn-shanghai-finance-1' => 'dataworks.aliyuncs.com',
            'cn-north-2-gov-1'      => 'dataworks.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('dataworks-public', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (!Utils::empty_($endpoint)) {
            return $endpoint;
        }
        if (!Utils::isUnset($endpointMap) && !Utils::empty_(@$endpointMap[$regionId])) {
            return @$endpointMap[$regionId];
        }

        return Endpoint::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * @summary Unpublishes a DataService Studio API.
     *  *
     * @param AbolishDataServiceApiRequest $request AbolishDataServiceApiRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return AbolishDataServiceApiResponse AbolishDataServiceApiResponse
     */
    public function abolishDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'AbolishDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AbolishDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Unpublishes a DataService Studio API.
     *  *
     * @param AbolishDataServiceApiRequest $request AbolishDataServiceApiRequest
     *
     * @return AbolishDataServiceApiResponse AbolishDataServiceApiResponse
     */
    public function abolishDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->abolishDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Adds an entity to a collection.
     *  *
     * @param AddMetaCollectionEntityRequest $request AddMetaCollectionEntityRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddMetaCollectionEntityResponse AddMetaCollectionEntityResponse
     */
    public function addMetaCollectionEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->collectionQualifiedName)) {
            $query['CollectionQualifiedName'] = $request->collectionQualifiedName;
        }
        if (!Utils::isUnset($request->entityQualifiedName)) {
            $query['EntityQualifiedName'] = $request->entityQualifiedName;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddMetaCollectionEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddMetaCollectionEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds an entity to a collection.
     *  *
     * @param AddMetaCollectionEntityRequest $request AddMetaCollectionEntityRequest
     *
     * @return AddMetaCollectionEntityResponse AddMetaCollectionEntityResponse
     */
    public function addMetaCollectionEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addMetaCollectionEntityWithOptions($request, $runtime);
    }

    /**
     * @summary Assigns a role to a member of a DataWorks workspace. Before you call this operation, you must add your account to a DataWorks workspace as a member.
     *  *
     * @description For information about how to add an account to a DataWorks workspace as a member, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
     *  *
     * @param AddProjectMemberToRoleRequest $request AddProjectMemberToRoleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddProjectMemberToRoleResponse AddProjectMemberToRoleResponse
     */
    public function addProjectMemberToRoleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->roleCode)) {
            $query['RoleCode'] = $request->roleCode;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddProjectMemberToRole',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddProjectMemberToRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Assigns a role to a member of a DataWorks workspace. Before you call this operation, you must add your account to a DataWorks workspace as a member.
     *  *
     * @description For information about how to add an account to a DataWorks workspace as a member, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
     *  *
     * @param AddProjectMemberToRoleRequest $request AddProjectMemberToRoleRequest
     *
     * @return AddProjectMemberToRoleResponse AddProjectMemberToRoleResponse
     */
    public function addProjectMemberToRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addProjectMemberToRoleWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
     *  *
     * @param AddRecognizeRuleRequest $request AddRecognizeRuleRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return AddRecognizeRuleResponse AddRecognizeRuleResponse
     */
    public function addRecognizeRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->accountName)) {
            $body['AccountName'] = $request->accountName;
        }
        if (!Utils::isUnset($request->colExclude)) {
            $body['ColExclude'] = $request->colExclude;
        }
        if (!Utils::isUnset($request->colScan)) {
            $body['ColScan'] = $request->colScan;
        }
        if (!Utils::isUnset($request->commentScan)) {
            $body['CommentScan'] = $request->commentScan;
        }
        if (!Utils::isUnset($request->contentScan)) {
            $body['ContentScan'] = $request->contentScan;
        }
        if (!Utils::isUnset($request->hitThreshold)) {
            $body['HitThreshold'] = $request->hitThreshold;
        }
        if (!Utils::isUnset($request->level)) {
            $body['Level'] = $request->level;
        }
        if (!Utils::isUnset($request->levelName)) {
            $body['LevelName'] = $request->levelName;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeParent)) {
            $body['NodeParent'] = $request->nodeParent;
        }
        if (!Utils::isUnset($request->operationType)) {
            $body['OperationType'] = $request->operationType;
        }
        if (!Utils::isUnset($request->recognizeRules)) {
            $body['RecognizeRules'] = $request->recognizeRules;
        }
        if (!Utils::isUnset($request->recognizeRulesType)) {
            $body['RecognizeRulesType'] = $request->recognizeRulesType;
        }
        if (!Utils::isUnset($request->sensitiveDescription)) {
            $body['SensitiveDescription'] = $request->sensitiveDescription;
        }
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'AddRecognizeRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddRecognizeRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
     *  *
     * @param AddRecognizeRuleRequest $request AddRecognizeRuleRequest
     *
     * @return AddRecognizeRuleResponse AddRecognizeRuleResponse
     */
    public function addRecognizeRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addRecognizeRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a metatable to a specified category.
     *  *
     * @param AddToMetaCategoryRequest $request AddToMetaCategoryRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return AddToMetaCategoryResponse AddToMetaCategoryResponse
     */
    public function addToMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddToMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddToMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a metatable to a specified category.
     *  *
     * @param AddToMetaCategoryRequest $request AddToMetaCategoryRequest
     *
     * @return AddToMetaCategoryResponse AddToMetaCategoryResponse
     */
    public function addToMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addToMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Processes a permission request order.
     *  *
     * @param ApprovePermissionApplyOrderRequest $request ApprovePermissionApplyOrderRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ApprovePermissionApplyOrderResponse ApprovePermissionApplyOrderResponse
     */
    public function approvePermissionApplyOrderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->approveAction)) {
            $query['ApproveAction'] = $request->approveAction;
        }
        if (!Utils::isUnset($request->approveComment)) {
            $query['ApproveComment'] = $request->approveComment;
        }
        if (!Utils::isUnset($request->flowId)) {
            $query['FlowId'] = $request->flowId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ApprovePermissionApplyOrder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ApprovePermissionApplyOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Processes a permission request order.
     *  *
     * @param ApprovePermissionApplyOrderRequest $request ApprovePermissionApplyOrderRequest
     *
     * @return ApprovePermissionApplyOrderResponse ApprovePermissionApplyOrderResponse
     */
    public function approvePermissionApplyOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->approvePermissionApplyOrderWithOptions($request, $runtime);
    }

    /**
     * @summary Sends the processing result of an extension point event by an extension to DataWorks.
     *  *
     * @param CallbackExtensionRequest $request CallbackExtensionRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CallbackExtensionResponse CallbackExtensionResponse
     */
    public function callbackExtensionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->checkMessage)) {
            $body['CheckMessage'] = $request->checkMessage;
        }
        if (!Utils::isUnset($request->checkResult)) {
            $body['CheckResult'] = $request->checkResult;
        }
        if (!Utils::isUnset($request->extensionCode)) {
            $body['ExtensionCode'] = $request->extensionCode;
        }
        if (!Utils::isUnset($request->messageId)) {
            $body['MessageId'] = $request->messageId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CallbackExtension',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CallbackExtensionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sends the processing result of an extension point event by an extension to DataWorks.
     *  *
     * @param CallbackExtensionRequest $request CallbackExtensionRequest
     *
     * @return CallbackExtensionResponse CallbackExtensionResponse
     */
    public function callbackExtension($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->callbackExtensionWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the resource group to which a resource belongs.
     *  *
     * @param ChangeResourceManagerResourceGroupRequest $request ChangeResourceManagerResourceGroupRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeResourceManagerResourceGroupResponse ChangeResourceManagerResourceGroupResponse
     */
    public function changeResourceManagerResourceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceManagerResourceGroupId)) {
            $query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeResourceManagerResourceGroup',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeResourceManagerResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the resource group to which a resource belongs.
     *  *
     * @param ChangeResourceManagerResourceGroupRequest $request ChangeResourceManagerResourceGroupRequest
     *
     * @return ChangeResourceManagerResourceGroupResponse ChangeResourceManagerResourceGroupResponse
     */
    public function changeResourceManagerResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeResourceManagerResourceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Returns the check events of a file. After you commit your file that is created on the DataStudio page, the system checks the file and returns check events before the system deploys the file. You must determine whether the check can be continued based on the events. You can call this operation to return the check events for the file that you want to deploy to DataWorks.
     *  *
     * @param CheckFileDeploymentRequest $request CheckFileDeploymentRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckFileDeploymentResponse CheckFileDeploymentResponse
     */
    public function checkFileDeploymentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->checkDetailUrl)) {
            $body['CheckDetailUrl'] = $request->checkDetailUrl;
        }
        if (!Utils::isUnset($request->checkerInstanceId)) {
            $body['CheckerInstanceId'] = $request->checkerInstanceId;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CheckFileDeployment',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckFileDeploymentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Returns the check events of a file. After you commit your file that is created on the DataStudio page, the system checks the file and returns check events before the system deploys the file. You must determine whether the check can be continued based on the events. You can call this operation to return the check events for the file that you want to deploy to DataWorks.
     *  *
     * @param CheckFileDeploymentRequest $request CheckFileDeploymentRequest
     *
     * @return CheckFileDeploymentResponse CheckFileDeploymentResponse
     */
    public function checkFileDeployment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkFileDeploymentWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether a partition in a MaxCompute metatable exists.
     *  *
     * @param CheckMetaPartitionRequest $request CheckMetaPartitionRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckMetaPartitionResponse CheckMetaPartitionResponse
     */
    public function checkMetaPartitionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->partition)) {
            $query['Partition'] = $request->partition;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckMetaPartition',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckMetaPartitionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether a partition in a MaxCompute metatable exists.
     *  *
     * @param CheckMetaPartitionRequest $request CheckMetaPartitionRequest
     *
     * @return CheckMetaPartitionResponse CheckMetaPartitionResponse
     */
    public function checkMetaPartition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkMetaPartitionWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether a metatable exists.
     *  *
     * @param CheckMetaTableRequest $request CheckMetaTableRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckMetaTableResponse CheckMetaTableResponse
     */
    public function checkMetaTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckMetaTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckMetaTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether a metatable exists.
     *  *
     * @param CheckMetaTableRequest $request CheckMetaTableRequest
     *
     * @return CheckMetaTableResponse CheckMetaTableResponse
     */
    public function checkMetaTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkMetaTableWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a baseline.
     *  *
     * @param CreateBaselineRequest $request CreateBaselineRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateBaselineResponse CreateBaselineResponse
     */
    public function createBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertMarginThreshold)) {
            $body['AlertMarginThreshold'] = $request->alertMarginThreshold;
        }
        if (!Utils::isUnset($request->baselineName)) {
            $body['BaselineName'] = $request->baselineName;
        }
        if (!Utils::isUnset($request->baselineType)) {
            $body['BaselineType'] = $request->baselineType;
        }
        if (!Utils::isUnset($request->nodeIds)) {
            $body['NodeIds'] = $request->nodeIds;
        }
        if (!Utils::isUnset($request->overtimeSettings)) {
            $body['OvertimeSettings'] = $request->overtimeSettings;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a baseline.
     *  *
     * @param CreateBaselineRequest $request CreateBaselineRequest
     *
     * @return CreateBaselineResponse CreateBaselineResponse
     */
    public function createBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBaselineWithOptions($request, $runtime);
    }

    /**
     * @param CreateBusinessRequest $request CreateBusinessRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateBusinessResponse CreateBusinessResponse
     */
    public function createBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessName)) {
            $body['BusinessName'] = $request->businessName;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->useType)) {
            $body['UseType'] = $request->useType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateBusinessRequest $request CreateBusinessRequest
     *
     * @return CreateBusinessResponse CreateBusinessResponse
     */
    public function createBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBusinessWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateConnection is deprecated
     *  *
     * @summary Adds a data source.
     *  *
     * Deprecated
     *
     * @param CreateConnectionRequest $request CreateConnectionRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateConnectionResponse CreateConnectionResponse
     */
    public function createConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->connectionType)) {
            $query['ConnectionType'] = $request->connectionType;
        }
        if (!Utils::isUnset($request->content)) {
            $query['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->subType)) {
            $query['SubType'] = $request->subType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateConnection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateConnection is deprecated
     *  *
     * @summary Adds a data source.
     *  *
     * Deprecated
     *
     * @param CreateConnectionRequest $request CreateConnectionRequest
     *
     * @return CreateConnectionResponse CreateConnectionResponse
     */
    public function createConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *  *
     * @param CreateDIAlarmRuleRequest $tmpReq  CreateDIAlarmRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDIAlarmRuleResponse CreateDIAlarmRuleResponse
     */
    public function createDIAlarmRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateDIAlarmRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->notificationSettings)) {
            $request->notificationSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->notificationSettings, 'NotificationSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->triggerConditions)) {
            $request->triggerConditionsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->triggerConditions, 'TriggerConditions', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->enabled)) {
            $body['Enabled'] = $request->enabled;
        }
        if (!Utils::isUnset($request->metricType)) {
            $body['MetricType'] = $request->metricType;
        }
        if (!Utils::isUnset($request->notificationSettingsShrink)) {
            $body['NotificationSettings'] = $request->notificationSettingsShrink;
        }
        if (!Utils::isUnset($request->triggerConditionsShrink)) {
            $body['TriggerConditions'] = $request->triggerConditionsShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDIAlarmRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *  *
     * @param CreateDIAlarmRuleRequest $request CreateDIAlarmRuleRequest
     *
     * @return CreateDIAlarmRuleResponse CreateDIAlarmRuleResponse
     */
    public function createDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a synchronization task of a new version in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres and batch synchronization of all data in a MySQL database to Hive.
     *  *
     * @param CreateDIJobRequest $tmpReq  CreateDIJobRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDIJobResponse CreateDIJobResponse
     */
    public function createDIJobWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateDIJobShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->destinationDataSourceSettings)) {
            $request->destinationDataSourceSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->destinationDataSourceSettings, 'DestinationDataSourceSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->jobSettings)) {
            $request->jobSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->jobSettings, 'JobSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->resourceSettings)) {
            $request->resourceSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->resourceSettings, 'ResourceSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->sourceDataSourceSettings)) {
            $request->sourceDataSourceSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->sourceDataSourceSettings, 'SourceDataSourceSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->tableMappings)) {
            $request->tableMappingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tableMappings, 'TableMappings', 'json');
        }
        if (!Utils::isUnset($tmpReq->transformationRules)) {
            $request->transformationRulesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->transformationRules, 'TransformationRules', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->systemDebug)) {
            $query['SystemDebug'] = $request->systemDebug;
        }
        $body = [];
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->destinationDataSourceSettingsShrink)) {
            $body['DestinationDataSourceSettings'] = $request->destinationDataSourceSettingsShrink;
        }
        if (!Utils::isUnset($request->destinationDataSourceType)) {
            $body['DestinationDataSourceType'] = $request->destinationDataSourceType;
        }
        if (!Utils::isUnset($request->jobName)) {
            $body['JobName'] = $request->jobName;
        }
        if (!Utils::isUnset($request->jobSettingsShrink)) {
            $body['JobSettings'] = $request->jobSettingsShrink;
        }
        if (!Utils::isUnset($request->migrationType)) {
            $body['MigrationType'] = $request->migrationType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->resourceSettingsShrink)) {
            $body['ResourceSettings'] = $request->resourceSettingsShrink;
        }
        if (!Utils::isUnset($request->sourceDataSourceSettingsShrink)) {
            $body['SourceDataSourceSettings'] = $request->sourceDataSourceSettingsShrink;
        }
        if (!Utils::isUnset($request->sourceDataSourceType)) {
            $body['SourceDataSourceType'] = $request->sourceDataSourceType;
        }
        if (!Utils::isUnset($request->tableMappingsShrink)) {
            $body['TableMappings'] = $request->tableMappingsShrink;
        }
        if (!Utils::isUnset($request->transformationRulesShrink)) {
            $body['TransformationRules'] = $request->transformationRulesShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a synchronization task of a new version in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres and batch synchronization of all data in a MySQL database to Hive.
     *  *
     * @param CreateDIJobRequest $request CreateDIJobRequest
     *
     * @return CreateDIJobResponse CreateDIJobResponse
     */
    public function createDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a data synchronization task.
     *  *
     * @param CreateDISyncTaskRequest $request CreateDISyncTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDISyncTaskResponse CreateDISyncTaskResponse
     */
    public function createDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskContent)) {
            $query['TaskContent'] = $request->taskContent;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskParam)) {
            $query['TaskParam'] = $request->taskParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a data synchronization task.
     *  *
     * @param CreateDISyncTaskRequest $request CreateDISyncTaskRequest
     *
     * @return CreateDISyncTaskResponse CreateDISyncTaskResponse
     */
    public function createDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateDagComplement is deprecated
     *  *
     * Deprecated
     *
     * @param CreateDagComplementRequest $request CreateDagComplementRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDagComplementResponse CreateDagComplementResponse
     */
    public function createDagComplementWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizBeginTime)) {
            $body['BizBeginTime'] = $request->bizBeginTime;
        }
        if (!Utils::isUnset($request->bizEndTime)) {
            $body['BizEndTime'] = $request->bizEndTime;
        }
        if (!Utils::isUnset($request->endBizDate)) {
            $body['EndBizDate'] = $request->endBizDate;
        }
        if (!Utils::isUnset($request->excludeNodeIds)) {
            $body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }
        if (!Utils::isUnset($request->includeNodeIds)) {
            $body['IncludeNodeIds'] = $request->includeNodeIds;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nodeParams)) {
            $body['NodeParams'] = $request->nodeParams;
        }
        if (!Utils::isUnset($request->parallelism)) {
            $body['Parallelism'] = $request->parallelism;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->rootNodeId)) {
            $body['RootNodeId'] = $request->rootNodeId;
        }
        if (!Utils::isUnset($request->startBizDate)) {
            $body['StartBizDate'] = $request->startBizDate;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDagComplement',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDagComplementResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateDagComplement is deprecated
     *  *
     * Deprecated
     *
     * @param CreateDagComplementRequest $request CreateDagComplementRequest
     *
     * @return CreateDagComplementResponse CreateDagComplementResponse
     */
    public function createDagComplement($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDagComplementWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateDagTest is deprecated
     *  *
     * Deprecated
     *
     * @param CreateDagTestRequest $request CreateDagTestRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDagTestResponse CreateDagTestResponse
     */
    public function createDagTestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeParams)) {
            $body['NodeParams'] = $request->nodeParams;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDagTest',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDagTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateDagTest is deprecated
     *  *
     * Deprecated
     *
     * @param CreateDagTestRequest $request CreateDagTestRequest
     *
     * @return CreateDagTestResponse CreateDagTestResponse
     */
    public function createDagTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDagTestWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an API.
     *  *
     * @param CreateDataServiceApiRequest $request CreateDataServiceApiRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataServiceApiResponse CreateDataServiceApiResponse
     */
    public function createDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiDescription)) {
            $body['ApiDescription'] = $request->apiDescription;
        }
        if (!Utils::isUnset($request->apiMode)) {
            $body['ApiMode'] = $request->apiMode;
        }
        if (!Utils::isUnset($request->apiName)) {
            $body['ApiName'] = $request->apiName;
        }
        if (!Utils::isUnset($request->apiPath)) {
            $body['ApiPath'] = $request->apiPath;
        }
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->protocols)) {
            $body['Protocols'] = $request->protocols;
        }
        if (!Utils::isUnset($request->registrationDetails)) {
            $body['RegistrationDetails'] = $request->registrationDetails;
        }
        if (!Utils::isUnset($request->requestContentType)) {
            $body['RequestContentType'] = $request->requestContentType;
        }
        if (!Utils::isUnset($request->requestMethod)) {
            $body['RequestMethod'] = $request->requestMethod;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $body['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->responseContentType)) {
            $body['ResponseContentType'] = $request->responseContentType;
        }
        if (!Utils::isUnset($request->scriptDetails)) {
            $body['ScriptDetails'] = $request->scriptDetails;
        }
        if (!Utils::isUnset($request->sqlMode)) {
            $body['SqlMode'] = $request->sqlMode;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        if (!Utils::isUnset($request->timeout)) {
            $body['Timeout'] = $request->timeout;
        }
        if (!Utils::isUnset($request->visibleRange)) {
            $body['VisibleRange'] = $request->visibleRange;
        }
        if (!Utils::isUnset($request->wizardDetails)) {
            $body['WizardDetails'] = $request->wizardDetails;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an API.
     *  *
     * @param CreateDataServiceApiRequest $request CreateDataServiceApiRequest
     *
     * @return CreateDataServiceApiResponse CreateDataServiceApiResponse
     */
    public function createDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Grants the access permissions on an API in DataService Studio.
     *  *
     * @param CreateDataServiceApiAuthorityRequest $request CreateDataServiceApiAuthorityRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataServiceApiAuthorityResponse CreateDataServiceApiAuthorityResponse
     */
    public function createDataServiceApiAuthorityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->authorizedProjectId)) {
            $body['AuthorizedProjectId'] = $request->authorizedProjectId;
        }
        if (!Utils::isUnset($request->endTime)) {
            $body['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDataServiceApiAuthority',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataServiceApiAuthorityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Grants the access permissions on an API in DataService Studio.
     *  *
     * @param CreateDataServiceApiAuthorityRequest $request CreateDataServiceApiAuthorityRequest
     *
     * @return CreateDataServiceApiAuthorityResponse CreateDataServiceApiAuthorityResponse
     */
    public function createDataServiceApiAuthority($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceApiAuthorityWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a folder in DataService Studio.
     *  *
     * @param CreateDataServiceFolderRequest $request CreateDataServiceFolderRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataServiceFolderResponse CreateDataServiceFolderResponse
     */
    public function createDataServiceFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderName)) {
            $body['FolderName'] = $request->folderName;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->parentId)) {
            $body['ParentId'] = $request->parentId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDataServiceFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataServiceFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a folder in DataService Studio.
     *  *
     * @param CreateDataServiceFolderRequest $request CreateDataServiceFolderRequest
     *
     * @return CreateDataServiceFolderResponse CreateDataServiceFolderResponse
     */
    public function createDataServiceFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a business process.
     *  *
     * @param CreateDataServiceGroupRequest $request CreateDataServiceGroupRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataServiceGroupResponse CreateDataServiceGroupResponse
     */
    public function createDataServiceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiGatewayGroupId)) {
            $body['ApiGatewayGroupId'] = $request->apiGatewayGroupId;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->groupName)) {
            $body['GroupName'] = $request->groupName;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDataServiceGroup',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataServiceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a business process.
     *  *
     * @param CreateDataServiceGroupRequest $request CreateDataServiceGroupRequest
     *
     * @return CreateDataServiceGroupResponse CreateDataServiceGroupResponse
     */
    public function createDataServiceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a data source to DataWorks.
     *  *
     * @param CreateDataSourceRequest $request CreateDataSourceRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataSourceResponse CreateDataSourceResponse
     */
    public function createDataSourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->content)) {
            $query['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->subType)) {
            $query['SubType'] = $request->subType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateDataSource',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a data source to DataWorks.
     *  *
     * @param CreateDataSourceRequest $request CreateDataSourceRequest
     *
     * @return CreateDataSourceResponse CreateDataSourceResponse
     */
    public function createDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataSourceWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an export task. You can use this operation to create an export task but cannot use this operation to start the created export task.
     *  *
     * @param CreateExportMigrationRequest $request CreateExportMigrationRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateExportMigrationResponse CreateExportMigrationResponse
     */
    public function createExportMigrationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->exportMode)) {
            $body['ExportMode'] = $request->exportMode;
        }
        if (!Utils::isUnset($request->exportObjectStatus)) {
            $body['ExportObjectStatus'] = $request->exportObjectStatus;
        }
        if (!Utils::isUnset($request->incrementalSince)) {
            $body['IncrementalSince'] = $request->incrementalSince;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateExportMigration',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateExportMigrationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an export task. You can use this operation to create an export task but cannot use this operation to start the created export task.
     *  *
     * @param CreateExportMigrationRequest $request CreateExportMigrationRequest
     *
     * @return CreateExportMigrationResponse CreateExportMigrationResponse
     */
    public function createExportMigration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExportMigrationWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a file in DataStudio. You cannot call this operation to create files for Data Integration nodes.
     *  *
     * @param CreateFileRequest $request CreateFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileResponse CreateFileResponse
     */
    public function createFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->advancedSettings)) {
            $body['AdvancedSettings'] = $request->advancedSettings;
        }
        if (!Utils::isUnset($request->applyScheduleImmediately)) {
            $body['ApplyScheduleImmediately'] = $request->applyScheduleImmediately;
        }
        if (!Utils::isUnset($request->autoParsing)) {
            $body['AutoParsing'] = $request->autoParsing;
        }
        if (!Utils::isUnset($request->autoRerunIntervalMillis)) {
            $body['AutoRerunIntervalMillis'] = $request->autoRerunIntervalMillis;
        }
        if (!Utils::isUnset($request->autoRerunTimes)) {
            $body['AutoRerunTimes'] = $request->autoRerunTimes;
        }
        if (!Utils::isUnset($request->connectionName)) {
            $body['ConnectionName'] = $request->connectionName;
        }
        if (!Utils::isUnset($request->content)) {
            $body['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->createFolderIfNotExists)) {
            $body['CreateFolderIfNotExists'] = $request->createFolderIfNotExists;
        }
        if (!Utils::isUnset($request->cronExpress)) {
            $body['CronExpress'] = $request->cronExpress;
        }
        if (!Utils::isUnset($request->cycleType)) {
            $body['CycleType'] = $request->cycleType;
        }
        if (!Utils::isUnset($request->dependentNodeIdList)) {
            $body['DependentNodeIdList'] = $request->dependentNodeIdList;
        }
        if (!Utils::isUnset($request->dependentType)) {
            $body['DependentType'] = $request->dependentType;
        }
        if (!Utils::isUnset($request->endEffectDate)) {
            $body['EndEffectDate'] = $request->endEffectDate;
        }
        if (!Utils::isUnset($request->fileDescription)) {
            $body['FileDescription'] = $request->fileDescription;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileName)) {
            $body['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->fileType)) {
            $body['FileType'] = $request->fileType;
        }
        if (!Utils::isUnset($request->ignoreParentSkipRunningProperty)) {
            $body['IgnoreParentSkipRunningProperty'] = $request->ignoreParentSkipRunningProperty;
        }
        if (!Utils::isUnset($request->inputList)) {
            $body['InputList'] = $request->inputList;
        }
        if (!Utils::isUnset($request->inputParameters)) {
            $body['InputParameters'] = $request->inputParameters;
        }
        if (!Utils::isUnset($request->outputParameters)) {
            $body['OutputParameters'] = $request->outputParameters;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->paraValue)) {
            $body['ParaValue'] = $request->paraValue;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->rerunMode)) {
            $body['RerunMode'] = $request->rerunMode;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $body['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceGroupIdentifier)) {
            $body['ResourceGroupIdentifier'] = $request->resourceGroupIdentifier;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        if (!Utils::isUnset($request->startEffectDate)) {
            $body['StartEffectDate'] = $request->startEffectDate;
        }
        if (!Utils::isUnset($request->startImmediately)) {
            $body['StartImmediately'] = $request->startImmediately;
        }
        if (!Utils::isUnset($request->stop)) {
            $body['Stop'] = $request->stop;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a file in DataStudio. You cannot call this operation to create files for Data Integration nodes.
     *  *
     * @param CreateFileRequest $request CreateFileRequest
     *
     * @return CreateFileResponse CreateFileResponse
     */
    public function createFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CreateFolder**.
     *  *
     * @param CreateFolderRequest $request CreateFolderRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFolderResponse CreateFolderResponse
     */
    public function createFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderPath)) {
            $body['FolderPath'] = $request->folderPath;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CreateFolder**.
     *  *
     * @param CreateFolderRequest $request CreateFolderRequest
     *
     * @return CreateFolderResponse CreateFolderResponse
     */
    public function createFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Creates an import task. The import task contains the import packages of data sources, nodes, and tables.
     *  *
     * @description The import package must be uploaded. Example of the upload method:
     *         Config config = new Config();
     *         config.setAccessKeyId(accessId);
     *         config.setAccessKeySecret(accessKey);
     *         config.setEndpoint(popEndpoint);
     *         config.setRegionId(regionId);
     *
     *         Client client = new Client(config);
     *         CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
     *         request.setName("test_migration_api_" + System.currentTimeMillis());
     *         request.setProjectId(123456L);
     *         request.setPackageType("DATAWORKS_MODEL");
     *         request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
     *         RuntimeOptions runtime = new RuntimeOptions();
     *         CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
     *         ...
     *  *
     * @param CreateImportMigrationRequest $request CreateImportMigrationRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateImportMigrationResponse CreateImportMigrationResponse
     */
    public function createImportMigrationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->calculateEngineMap)) {
            $body['CalculateEngineMap'] = $request->calculateEngineMap;
        }
        if (!Utils::isUnset($request->commitRule)) {
            $body['CommitRule'] = $request->commitRule;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->packageFile)) {
            $body['PackageFile'] = $request->packageFile;
        }
        if (!Utils::isUnset($request->packageType)) {
            $body['PackageType'] = $request->packageType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->resourceGroupMap)) {
            $body['ResourceGroupMap'] = $request->resourceGroupMap;
        }
        if (!Utils::isUnset($request->workspaceMap)) {
            $body['WorkspaceMap'] = $request->workspaceMap;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateImportMigration',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateImportMigrationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates an import task. The import task contains the import packages of data sources, nodes, and tables.
     *  *
     * @description The import package must be uploaded. Example of the upload method:
     *         Config config = new Config();
     *         config.setAccessKeyId(accessId);
     *         config.setAccessKeySecret(accessKey);
     *         config.setEndpoint(popEndpoint);
     *         config.setRegionId(regionId);
     *
     *         Client client = new Client(config);
     *         CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
     *         request.setName("test_migration_api_" + System.currentTimeMillis());
     *         request.setProjectId(123456L);
     *         request.setPackageType("DATAWORKS_MODEL");
     *         request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
     *         RuntimeOptions runtime = new RuntimeOptions();
     *         CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
     *         ...
     *  *
     * @param CreateImportMigrationRequest $request CreateImportMigrationRequest
     *
     * @return CreateImportMigrationResponse CreateImportMigrationResponse
     */
    public function createImportMigration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createImportMigrationWithOptions($request, $runtime);
    }

    /**
     * @param CreateImportMigrationAdvanceRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CreateImportMigrationResponse
     */
    public function createImportMigrationAdvance($request, $runtime)
    {
        // Step 0: init client
        $accessKeyId          = $this->_credential->getAccessKeyId();
        $accessKeySecret      = $this->_credential->getAccessKeySecret();
        $securityToken        = $this->_credential->getSecurityToken();
        $credentialType       = $this->_credential->getType();
        $openPlatformEndpoint = $this->_openPlatformEndpoint;
        if (Utils::empty_($openPlatformEndpoint)) {
            $openPlatformEndpoint = 'openplatform.aliyuncs.com';
        }
        if (Utils::isUnset($credentialType)) {
            $credentialType = 'access_key';
        }
        $authConfig = new Config([
            'accessKeyId'     => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'securityToken'   => $securityToken,
            'type'            => $credentialType,
            'endpoint'        => $openPlatformEndpoint,
            'protocol'        => $this->_protocol,
            'regionId'        => $this->_regionId,
        ]);
        $authClient  = new OpenPlatform($authConfig);
        $authRequest = new AuthorizeFileUploadRequest([
            'product'  => 'dataworks-public',
            'regionId' => $this->_regionId,
        ]);
        $authResponse = new AuthorizeFileUploadResponse([]);
        $ossConfig    = new \AlibabaCloud\SDK\OSS\OSS\Config([
            'accessKeyId'     => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'type'            => 'access_key',
            'protocol'        => $this->_protocol,
            'regionId'        => $this->_regionId,
        ]);
        $ossClient     = new OSS($ossConfig);
        $fileObj       = new FileField([]);
        $ossHeader     = new header([]);
        $uploadRequest = new PostObjectRequest([]);
        $ossRuntime    = new \AlibabaCloud\Tea\OSSUtils\OSSUtils\RuntimeOptions([]);
        OpenApiUtilClient::convert($runtime, $ossRuntime);
        $createImportMigrationReq = new CreateImportMigrationRequest([]);
        OpenApiUtilClient::convert($request, $createImportMigrationReq);
        if (!Utils::isUnset($request->packageFileObject)) {
            $authResponse           = $authClient->authorizeFileUploadWithOptions($authRequest, $runtime);
            $ossConfig->accessKeyId = $authResponse->body->accessKeyId;
            $ossConfig->endpoint    = OpenApiUtilClient::getEndpoint($authResponse->body->endpoint, $authResponse->body->useAccelerate, $this->_endpointType);
            $ossClient              = new OSS($ossConfig);
            $fileObj                = new FileField([
                'filename'    => $authResponse->body->objectKey,
                'content'     => $request->packageFileObject,
                'contentType' => '',
            ]);
            $ossHeader = new header([
                'accessKeyId'         => $authResponse->body->accessKeyId,
                'policy'              => $authResponse->body->encodedPolicy,
                'signature'           => $authResponse->body->signature,
                'key'                 => $authResponse->body->objectKey,
                'file'                => $fileObj,
                'successActionStatus' => '201',
            ]);
            $uploadRequest = new PostObjectRequest([
                'bucketName' => $authResponse->body->bucket,
                'header'     => $ossHeader,
            ]);
            $ossClient->postObject($uploadRequest, $ossRuntime);
            $createImportMigrationReq->packageFile = 'http://' . $authResponse->body->bucket . '.' . $authResponse->body->endpoint . '/' . $authResponse->body->objectKey . '';
        }

        return $this->createImportMigrationWithOptions($createImportMigrationReq, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateManualDag is deprecated
     *  *
     * @summary Triggers a manually triggered workflow to run. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find the manually triggered workflow on the Operation Center page only after the manually triggered workflow is committed and deployed.
     *  *
     * Deprecated
     *
     * @param CreateManualDagRequest $request CreateManualDagRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateManualDagResponse CreateManualDagResponse
     */
    public function createManualDagWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->dagParameters)) {
            $body['DagParameters'] = $request->dagParameters;
        }
        if (!Utils::isUnset($request->excludeNodeIds)) {
            $body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }
        if (!Utils::isUnset($request->flowName)) {
            $body['FlowName'] = $request->flowName;
        }
        if (!Utils::isUnset($request->includeNodeIds)) {
            $body['IncludeNodeIds'] = $request->includeNodeIds;
        }
        if (!Utils::isUnset($request->nodeParameters)) {
            $body['NodeParameters'] = $request->nodeParameters;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateManualDag',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateManualDagResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateManualDag is deprecated
     *  *
     * @summary Triggers a manually triggered workflow to run. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find the manually triggered workflow on the Operation Center page only after the manually triggered workflow is committed and deployed.
     *  *
     * Deprecated
     *
     * @param CreateManualDagRequest $request CreateManualDagRequest
     *
     * @return CreateManualDagResponse CreateManualDagResponse
     */
    public function createManualDag($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createManualDagWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a category.
     *  *
     * @param CreateMetaCategoryRequest $request CreateMetaCategoryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMetaCategoryResponse CreateMetaCategoryResponse
     */
    public function createMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->parentId)) {
            $body['ParentId'] = $request->parentId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a category.
     *  *
     * @param CreateMetaCategoryRequest $request CreateMetaCategoryRequest
     *
     * @return CreateMetaCategoryResponse CreateMetaCategoryResponse
     */
    public function createMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a collection.
     *  *
     * @description Collections are classified into various types. The names of collections of the same type must be different.
     *  *
     * @param CreateMetaCollectionRequest $request CreateMetaCollectionRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMetaCollectionResponse CreateMetaCollectionResponse
     */
    public function createMetaCollectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->collectionType)) {
            $query['CollectionType'] = $request->collectionType;
        }
        if (!Utils::isUnset($request->comment)) {
            $query['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->parentQualifiedName)) {
            $query['ParentQualifiedName'] = $request->parentQualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateMetaCollection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateMetaCollectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a collection.
     *  *
     * @description Collections are classified into various types. The names of collections of the same type must be different.
     *  *
     * @param CreateMetaCollectionRequest $request CreateMetaCollectionRequest
     *
     * @return CreateMetaCollectionResponse CreateMetaCollectionResponse
     */
    public function createMetaCollection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMetaCollectionWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a permission request order.
     *  *
     * @param CreatePermissionApplyOrderRequest $request CreatePermissionApplyOrderRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreatePermissionApplyOrderResponse CreatePermissionApplyOrderResponse
     */
    public function createPermissionApplyOrderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->applyObject)) {
            $query['ApplyObject'] = $request->applyObject;
        }
        if (!Utils::isUnset($request->applyReason)) {
            $query['ApplyReason'] = $request->applyReason;
        }
        if (!Utils::isUnset($request->applyUserIds)) {
            $query['ApplyUserIds'] = $request->applyUserIds;
        }
        if (!Utils::isUnset($request->deadline)) {
            $query['Deadline'] = $request->deadline;
        }
        if (!Utils::isUnset($request->engineType)) {
            $query['EngineType'] = $request->engineType;
        }
        if (!Utils::isUnset($request->maxComputeProjectName)) {
            $query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }
        if (!Utils::isUnset($request->orderType)) {
            $query['OrderType'] = $request->orderType;
        }
        if (!Utils::isUnset($request->workspaceId)) {
            $query['WorkspaceId'] = $request->workspaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreatePermissionApplyOrder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreatePermissionApplyOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a permission request order.
     *  *
     * @param CreatePermissionApplyOrderRequest $request CreatePermissionApplyOrderRequest
     *
     * @return CreatePermissionApplyOrderResponse CreatePermissionApplyOrderResponse
     */
    public function createPermissionApplyOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPermissionApplyOrderWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a DataWorks workspace.
     *  *
     * @param CreateProjectRequest $tmpReq  CreateProjectRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateProjectResponse CreateProjectResponse
     */
    public function createProjectWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateProjectShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->disableDevelopment)) {
            $query['DisableDevelopment'] = $request->disableDevelopment;
        }
        if (!Utils::isUnset($request->isAllowDownload)) {
            $query['IsAllowDownload'] = $request->isAllowDownload;
        }
        if (!Utils::isUnset($request->projectDescription)) {
            $query['ProjectDescription'] = $request->projectDescription;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $query['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->projectMode)) {
            $query['ProjectMode'] = $request->projectMode;
        }
        if (!Utils::isUnset($request->projectName)) {
            $query['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->resourceManagerResourceGroupId)) {
            $query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }
        if (!Utils::isUnset($request->tagsShrink)) {
            $query['Tags'] = $request->tagsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateProject',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a DataWorks workspace.
     *  *
     * @param CreateProjectRequest $request CreateProjectRequest
     *
     * @return CreateProjectResponse CreateProjectResponse
     */
    public function createProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createProjectWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a user to a DataWorks workspace.
     *  *
     * @param CreateProjectMemberRequest $request CreateProjectMemberRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateProjectMemberResponse CreateProjectMemberResponse
     */
    public function createProjectMemberWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->roleCode)) {
            $query['RoleCode'] = $request->roleCode;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateProjectMember',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateProjectMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a user to a DataWorks workspace.
     *  *
     * @param CreateProjectMemberRequest $request CreateProjectMemberRequest
     *
     * @return CreateProjectMemberResponse CreateProjectMemberResponse
     */
    public function createProjectMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createProjectMemberWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a partition filter expression.
     *  *
     * @param CreateQualityEntityRequest $request CreateQualityEntityRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateQualityEntityResponse CreateQualityEntityResponse
     */
    public function createQualityEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->entityLevel)) {
            $body['EntityLevel'] = $request->entityLevel;
        }
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->matchExpression)) {
            $body['MatchExpression'] = $request->matchExpression;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $body['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateQualityEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateQualityEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a partition filter expression.
     *  *
     * @param CreateQualityEntityRequest $request CreateQualityEntityRequest
     *
     * @return CreateQualityEntityResponse CreateQualityEntityResponse
     */
    public function createQualityEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityEntityWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a subscriber for a partition filter expression.
     *  *
     * @param CreateQualityFollowerRequest $request CreateQualityFollowerRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateQualityFollowerResponse CreateQualityFollowerResponse
     */
    public function createQualityFollowerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alarmMode)) {
            $body['AlarmMode'] = $request->alarmMode;
        }
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->follower)) {
            $body['Follower'] = $request->follower;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateQualityFollower',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a subscriber for a partition filter expression.
     *  *
     * @param CreateQualityFollowerRequest $request CreateQualityFollowerRequest
     *
     * @return CreateQualityFollowerResponse CreateQualityFollowerResponse
     */
    public function createQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * @summary Associates a node with a partition filter expression.
     *  *
     * @param CreateQualityRelativeNodeRequest $request CreateQualityRelativeNodeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateQualityRelativeNodeResponse CreateQualityRelativeNodeResponse
     */
    public function createQualityRelativeNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->matchExpression)) {
            $body['MatchExpression'] = $request->matchExpression;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $body['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->targetNodeProjectId)) {
            $body['TargetNodeProjectId'] = $request->targetNodeProjectId;
        }
        if (!Utils::isUnset($request->targetNodeProjectName)) {
            $body['TargetNodeProjectName'] = $request->targetNodeProjectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateQualityRelativeNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateQualityRelativeNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Associates a node with a partition filter expression.
     *  *
     * @param CreateQualityRelativeNodeRequest $request CreateQualityRelativeNodeRequest
     *
     * @return CreateQualityRelativeNodeResponse CreateQualityRelativeNodeResponse
     */
    public function createQualityRelativeNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityRelativeNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a monitoring rule.
     *  *
     * @param CreateQualityRuleRequest $request CreateQualityRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateQualityRuleResponse CreateQualityRuleResponse
     */
    public function createQualityRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->blockType)) {
            $body['BlockType'] = $request->blockType;
        }
        if (!Utils::isUnset($request->checker)) {
            $body['Checker'] = $request->checker;
        }
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->criticalThreshold)) {
            $body['CriticalThreshold'] = $request->criticalThreshold;
        }
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->expectValue)) {
            $body['ExpectValue'] = $request->expectValue;
        }
        if (!Utils::isUnset($request->methodName)) {
            $body['MethodName'] = $request->methodName;
        }
        if (!Utils::isUnset($request->operator)) {
            $body['Operator'] = $request->operator;
        }
        if (!Utils::isUnset($request->predictType)) {
            $body['PredictType'] = $request->predictType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->property)) {
            $body['Property'] = $request->property;
        }
        if (!Utils::isUnset($request->propertyType)) {
            $body['PropertyType'] = $request->propertyType;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $body['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $body['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->taskSetting)) {
            $body['TaskSetting'] = $request->taskSetting;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->trend)) {
            $body['Trend'] = $request->trend;
        }
        if (!Utils::isUnset($request->warningThreshold)) {
            $body['WarningThreshold'] = $request->warningThreshold;
        }
        if (!Utils::isUnset($request->whereCondition)) {
            $body['WhereCondition'] = $request->whereCondition;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateQualityRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a monitoring rule.
     *  *
     * @param CreateQualityRuleRequest $request CreateQualityRuleRequest
     *
     * @return CreateQualityRuleResponse CreateQualityRuleResponse
     */
    public function createQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a custom alert rule.
     *  *
     * @param CreateRemindRequest $request CreateRemindRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRemindResponse CreateRemindResponse
     */
    public function createRemindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertInterval)) {
            $body['AlertInterval'] = $request->alertInterval;
        }
        if (!Utils::isUnset($request->alertMethods)) {
            $body['AlertMethods'] = $request->alertMethods;
        }
        if (!Utils::isUnset($request->alertTargets)) {
            $body['AlertTargets'] = $request->alertTargets;
        }
        if (!Utils::isUnset($request->alertUnit)) {
            $body['AlertUnit'] = $request->alertUnit;
        }
        if (!Utils::isUnset($request->baselineIds)) {
            $body['BaselineIds'] = $request->baselineIds;
        }
        if (!Utils::isUnset($request->bizProcessIds)) {
            $body['BizProcessIds'] = $request->bizProcessIds;
        }
        if (!Utils::isUnset($request->detail)) {
            $body['Detail'] = $request->detail;
        }
        if (!Utils::isUnset($request->dndEnd)) {
            $body['DndEnd'] = $request->dndEnd;
        }
        if (!Utils::isUnset($request->maxAlertTimes)) {
            $body['MaxAlertTimes'] = $request->maxAlertTimes;
        }
        if (!Utils::isUnset($request->nodeIds)) {
            $body['NodeIds'] = $request->nodeIds;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->remindName)) {
            $body['RemindName'] = $request->remindName;
        }
        if (!Utils::isUnset($request->remindType)) {
            $body['RemindType'] = $request->remindType;
        }
        if (!Utils::isUnset($request->remindUnit)) {
            $body['RemindUnit'] = $request->remindUnit;
        }
        if (!Utils::isUnset($request->robotUrls)) {
            $body['RobotUrls'] = $request->robotUrls;
        }
        if (!Utils::isUnset($request->webhooks)) {
            $body['Webhooks'] = $request->webhooks;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateRemind',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a custom alert rule.
     *  *
     * @param CreateRemindRequest $request CreateRemindRequest
     *
     * @return CreateRemindResponse CreateRemindResponse
     */
    public function createRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRemindWithOptions($request, $runtime);
    }

    /**
     * @summary 支持用户指定自己的文件（比如jar，py，arhive，file等）创建数据开发资源文件
     *  *
     * @param CreateResourceFileRequest $request CreateResourceFileRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateResourceFileResponse CreateResourceFileResponse
     */
    public function createResourceFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->content)) {
            $body['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->fileDescription)) {
            $body['FileDescription'] = $request->fileDescription;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileName)) {
            $body['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->fileType)) {
            $body['FileType'] = $request->fileType;
        }
        if (!Utils::isUnset($request->originResourceName)) {
            $body['OriginResourceName'] = $request->originResourceName;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->registerToCalcEngine)) {
            $body['RegisterToCalcEngine'] = $request->registerToCalcEngine;
        }
        if (!Utils::isUnset($request->resourceFile)) {
            $body['ResourceFile'] = $request->resourceFile;
        }
        if (!Utils::isUnset($request->storageURL)) {
            $body['StorageURL'] = $request->storageURL;
        }
        if (!Utils::isUnset($request->uploadMode)) {
            $body['UploadMode'] = $request->uploadMode;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateResourceFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateResourceFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 支持用户指定自己的文件（比如jar，py，arhive，file等）创建数据开发资源文件
     *  *
     * @param CreateResourceFileRequest $request CreateResourceFileRequest
     *
     * @return CreateResourceFileResponse CreateResourceFileResponse
     */
    public function createResourceFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createResourceFileWithOptions($request, $runtime);
    }

    /**
     * @param CreateResourceFileAdvanceRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateResourceFileResponse
     */
    public function createResourceFileAdvance($request, $runtime)
    {
        // Step 0: init client
        $accessKeyId          = $this->_credential->getAccessKeyId();
        $accessKeySecret      = $this->_credential->getAccessKeySecret();
        $securityToken        = $this->_credential->getSecurityToken();
        $credentialType       = $this->_credential->getType();
        $openPlatformEndpoint = $this->_openPlatformEndpoint;
        if (Utils::empty_($openPlatformEndpoint)) {
            $openPlatformEndpoint = 'openplatform.aliyuncs.com';
        }
        if (Utils::isUnset($credentialType)) {
            $credentialType = 'access_key';
        }
        $authConfig = new Config([
            'accessKeyId'     => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'securityToken'   => $securityToken,
            'type'            => $credentialType,
            'endpoint'        => $openPlatformEndpoint,
            'protocol'        => $this->_protocol,
            'regionId'        => $this->_regionId,
        ]);
        $authClient  = new OpenPlatform($authConfig);
        $authRequest = new AuthorizeFileUploadRequest([
            'product'  => 'dataworks-public',
            'regionId' => $this->_regionId,
        ]);
        $authResponse = new AuthorizeFileUploadResponse([]);
        $ossConfig    = new \AlibabaCloud\SDK\OSS\OSS\Config([
            'accessKeyId'     => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'type'            => 'access_key',
            'protocol'        => $this->_protocol,
            'regionId'        => $this->_regionId,
        ]);
        $ossClient     = new OSS($ossConfig);
        $fileObj       = new FileField([]);
        $ossHeader     = new header([]);
        $uploadRequest = new PostObjectRequest([]);
        $ossRuntime    = new \AlibabaCloud\Tea\OSSUtils\OSSUtils\RuntimeOptions([]);
        OpenApiUtilClient::convert($runtime, $ossRuntime);
        $createResourceFileReq = new CreateResourceFileRequest([]);
        OpenApiUtilClient::convert($request, $createResourceFileReq);
        if (!Utils::isUnset($request->resourceFileObject)) {
            $authResponse           = $authClient->authorizeFileUploadWithOptions($authRequest, $runtime);
            $ossConfig->accessKeyId = $authResponse->body->accessKeyId;
            $ossConfig->endpoint    = OpenApiUtilClient::getEndpoint($authResponse->body->endpoint, $authResponse->body->useAccelerate, $this->_endpointType);
            $ossClient              = new OSS($ossConfig);
            $fileObj                = new FileField([
                'filename'    => $authResponse->body->objectKey,
                'content'     => $request->resourceFileObject,
                'contentType' => '',
            ]);
            $ossHeader = new header([
                'accessKeyId'         => $authResponse->body->accessKeyId,
                'policy'              => $authResponse->body->encodedPolicy,
                'signature'           => $authResponse->body->signature,
                'key'                 => $authResponse->body->objectKey,
                'file'                => $fileObj,
                'successActionStatus' => '201',
            ]);
            $uploadRequest = new PostObjectRequest([
                'bucketName' => $authResponse->body->bucket,
                'header'     => $ossHeader,
            ]);
            $ossClient->postObject($uploadRequest, $ossRuntime);
            $createResourceFileReq->resourceFile = 'http://' . $authResponse->body->bucket . '.' . $authResponse->body->endpoint . '/' . $authResponse->body->objectKey . '';
        }

        return $this->createResourceFileWithOptions($createResourceFileReq, $runtime);
    }

    /**
     * @summary Creates a MaxCompute table or view.
     *  *
     * @param CreateTableRequest $request CreateTableRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateTableResponse CreateTableResponse
     */
    public function createTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->comment)) {
            $query['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->externalTableType)) {
            $query['ExternalTableType'] = $request->externalTableType;
        }
        if (!Utils::isUnset($request->hasPart)) {
            $query['HasPart'] = $request->hasPart;
        }
        if (!Utils::isUnset($request->isView)) {
            $query['IsView'] = $request->isView;
        }
        if (!Utils::isUnset($request->lifeCycle)) {
            $query['LifeCycle'] = $request->lifeCycle;
        }
        if (!Utils::isUnset($request->location)) {
            $query['Location'] = $request->location;
        }
        if (!Utils::isUnset($request->logicalLevelId)) {
            $query['LogicalLevelId'] = $request->logicalLevelId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicsLevelId)) {
            $query['PhysicsLevelId'] = $request->physicsLevelId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->visibility)) {
            $query['Visibility'] = $request->visibility;
        }
        $body = [];
        if (!Utils::isUnset($request->columns)) {
            $body['Columns'] = $request->columns;
        }
        if (!Utils::isUnset($request->endpoint)) {
            $body['Endpoint'] = $request->endpoint;
        }
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->themes)) {
            $body['Themes'] = $request->themes;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a MaxCompute table or view.
     *  *
     * @param CreateTableRequest $request CreateTableRequest
     *
     * @return CreateTableResponse CreateTableResponse
     */
    public function createTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTableWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param CreateTableLevelRequest $request CreateTableLevelRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateTableLevelResponse CreateTableLevelResponse
     */
    public function createTableLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->levelType)) {
            $query['LevelType'] = $request->levelType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateTableLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param CreateTableLevelRequest $request CreateTableLevelRequest
     *
     * @return CreateTableLevelResponse CreateTableLevelResponse
     */
    public function createTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTableLevelWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param CreateTableThemeRequest $request CreateTableThemeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateTableThemeResponse CreateTableThemeResponse
     */
    public function createTableThemeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->level)) {
            $query['Level'] = $request->level;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->parentId)) {
            $query['ParentId'] = $request->parentId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateTableTheme',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param CreateTableThemeRequest $request CreateTableThemeRequest
     *
     * @return CreateTableThemeResponse CreateTableThemeResponse
     */
    public function createTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTableThemeWithOptions($request, $runtime);
    }

    /**
     * @param CreateUdfFileRequest $request CreateUdfFileRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateUdfFileResponse CreateUdfFileResponse
     */
    public function createUdfFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->className)) {
            $body['ClassName'] = $request->className;
        }
        if (!Utils::isUnset($request->cmdDescription)) {
            $body['CmdDescription'] = $request->cmdDescription;
        }
        if (!Utils::isUnset($request->createFolderIfNotExists)) {
            $body['CreateFolderIfNotExists'] = $request->createFolderIfNotExists;
        }
        if (!Utils::isUnset($request->example)) {
            $body['Example'] = $request->example;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileName)) {
            $body['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->functionType)) {
            $body['FunctionType'] = $request->functionType;
        }
        if (!Utils::isUnset($request->parameterDescription)) {
            $body['ParameterDescription'] = $request->parameterDescription;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->resources)) {
            $body['Resources'] = $request->resources;
        }
        if (!Utils::isUnset($request->returnValue)) {
            $body['ReturnValue'] = $request->returnValue;
        }
        if (!Utils::isUnset($request->udfDescription)) {
            $body['UdfDescription'] = $request->udfDescription;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateUdfFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateUdfFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateUdfFileRequest $request CreateUdfFileRequest
     *
     * @return CreateUdfFileResponse CreateUdfFileResponse
     */
    public function createUdfFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUdfFileWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a baseline based on its ID. You can delete a baseline only if the nodes in the baseline does not have ancestor nodes. You can call the UpdateBaseline operation to delete the relationships between the nodes and their ancestor nodes.
     *  *
     * @param DeleteBaselineRequest $request DeleteBaselineRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBaselineResponse DeleteBaselineResponse
     */
    public function deleteBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a baseline based on its ID. You can delete a baseline only if the nodes in the baseline does not have ancestor nodes. You can call the UpdateBaseline operation to delete the relationships between the nodes and their ancestor nodes.
     *  *
     * @param DeleteBaselineRequest $request DeleteBaselineRequest
     *
     * @return DeleteBaselineResponse DeleteBaselineResponse
     */
    public function deleteBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBaselineWithOptions($request, $runtime);
    }

    /**
     * @param DeleteBusinessRequest $request DeleteBusinessRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBusinessResponse DeleteBusinessResponse
     */
    public function deleteBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessId)) {
            $body['BusinessId'] = $request->businessId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteBusinessRequest $request DeleteBusinessRequest
     *
     * @return DeleteBusinessResponse DeleteBusinessResponse
     */
    public function deleteBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBusinessWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DeleteConnection is deprecated
     *  *
     * @summary Removes a data source.
     *  *
     * Deprecated
     *
     * @param DeleteConnectionRequest $request DeleteConnectionRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteConnectionResponse DeleteConnectionResponse
     */
    public function deleteConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->connectionId)) {
            $query['ConnectionId'] = $request->connectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteConnection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DeleteConnection is deprecated
     *  *
     * @summary Removes a data source.
     *  *
     * Deprecated
     *
     * @param DeleteConnectionRequest $request DeleteConnectionRequest
     *
     * @return DeleteConnectionResponse DeleteConnectionResponse
     */
    public function deleteConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks whose MigrationType is set to RealtimeIncremental.
     *  *
     * @param DeleteDIAlarmRuleRequest $request DeleteDIAlarmRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDIAlarmRuleResponse DeleteDIAlarmRuleResponse
     */
    public function deleteDIAlarmRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIAlarmRuleId)) {
            $body['DIAlarmRuleId'] = $request->DIAlarmRuleId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteDIAlarmRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks whose MigrationType is set to RealtimeIncremental.
     *  *
     * @param DeleteDIAlarmRuleRequest $request DeleteDIAlarmRuleRequest
     *
     * @return DeleteDIAlarmRuleResponse DeleteDIAlarmRuleResponse
     */
    public function deleteDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @param DeleteDIJobRequest $request DeleteDIJobRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDIJobResponse DeleteDIJobResponse
     */
    public function deleteDIJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @param DeleteDIJobRequest $request DeleteDIJobRequest
     *
     * @return DeleteDIJobResponse DeleteDIJobResponse
     */
    public function deleteDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a synchronization task. You can call this operation to delete only a real-time synchronization task.
     *  *
     * @description If you want to delete a batch synchronization task, call the DeleteFile operation. For more information, see [Delete a synchronization task](https://help.aliyun.com/document_detail/321443.html).
     *  *
     * @param DeleteDISyncTaskRequest $request DeleteDISyncTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDISyncTaskResponse DeleteDISyncTaskResponse
     */
    public function deleteDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a synchronization task. You can call this operation to delete only a real-time synchronization task.
     *  *
     * @description If you want to delete a batch synchronization task, call the DeleteFile operation. For more information, see [Delete a synchronization task](https://help.aliyun.com/document_detail/321443.html).
     *  *
     * @param DeleteDISyncTaskRequest $request DeleteDISyncTaskRequest
     *
     * @return DeleteDISyncTaskResponse DeleteDISyncTaskResponse
     */
    public function deleteDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an API in DataService Studio.
     *  *
     * @param DeleteDataServiceApiRequest $request DeleteDataServiceApiRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDataServiceApiResponse DeleteDataServiceApiResponse
     */
    public function deleteDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an API in DataService Studio.
     *  *
     * @param DeleteDataServiceApiRequest $request DeleteDataServiceApiRequest
     *
     * @return DeleteDataServiceApiResponse DeleteDataServiceApiResponse
     */
    public function deleteDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Revokes the access permissions on an API.
     *  *
     * @param DeleteDataServiceApiAuthorityRequest $request DeleteDataServiceApiAuthorityRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDataServiceApiAuthorityResponse DeleteDataServiceApiAuthorityResponse
     */
    public function deleteDataServiceApiAuthorityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->authorizedProjectId)) {
            $body['AuthorizedProjectId'] = $request->authorizedProjectId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteDataServiceApiAuthority',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDataServiceApiAuthorityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Revokes the access permissions on an API.
     *  *
     * @param DeleteDataServiceApiAuthorityRequest $request DeleteDataServiceApiAuthorityRequest
     *
     * @return DeleteDataServiceApiAuthorityResponse DeleteDataServiceApiAuthorityResponse
     */
    public function deleteDataServiceApiAuthority($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDataServiceApiAuthorityWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a data source.
     *  *
     * @param DeleteDataSourceRequest $request DeleteDataSourceRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDataSourceResponse DeleteDataSourceResponse
     */
    public function deleteDataSourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dataSourceId)) {
            $query['DataSourceId'] = $request->dataSourceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteDataSource',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a data source.
     *  *
     * @param DeleteDataSourceRequest $request DeleteDataSourceRequest
     *
     * @return DeleteDataSourceResponse DeleteDataSourceResponse
     */
    public function deleteDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDataSourceWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a file from DataStudio. If the file has been committed, an asynchronous process is triggered to delete the file in the scheduling system. The value of the DeploymentId parameter returned is used to call the GetDeployment operation to poll the status of the asynchronous process.
     *  *
     * @param DeleteFileRequest $request DeleteFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFileResponse DeleteFileResponse
     */
    public function deleteFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a file from DataStudio. If the file has been committed, an asynchronous process is triggered to delete the file in the scheduling system. The value of the DeploymentId parameter returned is used to call the GetDeployment operation to poll the status of the asynchronous process.
     *  *
     * @param DeleteFileRequest $request DeleteFileRequest
     *
     * @return DeleteFileResponse DeleteFileResponse
     */
    public function deleteFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFileWithOptions($request, $runtime);
    }

    /**
     * @param DeleteFolderRequest $request DeleteFolderRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFolderResponse DeleteFolderResponse
     */
    public function deleteFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteFolderRequest $request DeleteFolderRequest
     *
     * @return DeleteFolderResponse DeleteFolderResponse
     */
    public function deleteFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a table from a specified category.
     *  *
     * @param DeleteFromMetaCategoryRequest $request DeleteFromMetaCategoryRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFromMetaCategoryResponse DeleteFromMetaCategoryResponse
     */
    public function deleteFromMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteFromMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFromMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a table from a specified category.
     *  *
     * @param DeleteFromMetaCategoryRequest $request DeleteFromMetaCategoryRequest
     *
     * @return DeleteFromMetaCategoryResponse DeleteFromMetaCategoryResponse
     */
    public function deleteFromMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFromMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes the lineage between entities. You can call this operation to delete only custom lineages that are registered by users.
     *  *
     * @description This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
     *  *
     * @param DeleteLineageRelationRequest $request DeleteLineageRelationRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLineageRelationResponse DeleteLineageRelationResponse
     */
    public function deleteLineageRelationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destEntityQualifiedName)) {
            $query['DestEntityQualifiedName'] = $request->destEntityQualifiedName;
        }
        if (!Utils::isUnset($request->relationshipGuid)) {
            $query['RelationshipGuid'] = $request->relationshipGuid;
        }
        if (!Utils::isUnset($request->relationshipType)) {
            $query['RelationshipType'] = $request->relationshipType;
        }
        if (!Utils::isUnset($request->srcEntityQualifiedName)) {
            $query['SrcEntityQualifiedName'] = $request->srcEntityQualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteLineageRelation',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteLineageRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes the lineage between entities. You can call this operation to delete only custom lineages that are registered by users.
     *  *
     * @description This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
     *  *
     * @param DeleteLineageRelationRequest $request DeleteLineageRelationRequest
     *
     * @return DeleteLineageRelationResponse DeleteLineageRelationResponse
     */
    public function deleteLineageRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLineageRelationWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a category.
     *  *
     * @param DeleteMetaCategoryRequest $request DeleteMetaCategoryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMetaCategoryResponse DeleteMetaCategoryResponse
     */
    public function deleteMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a category.
     *  *
     * @param DeleteMetaCategoryRequest $request DeleteMetaCategoryRequest
     *
     * @return DeleteMetaCategoryResponse DeleteMetaCategoryResponse
     */
    public function deleteMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a collection.
     *  *
     * @param DeleteMetaCollectionRequest $request DeleteMetaCollectionRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMetaCollectionResponse DeleteMetaCollectionResponse
     */
    public function deleteMetaCollectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMetaCollection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMetaCollectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a collection.
     *  *
     * @param DeleteMetaCollectionRequest $request DeleteMetaCollectionRequest
     *
     * @return DeleteMetaCollectionResponse DeleteMetaCollectionResponse
     */
    public function deleteMetaCollection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMetaCollectionWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an entity from a collection.
     *  *
     * @param DeleteMetaCollectionEntityRequest $request DeleteMetaCollectionEntityRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMetaCollectionEntityResponse DeleteMetaCollectionEntityResponse
     */
    public function deleteMetaCollectionEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->collectionQualifiedName)) {
            $query['CollectionQualifiedName'] = $request->collectionQualifiedName;
        }
        if (!Utils::isUnset($request->entityQualifiedName)) {
            $query['EntityQualifiedName'] = $request->entityQualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMetaCollectionEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMetaCollectionEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an entity from a collection.
     *  *
     * @param DeleteMetaCollectionEntityRequest $request DeleteMetaCollectionEntityRequest
     *
     * @return DeleteMetaCollectionEntityResponse DeleteMetaCollectionEntityResponse
     */
    public function deleteMetaCollectionEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMetaCollectionEntityWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a user from a DataWorks workspace.
     *  *
     * @param DeleteProjectMemberRequest $request DeleteProjectMemberRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteProjectMemberResponse DeleteProjectMemberResponse
     */
    public function deleteProjectMemberWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteProjectMember',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteProjectMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a user from a DataWorks workspace.
     *  *
     * @param DeleteProjectMemberRequest $request DeleteProjectMemberRequest
     *
     * @return DeleteProjectMemberResponse DeleteProjectMemberResponse
     */
    public function deleteProjectMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteProjectMemberWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a partition filter expression.
     *  *
     * @param DeleteQualityEntityRequest $request DeleteQualityEntityRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteQualityEntityResponse DeleteQualityEntityResponse
     */
    public function deleteQualityEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteQualityEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteQualityEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a partition filter expression.
     *  *
     * @param DeleteQualityEntityRequest $request DeleteQualityEntityRequest
     *
     * @return DeleteQualityEntityResponse DeleteQualityEntityResponse
     */
    public function deleteQualityEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityEntityWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a subscriber of a partition filter expression.
     *  *
     * @description In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transform, and load (ETL). This way, you can prevent tasks from producing unexpected dirty data that affects the smooth running of tasks and business decision-making. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule that is created based on the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors at the earliest opportunity. For more information, see [Configure monitoring rules](https://help.aliyun.com/document_detail/73690.html).
     *  *
     * @param DeleteQualityFollowerRequest $request DeleteQualityFollowerRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteQualityFollowerResponse DeleteQualityFollowerResponse
     */
    public function deleteQualityFollowerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->followerId)) {
            $body['FollowerId'] = $request->followerId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteQualityFollower',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a subscriber of a partition filter expression.
     *  *
     * @description In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transform, and load (ETL). This way, you can prevent tasks from producing unexpected dirty data that affects the smooth running of tasks and business decision-making. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule that is created based on the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors at the earliest opportunity. For more information, see [Configure monitoring rules](https://help.aliyun.com/document_detail/73690.html).
     *  *
     * @param DeleteQualityFollowerRequest $request DeleteQualityFollowerRequest
     *
     * @return DeleteQualityFollowerResponse DeleteQualityFollowerResponse
     */
    public function deleteQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * @param DeleteQualityRelativeNodeRequest $request DeleteQualityRelativeNodeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteQualityRelativeNodeResponse DeleteQualityRelativeNodeResponse
     */
    public function deleteQualityRelativeNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->matchExpression)) {
            $body['MatchExpression'] = $request->matchExpression;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $body['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->targetNodeProjectId)) {
            $body['TargetNodeProjectId'] = $request->targetNodeProjectId;
        }
        if (!Utils::isUnset($request->targetNodeProjectName)) {
            $body['TargetNodeProjectName'] = $request->targetNodeProjectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteQualityRelativeNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteQualityRelativeNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteQualityRelativeNodeRequest $request DeleteQualityRelativeNodeRequest
     *
     * @return DeleteQualityRelativeNodeResponse DeleteQualityRelativeNodeResponse
     */
    public function deleteQualityRelativeNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityRelativeNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a monitoring rule.
     *  *
     * @param DeleteQualityRuleRequest $request DeleteQualityRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteQualityRuleResponse DeleteQualityRuleResponse
     */
    public function deleteQualityRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $body['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteQualityRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a monitoring rule.
     *  *
     * @param DeleteQualityRuleRequest $request DeleteQualityRuleRequest
     *
     * @return DeleteQualityRuleResponse DeleteQualityRuleResponse
     */
    public function deleteQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes sensitive field types.
     *  *
     * @param DeleteRecognizeRuleRequest $request DeleteRecognizeRuleRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRecognizeRuleResponse DeleteRecognizeRuleResponse
     */
    public function deleteRecognizeRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->sensitiveId)) {
            $body['SensitiveId'] = $request->sensitiveId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteRecognizeRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteRecognizeRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes sensitive field types.
     *  *
     * @param DeleteRecognizeRuleRequest $request DeleteRecognizeRuleRequest
     *
     * @return DeleteRecognizeRuleResponse DeleteRecognizeRuleResponse
     */
    public function deleteRecognizeRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRecognizeRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a custom alert rule.
     *  *
     * @param DeleteRemindRequest $request DeleteRemindRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRemindResponse DeleteRemindResponse
     */
    public function deleteRemindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->remindId)) {
            $body['RemindId'] = $request->remindId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteRemind',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a custom alert rule.
     *  *
     * @param DeleteRemindRequest $request DeleteRemindRequest
     *
     * @return DeleteRemindResponse DeleteRemindResponse
     */
    public function deleteRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRemindWithOptions($request, $runtime);
    }

    /**
     * @param DeleteTableRequest $request DeleteTableRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTableResponse DeleteTableResponse
     */
    public function deleteTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteTableRequest $request DeleteTableRequest
     *
     * @return DeleteTableResponse DeleteTableResponse
     */
    public function deleteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTableWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param DeleteTableLevelRequest $request DeleteTableLevelRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTableLevelResponse DeleteTableLevelResponse
     */
    public function deleteTableLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->levelId)) {
            $query['LevelId'] = $request->levelId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTableLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param DeleteTableLevelRequest $request DeleteTableLevelRequest
     *
     * @return DeleteTableLevelResponse DeleteTableLevelResponse
     */
    public function deleteTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTableLevelWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param DeleteTableThemeRequest $request DeleteTableThemeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTableThemeResponse DeleteTableThemeResponse
     */
    public function deleteTableThemeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->themeId)) {
            $query['ThemeId'] = $request->themeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTableTheme',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param DeleteTableThemeRequest $request DeleteTableThemeRequest
     *
     * @return DeleteTableThemeResponse DeleteTableThemeResponse
     */
    public function deleteTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTableThemeWithOptions($request, $runtime);
    }

    /**
     * @summary Deploys a real-time synchronization task.
     *  *
     * @param DeployDISyncTaskRequest $request DeployDISyncTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeployDISyncTaskResponse DeployDISyncTaskResponse
     */
    public function deployDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeployDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeployDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deploys a real-time synchronization task.
     *  *
     * @param DeployDISyncTaskRequest $request DeployDISyncTaskRequest
     *
     * @return DeployDISyncTaskResponse DeployDISyncTaskResponse
     */
    public function deployDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deployDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Deploys a file to the production environment.
     *  *
     * @param DeployFileRequest $request DeployFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeployFileResponse DeployFileResponse
     */
    public function deployFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeployFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeployFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deploys a file to the production environment.
     *  *
     * @param DeployFileRequest $request DeployFileRequest
     *
     * @return DeployFileResponse DeployFileResponse
     */
    public function deployFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deployFileWithOptions($request, $runtime);
    }

    /**
     * @summary Masks data.
     *  *
     * @param DesensitizeDataRequest $request DesensitizeDataRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DesensitizeDataResponse DesensitizeDataResponse
     */
    public function desensitizeDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DesensitizeData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DesensitizeDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Masks data.
     *  *
     * @param DesensitizeDataRequest $request DesensitizeDataRequest
     *
     * @return DesensitizeDataResponse DesensitizeDataResponse
     */
    public function desensitizeData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->desensitizeDataWithOptions($request, $runtime);
    }

    /**
     * @summary Adds or modifies a data masking rule.
     *  *
     * @param DsgDesensPlanAddOrUpdateRequest $tmpReq  DsgDesensPlanAddOrUpdateRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgDesensPlanAddOrUpdateResponse DsgDesensPlanAddOrUpdateResponse
     */
    public function dsgDesensPlanAddOrUpdateWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgDesensPlanAddOrUpdateShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->desensRules)) {
            $request->desensRulesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->desensRules, 'DesensRules', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->desensRulesShrink)) {
            $query['DesensRules'] = $request->desensRulesShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgDesensPlanAddOrUpdate',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgDesensPlanAddOrUpdateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds or modifies a data masking rule.
     *  *
     * @param DsgDesensPlanAddOrUpdateRequest $request DsgDesensPlanAddOrUpdateRequest
     *
     * @return DsgDesensPlanAddOrUpdateResponse DsgDesensPlanAddOrUpdateResponse
     */
    public function dsgDesensPlanAddOrUpdate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanAddOrUpdateWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a data masking rule created in Data Security Guard.
     *  *
     * @param DsgDesensPlanDeleteRequest $tmpReq  DsgDesensPlanDeleteRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgDesensPlanDeleteResponse DsgDesensPlanDeleteResponse
     */
    public function dsgDesensPlanDeleteWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgDesensPlanDeleteShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        if (!Utils::isUnset($request->sceneCode)) {
            $query['SceneCode'] = $request->sceneCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgDesensPlanDelete',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgDesensPlanDeleteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a data masking rule created in Data Security Guard.
     *  *
     * @param DsgDesensPlanDeleteRequest $request DsgDesensPlanDeleteRequest
     *
     * @return DsgDesensPlanDeleteResponse DsgDesensPlanDeleteResponse
     */
    public function dsgDesensPlanDelete($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanDeleteWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of data masking rules.
     *  *
     * @param DsgDesensPlanQueryListRequest $request DsgDesensPlanQueryListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgDesensPlanQueryListResponse DsgDesensPlanQueryListResponse
     */
    public function dsgDesensPlanQueryListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgDesensPlanQueryList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgDesensPlanQueryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of data masking rules.
     *  *
     * @param DsgDesensPlanQueryListRequest $request DsgDesensPlanQueryListRequest
     *
     * @return DsgDesensPlanQueryListResponse DsgDesensPlanQueryListResponse
     */
    public function dsgDesensPlanQueryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanQueryListWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the status of a data masking rule.
     *  *
     * @param DsgDesensPlanUpdateStatusRequest $tmpReq  DsgDesensPlanUpdateStatusRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgDesensPlanUpdateStatusResponse DsgDesensPlanUpdateStatusResponse
     */
    public function dsgDesensPlanUpdateStatusWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgDesensPlanUpdateStatusShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        if (!Utils::isUnset($request->sceneCode)) {
            $query['SceneCode'] = $request->sceneCode;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgDesensPlanUpdateStatus',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgDesensPlanUpdateStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the status of a data masking rule.
     *  *
     * @param DsgDesensPlanUpdateStatusRequest $request DsgDesensPlanUpdateStatusRequest
     *
     * @return DsgDesensPlanUpdateStatusResponse DsgDesensPlanUpdateStatusResponse
     */
    public function dsgDesensPlanUpdateStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanUpdateStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of compute engines of different types in the current tenant.
     *  *
     * @param DsgPlatformQueryProjectsAndSchemaFromMetaRequest $request DsgPlatformQueryProjectsAndSchemaFromMetaRequest
     * @param RuntimeOptions                                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgPlatformQueryProjectsAndSchemaFromMetaResponse DsgPlatformQueryProjectsAndSchemaFromMetaResponse
     */
    public function dsgPlatformQueryProjectsAndSchemaFromMetaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgPlatformQueryProjectsAndSchemaFromMeta',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgPlatformQueryProjectsAndSchemaFromMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of compute engines of different types in the current tenant.
     *  *
     * @param DsgPlatformQueryProjectsAndSchemaFromMetaRequest $request DsgPlatformQueryProjectsAndSchemaFromMetaRequest
     *
     * @return DsgPlatformQueryProjectsAndSchemaFromMetaResponse DsgPlatformQueryProjectsAndSchemaFromMetaResponse
     */
    public function dsgPlatformQueryProjectsAndSchemaFromMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgPlatformQueryProjectsAndSchemaFromMetaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of available sensitive field type templates and the data masking rules supported by the templates. You can refer to the response parameters of this operation to configure a data masking rule.
     *  *
     * @param DsgQueryDefaultTemplatesRequest $request DsgQueryDefaultTemplatesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgQueryDefaultTemplatesResponse DsgQueryDefaultTemplatesResponse
     */
    public function dsgQueryDefaultTemplatesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgQueryDefaultTemplates',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgQueryDefaultTemplatesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of available sensitive field type templates and the data masking rules supported by the templates. You can refer to the response parameters of this operation to configure a data masking rule.
     *  *
     * @param DsgQueryDefaultTemplatesRequest $request DsgQueryDefaultTemplatesRequest
     *
     * @return DsgQueryDefaultTemplatesResponse DsgQueryDefaultTemplatesResponse
     */
    public function dsgQueryDefaultTemplates($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgQueryDefaultTemplatesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the identification results of sensitive data.
     *  *
     * @description The query capability of the API operation is similar to the query feature in Data Security Guard in the DataWorks console. The API operation can be used to query the identification results of sensitive data of a tenant based on the association with the tenant ID.
     * *   You can search for a specific identification result based on filter conditions such as data source type and workspace.
     * *   You can sort the identification results of sensitive data of a tenant based on the values of a field in ascending or descending order.
     * *   This operation supports paged query.
     *  *
     * @param DsgQuerySensResultRequest $request DsgQuerySensResultRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgQuerySensResultResponse DsgQuerySensResultResponse
     */
    public function dsgQuerySensResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->col)) {
            $body['Col'] = $request->col;
        }
        if (!Utils::isUnset($request->dbType)) {
            $body['DbType'] = $request->dbType;
        }
        if (!Utils::isUnset($request->level)) {
            $body['Level'] = $request->level;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $body['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->order)) {
            $body['Order'] = $request->order;
        }
        if (!Utils::isUnset($request->orderField)) {
            $body['OrderField'] = $request->orderField;
        }
        if (!Utils::isUnset($request->pageNo)) {
            $body['PageNo'] = $request->pageNo;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->schemaName)) {
            $body['SchemaName'] = $request->schemaName;
        }
        if (!Utils::isUnset($request->sensStatus)) {
            $body['SensStatus'] = $request->sensStatus;
        }
        if (!Utils::isUnset($request->sensitiveId)) {
            $body['SensitiveId'] = $request->sensitiveId;
        }
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->table)) {
            $body['Table'] = $request->table;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DsgQuerySensResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgQuerySensResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the identification results of sensitive data.
     *  *
     * @description The query capability of the API operation is similar to the query feature in Data Security Guard in the DataWorks console. The API operation can be used to query the identification results of sensitive data of a tenant based on the association with the tenant ID.
     * *   You can search for a specific identification result based on filter conditions such as data source type and workspace.
     * *   You can sort the identification results of sensitive data of a tenant based on the values of a field in ascending or descending order.
     * *   This operation supports paged query.
     *  *
     * @param DsgQuerySensResultRequest $request DsgQuerySensResultRequest
     *
     * @return DsgQuerySensResultResponse DsgQuerySensResultResponse
     */
    public function dsgQuerySensResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgQuerySensResultWithOptions($request, $runtime);
    }

    /**
     * @summary Starts a sensitive data identification task in Data Security Guard.
     *  *
     * @param DsgRunSensIdentifyRequest $tmpReq  DsgRunSensIdentifyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgRunSensIdentifyResponse DsgRunSensIdentifyResponse
     */
    public function dsgRunSensIdentifyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgRunSensIdentifyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->esMetaParams)) {
            $request->esMetaParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->esMetaParams, 'EsMetaParams', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->esMetaParamsShrink)) {
            $body['EsMetaParams'] = $request->esMetaParamsShrink;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DsgRunSensIdentify',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgRunSensIdentifyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a sensitive data identification task in Data Security Guard.
     *  *
     * @param DsgRunSensIdentifyRequest $request DsgRunSensIdentifyRequest
     *
     * @return DsgRunSensIdentifyResponse DsgRunSensIdentifyResponse
     */
    public function dsgRunSensIdentify($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgRunSensIdentifyWithOptions($request, $runtime);
    }

    /**
     * @summary Adds or modifies a level-2 data masking scenario.
     *  *
     * @param DsgSceneAddOrUpdateSceneRequest $tmpReq  DsgSceneAddOrUpdateSceneRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgSceneAddOrUpdateSceneResponse DsgSceneAddOrUpdateSceneResponse
     */
    public function dsgSceneAddOrUpdateSceneWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgSceneAddOrUpdateSceneShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->scenes)) {
            $request->scenesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->scenes, 'scenes', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->scenesShrink)) {
            $query['scenes'] = $request->scenesShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgSceneAddOrUpdateScene',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgSceneAddOrUpdateSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds or modifies a level-2 data masking scenario.
     *  *
     * @param DsgSceneAddOrUpdateSceneRequest $request DsgSceneAddOrUpdateSceneRequest
     *
     * @return DsgSceneAddOrUpdateSceneResponse DsgSceneAddOrUpdateSceneResponse
     */
    public function dsgSceneAddOrUpdateScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgSceneAddOrUpdateSceneWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of data masking scenarios.
     *  *
     * @param DsgSceneQuerySceneListByNameRequest $request DsgSceneQuerySceneListByNameRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgSceneQuerySceneListByNameResponse DsgSceneQuerySceneListByNameResponse
     */
    public function dsgSceneQuerySceneListByNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgSceneQuerySceneListByName',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgSceneQuerySceneListByNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of data masking scenarios.
     *  *
     * @param DsgSceneQuerySceneListByNameRequest $request DsgSceneQuerySceneListByNameRequest
     *
     * @return DsgSceneQuerySceneListByNameResponse DsgSceneQuerySceneListByNameResponse
     */
    public function dsgSceneQuerySceneListByName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgSceneQuerySceneListByNameWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a level-2 data masking scenario created in Data Security Guard.
     *  *
     * @param DsgScenedDeleteSceneRequest $tmpReq  DsgScenedDeleteSceneRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgScenedDeleteSceneResponse DsgScenedDeleteSceneResponse
     */
    public function dsgScenedDeleteSceneWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgScenedDeleteSceneShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgScenedDeleteScene',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgScenedDeleteSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a level-2 data masking scenario created in Data Security Guard.
     *  *
     * @param DsgScenedDeleteSceneRequest $request DsgScenedDeleteSceneRequest
     *
     * @return DsgScenedDeleteSceneResponse DsgScenedDeleteSceneResponse
     */
    public function dsgScenedDeleteScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgScenedDeleteSceneWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a sensitive data identification task.
     *  *
     * @param DsgStopSensIdentifyRequest $request DsgStopSensIdentifyRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgStopSensIdentifyResponse DsgStopSensIdentifyResponse
     */
    public function dsgStopSensIdentifyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->jobId)) {
            $body['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DsgStopSensIdentify',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgStopSensIdentifyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a sensitive data identification task.
     *  *
     * @param DsgStopSensIdentifyRequest $request DsgStopSensIdentifyRequest
     *
     * @return DsgStopSensIdentifyResponse DsgStopSensIdentifyResponse
     */
    public function dsgStopSensIdentify($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgStopSensIdentifyWithOptions($request, $runtime);
    }

    /**
     * @summary Adds or modifies a user group.
     *  *
     * @param DsgUserGroupAddOrUpdateRequest $tmpReq  DsgUserGroupAddOrUpdateRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupAddOrUpdateResponse DsgUserGroupAddOrUpdateResponse
     */
    public function dsgUserGroupAddOrUpdateWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgUserGroupAddOrUpdateShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->userGroups)) {
            $request->userGroupsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->userGroups, 'UserGroups', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->userGroupsShrink)) {
            $query['UserGroups'] = $request->userGroupsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgUserGroupAddOrUpdate',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupAddOrUpdateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds or modifies a user group.
     *  *
     * @param DsgUserGroupAddOrUpdateRequest $request DsgUserGroupAddOrUpdateRequest
     *
     * @return DsgUserGroupAddOrUpdateResponse DsgUserGroupAddOrUpdateResponse
     */
    public function dsgUserGroupAddOrUpdate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupAddOrUpdateWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a user group configured in Data Security Guard.
     *  *
     * @param DsgUserGroupDeleteRequest $tmpReq  DsgUserGroupDeleteRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupDeleteResponse DsgUserGroupDeleteResponse
     */
    public function dsgUserGroupDeleteWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgUserGroupDeleteShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgUserGroupDelete',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupDeleteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a user group configured in Data Security Guard.
     *  *
     * @param DsgUserGroupDeleteRequest $request DsgUserGroupDeleteRequest
     *
     * @return DsgUserGroupDeleteResponse DsgUserGroupDeleteResponse
     */
    public function dsgUserGroupDelete($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupDeleteWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of MaxCompute roles that can be selected by the members of a user group when the user group is created or modified by the tenant in Data Security Guard.
     *  *
     * @param DsgUserGroupGetOdpsRoleGroupsRequest $request DsgUserGroupGetOdpsRoleGroupsRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupGetOdpsRoleGroupsResponse DsgUserGroupGetOdpsRoleGroupsResponse
     */
    public function dsgUserGroupGetOdpsRoleGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgUserGroupGetOdpsRoleGroups',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupGetOdpsRoleGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of MaxCompute roles that can be selected by the members of a user group when the user group is created or modified by the tenant in Data Security Guard.
     *  *
     * @param DsgUserGroupGetOdpsRoleGroupsRequest $request DsgUserGroupGetOdpsRoleGroupsRequest
     *
     * @return DsgUserGroupGetOdpsRoleGroupsResponse DsgUserGroupGetOdpsRoleGroupsResponse
     */
    public function dsgUserGroupGetOdpsRoleGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupGetOdpsRoleGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of user groups in Data Security Guard.
     *  *
     * @param DsgUserGroupQueryListRequest $request DsgUserGroupQueryListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupQueryListResponse DsgUserGroupQueryListResponse
     */
    public function dsgUserGroupQueryListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgUserGroupQueryList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupQueryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of user groups in Data Security Guard.
     *  *
     * @param DsgUserGroupQueryListRequest $request DsgUserGroupQueryListRequest
     *
     * @return DsgUserGroupQueryListResponse DsgUserGroupQueryListResponse
     */
    public function dsgUserGroupQueryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupQueryListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of users or roles of the current tenant.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupQueryUserListResponse DsgUserGroupQueryUserListResponse
     */
    public function dsgUserGroupQueryUserListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DsgUserGroupQueryUserList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupQueryUserListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of users or roles of the current tenant.
     *  *
     * @return DsgUserGroupQueryUserListResponse DsgUserGroupQueryUserListResponse
     */
    public function dsgUserGroupQueryUserList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupQueryUserListWithOptions($runtime);
    }

    /**
     * @summary Adds or modifies a data masking whitelist.
     *  *
     * @param DsgWhiteListAddOrUpdateRequest $tmpReq  DsgWhiteListAddOrUpdateRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgWhiteListAddOrUpdateResponse DsgWhiteListAddOrUpdateResponse
     */
    public function dsgWhiteListAddOrUpdateWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgWhiteListAddOrUpdateShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->whiteLists)) {
            $request->whiteListsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->whiteLists, 'WhiteLists', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->whiteListsShrink)) {
            $query['WhiteLists'] = $request->whiteListsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgWhiteListAddOrUpdate',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgWhiteListAddOrUpdateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds or modifies a data masking whitelist.
     *  *
     * @param DsgWhiteListAddOrUpdateRequest $request DsgWhiteListAddOrUpdateRequest
     *
     * @return DsgWhiteListAddOrUpdateResponse DsgWhiteListAddOrUpdateResponse
     */
    public function dsgWhiteListAddOrUpdate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgWhiteListAddOrUpdateWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a data masking whitelist configured in Data Security Guard.
     *  *
     * @param DsgWhiteListDeleteListRequest $tmpReq  DsgWhiteListDeleteListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgWhiteListDeleteListResponse DsgWhiteListDeleteListResponse
     */
    public function dsgWhiteListDeleteListWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgWhiteListDeleteListShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgWhiteListDeleteList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgWhiteListDeleteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a data masking whitelist configured in Data Security Guard.
     *  *
     * @param DsgWhiteListDeleteListRequest $request DsgWhiteListDeleteListRequest
     *
     * @return DsgWhiteListDeleteListResponse DsgWhiteListDeleteListResponse
     */
    public function dsgWhiteListDeleteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgWhiteListDeleteListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a data masking whitelist.
     *  *
     * @param DsgWhiteListQueryListRequest $request DsgWhiteListQueryListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgWhiteListQueryListResponse DsgWhiteListQueryListResponse
     */
    public function dsgWhiteListQueryListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgWhiteListQueryList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgWhiteListQueryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a data masking whitelist.
     *  *
     * @param DsgWhiteListQueryListRequest $request DsgWhiteListQueryListRequest
     *
     * @return DsgWhiteListQueryListResponse DsgWhiteListQueryListResponse
     */
    public function dsgWhiteListQueryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgWhiteListQueryListWithOptions($request, $runtime);
    }

    /**
     * @summary Edits a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
     *  *
     * @param EditRecognizeRuleRequest $request EditRecognizeRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return EditRecognizeRuleResponse EditRecognizeRuleResponse
     */
    public function editRecognizeRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->accountName)) {
            $body['AccountName'] = $request->accountName;
        }
        if (!Utils::isUnset($request->colExclude)) {
            $body['ColExclude'] = $request->colExclude;
        }
        if (!Utils::isUnset($request->colScan)) {
            $body['ColScan'] = $request->colScan;
        }
        if (!Utils::isUnset($request->commentScan)) {
            $body['CommentScan'] = $request->commentScan;
        }
        if (!Utils::isUnset($request->contentScan)) {
            $body['ContentScan'] = $request->contentScan;
        }
        if (!Utils::isUnset($request->hitThreshold)) {
            $body['HitThreshold'] = $request->hitThreshold;
        }
        if (!Utils::isUnset($request->levelName)) {
            $body['LevelName'] = $request->levelName;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeParent)) {
            $body['NodeParent'] = $request->nodeParent;
        }
        if (!Utils::isUnset($request->operationType)) {
            $body['OperationType'] = $request->operationType;
        }
        if (!Utils::isUnset($request->recognizeRules)) {
            $body['RecognizeRules'] = $request->recognizeRules;
        }
        if (!Utils::isUnset($request->recognizeRulesType)) {
            $body['RecognizeRulesType'] = $request->recognizeRulesType;
        }
        if (!Utils::isUnset($request->sensitiveDescription)) {
            $body['SensitiveDescription'] = $request->sensitiveDescription;
        }
        if (!Utils::isUnset($request->sensitiveId)) {
            $body['SensitiveId'] = $request->sensitiveId;
        }
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        if (!Utils::isUnset($request->level)) {
            $body['level'] = $request->level;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'EditRecognizeRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EditRecognizeRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Edits a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
     *  *
     * @param EditRecognizeRuleRequest $request EditRecognizeRuleRequest
     *
     * @return EditRecognizeRuleResponse EditRecognizeRuleResponse
     */
    public function editRecognizeRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->editRecognizeRuleWithOptions($request, $runtime);
    }

    /**
     * @param EstablishRelationTableToBusinessRequest $request EstablishRelationTableToBusinessRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return EstablishRelationTableToBusinessResponse EstablishRelationTableToBusinessResponse
     */
    public function establishRelationTableToBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessId)) {
            $body['BusinessId'] = $request->businessId;
        }
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $body['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'EstablishRelationTableToBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EstablishRelationTableToBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param EstablishRelationTableToBusinessRequest $request EstablishRelationTableToBusinessRequest
     *
     * @return EstablishRelationTableToBusinessResponse EstablishRelationTableToBusinessResponse
     */
    public function establishRelationTableToBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->establishRelationTableToBusinessWithOptions($request, $runtime);
    }

    /**
     * @summary Exports a list of data sources.
     *  *
     * @param ExportDataSourcesRequest $request ExportDataSourcesRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportDataSourcesResponse ExportDataSourcesResponse
     */
    public function exportDataSourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportDataSources',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportDataSourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Exports a list of data sources.
     *  *
     * @param ExportDataSourcesRequest $request ExportDataSourcesRequest
     *
     * @return ExportDataSourcesResponse ExportDataSourcesResponse
     */
    public function exportDataSources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportDataSourcesWithOptions($request, $runtime);
    }

    /**
     * @summary Generates an ID for an asynchronous thread that is used to create a synchronization task in Data Integration.
     *  *
     * @description DataWorks allows you to use the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to directly create a batch synchronization task in Data Integration. To create a real-time synchronization task or another type of synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can use the parameters as request parameters of [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) and call the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a real-time synchronization task or another type of synchronization task. DataWorks allows you to create real-time synchronization tasks and other types of synchronization tasks in Data Integration only in asynchronous mode.
     *  *
     * @param GenerateDISyncTaskConfigForCreatingRequest $request GenerateDISyncTaskConfigForCreatingRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return GenerateDISyncTaskConfigForCreatingResponse GenerateDISyncTaskConfigForCreatingResponse
     */
    public function generateDISyncTaskConfigForCreatingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskParam)) {
            $query['TaskParam'] = $request->taskParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GenerateDISyncTaskConfigForCreating',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GenerateDISyncTaskConfigForCreatingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Generates an ID for an asynchronous thread that is used to create a synchronization task in Data Integration.
     *  *
     * @description DataWorks allows you to use the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to directly create a batch synchronization task in Data Integration. To create a real-time synchronization task or another type of synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can use the parameters as request parameters of [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) and call the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a real-time synchronization task or another type of synchronization task. DataWorks allows you to create real-time synchronization tasks and other types of synchronization tasks in Data Integration only in asynchronous mode.
     *  *
     * @param GenerateDISyncTaskConfigForCreatingRequest $request GenerateDISyncTaskConfigForCreatingRequest
     *
     * @return GenerateDISyncTaskConfigForCreatingResponse GenerateDISyncTaskConfigForCreatingResponse
     */
    public function generateDISyncTaskConfigForCreating($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateDISyncTaskConfigForCreatingWithOptions($request, $runtime);
    }

    /**
     * @summary Generates the JSON for an asynchronous thread that is used to update a real-time synchronization task in Data Integration.
     *  *
     * @description DataWorks allows you to use only the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To update a real-time synchronization task, you must first call the GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the UpdateDISyncTask operation and use the parameters as request parameters to update a real-time synchronization task in Data Integration. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
     *  *
     * @param GenerateDISyncTaskConfigForUpdatingRequest $request GenerateDISyncTaskConfigForUpdatingRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return GenerateDISyncTaskConfigForUpdatingResponse GenerateDISyncTaskConfigForUpdatingResponse
     */
    public function generateDISyncTaskConfigForUpdatingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->taskParam)) {
            $query['TaskParam'] = $request->taskParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GenerateDISyncTaskConfigForUpdating',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GenerateDISyncTaskConfigForUpdatingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Generates the JSON for an asynchronous thread that is used to update a real-time synchronization task in Data Integration.
     *  *
     * @description DataWorks allows you to use only the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To update a real-time synchronization task, you must first call the GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the UpdateDISyncTask operation and use the parameters as request parameters to update a real-time synchronization task in Data Integration. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
     *  *
     * @param GenerateDISyncTaskConfigForUpdatingRequest $request GenerateDISyncTaskConfigForUpdatingRequest
     *
     * @return GenerateDISyncTaskConfigForUpdatingResponse GenerateDISyncTaskConfigForUpdatingResponse
     */
    public function generateDISyncTaskConfigForUpdating($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateDISyncTaskConfigForUpdatingWithOptions($request, $runtime);
    }

    /**
     * @summary Queries alert information based on the alert ID that is specified by the AlertId parameter.
     *  *
     * @param GetAlertMessageRequest $request GetAlertMessageRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAlertMessageResponse GetAlertMessageResponse
     */
    public function getAlertMessageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertId)) {
            $body['AlertId'] = $request->alertId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetAlertMessage',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAlertMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries alert information based on the alert ID that is specified by the AlertId parameter.
     *  *
     * @param GetAlertMessageRequest $request GetAlertMessageRequest
     *
     * @return GetAlertMessageResponse GetAlertMessageResponse
     */
    public function getAlertMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAlertMessageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a baseline based on its ID.
     *  *
     * @param GetBaselineRequest $request GetBaselineRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBaselineResponse GetBaselineResponse
     */
    public function getBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a baseline based on its ID.
     *  *
     * @param GetBaselineRequest $request GetBaselineRequest
     *
     * @return GetBaselineResponse GetBaselineResponse
     */
    public function getBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the configurations of a baseline.
     *  *
     * @param GetBaselineConfigRequest $request GetBaselineConfigRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBaselineConfigResponse GetBaselineConfigResponse
     */
    public function getBaselineConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBaselineConfig',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBaselineConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the configurations of a baseline.
     *  *
     * @param GetBaselineConfigRequest $request GetBaselineConfigRequest
     *
     * @return GetBaselineConfigResponse GetBaselineConfigResponse
     */
    public function getBaselineConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineConfigWithOptions($request, $runtime);
    }

    /**
     * @summary The information about the events that are associated with the instance.
     *  *
     * @param GetBaselineKeyPathRequest $request GetBaselineKeyPathRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBaselineKeyPathResponse GetBaselineKeyPathResponse
     */
    public function getBaselineKeyPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->inGroupId)) {
            $body['InGroupId'] = $request->inGroupId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBaselineKeyPath',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBaselineKeyPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The information about the events that are associated with the instance.
     *  *
     * @param GetBaselineKeyPathRequest $request GetBaselineKeyPathRequest
     *
     * @return GetBaselineKeyPathResponse GetBaselineKeyPathResponse
     */
    public function getBaselineKeyPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineKeyPathWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a baseline instance.
     *  *
     * @param GetBaselineStatusRequest $request GetBaselineStatusRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBaselineStatusResponse GetBaselineStatusResponse
     */
    public function getBaselineStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->inGroupId)) {
            $body['InGroupId'] = $request->inGroupId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBaselineStatus',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBaselineStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a baseline instance.
     *  *
     * @param GetBaselineStatusRequest $request GetBaselineStatusRequest
     *
     * @return GetBaselineStatusResponse GetBaselineStatusResponse
     */
    public function getBaselineStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineStatusWithOptions($request, $runtime);
    }

    /**
     * @param GetBusinessRequest $request GetBusinessRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBusinessResponse GetBusinessResponse
     */
    public function getBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessId)) {
            $body['BusinessId'] = $request->businessId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetBusinessRequest $request GetBusinessRequest
     *
     * @return GetBusinessResponse GetBusinessResponse
     */
    public function getBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBusinessWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of a table creation, update, or deletion task.
     *  *
     * @param GetDDLJobStatusRequest $request GetDDLJobStatusRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDDLJobStatusResponse GetDDLJobStatusResponse
     */
    public function getDDLJobStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDDLJobStatus',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDDLJobStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of a table creation, update, or deletion task.
     *  *
     * @param GetDDLJobStatusRequest $request GetDDLJobStatusRequest
     *
     * @return GetDDLJobStatusResponse GetDDLJobStatusResponse
     */
    public function getDDLJobStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDDLJobStatusWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *  *
     * @param GetDIAlarmRuleRequest $request GetDIAlarmRuleRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDIAlarmRuleResponse GetDIAlarmRuleResponse
     */
    public function getDIAlarmRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIAlarmRuleId)) {
            $body['DIAlarmRuleId'] = $request->DIAlarmRuleId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDIAlarmRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *  *
     * @param GetDIAlarmRuleRequest $request GetDIAlarmRuleRequest
     *
     * @return GetDIAlarmRuleResponse GetDIAlarmRuleResponse
     */
    public function getDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a new-version synchronization task created in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres.
     *  *
     * @param GetDIJobRequest $request GetDIJobRequest
     * @param RuntimeOptions  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDIJobResponse GetDIJobResponse
     */
    public function getDIJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->withDetails)) {
            $body['WithDetails'] = $request->withDetails;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a new-version synchronization task created in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres.
     *  *
     * @param GetDIJobRequest $request GetDIJobRequest
     *
     * @return GetDIJobResponse GetDIJobResponse
     */
    public function getDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of a real-time synchronization task or a data synchronization solution.
     *  *
     * @param GetDISyncInstanceInfoRequest $request GetDISyncInstanceInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDISyncInstanceInfoResponse GetDISyncInstanceInfoResponse
     */
    public function getDISyncInstanceInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDISyncInstanceInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDISyncInstanceInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of a real-time synchronization task or a data synchronization solution.
     *  *
     * @param GetDISyncInstanceInfoRequest $request GetDISyncInstanceInfoRequest
     *
     * @return GetDISyncInstanceInfoResponse GetDISyncInstanceInfoResponse
     */
    public function getDISyncInstanceInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDISyncInstanceInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a real-time synchronization task or a data synchronization solution.
     *  *
     * @param GetDISyncTaskRequest $request GetDISyncTaskRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDISyncTaskResponse GetDISyncTaskResponse
     */
    public function getDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a real-time synchronization task or a data synchronization solution.
     *  *
     * @param GetDISyncTaskRequest $request GetDISyncTaskRequest
     *
     * @return GetDISyncTaskResponse GetDISyncTaskResponse
     */
    public function getDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a directed acyclic graph (DAG). You can call the GetDag operation to query the information about the DAG for a manually triggered workflow, a manually triggered node, or a data backfill instance. However, you cannot query the information about the DAG for an auto triggered node or an auto triggered workflow.
     *  *
     * @description Supported DAG types:
     * *   MANUAL: DAG for a manually triggered workflow
     * *   SMOKE_TEST: DAG for a smoke testing workflow
     * *   SUPPLY_DATA: DAG for a data backfill instance
     * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
     * Supported DAG states:
     * *   CREATED
     * *   RUNNING
     * *   FAILURE
     * *   SUCCESS
     *  *
     * @param GetDagRequest  $request GetDagRequest
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDagResponse GetDagResponse
     */
    public function getDagWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->dagId)) {
            $body['DagId'] = $request->dagId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDag',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDagResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a directed acyclic graph (DAG). You can call the GetDag operation to query the information about the DAG for a manually triggered workflow, a manually triggered node, or a data backfill instance. However, you cannot query the information about the DAG for an auto triggered node or an auto triggered workflow.
     *  *
     * @description Supported DAG types:
     * *   MANUAL: DAG for a manually triggered workflow
     * *   SMOKE_TEST: DAG for a smoke testing workflow
     * *   SUPPLY_DATA: DAG for a data backfill instance
     * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
     * Supported DAG states:
     * *   CREATED
     * *   RUNNING
     * *   FAILURE
     * *   SUCCESS
     *  *
     * @param GetDagRequest $request GetDagRequest
     *
     * @return GetDagResponse GetDagResponse
     */
    public function getDag($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDagWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a DataService Studio API in the development state.
     *  *
     * @param GetDataServiceApiRequest $request GetDataServiceApiRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceApiResponse GetDataServiceApiResponse
     */
    public function getDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a DataService Studio API in the development state.
     *  *
     * @param GetDataServiceApiRequest $request GetDataServiceApiRequest
     *
     * @return GetDataServiceApiResponse GetDataServiceApiResponse
     */
    public function getDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the test results of an API in DataService Studio.
     *  *
     * @param GetDataServiceApiTestRequest $request GetDataServiceApiTestRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceApiTestResponse GetDataServiceApiTestResponse
     */
    public function getDataServiceApiTestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceApiTest',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceApiTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the test results of an API in DataService Studio.
     *  *
     * @param GetDataServiceApiTestRequest $request GetDataServiceApiTestRequest
     *
     * @return GetDataServiceApiTestResponse GetDataServiceApiTestResponse
     */
    public function getDataServiceApiTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceApiTestWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an application.
     *  *
     * @param GetDataServiceApplicationRequest $request GetDataServiceApplicationRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceApplicationResponse GetDataServiceApplicationResponse
     */
    public function getDataServiceApplicationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->applicationId)) {
            $body['ApplicationId'] = $request->applicationId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceApplication',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceApplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an application.
     *  *
     * @param GetDataServiceApplicationRequest $request GetDataServiceApplicationRequest
     *
     * @return GetDataServiceApplicationResponse GetDataServiceApplicationResponse
     */
    public function getDataServiceApplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceApplicationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a folder.
     *  *
     * @param GetDataServiceFolderRequest $request GetDataServiceFolderRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceFolderResponse GetDataServiceFolderResponse
     */
    public function getDataServiceFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a folder.
     *  *
     * @param GetDataServiceFolderRequest $request GetDataServiceFolderRequest
     *
     * @return GetDataServiceFolderResponse GetDataServiceFolderResponse
     */
    public function getDataServiceFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a business process.
     *  *
     * @param GetDataServiceGroupRequest $request GetDataServiceGroupRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceGroupResponse GetDataServiceGroupResponse
     */
    public function getDataServiceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceGroup',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a business process.
     *  *
     * @param GetDataServiceGroupRequest $request GetDataServiceGroupRequest
     *
     * @return GetDataServiceGroupResponse GetDataServiceGroupResponse
     */
    public function getDataServiceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a DataService Studio API in the published state.
     *  *
     * @param GetDataServicePublishedApiRequest $request GetDataServicePublishedApiRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServicePublishedApiResponse GetDataServicePublishedApiResponse
     */
    public function getDataServicePublishedApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServicePublishedApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServicePublishedApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a DataService Studio API in the published state.
     *  *
     * @param GetDataServicePublishedApiRequest $request GetDataServicePublishedApiRequest
     *
     * @return GetDataServicePublishedApiResponse GetDataServicePublishedApiResponse
     */
    public function getDataServicePublishedApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServicePublishedApiWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the metadata of a specified data source.
     *  *
     * @param GetDataSourceMetaRequest $request GetDataSourceMetaRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataSourceMetaResponse GetDataSourceMetaResponse
     */
    public function getDataSourceMetaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->datasourceName)) {
            $query['DatasourceName'] = $request->datasourceName;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDataSourceMeta',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataSourceMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the metadata of a specified data source.
     *  *
     * @param GetDataSourceMetaRequest $request GetDataSourceMetaRequest
     *
     * @return GetDataSourceMetaResponse GetDataSourceMetaResponse
     */
    public function getDataSourceMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataSourceMetaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a deployment package.
     *  *
     * @param GetDeploymentRequest $request GetDeploymentRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDeploymentResponse GetDeploymentResponse
     */
    public function getDeploymentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->deploymentId)) {
            $body['DeploymentId'] = $request->deploymentId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDeployment',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDeploymentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a deployment package.
     *  *
     * @param GetDeploymentRequest $request GetDeploymentRequest
     *
     * @return GetDeploymentResponse GetDeploymentResponse
     */
    public function getDeployment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDeploymentWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an extension.
     *  *
     * @param GetExtensionRequest $request GetExtensionRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetExtensionResponse GetExtensionResponse
     */
    public function getExtensionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->extensionCode)) {
            $query['ExtensionCode'] = $request->extensionCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetExtension',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetExtensionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an extension.
     *  *
     * @param GetExtensionRequest $request GetExtensionRequest
     *
     * @return GetExtensionResponse GetExtensionResponse
     */
    public function getExtension($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getExtensionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a file.
     *  *
     * @param GetFileRequest $request GetFileRequest
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileResponse GetFileResponse
     */
    public function getFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a file.
     *  *
     * @param GetFileRequest $request GetFileRequest
     *
     * @return GetFileResponse GetFileResponse
     */
    public function getFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the distribution of node types.
     *  *
     * @param GetFileTypeStatisticRequest $request GetFileTypeStatisticRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileTypeStatisticResponse GetFileTypeStatisticResponse
     */
    public function getFileTypeStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetFileTypeStatistic',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileTypeStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the distribution of node types.
     *  *
     * @param GetFileTypeStatisticRequest $request GetFileTypeStatisticRequest
     *
     * @return GetFileTypeStatisticResponse GetFileTypeStatisticResponse
     */
    public function getFileTypeStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileTypeStatisticWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a file version.
     *  *
     * @param GetFileVersionRequest $request GetFileVersionRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileVersionResponse GetFileVersionResponse
     */
    public function getFileVersionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->fileVersion)) {
            $body['FileVersion'] = $request->fileVersion;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetFileVersion',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a file version.
     *  *
     * @param GetFileVersionRequest $request GetFileVersionRequest
     *
     * @return GetFileVersionResponse GetFileVersionResponse
     */
    public function getFileVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileVersionWithOptions($request, $runtime);
    }

    /**
     * @param GetFolderRequest $request GetFolderRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFolderResponse GetFolderResponse
     */
    public function getFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->folderPath)) {
            $body['FolderPath'] = $request->folderPath;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetFolderRequest $request GetFolderRequest
     *
     * @return GetFolderResponse GetFolderResponse
     */
    public function getFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the data snapshot of an extension point based on the ID of a message in DataWorks OpenEvent when the related extension point event is triggered.
     *  *
     * @param GetIDEEventDetailRequest $request GetIDEEventDetailRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetIDEEventDetailResponse GetIDEEventDetailResponse
     */
    public function getIDEEventDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->messageId)) {
            $body['MessageId'] = $request->messageId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetIDEEventDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetIDEEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the data snapshot of an extension point based on the ID of a message in DataWorks OpenEvent when the related extension point event is triggered.
     *  *
     * @param GetIDEEventDetailRequest $request GetIDEEventDetailRequest
     *
     * @return GetIDEEventDetailResponse GetIDEEventDetailResponse
     */
    public function getIDEEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getIDEEventDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an instance.
     *  *
     * @param GetInstanceRequest $request GetInstanceRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceResponse GetInstanceResponse
     */
    public function getInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an instance.
     *  *
     * @param GetInstanceRequest $request GetInstanceRequest
     *
     * @return GetInstanceResponse GetInstanceResponse
     */
    public function getInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetInstanceConsumeTimeRank is deprecated
     *  *
     * @summary Queries the ranking of the running durations of instances.
     *  *
     * Deprecated
     *
     * @param GetInstanceConsumeTimeRankRequest $request GetInstanceConsumeTimeRankRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceConsumeTimeRankResponse GetInstanceConsumeTimeRankResponse
     */
    public function getInstanceConsumeTimeRankWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceConsumeTimeRank',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceConsumeTimeRankResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetInstanceConsumeTimeRank is deprecated
     *  *
     * @summary Queries the ranking of the running durations of instances.
     *  *
     * Deprecated
     *
     * @param GetInstanceConsumeTimeRankRequest $request GetInstanceConsumeTimeRankRequest
     *
     * @return GetInstanceConsumeTimeRankResponse GetInstanceConsumeTimeRankResponse
     */
    public function getInstanceConsumeTimeRank($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceConsumeTimeRankWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetInstanceCountTrend is deprecated
     *  *
     * @summary Queries the quantity trend of auto triggered instances.
     *  *
     * Deprecated
     *
     * @param GetInstanceCountTrendRequest $request GetInstanceCountTrendRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceCountTrendResponse GetInstanceCountTrendResponse
     */
    public function getInstanceCountTrendWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginDate)) {
            $body['BeginDate'] = $request->beginDate;
        }
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceCountTrend',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceCountTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetInstanceCountTrend is deprecated
     *  *
     * @summary Queries the quantity trend of auto triggered instances.
     *  *
     * Deprecated
     *
     * @param GetInstanceCountTrendRequest $request GetInstanceCountTrendRequest
     *
     * @return GetInstanceCountTrendResponse GetInstanceCountTrendResponse
     */
    public function getInstanceCountTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceCountTrendWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetInstanceErrorRank is deprecated
     *  *
     * @summary Queries the ranking of nodes on which errors occur within the last month.
     *  *
     * Deprecated
     *
     * @param GetInstanceErrorRankRequest $request GetInstanceErrorRankRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceErrorRankResponse GetInstanceErrorRankResponse
     */
    public function getInstanceErrorRankWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceErrorRank',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceErrorRankResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetInstanceErrorRank is deprecated
     *  *
     * @summary Queries the ranking of nodes on which errors occur within the last month.
     *  *
     * Deprecated
     *
     * @param GetInstanceErrorRankRequest $request GetInstanceErrorRankRequest
     *
     * @return GetInstanceErrorRankResponse GetInstanceErrorRankResponse
     */
    public function getInstanceErrorRank($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceErrorRankWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the logs of an instance.
     *  *
     * @description You may not obtain the instance logs that were generated more than seven days ago.
     *  *
     * @param GetInstanceLogRequest $request GetInstanceLogRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceLogResponse GetInstanceLogResponse
     */
    public function getInstanceLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceHistoryId)) {
            $body['InstanceHistoryId'] = $request->instanceHistoryId;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceLog',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the logs of an instance.
     *  *
     * @description You may not obtain the instance logs that were generated more than seven days ago.
     *  *
     * @param GetInstanceLogRequest $request GetInstanceLogRequest
     *
     * @return GetInstanceLogResponse GetInstanceLogResponse
     */
    public function getInstanceLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceLogWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetInstanceStatusCount is deprecated
     *  *
     * @summary Queries the statistics of instances in different states.
     *  *
     * Deprecated
     *
     * @param GetInstanceStatusCountRequest $request GetInstanceStatusCountRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceStatusCountResponse GetInstanceStatusCountResponse
     */
    public function getInstanceStatusCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceStatusCount',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceStatusCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetInstanceStatusCount is deprecated
     *  *
     * @summary Queries the statistics of instances in different states.
     *  *
     * Deprecated
     *
     * @param GetInstanceStatusCountRequest $request GetInstanceStatusCountRequest
     *
     * @return GetInstanceStatusCountResponse GetInstanceStatusCountResponse
     */
    public function getInstanceStatusCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceStatusCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the number of instances that are in each state.
     *  *
     * @param GetInstanceStatusStatisticRequest $request GetInstanceStatusStatisticRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceStatusStatisticResponse GetInstanceStatusStatisticResponse
     */
    public function getInstanceStatusStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->dagType)) {
            $body['DagType'] = $request->dagType;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schedulerPeriod)) {
            $body['SchedulerPeriod'] = $request->schedulerPeriod;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceStatusStatistic',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceStatusStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the number of instances that are in each state.
     *  *
     * @param GetInstanceStatusStatisticRequest $request GetInstanceStatusStatisticRequest
     *
     * @return GetInstanceStatusStatisticResponse GetInstanceStatusStatisticResponse
     */
    public function getInstanceStatusStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceStatusStatisticWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetManualDagInstances is deprecated
     *  *
     * @summary Queries the information about instances in a manually triggered workflow.
     *  *
     * Deprecated
     *
     * @param GetManualDagInstancesRequest $request GetManualDagInstancesRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetManualDagInstancesResponse GetManualDagInstancesResponse
     */
    public function getManualDagInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->dagId)) {
            $body['DagId'] = $request->dagId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetManualDagInstances',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetManualDagInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetManualDagInstances is deprecated
     *  *
     * @summary Queries the information about instances in a manually triggered workflow.
     *  *
     * Deprecated
     *
     * @param GetManualDagInstancesRequest $request GetManualDagInstancesRequest
     *
     * @return GetManualDagInstancesResponse GetManualDagInstancesResponse
     */
    public function getManualDagInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getManualDagInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a category tree.
     *  *
     * @param GetMetaCategoryRequest $request GetMetaCategoryRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaCategoryResponse GetMetaCategoryResponse
     */
    public function getMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentCategoryId)) {
            $query['ParentCategoryId'] = $request->parentCategoryId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a category tree.
     *  *
     * @param GetMetaCategoryRequest $request GetMetaCategoryRequest
     *
     * @return GetMetaCategoryResponse GetMetaCategoryResponse
     */
    public function getMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a collection.
     *  *
     * @param GetMetaCollectionDetailRequest $request GetMetaCollectionDetailRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaCollectionDetailResponse GetMetaCollectionDetailResponse
     */
    public function getMetaCollectionDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaCollectionDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaCollectionDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a collection.
     *  *
     * @param GetMetaCollectionDetailRequest $request GetMetaCollectionDetailRequest
     *
     * @return GetMetaCollectionDetailResponse GetMetaCollectionDetailResponse
     */
    public function getMetaCollectionDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaCollectionDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the lineage of a field in a metatable.
     *  *
     * @param GetMetaColumnLineageRequest $request GetMetaColumnLineageRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaColumnLineageResponse GetMetaColumnLineageResponse
     */
    public function getMetaColumnLineageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->columnGuid)) {
            $query['ColumnGuid'] = $request->columnGuid;
        }
        if (!Utils::isUnset($request->columnName)) {
            $query['ColumnName'] = $request->columnName;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->direction)) {
            $query['Direction'] = $request->direction;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaColumnLineage',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaColumnLineageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the lineage of a field in a metatable.
     *  *
     * @param GetMetaColumnLineageRequest $request GetMetaColumnLineageRequest
     *
     * @return GetMetaColumnLineageResponse GetMetaColumnLineageResponse
     */
    public function getMetaColumnLineage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaColumnLineageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the basic metadata information about a compute engine instance.
     *  *
     * @description The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
     * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
     *  *
     * @param GetMetaDBInfoRequest $request GetMetaDBInfoRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaDBInfoResponse GetMetaDBInfoResponse
     */
    public function getMetaDBInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaDBInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaDBInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the basic metadata information about a compute engine instance.
     *  *
     * @description The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
     * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
     *  *
     * @param GetMetaDBInfoRequest $request GetMetaDBInfoRequest
     *
     * @return GetMetaDBInfoResponse GetMetaDBInfoResponse
     */
    public function getMetaDBInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaDBInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries metatables in a compute engine instance.
     *  *
     * @param GetMetaDBTableListRequest $request GetMetaDBTableListRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaDBTableListResponse GetMetaDBTableListResponse
     */
    public function getMetaDBTableListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaDBTableList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaDBTableListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries metatables in a compute engine instance.
     *  *
     * @param GetMetaDBTableListRequest $request GetMetaDBTableListRequest
     *
     * @return GetMetaDBTableListResponse GetMetaDBTableListResponse
     */
    public function getMetaDBTableList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaDBTableListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the basic information about a metatable.
     *  *
     * @param GetMetaTableBasicInfoRequest $request GetMetaTableBasicInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableBasicInfoResponse GetMetaTableBasicInfoResponse
     */
    public function getMetaTableBasicInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableBasicInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableBasicInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the basic information about a metatable.
     *  *
     * @param GetMetaTableBasicInfoRequest $request GetMetaTableBasicInfoRequest
     *
     * @return GetMetaTableBasicInfoResponse GetMetaTableBasicInfoResponse
     */
    public function getMetaTableBasicInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableBasicInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the change logs of a metatable.
     *  *
     * @description > This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param GetMetaTableChangeLogRequest $request GetMetaTableChangeLogRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableChangeLogResponse GetMetaTableChangeLogResponse
     */
    public function getMetaTableChangeLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->changeType)) {
            $body['ChangeType'] = $request->changeType;
        }
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->objectType)) {
            $body['ObjectType'] = $request->objectType;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startDate)) {
            $body['StartDate'] = $request->startDate;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $body['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableChangeLog',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableChangeLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the change logs of a metatable.
     *  *
     * @description > This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param GetMetaTableChangeLogRequest $request GetMetaTableChangeLogRequest
     *
     * @return GetMetaTableChangeLogResponse GetMetaTableChangeLogResponse
     */
    public function getMetaTableChangeLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableChangeLogWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the field information of a metatable.
     *  *
     * @param GetMetaTableColumnRequest $request GetMetaTableColumnRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableColumnResponse GetMetaTableColumnResponse
     */
    public function getMetaTableColumnWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableColumn',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableColumnResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the field information of a metatable.
     *  *
     * @param GetMetaTableColumnRequest $request GetMetaTableColumnRequest
     *
     * @return GetMetaTableColumnResponse GetMetaTableColumnResponse
     */
    public function getMetaTableColumn($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableColumnWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the complete information about a metatable, including information about fields in the metatable.
     *  *
     * @param GetMetaTableFullInfoRequest $request GetMetaTableFullInfoRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableFullInfoResponse GetMetaTableFullInfoResponse
     */
    public function getMetaTableFullInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableFullInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableFullInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the complete information about a metatable, including information about fields in the metatable.
     *  *
     * @param GetMetaTableFullInfoRequest $request GetMetaTableFullInfoRequest
     *
     * @return GetMetaTableFullInfoResponse GetMetaTableFullInfoResponse
     */
    public function getMetaTableFullInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableFullInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the instructions on how to use a table.
     *  *
     * @param GetMetaTableIntroWikiRequest $request GetMetaTableIntroWikiRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableIntroWikiResponse GetMetaTableIntroWikiResponse
     */
    public function getMetaTableIntroWikiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->wikiVersion)) {
            $query['WikiVersion'] = $request->wikiVersion;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableIntroWiki',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableIntroWikiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the instructions on how to use a table.
     *  *
     * @param GetMetaTableIntroWikiRequest $request GetMetaTableIntroWikiRequest
     *
     * @return GetMetaTableIntroWikiResponse GetMetaTableIntroWikiResponse
     */
    public function getMetaTableIntroWiki($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableIntroWikiWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the lineage of a metatable.
     *  *
     * @param GetMetaTableLineageRequest $request GetMetaTableLineageRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableLineageResponse GetMetaTableLineageResponse
     */
    public function getMetaTableLineageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->direction)) {
            $query['Direction'] = $request->direction;
        }
        if (!Utils::isUnset($request->nextPrimaryKey)) {
            $query['NextPrimaryKey'] = $request->nextPrimaryKey;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableLineage',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableLineageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the lineage of a metatable.
     *  *
     * @param GetMetaTableLineageRequest $request GetMetaTableLineageRequest
     *
     * @return GetMetaTableLineageResponse GetMetaTableLineageResponse
     */
    public function getMetaTableLineage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableLineageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries metatables in a specified category.
     *  *
     * @param GetMetaTableListByCategoryRequest $request GetMetaTableListByCategoryRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableListByCategoryResponse GetMetaTableListByCategoryResponse
     */
    public function getMetaTableListByCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableListByCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableListByCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries metatables in a specified category.
     *  *
     * @param GetMetaTableListByCategoryRequest $request GetMetaTableListByCategoryRequest
     *
     * @return GetMetaTableListByCategoryResponse GetMetaTableListByCategoryResponse
     */
    public function getMetaTableListByCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableListByCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the output information of a metatable.
     *  *
     * @param GetMetaTableOutputRequest $request GetMetaTableOutputRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableOutputResponse GetMetaTableOutputResponse
     */
    public function getMetaTableOutputWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endDate)) {
            $query['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startDate)) {
            $query['StartDate'] = $request->startDate;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableOutput',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the output information of a metatable.
     *  *
     * @param GetMetaTableOutputRequest $request GetMetaTableOutputRequest
     *
     * @return GetMetaTableOutputResponse GetMetaTableOutputResponse
     */
    public function getMetaTableOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableOutputWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains a list of partitions in a metatable.
     *  *
     * @description You can call this operation to query only the partitions of a metatable in a MaxCompute or E-MapReduce (EMR) compute engine. If you query partitions of a metatable in an EMR compute engine, only DataLake clusters that use Data Lake Formation (DLF) to manage metadata and Hadoop clusters whose cluster version is earlier than 3.41.0 or 5.7.0 are supported.
     *  *
     * @param GetMetaTablePartitionRequest $tmpReq  GetMetaTablePartitionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTablePartitionResponse GetMetaTablePartitionResponse
     */
    public function getMetaTablePartitionWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new GetMetaTablePartitionShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->sortCriterion)) {
            $request->sortCriterionShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->sortCriterion, 'SortCriterion', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sortCriterionShrink)) {
            $query['SortCriterion'] = $request->sortCriterionShrink;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTablePartition',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTablePartitionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains a list of partitions in a metatable.
     *  *
     * @description You can call this operation to query only the partitions of a metatable in a MaxCompute or E-MapReduce (EMR) compute engine. If you query partitions of a metatable in an EMR compute engine, only DataLake clusters that use Data Lake Formation (DLF) to manage metadata and Hadoop clusters whose cluster version is earlier than 3.41.0 or 5.7.0 are supported.
     *  *
     * @param GetMetaTablePartitionRequest $request GetMetaTablePartitionRequest
     *
     * @return GetMetaTablePartitionResponse GetMetaTablePartitionResponse
     */
    public function getMetaTablePartition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTablePartitionWithOptions($request, $runtime);
    }

    /**
     * @summary 获取Table的产出任务列表
     *  *
     * @param GetMetaTableProducingTasksRequest $request GetMetaTableProducingTasksRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableProducingTasksResponse GetMetaTableProducingTasksResponse
     */
    public function getMetaTableProducingTasksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->dbName)) {
            $query['DbName'] = $request->dbName;
        }
        if (!Utils::isUnset($request->schemaName)) {
            $query['SchemaName'] = $request->schemaName;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableProducingTasks',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableProducingTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 获取Table的产出任务列表
     *  *
     * @param GetMetaTableProducingTasksRequest $request GetMetaTableProducingTasksRequest
     *
     * @return GetMetaTableProducingTasksResponse GetMetaTableProducingTasksResponse
     */
    public function getMetaTableProducingTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableProducingTasksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about the themes and levels of a metatable.
     *  *
     * @param GetMetaTableThemeLevelRequest $request GetMetaTableThemeLevelRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableThemeLevelResponse GetMetaTableThemeLevelResponse
     */
    public function getMetaTableThemeLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableThemeLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableThemeLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about the themes and levels of a metatable.
     *  *
     * @param GetMetaTableThemeLevelRequest $request GetMetaTableThemeLevelRequest
     *
     * @return GetMetaTableThemeLevelResponse GetMetaTableThemeLevelResponse
     */
    public function getMetaTableThemeLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableThemeLevelWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the progress of a migration task.
     *  *
     * @param GetMigrationProcessRequest $request GetMigrationProcessRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMigrationProcessResponse GetMigrationProcessResponse
     */
    public function getMigrationProcessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->migrationId)) {
            $body['MigrationId'] = $request->migrationId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetMigrationProcess',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMigrationProcessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the progress of a migration task.
     *  *
     * @param GetMigrationProcessRequest $request GetMigrationProcessRequest
     *
     * @return GetMigrationProcessResponse GetMigrationProcessResponse
     */
    public function getMigrationProcess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMigrationProcessWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a migration task.
     *  *
     * @param GetMigrationSummaryRequest $request GetMigrationSummaryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMigrationSummaryResponse GetMigrationSummaryResponse
     */
    public function getMigrationSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->migrationId)) {
            $body['MigrationId'] = $request->migrationId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetMigrationSummary',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMigrationSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a migration task.
     *  *
     * @param GetMigrationSummaryRequest $request GetMigrationSummaryRequest
     *
     * @return GetMigrationSummaryResponse GetMigrationSummaryResponse
     */
    public function getMigrationSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMigrationSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Indicates whether the request is successful.
     *  *
     * @param GetNodeRequest $request GetNodeRequest
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeResponse GetNodeResponse
     */
    public function getNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Indicates whether the request is successful.
     *  *
     * @param GetNodeRequest $request GetNodeRequest
     *
     * @return GetNodeResponse GetNodeResponse
     */
    public function getNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of instances.
     *  *
     * @param GetNodeChildrenRequest $request GetNodeChildrenRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeChildrenResponse GetNodeChildrenResponse
     */
    public function getNodeChildrenWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeChildren',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeChildrenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of instances.
     *  *
     * @param GetNodeChildrenRequest $request GetNodeChildrenRequest
     *
     * @return GetNodeChildrenResponse GetNodeChildrenResponse
     */
    public function getNodeChildren($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeChildrenWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the code of a node.
     *  *
     * @param GetNodeCodeRequest $request GetNodeCodeRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeCodeResponse GetNodeCodeResponse
     */
    public function getNodeCodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeCode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the code of a node.
     *  *
     * @param GetNodeCodeRequest $request GetNodeCodeRequest
     *
     * @return GetNodeCodeResponse GetNodeCodeResponse
     */
    public function getNodeCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeCodeWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetNodeOnBaseline is deprecated
     *  *
     * @summary Queries the nodes associated with a baseline.
     *  *
     * Deprecated
     *
     * @param GetNodeOnBaselineRequest $request GetNodeOnBaselineRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeOnBaselineResponse GetNodeOnBaselineResponse
     */
    public function getNodeOnBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeOnBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeOnBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetNodeOnBaseline is deprecated
     *  *
     * @summary Queries the nodes associated with a baseline.
     *  *
     * Deprecated
     *
     * @param GetNodeOnBaselineRequest $request GetNodeOnBaselineRequest
     *
     * @return GetNodeOnBaselineResponse GetNodeOnBaselineResponse
     */
    public function getNodeOnBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeOnBaselineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the ancestor nodes of a node.
     *  *
     * @param GetNodeParentsRequest $request GetNodeParentsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeParentsResponse GetNodeParentsResponse
     */
    public function getNodeParentsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeParents',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeParentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the ancestor nodes of a node.
     *  *
     * @param GetNodeParentsRequest $request GetNodeParentsRequest
     *
     * @return GetNodeParentsResponse GetNodeParentsResponse
     */
    public function getNodeParents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeParentsWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetNodeTypeListInfo is deprecated
     *  *
     * @summary Queries the information about node types, including the code and name of a node type.
     *  *
     * Deprecated
     *
     * @param GetNodeTypeListInfoRequest $request GetNodeTypeListInfoRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeTypeListInfoResponse GetNodeTypeListInfoResponse
     */
    public function getNodeTypeListInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->locale)) {
            $body['Locale'] = $request->locale;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeTypeListInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeTypeListInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetNodeTypeListInfo is deprecated
     *  *
     * @summary Queries the information about node types, including the code and name of a node type.
     *  *
     * Deprecated
     *
     * @param GetNodeTypeListInfoRequest $request GetNodeTypeListInfoRequest
     *
     * @return GetNodeTypeListInfoResponse GetNodeTypeListInfoResponse
     */
    public function getNodeTypeListInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeTypeListInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the records that are generated on a specified date for access to the high-risk sensitive data in all the DataWorks workspaces of a tenant.
     *  *
     * @param GetOpRiskDataRequest $request GetOpRiskDataRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpRiskDataResponse GetOpRiskDataResponse
     */
    public function getOpRiskDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpRiskData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpRiskDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the records that are generated on a specified date for access to the high-risk sensitive data in all the DataWorks workspaces of a tenant.
     *  *
     * @param GetOpRiskDataRequest $request GetOpRiskDataRequest
     *
     * @return GetOpRiskDataResponse GetOpRiskDataResponse
     */
    public function getOpRiskData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpRiskDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the records that are generated on a specified date for access to sensitive data in all the DataWorks workspaces of a tenant.
     *  *
     * @param GetOpSensitiveDataRequest $request GetOpSensitiveDataRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpSensitiveDataResponse GetOpSensitiveDataResponse
     */
    public function getOpSensitiveDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpSensitiveData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpSensitiveDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the records that are generated on a specified date for access to sensitive data in all the DataWorks workspaces of a tenant.
     *  *
     * @param GetOpSensitiveDataRequest $request GetOpSensitiveDataRequest
     *
     * @return GetOpSensitiveDataResponse GetOpSensitiveDataResponse
     */
    public function getOpSensitiveData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpSensitiveDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the option settings of an extension in a workspace.
     *  *
     * @param GetOptionValueForProjectRequest $request GetOptionValueForProjectRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOptionValueForProjectResponse GetOptionValueForProjectResponse
     */
    public function getOptionValueForProjectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->extensionCode)) {
            $body['ExtensionCode'] = $request->extensionCode;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetOptionValueForProject',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOptionValueForProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the option settings of an extension in a workspace.
     *  *
     * @param GetOptionValueForProjectRequest $request GetOptionValueForProjectRequest
     *
     * @return GetOptionValueForProjectResponse GetOptionValueForProjectResponse
     */
    public function getOptionValueForProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOptionValueForProjectWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a permission request order.
     *  *
     * @param GetPermissionApplyOrderDetailRequest $request GetPermissionApplyOrderDetailRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetPermissionApplyOrderDetailResponse GetPermissionApplyOrderDetailResponse
     */
    public function getPermissionApplyOrderDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->flowId)) {
            $query['FlowId'] = $request->flowId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetPermissionApplyOrderDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetPermissionApplyOrderDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a permission request order.
     *  *
     * @param GetPermissionApplyOrderDetailRequest $request GetPermissionApplyOrderDetailRequest
     *
     * @return GetPermissionApplyOrderDetailResponse GetPermissionApplyOrderDetailResponse
     */
    public function getPermissionApplyOrderDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPermissionApplyOrderDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a DataWorks workspace.
     *  *
     * @param GetProjectRequest $request GetProjectRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetProjectResponse GetProjectResponse
     */
    public function getProjectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $query['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetProject',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a DataWorks workspace.
     *  *
     * @param GetProjectRequest $request GetProjectRequest
     *
     * @return GetProjectResponse GetProjectResponse
     */
    public function getProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getProjectWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetProjectDetail is deprecated
     *  *
     * @summary Queries the information about a DataWorks workspace.
     *  *
     * Deprecated
     *
     * @param GetProjectDetailRequest $request GetProjectDetailRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetProjectDetailResponse GetProjectDetailResponse
     */
    public function getProjectDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetProjectDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetProjectDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetProjectDetail is deprecated
     *  *
     * @summary Queries the information about a DataWorks workspace.
     *  *
     * Deprecated
     *
     * @param GetProjectDetailRequest $request GetProjectDetailRequest
     *
     * @return GetProjectDetailResponse GetProjectDetailResponse
     */
    public function getProjectDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getProjectDetailWithOptions($request, $runtime);
    }

    /**
     * @param GetQualityEntityRequest $request GetQualityEntityRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetQualityEntityResponse GetQualityEntityResponse
     */
    public function getQualityEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->matchExpression)) {
            $body['MatchExpression'] = $request->matchExpression;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $body['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetQualityEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetQualityEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetQualityEntityRequest $request GetQualityEntityRequest
     *
     * @return GetQualityEntityResponse GetQualityEntityResponse
     */
    public function getQualityEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getQualityEntityWithOptions($request, $runtime);
    }

    /**
     * @param GetQualityFollowerRequest $request GetQualityFollowerRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetQualityFollowerResponse GetQualityFollowerResponse
     */
    public function getQualityFollowerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetQualityFollower',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetQualityFollowerRequest $request GetQualityFollowerRequest
     *
     * @return GetQualityFollowerResponse GetQualityFollowerResponse
     */
    public function getQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a monitoring rule.
     *  *
     * @param GetQualityRuleRequest $request GetQualityRuleRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetQualityRuleResponse GetQualityRuleResponse
     */
    public function getQualityRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $body['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetQualityRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a monitoring rule.
     *  *
     * @param GetQualityRuleRequest $request GetQualityRuleRequest
     *
     * @return GetQualityRuleResponse GetQualityRuleResponse
     */
    public function getQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getQualityRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a custom alert rule.
     *  *
     * @description ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetRemind\\&type=RPC\\&version=2020-05-18)
     *  *
     * @param GetRemindRequest $request GetRemindRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetRemindResponse GetRemindResponse
     */
    public function getRemindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->remindId)) {
            $body['RemindId'] = $request->remindId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetRemind',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a custom alert rule.
     *  *
     * @description ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetRemind\\&type=RPC\\&version=2020-05-18)
     *  *
     * @param GetRemindRequest $request GetRemindRequest
     *
     * @return GetRemindResponse GetRemindResponse
     */
    public function getRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRemindWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the latest sensitive data in all the DataWorks workspaces of a tenant.
     *  *
     * @param GetSensitiveDataRequest $request GetSensitiveDataRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSensitiveDataResponse GetSensitiveDataResponse
     */
    public function getSensitiveDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSensitiveData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSensitiveDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the latest sensitive data in all the DataWorks workspaces of a tenant.
     *  *
     * @param GetSensitiveDataRequest $request GetSensitiveDataRequest
     *
     * @return GetSensitiveDataResponse GetSensitiveDataResponse
     */
    public function getSensitiveData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSensitiveDataWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetSuccessInstanceTrend is deprecated
     *  *
     * @summary Queries the statistics of instances in different periods of a day.
     *  *
     * Deprecated
     *
     * @param GetSuccessInstanceTrendRequest $request GetSuccessInstanceTrendRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSuccessInstanceTrendResponse GetSuccessInstanceTrendResponse
     */
    public function getSuccessInstanceTrendWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetSuccessInstanceTrend',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSuccessInstanceTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetSuccessInstanceTrend is deprecated
     *  *
     * @summary Queries the statistics of instances in different periods of a day.
     *  *
     * Deprecated
     *
     * @param GetSuccessInstanceTrendRequest $request GetSuccessInstanceTrendRequest
     *
     * @return GetSuccessInstanceTrendResponse GetSuccessInstanceTrendResponse
     */
    public function getSuccessInstanceTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSuccessInstanceTrendWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about an event.
     *  *
     * @description ****
     *  *
     * @param GetTopicRequest $request GetTopicRequest
     * @param RuntimeOptions  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetTopicResponse GetTopicResponse
     */
    public function getTopicWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->topicId)) {
            $body['TopicId'] = $request->topicId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetTopic',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetTopicResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about an event.
     *  *
     * @description ****
     *  *
     * @param GetTopicRequest $request GetTopicRequest
     *
     * @return GetTopicResponse GetTopicResponse
     */
    public function getTopic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTopicWithOptions($request, $runtime);
    }

    /**
     * @param GetTopicInfluenceRequest $request GetTopicInfluenceRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetTopicInfluenceResponse GetTopicInfluenceResponse
     */
    public function getTopicInfluenceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->topicId)) {
            $body['TopicId'] = $request->topicId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetTopicInfluence',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetTopicInfluenceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetTopicInfluenceRequest $request GetTopicInfluenceRequest
     *
     * @return GetTopicInfluenceResponse GetTopicInfluenceResponse
     */
    public function getTopicInfluence($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTopicInfluenceWithOptions($request, $runtime);
    }

    /**
     * @summary Imports data sources from your on-premises machine to a specific DataWorks workspace.
     *  *
     * @description You can import self-managed data sources or data sources that are exported from other DataWorks workspaces to a specific DataWorks workspace.
     * *   To import a self-managed data source to a DataWorks workspace, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](https://help.aliyun.com/document_detail/181656.html).
     * *   For more information about how to export data sources from DataWorks workspaces to your on-premises machine, see [ExportDataSources](https://help.aliyun.com/document_detail/279570.html).
     *  *
     * @param ImportDataSourcesRequest $request ImportDataSourcesRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ImportDataSourcesResponse ImportDataSourcesResponse
     */
    public function importDataSourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dataSources)) {
            $query['DataSources'] = $request->dataSources;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ImportDataSources',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ImportDataSourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Imports data sources from your on-premises machine to a specific DataWorks workspace.
     *  *
     * @description You can import self-managed data sources or data sources that are exported from other DataWorks workspaces to a specific DataWorks workspace.
     * *   To import a self-managed data source to a DataWorks workspace, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](https://help.aliyun.com/document_detail/181656.html).
     * *   For more information about how to export data sources from DataWorks workspaces to your on-premises machine, see [ExportDataSources](https://help.aliyun.com/document_detail/279570.html).
     *  *
     * @param ImportDataSourcesRequest $request ImportDataSourcesRequest
     *
     * @return ImportDataSourcesResponse ImportDataSourcesResponse
     */
    public function importDataSources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->importDataSourcesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of alerts.
     *  *
     * @param ListAlertMessagesRequest $request ListAlertMessagesRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAlertMessagesResponse ListAlertMessagesResponse
     */
    public function listAlertMessagesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertMethods)) {
            $body['AlertMethods'] = $request->alertMethods;
        }
        if (!Utils::isUnset($request->alertRuleTypes)) {
            $body['AlertRuleTypes'] = $request->alertRuleTypes;
        }
        if (!Utils::isUnset($request->alertUser)) {
            $body['AlertUser'] = $request->alertUser;
        }
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->beginTime)) {
            $body['BeginTime'] = $request->beginTime;
        }
        if (!Utils::isUnset($request->endTime)) {
            $body['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remindId)) {
            $body['RemindId'] = $request->remindId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListAlertMessages',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAlertMessagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of alerts.
     *  *
     * @param ListAlertMessagesRequest $request ListAlertMessagesRequest
     *
     * @return ListAlertMessagesResponse ListAlertMessagesResponse
     */
    public function listAlertMessages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAlertMessagesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of baselines.
     *  *
     * @param ListBaselineConfigsRequest $request ListBaselineConfigsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBaselineConfigsResponse ListBaselineConfigsResponse
     */
    public function listBaselineConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineTypes)) {
            $body['BaselineTypes'] = $request->baselineTypes;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->searchText)) {
            $body['SearchText'] = $request->searchText;
        }
        if (!Utils::isUnset($request->useflag)) {
            $body['Useflag'] = $request->useflag;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListBaselineConfigs',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBaselineConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of baselines.
     *  *
     * @param ListBaselineConfigsRequest $request ListBaselineConfigsRequest
     *
     * @return ListBaselineConfigsResponse ListBaselineConfigsResponse
     */
    public function listBaselineConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselineConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of baseline instances.
     *  *
     * @param ListBaselineStatusesRequest $request ListBaselineStatusesRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBaselineStatusesResponse ListBaselineStatusesResponse
     */
    public function listBaselineStatusesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineTypes)) {
            $body['BaselineTypes'] = $request->baselineTypes;
        }
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->finishStatus)) {
            $body['FinishStatus'] = $request->finishStatus;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->searchText)) {
            $body['SearchText'] = $request->searchText;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->topicId)) {
            $body['TopicId'] = $request->topicId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListBaselineStatuses',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBaselineStatusesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of baseline instances.
     *  *
     * @param ListBaselineStatusesRequest $request ListBaselineStatusesRequest
     *
     * @return ListBaselineStatusesResponse ListBaselineStatusesResponse
     */
    public function listBaselineStatuses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselineStatusesWithOptions($request, $runtime);
    }

    /**
     * @summary Obtains a list of baselines.
     *  *
     * @param ListBaselinesRequest $request ListBaselinesRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBaselinesResponse ListBaselinesResponse
     */
    public function listBaselinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineTypes)) {
            $body['BaselineTypes'] = $request->baselineTypes;
        }
        if (!Utils::isUnset($request->enable)) {
            $body['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->searchText)) {
            $body['SearchText'] = $request->searchText;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListBaselines',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBaselinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Obtains a list of baselines.
     *  *
     * @param ListBaselinesRequest $request ListBaselinesRequest
     *
     * @return ListBaselinesResponse ListBaselinesResponse
     */
    public function listBaselines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of workflows.
     *  *
     * @param ListBusinessRequest $request ListBusinessRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBusinessResponse ListBusinessResponse
     */
    public function listBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of workflows.
     *  *
     * @param ListBusinessRequest $request ListBusinessRequest
     *
     * @return ListBusinessResponse ListBusinessResponse
     */
    public function listBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBusinessWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of compute engines that are associated with a DataWorks workspace.
     *  *
     * @param ListCalcEnginesRequest $request ListCalcEnginesRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCalcEnginesResponse ListCalcEnginesResponse
     */
    public function listCalcEnginesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->calcEngineType)) {
            $query['CalcEngineType'] = $request->calcEngineType;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCalcEngines',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCalcEnginesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of compute engines that are associated with a DataWorks workspace.
     *  *
     * @param ListCalcEnginesRequest $request ListCalcEnginesRequest
     *
     * @return ListCalcEnginesResponse ListCalcEnginesResponse
     */
    public function listCalcEngines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCalcEnginesWithOptions($request, $runtime);
    }

    /**
     * @summary 列出集群的配置信息
     *  *
     * @param ListClusterConfigsRequest $request ListClusterConfigsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClusterConfigsResponse ListClusterConfigsResponse
     */
    public function listClusterConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClusterConfigs',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClusterConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 列出集群的配置信息
     *  *
     * @param ListClusterConfigsRequest $request ListClusterConfigsRequest
     *
     * @return ListClusterConfigsResponse ListClusterConfigsResponse
     */
    public function listClusterConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary 列出注册到 DataWorks 的集群的信息
     *  *
     * @param ListClustersRequest $request ListClustersRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListClustersResponse ListClustersResponse
     */
    public function listClustersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListClusters',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListClustersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 列出注册到 DataWorks 的集群的信息
     *  *
     * @param ListClustersRequest $request ListClustersRequest
     *
     * @return ListClustersResponse ListClustersResponse
     */
    public function listClusters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClustersWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ListConnections is deprecated
     *  *
     * @summary Queries a list of data sources.
     *  *
     * Deprecated
     *
     * @param ListConnectionsRequest $request ListConnectionsRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListConnectionsResponse ListConnectionsResponse
     */
    public function listConnectionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListConnections',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ListConnections is deprecated
     *  *
     * @summary Queries a list of data sources.
     *  *
     * Deprecated
     *
     * @param ListConnectionsRequest $request ListConnectionsRequest
     *
     * @return ListConnectionsResponse ListConnectionsResponse
     */
    public function listConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listConnectionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of alert rules for a new-version synchronization task. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *  *
     * @param ListDIAlarmRulesRequest $request ListDIAlarmRulesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDIAlarmRulesResponse ListDIAlarmRulesResponse
     */
    public function listDIAlarmRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDIAlarmRules',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDIAlarmRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of alert rules for a new-version synchronization task. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *  *
     * @param ListDIAlarmRulesRequest $request ListDIAlarmRulesRequest
     *
     * @return ListDIAlarmRulesResponse ListDIAlarmRulesResponse
     */
    public function listDIAlarmRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDIAlarmRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of new-version synchronization tasks. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can call this operation to obtain only the basic information about the tasks. If you want to obtain the details of a task, call the GetDIJob operation.
     *  *
     * @param ListDIJobsRequest $request ListDIJobsRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDIJobsResponse ListDIJobsResponse
     */
    public function listDIJobsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->destinationDataSourceType)) {
            $body['DestinationDataSourceType'] = $request->destinationDataSourceType;
        }
        if (!Utils::isUnset($request->jobName)) {
            $body['JobName'] = $request->jobName;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->sourceDataSourceType)) {
            $body['SourceDataSourceType'] = $request->sourceDataSourceType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDIJobs',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDIJobsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of new-version synchronization tasks. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @description You can call this operation to obtain only the basic information about the tasks. If you want to obtain the details of a task, call the GetDIJob operation.
     *  *
     * @param ListDIJobsRequest $request ListDIJobsRequest
     *
     * @return ListDIJobsResponse ListDIJobsResponse
     */
    public function listDIJobs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDIJobsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the default global configurations of synchronization solutions in a specified DataWorks workspace.
     *  *
     * @description DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *  *
     * @param ListDIProjectConfigRequest $request ListDIProjectConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDIProjectConfigResponse ListDIProjectConfigResponse
     */
    public function listDIProjectConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destinationType)) {
            $query['DestinationType'] = $request->destinationType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->sourceType)) {
            $query['SourceType'] = $request->sourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListDIProjectConfig',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDIProjectConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the default global configurations of synchronization solutions in a specified DataWorks workspace.
     *  *
     * @description DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *  *
     * @param ListDIProjectConfigRequest $request ListDIProjectConfigRequest
     *
     * @return ListDIProjectConfigResponse ListDIProjectConfigResponse
     */
    public function listDIProjectConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDIProjectConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of directed acyclic graphs (DAGs) for a single data backfill instance based on OpSeq.
     *  *
     * @description Supported DAG types:
     * *   MANUAL: DAG for a manually triggered workflow
     * *   SMOKE_TEST: DAG for a smoke testing workflow
     * *   SUPPLY_DATA: DAG for a data backfill instance
     * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
     * Supported DAG states:
     * *   CREATED: The DAG is created.
     * *   RUNNING: The DAG is running.
     * *   FAILURE: The DAG fails to run.
     * *   SUCCESS: The DAG is successfully run.
     *  *
     * @param ListDagsRequest $request ListDagsRequest
     * @param RuntimeOptions  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDagsResponse ListDagsResponse
     */
    public function listDagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->opSeq)) {
            $body['OpSeq'] = $request->opSeq;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of directed acyclic graphs (DAGs) for a single data backfill instance based on OpSeq.
     *  *
     * @description Supported DAG types:
     * *   MANUAL: DAG for a manually triggered workflow
     * *   SMOKE_TEST: DAG for a smoke testing workflow
     * *   SUPPLY_DATA: DAG for a data backfill instance
     * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
     * Supported DAG states:
     * *   CREATED: The DAG is created.
     * *   RUNNING: The DAG is running.
     * *   FAILURE: The DAG fails to run.
     * *   SUCCESS: The DAG is successfully run.
     *  *
     * @param ListDagsRequest $request ListDagsRequest
     *
     * @return ListDagsResponse ListDagsResponse
     */
    public function listDags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDagsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the APIs on which other users are granted the access permissions.
     *  *
     * @param ListDataServiceApiAuthoritiesRequest $request ListDataServiceApiAuthoritiesRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceApiAuthoritiesResponse ListDataServiceApiAuthoritiesResponse
     */
    public function listDataServiceApiAuthoritiesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $body = [];
        if (!Utils::isUnset($request->apiNameKeyword)) {
            $body['ApiNameKeyword'] = $request->apiNameKeyword;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceApiAuthorities',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceApiAuthoritiesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the APIs on which other users are granted the access permissions.
     *  *
     * @param ListDataServiceApiAuthoritiesRequest $request ListDataServiceApiAuthoritiesRequest
     *
     * @return ListDataServiceApiAuthoritiesResponse ListDataServiceApiAuthoritiesResponse
     */
    public function listDataServiceApiAuthorities($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApiAuthoritiesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the test records of a DataService Studio API. This API operation allows you to query only the test records that are generated within the previous month.
     *  *
     * @param ListDataServiceApiTestRequest $request ListDataServiceApiTestRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceApiTestResponse ListDataServiceApiTestResponse
     */
    public function listDataServiceApiTestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceApiTest',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceApiTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the test records of a DataService Studio API. This API operation allows you to query only the test records that are generated within the previous month.
     *  *
     * @param ListDataServiceApiTestRequest $request ListDataServiceApiTestRequest
     *
     * @return ListDataServiceApiTestResponse ListDataServiceApiTestResponse
     */
    public function listDataServiceApiTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApiTestWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of APIs in the development state.
     *  *
     * @param ListDataServiceApisRequest $request ListDataServiceApisRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceApisResponse ListDataServiceApisResponse
     */
    public function listDataServiceApisWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiNameKeyword)) {
            $body['ApiNameKeyword'] = $request->apiNameKeyword;
        }
        if (!Utils::isUnset($request->apiPathKeyword)) {
            $body['ApiPathKeyword'] = $request->apiPathKeyword;
        }
        if (!Utils::isUnset($request->creatorId)) {
            $body['CreatorId'] = $request->creatorId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceApis',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceApisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of APIs in the development state.
     *  *
     * @param ListDataServiceApisRequest $request ListDataServiceApisRequest
     *
     * @return ListDataServiceApisResponse ListDataServiceApisResponse
     */
    public function listDataServiceApis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApisWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the basic information of applications.
     *  *
     * @param ListDataServiceApplicationsRequest $request ListDataServiceApplicationsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceApplicationsResponse ListDataServiceApplicationsResponse
     */
    public function listDataServiceApplicationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectIdList)) {
            $body['ProjectIdList'] = $request->projectIdList;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceApplications',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceApplicationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the basic information of applications.
     *  *
     * @param ListDataServiceApplicationsRequest $request ListDataServiceApplicationsRequest
     *
     * @return ListDataServiceApplicationsResponse ListDataServiceApplicationsResponse
     */
    public function listDataServiceApplications($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApplicationsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the APIs that you are authorized to access.
     *  *
     * @param ListDataServiceAuthorizedApisRequest $request ListDataServiceAuthorizedApisRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceAuthorizedApisResponse ListDataServiceAuthorizedApisResponse
     */
    public function listDataServiceAuthorizedApisWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $body = [];
        if (!Utils::isUnset($request->apiNameKeyword)) {
            $body['ApiNameKeyword'] = $request->apiNameKeyword;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceAuthorizedApis',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceAuthorizedApisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the APIs that you are authorized to access.
     *  *
     * @param ListDataServiceAuthorizedApisRequest $request ListDataServiceAuthorizedApisRequest
     *
     * @return ListDataServiceAuthorizedApisResponse ListDataServiceAuthorizedApisResponse
     */
    public function listDataServiceAuthorizedApis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceAuthorizedApisWithOptions($request, $runtime);
    }

    /**
     * @summary Queries folders.
     *  *
     * @param ListDataServiceFoldersRequest $request ListDataServiceFoldersRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceFoldersResponse ListDataServiceFoldersResponse
     */
    public function listDataServiceFoldersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderNameKeyword)) {
            $body['FolderNameKeyword'] = $request->folderNameKeyword;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceFolders',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceFoldersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries folders.
     *  *
     * @param ListDataServiceFoldersRequest $request ListDataServiceFoldersRequest
     *
     * @return ListDataServiceFoldersResponse ListDataServiceFoldersResponse
     */
    public function listDataServiceFolders($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceFoldersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries business processes.
     *  *
     * @param ListDataServiceGroupsRequest $request ListDataServiceGroupsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceGroupsResponse ListDataServiceGroupsResponse
     */
    public function listDataServiceGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->groupNameKeyword)) {
            $body['GroupNameKeyword'] = $request->groupNameKeyword;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceGroups',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries business processes.
     *  *
     * @param ListDataServiceGroupsRequest $request ListDataServiceGroupsRequest
     *
     * @return ListDataServiceGroupsResponse ListDataServiceGroupsResponse
     */
    public function listDataServiceGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of APIs in the published state.
     *  *
     * @param ListDataServicePublishedApisRequest $request ListDataServicePublishedApisRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServicePublishedApisResponse ListDataServicePublishedApisResponse
     */
    public function listDataServicePublishedApisWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiNameKeyword)) {
            $body['ApiNameKeyword'] = $request->apiNameKeyword;
        }
        if (!Utils::isUnset($request->apiPathKeyword)) {
            $body['ApiPathKeyword'] = $request->apiPathKeyword;
        }
        if (!Utils::isUnset($request->creatorId)) {
            $body['CreatorId'] = $request->creatorId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServicePublishedApis',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServicePublishedApisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of APIs in the published state.
     *  *
     * @param ListDataServicePublishedApisRequest $request ListDataServicePublishedApisRequest
     *
     * @return ListDataServicePublishedApisResponse ListDataServicePublishedApisResponse
     */
    public function listDataServicePublishedApis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServicePublishedApisWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the data sources added to a DataWorks workspace.
     *  *
     * @param ListDataSourcesRequest $request ListDataSourcesRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataSourcesResponse ListDataSourcesResponse
     */
    public function listDataSourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListDataSources',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataSourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the data sources added to a DataWorks workspace.
     *  *
     * @param ListDataSourcesRequest $request ListDataSourcesRequest
     *
     * @return ListDataSourcesResponse ListDataSourcesResponse
     */
    public function listDataSources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataSourcesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of deployment packages. This operation is equivalent to viewing a list of deployment packages on the Deployment Packages page of the DataWorks console.
     *  *
     * @param ListDeploymentsRequest $request ListDeploymentsRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDeploymentsResponse ListDeploymentsResponse
     */
    public function listDeploymentsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->creator)) {
            $body['Creator'] = $request->creator;
        }
        if (!Utils::isUnset($request->endCreateTime)) {
            $body['EndCreateTime'] = $request->endCreateTime;
        }
        if (!Utils::isUnset($request->endExecuteTime)) {
            $body['EndExecuteTime'] = $request->endExecuteTime;
        }
        if (!Utils::isUnset($request->executor)) {
            $body['Executor'] = $request->executor;
        }
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDeployments',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDeploymentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of deployment packages. This operation is equivalent to viewing a list of deployment packages on the Deployment Packages page of the DataWorks console.
     *  *
     * @param ListDeploymentsRequest $request ListDeploymentsRequest
     *
     * @return ListDeploymentsResponse ListDeploymentsResponse
     */
    public function listDeployments($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDeploymentsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of built-in and custom extensions that are enabled in a workspace.
     *  *
     * @description For information about codes of extension point events, see [Development references: Extension point event codes](https://help.aliyun.com/document_detail/463357.html).
     *  *
     * @param ListEnabledExtensionsForProjectRequest $request ListEnabledExtensionsForProjectRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEnabledExtensionsForProjectResponse ListEnabledExtensionsForProjectResponse
     */
    public function listEnabledExtensionsForProjectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->eventCode)) {
            $body['EventCode'] = $request->eventCode;
        }
        if (!Utils::isUnset($request->fileType)) {
            $body['FileType'] = $request->fileType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListEnabledExtensionsForProject',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListEnabledExtensionsForProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of built-in and custom extensions that are enabled in a workspace.
     *  *
     * @description For information about codes of extension point events, see [Development references: Extension point event codes](https://help.aliyun.com/document_detail/463357.html).
     *  *
     * @param ListEnabledExtensionsForProjectRequest $request ListEnabledExtensionsForProjectRequest
     *
     * @return ListEnabledExtensionsForProjectResponse ListEnabledExtensionsForProjectResponse
     */
    public function listEnabledExtensionsForProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEnabledExtensionsForProjectWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of entities by tag. Only entities of the maxcompute-table type are supported.
     *  *
     * @param ListEntitiesByTagsRequest $tmpReq  ListEntitiesByTagsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEntitiesByTagsResponse ListEntitiesByTagsResponse
     */
    public function listEntitiesByTagsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListEntitiesByTagsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListEntitiesByTags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListEntitiesByTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of entities by tag. Only entities of the maxcompute-table type are supported.
     *  *
     * @param ListEntitiesByTagsRequest $request ListEntitiesByTagsRequest
     *
     * @return ListEntitiesByTagsResponse ListEntitiesByTagsResponse
     */
    public function listEntitiesByTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEntitiesByTagsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of tags of an entity. Only entities of the maxcompute-table type are supported.
     *  *
     * @param ListEntityTagsRequest $request ListEntityTagsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEntityTagsResponse ListEntityTagsResponse
     */
    public function listEntityTagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListEntityTags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListEntityTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of tags of an entity. Only entities of the maxcompute-table type are supported.
     *  *
     * @param ListEntityTagsRequest $request ListEntityTagsRequest
     *
     * @return ListEntityTagsResponse ListEntityTagsResponse
     */
    public function listEntityTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEntityTagsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of extensions.
     *  *
     * @param ListExtensionsRequest $request ListExtensionsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListExtensionsResponse ListExtensionsResponse
     */
    public function listExtensionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListExtensions',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListExtensionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of extensions.
     *  *
     * @param ListExtensionsRequest $request ListExtensionsRequest
     *
     * @return ListExtensionsResponse ListExtensionsResponse
     */
    public function listExtensions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listExtensionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about node types, such as the code and name.
     *  *
     * @param ListFileTypeRequest $request ListFileTypeRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileTypeResponse ListFileTypeResponse
     */
    public function listFileTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->locale)) {
            $body['Locale'] = $request->locale;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListFileType',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about node types, such as the code and name.
     *  *
     * @param ListFileTypeRequest $request ListFileTypeRequest
     *
     * @return ListFileTypeResponse ListFileTypeResponse
     */
    public function listFileType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileTypeWithOptions($request, $runtime);
    }

    /**
     * @param ListFileVersionsRequest $request ListFileVersionsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileVersionsResponse ListFileVersionsResponse
     */
    public function listFileVersionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListFileVersions',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileVersionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListFileVersionsRequest $request ListFileVersionsRequest
     *
     * @return ListFileVersionsResponse ListFileVersionsResponse
     */
    public function listFileVersions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileVersionsWithOptions($request, $runtime);
    }

    /**
     * @param ListFilesRequest $request ListFilesRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFilesResponse ListFilesResponse
     */
    public function listFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->exactFileName)) {
            $body['ExactFileName'] = $request->exactFileName;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileIdIn)) {
            $body['FileIdIn'] = $request->fileIdIn;
        }
        if (!Utils::isUnset($request->fileTypes)) {
            $body['FileTypes'] = $request->fileTypes;
        }
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->needAbsoluteFolderPath)) {
            $body['NeedAbsoluteFolderPath'] = $request->needAbsoluteFolderPath;
        }
        if (!Utils::isUnset($request->needContent)) {
            $body['NeedContent'] = $request->needContent;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->useType)) {
            $body['UseType'] = $request->useType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListFiles',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListFilesRequest $request ListFilesRequest
     *
     * @return ListFilesResponse ListFilesResponse
     */
    public function listFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFilesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of folders.
     *  *
     * @param ListFoldersRequest $request ListFoldersRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFoldersResponse ListFoldersResponse
     */
    public function listFoldersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentFolderPath)) {
            $body['ParentFolderPath'] = $request->parentFolderPath;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListFolders',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFoldersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of folders.
     *  *
     * @param ListFoldersRequest $request ListFoldersRequest
     *
     * @return ListFoldersResponse ListFoldersResponse
     */
    public function listFolders($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFoldersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about inner nodes. For example, you can call this operation to query the inner nodes of a node group or a do-while node. You cannot call this operation to query the inner nodes of a PAI node.
     *  *
     * @param ListInnerNodesRequest $request ListInnerNodesRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInnerNodesResponse ListInnerNodesResponse
     */
    public function listInnerNodesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeName)) {
            $body['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->outerNodeId)) {
            $body['OuterNodeId'] = $request->outerNodeId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->programType)) {
            $body['ProgramType'] = $request->programType;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListInnerNodes',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInnerNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about inner nodes. For example, you can call this operation to query the inner nodes of a node group or a do-while node. You cannot call this operation to query the inner nodes of a PAI node.
     *  *
     * @param ListInnerNodesRequest $request ListInnerNodesRequest
     *
     * @return ListInnerNodesResponse ListInnerNodesResponse
     */
    public function listInnerNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInnerNodesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the trend of the number of auto triggered node instances within a specified period of time.
     *  *
     * @param ListInstanceAmountRequest $request ListInstanceAmountRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceAmountResponse ListInstanceAmountResponse
     */
    public function listInstanceAmountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginDate)) {
            $body['BeginDate'] = $request->beginDate;
        }
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceAmount',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceAmountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the trend of the number of auto triggered node instances within a specified period of time.
     *  *
     * @param ListInstanceAmountRequest $request ListInstanceAmountRequest
     *
     * @return ListInstanceAmountResponse ListInstanceAmountResponse
     */
    public function listInstanceAmount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceAmountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about the historical records of all instances. One historical record is generated if an instance is rerun once.
     *  *
     * @param ListInstanceHistoryRequest $request ListInstanceHistoryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceHistoryResponse ListInstanceHistoryResponse
     */
    public function listInstanceHistoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceHistory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceHistoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about the historical records of all instances. One historical record is generated if an instance is rerun once.
     *  *
     * @param ListInstanceHistoryRequest $request ListInstanceHistoryRequest
     *
     * @return ListInstanceHistoryResponse ListInstanceHistoryResponse
     */
    public function listInstanceHistory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceHistoryWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the directed acyclic graph (DAG). You can set this parameter to the value of the DagId parameter returned by the [RunCycleDagNodes](https://help.aliyun.com/document_detail/212961.html), [RunSmokeTest](https://help.aliyun.com/document_detail/212949.html), or [RunManualDagNodes](https://help.aliyun.com/document_detail/212830.html) operation based on your business requirements. The RunManualDagNodes operation is used to backfill data, the RunSmokeTest operation is used to perform smoke testing, and the RunManualDagNodes operation is used to run nodes in a manually triggered workflow.
     *  *
     * @param ListInstancesRequest $request ListInstancesRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstancesResponse ListInstancesResponse
     */
    public function listInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginBizdate)) {
            $body['BeginBizdate'] = $request->beginBizdate;
        }
        if (!Utils::isUnset($request->bizName)) {
            $body['BizName'] = $request->bizName;
        }
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->dagId)) {
            $body['DagId'] = $request->dagId;
        }
        if (!Utils::isUnset($request->endBizdate)) {
            $body['EndBizdate'] = $request->endBizdate;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $body['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->orderBy)) {
            $body['OrderBy'] = $request->orderBy;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->programType)) {
            $body['ProgramType'] = $request->programType;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListInstances',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the directed acyclic graph (DAG). You can set this parameter to the value of the DagId parameter returned by the [RunCycleDagNodes](https://help.aliyun.com/document_detail/212961.html), [RunSmokeTest](https://help.aliyun.com/document_detail/212949.html), or [RunManualDagNodes](https://help.aliyun.com/document_detail/212830.html) operation based on your business requirements. The RunManualDagNodes operation is used to backfill data, the RunSmokeTest operation is used to perform smoke testing, and the RunManualDagNodes operation is used to run nodes in a manually triggered workflow.
     *  *
     * @param ListInstancesRequest $request ListInstancesRequest
     *
     * @return ListInstancesResponse ListInstancesResponse
     */
    public function listInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the ancestor or descendant lineage of an entity.
     *  *
     * @param ListLineageRequest $request ListLineageRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLineageResponse ListLineageResponse
     */
    public function listLineageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->direction)) {
            $query['Direction'] = $request->direction;
        }
        if (!Utils::isUnset($request->entityQualifiedName)) {
            $query['EntityQualifiedName'] = $request->entityQualifiedName;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListLineage',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListLineageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the ancestor or descendant lineage of an entity.
     *  *
     * @param ListLineageRequest $request ListLineageRequest
     *
     * @return ListLineageResponse ListLineageResponse
     */
    public function listLineage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLineageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about instances in a manually triggered workflow.
     *  *
     * @param ListManualDagInstancesRequest $request ListManualDagInstancesRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListManualDagInstancesResponse ListManualDagInstancesResponse
     */
    public function listManualDagInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->dagId)) {
            $body['DagId'] = $request->dagId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListManualDagInstances',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListManualDagInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about instances in a manually triggered workflow.
     *  *
     * @param ListManualDagInstancesRequest $request ListManualDagInstancesRequest
     *
     * @return ListManualDagInstancesResponse ListManualDagInstancesResponse
     */
    public function listManualDagInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listManualDagInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary 查询DataWorks计量数据
     *  *
     * @param ListMeasureDataRequest $request ListMeasureDataRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMeasureDataResponse ListMeasureDataResponse
     */
    public function listMeasureDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->componentCode)) {
            $query['ComponentCode'] = $request->componentCode;
        }
        if (!Utils::isUnset($request->domainCode)) {
            $query['DomainCode'] = $request->domainCode;
        }
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListMeasureData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMeasureDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 查询DataWorks计量数据
     *  *
     * @param ListMeasureDataRequest $request ListMeasureDataRequest
     *
     * @return ListMeasureDataResponse ListMeasureDataResponse
     */
    public function listMeasureData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMeasureDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the entities in a collection.
     *  *
     * @param ListMetaCollectionEntitiesRequest $request ListMetaCollectionEntitiesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMetaCollectionEntitiesResponse ListMetaCollectionEntitiesResponse
     */
    public function listMetaCollectionEntitiesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->collectionQualifiedName)) {
            $query['CollectionQualifiedName'] = $request->collectionQualifiedName;
        }
        if (!Utils::isUnset($request->entityType)) {
            $query['EntityType'] = $request->entityType;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListMetaCollectionEntities',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMetaCollectionEntitiesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the entities in a collection.
     *  *
     * @param ListMetaCollectionEntitiesRequest $request ListMetaCollectionEntitiesRequest
     *
     * @return ListMetaCollectionEntitiesResponse ListMetaCollectionEntitiesResponse
     */
    public function listMetaCollectionEntities($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMetaCollectionEntitiesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about collections. Collections include data albums that are displayed on the Data Map page and categories that are created in the data albums. You can call this API operation to query collections by type.
     *  *
     * @description The type can be ALBUM or ALBUM_CATEGORY. ALBUM indicates data albums. ALBUM_CATEGORY indicates categories.
     *  *
     * @param ListMetaCollectionsRequest $request ListMetaCollectionsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMetaCollectionsResponse ListMetaCollectionsResponse
     */
    public function listMetaCollectionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->administrator)) {
            $query['Administrator'] = $request->administrator;
        }
        if (!Utils::isUnset($request->collectionType)) {
            $query['CollectionType'] = $request->collectionType;
        }
        if (!Utils::isUnset($request->creator)) {
            $query['Creator'] = $request->creator;
        }
        if (!Utils::isUnset($request->follower)) {
            $query['Follower'] = $request->follower;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->orderBy)) {
            $query['OrderBy'] = $request->orderBy;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentQualifiedName)) {
            $query['ParentQualifiedName'] = $request->parentQualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListMetaCollections',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMetaCollectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about collections. Collections include data albums that are displayed on the Data Map page and categories that are created in the data albums. You can call this API operation to query collections by type.
     *  *
     * @description The type can be ALBUM or ALBUM_CATEGORY. ALBUM indicates data albums. ALBUM_CATEGORY indicates categories.
     *  *
     * @param ListMetaCollectionsRequest $request ListMetaCollectionsRequest
     *
     * @return ListMetaCollectionsResponse ListMetaCollectionsResponse
     */
    public function listMetaCollections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMetaCollectionsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of metadatabases.
     *  *
     * @param ListMetaDBRequest $request ListMetaDBRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMetaDBResponse ListMetaDBResponse
     */
    public function listMetaDBWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListMetaDB',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMetaDBResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of metadatabases.
     *  *
     * @param ListMetaDBRequest $request ListMetaDBRequest
     *
     * @return ListMetaDBResponse ListMetaDBResponse
     */
    public function listMetaDB($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMetaDBWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of migration tasks.
     *  *
     * @param ListMigrationsRequest $request ListMigrationsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMigrationsResponse ListMigrationsResponse
     */
    public function listMigrationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->migrationType)) {
            $body['MigrationType'] = $request->migrationType;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListMigrations',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMigrationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of migration tasks.
     *  *
     * @param ListMigrationsRequest $request ListMigrationsRequest
     *
     * @return ListMigrationsResponse ListMigrationsResponse
     */
    public function listMigrations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMigrationsWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ListNodeIO is deprecated
     *  *
     * @summary Queries the information about one level of ancestor or descendant nodes of a node.
     *  *
     * Deprecated
     *
     * @param ListNodeIORequest $request ListNodeIORequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodeIOResponse ListNodeIOResponse
     */
    public function listNodeIOWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->ioType)) {
            $body['IoType'] = $request->ioType;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodeIO',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodeIOResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ListNodeIO is deprecated
     *  *
     * @summary Queries the information about one level of ancestor or descendant nodes of a node.
     *  *
     * Deprecated
     *
     * @param ListNodeIORequest $request ListNodeIORequest
     *
     * @return ListNodeIOResponse ListNodeIOResponse
     */
    public function listNodeIO($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodeIOWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the input and output information about a node. Only the ancestor or descendant nodes at the nearest level can be queried each time.
     *  *
     * @param ListNodeInputOrOutputRequest $request ListNodeInputOrOutputRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodeInputOrOutputResponse ListNodeInputOrOutputResponse
     */
    public function listNodeInputOrOutputWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->ioType)) {
            $body['IoType'] = $request->ioType;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodeInputOrOutput',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodeInputOrOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the input and output information about a node. Only the ancestor or descendant nodes at the nearest level can be queried each time.
     *  *
     * @param ListNodeInputOrOutputRequest $request ListNodeInputOrOutputRequest
     *
     * @return ListNodeInputOrOutputResponse ListNodeInputOrOutputResponse
     */
    public function listNodeInputOrOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodeInputOrOutputWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the workspace.
     *  *
     * @param ListNodesRequest $request ListNodesRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodesResponse ListNodesResponse
     */
    public function listNodesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizName)) {
            $body['BizName'] = $request->bizName;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $body['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->programType)) {
            $body['ProgramType'] = $request->programType;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodes',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the workspace.
     *  *
     * @param ListNodesRequest $request ListNodesRequest
     *
     * @return ListNodesResponse ListNodesResponse
     */
    public function listNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries nodes in a baseline.
     *  *
     * @param ListNodesByBaselineRequest $request ListNodesByBaselineRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodesByBaselineResponse ListNodesByBaselineResponse
     */
    public function listNodesByBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodesByBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodesByBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries nodes in a baseline.
     *  *
     * @param ListNodesByBaselineRequest $request ListNodesByBaselineRequest
     *
     * @return ListNodesByBaselineResponse ListNodesByBaselineResponse
     */
    public function listNodesByBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodesByBaselineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries nodes based on the output of the nodes.
     *  *
     * @param ListNodesByOutputRequest $request ListNodesByOutputRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodesByOutputResponse ListNodesByOutputResponse
     */
    public function listNodesByOutputWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->outputs)) {
            $body['Outputs'] = $request->outputs;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodesByOutput',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodesByOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries nodes based on the output of the nodes.
     *  *
     * @param ListNodesByOutputRequest $request ListNodesByOutputRequest
     *
     * @return ListNodesByOutputResponse ListNodesByOutputResponse
     */
    public function listNodesByOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodesByOutputWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of permission request orders.
     *  *
     * @param ListPermissionApplyOrdersRequest $request ListPermissionApplyOrdersRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPermissionApplyOrdersResponse ListPermissionApplyOrdersResponse
     */
    public function listPermissionApplyOrdersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->engineType)) {
            $query['EngineType'] = $request->engineType;
        }
        if (!Utils::isUnset($request->flowStatus)) {
            $query['FlowStatus'] = $request->flowStatus;
        }
        if (!Utils::isUnset($request->maxComputeProjectName)) {
            $query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }
        if (!Utils::isUnset($request->orderType)) {
            $query['OrderType'] = $request->orderType;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->queryType)) {
            $query['QueryType'] = $request->queryType;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->workspaceId)) {
            $query['WorkspaceId'] = $request->workspaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPermissionApplyOrders',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPermissionApplyOrdersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of permission request orders.
     *  *
     * @param ListPermissionApplyOrdersRequest $request ListPermissionApplyOrdersRequest
     *
     * @return ListPermissionApplyOrdersResponse ListPermissionApplyOrdersResponse
     */
    public function listPermissionApplyOrders($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPermissionApplyOrdersWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ListProgramTypeCount is deprecated
     *  *
     * @summary Queries the distribution of different types of nodes.
     *  *
     * Deprecated
     *
     * @param ListProgramTypeCountRequest $request ListProgramTypeCountRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProgramTypeCountResponse ListProgramTypeCountResponse
     */
    public function listProgramTypeCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListProgramTypeCount',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProgramTypeCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ListProgramTypeCount is deprecated
     *  *
     * @summary Queries the distribution of different types of nodes.
     *  *
     * Deprecated
     *
     * @param ListProgramTypeCountRequest $request ListProgramTypeCountRequest
     *
     * @return ListProgramTypeCountResponse ListProgramTypeCountResponse
     */
    public function listProgramTypeCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProgramTypeCountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the IDs of the workspaces on which a specific Alibaba Cloud account or RAM user has permissions in a specific region.
     *  *
     * @description An Alibaba Cloud account can assume a role such as the developer, O\\&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
     *  *
     * @param ListProjectIdsRequest $request ListProjectIdsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProjectIdsResponse ListProjectIdsResponse
     */
    public function listProjectIdsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListProjectIds',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProjectIdsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the IDs of the workspaces on which a specific Alibaba Cloud account or RAM user has permissions in a specific region.
     *  *
     * @description An Alibaba Cloud account can assume a role such as the developer, O\\&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
     *  *
     * @param ListProjectIdsRequest $request ListProjectIdsRequest
     *
     * @return ListProjectIdsResponse ListProjectIdsResponse
     */
    public function listProjectIds($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectIdsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of existing members in a DataWorks workspace.
     *  *
     * @param ListProjectMembersRequest $request ListProjectMembersRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProjectMembersResponse ListProjectMembersResponse
     */
    public function listProjectMembersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListProjectMembers',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProjectMembersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of existing members in a DataWorks workspace.
     *  *
     * @param ListProjectMembersRequest $request ListProjectMembersRequest
     *
     * @return ListProjectMembersResponse ListProjectMembersResponse
     */
    public function listProjectMembers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectMembersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of roles in a DataWorks workspace.
     *  *
     * @description ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=ListProjectRoles\\&type=RPC\\&version=2020-05-18)
     *  *
     * @param ListProjectRolesRequest $request ListProjectRolesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProjectRolesResponse ListProjectRolesResponse
     */
    public function listProjectRolesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListProjectRoles',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProjectRolesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of roles in a DataWorks workspace.
     *  *
     * @description ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=ListProjectRoles\\&type=RPC\\&version=2020-05-18)
     *  *
     * @param ListProjectRolesRequest $request ListProjectRolesRequest
     *
     * @return ListProjectRolesResponse ListProjectRolesResponse
     */
    public function listProjectRoles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectRolesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of DataWorks workspaces of the tenant to which a user belongs.
     *  *
     * @param ListProjectsRequest $tmpReq  ListProjectsRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProjectsResponse ListProjectsResponse
     */
    public function listProjectsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListProjectsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceManagerResourceGroupId)) {
            $query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }
        if (!Utils::isUnset($request->tagsShrink)) {
            $query['Tags'] = $request->tagsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListProjects',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProjectsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of DataWorks workspaces of the tenant to which a user belongs.
     *  *
     * @param ListProjectsRequest $request ListProjectsRequest
     *
     * @return ListProjectsResponse ListProjectsResponse
     */
    public function listProjects($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of historical check results based on a partition filter expression.
     *  *
     * @description ****
     *  *
     * @param ListQualityResultsByEntityRequest $request ListQualityResultsByEntityRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListQualityResultsByEntityResponse ListQualityResultsByEntityResponse
     */
    public function listQualityResultsByEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->startDate)) {
            $body['StartDate'] = $request->startDate;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListQualityResultsByEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListQualityResultsByEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of historical check results based on a partition filter expression.
     *  *
     * @description ****
     *  *
     * @param ListQualityResultsByEntityRequest $request ListQualityResultsByEntityRequest
     *
     * @return ListQualityResultsByEntityResponse ListQualityResultsByEntityResponse
     */
    public function listQualityResultsByEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQualityResultsByEntityWithOptions($request, $runtime);
    }

    /**
     * @summary Queries monitoring results after the data quality of a data source or a compute engine is monitored based on monitoring rules.
     *  *
     * @param ListQualityResultsByRuleRequest $request ListQualityResultsByRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListQualityResultsByRuleResponse ListQualityResultsByRuleResponse
     */
    public function listQualityResultsByRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $body['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->startDate)) {
            $body['StartDate'] = $request->startDate;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListQualityResultsByRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListQualityResultsByRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries monitoring results after the data quality of a data source or a compute engine is monitored based on monitoring rules.
     *  *
     * @param ListQualityResultsByRuleRequest $request ListQualityResultsByRuleRequest
     *
     * @return ListQualityResultsByRuleResponse ListQualityResultsByRuleResponse
     */
    public function listQualityResultsByRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQualityResultsByRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries monitoring rules based on a partition filter expression.
     *  *
     * @param ListQualityRulesRequest $request ListQualityRulesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListQualityRulesResponse ListQualityRulesResponse
     */
    public function listQualityRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListQualityRules',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListQualityRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries monitoring rules based on a partition filter expression.
     *  *
     * @param ListQualityRulesRequest $request ListQualityRulesRequest
     *
     * @return ListQualityRulesResponse ListQualityRulesResponse
     */
    public function listQualityRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQualityRulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries synchronization tasks in Data Integration that use a specific data source.
     *  *
     * @param ListRefDISyncTasksRequest $request ListRefDISyncTasksRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListRefDISyncTasksResponse ListRefDISyncTasksResponse
     */
    public function listRefDISyncTasksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->datasourceName)) {
            $query['DatasourceName'] = $request->datasourceName;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->refType)) {
            $query['RefType'] = $request->refType;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListRefDISyncTasks',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListRefDISyncTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries synchronization tasks in Data Integration that use a specific data source.
     *  *
     * @param ListRefDISyncTasksRequest $request ListRefDISyncTasksRequest
     *
     * @return ListRefDISyncTasksResponse ListRefDISyncTasksResponse
     */
    public function listRefDISyncTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRefDISyncTasksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of custom alert rules.
     *  *
     * @param ListRemindsRequest $request ListRemindsRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListRemindsResponse ListRemindsResponse
     */
    public function listRemindsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertTarget)) {
            $body['AlertTarget'] = $request->alertTarget;
        }
        if (!Utils::isUnset($request->founder)) {
            $body['Founder'] = $request->founder;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remindTypes)) {
            $body['RemindTypes'] = $request->remindTypes;
        }
        if (!Utils::isUnset($request->searchText)) {
            $body['SearchText'] = $request->searchText;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListReminds',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListRemindsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of custom alert rules.
     *  *
     * @param ListRemindsRequest $request ListRemindsRequest
     *
     * @return ListRemindsResponse ListRemindsResponse
     */
    public function listReminds($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRemindsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of resource groups of a specific type.
     *  *
     * @param ListResourceGroupsRequest $tmpReq  ListResourceGroupsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListResourceGroupsResponse ListResourceGroupsResponse
     */
    public function listResourceGroupsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListResourceGroupsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->bizExtKey)) {
            $query['BizExtKey'] = $request->bizExtKey;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->resourceGroupType)) {
            $query['ResourceGroupType'] = $request->resourceGroupType;
        }
        if (!Utils::isUnset($request->resourceManagerResourceGroupId)) {
            $query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }
        if (!Utils::isUnset($request->tagsShrink)) {
            $query['Tags'] = $request->tagsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListResourceGroups',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListResourceGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of resource groups of a specific type.
     *  *
     * @param ListResourceGroupsRequest $request ListResourceGroupsRequest
     *
     * @return ListResourceGroupsResponse ListResourceGroupsResponse
     */
    public function listResourceGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listResourceGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of on-duty engineers in a shift schedule.
     *  *
     * @param ListShiftPersonnelsRequest $request ListShiftPersonnelsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListShiftPersonnelsResponse ListShiftPersonnelsResponse
     */
    public function listShiftPersonnelsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginTime)) {
            $body['BeginTime'] = $request->beginTime;
        }
        if (!Utils::isUnset($request->endTime)) {
            $body['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->shiftPersonUID)) {
            $body['ShiftPersonUID'] = $request->shiftPersonUID;
        }
        if (!Utils::isUnset($request->shiftScheduleIdentifier)) {
            $body['ShiftScheduleIdentifier'] = $request->shiftScheduleIdentifier;
        }
        if (!Utils::isUnset($request->userType)) {
            $body['UserType'] = $request->userType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListShiftPersonnels',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListShiftPersonnelsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of on-duty engineers in a shift schedule.
     *  *
     * @param ListShiftPersonnelsRequest $request ListShiftPersonnelsRequest
     *
     * @return ListShiftPersonnelsResponse ListShiftPersonnelsResponse
     */
    public function listShiftPersonnels($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listShiftPersonnelsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of shift schedules in Operation Center.
     *  *
     * @param ListShiftSchedulesRequest $request ListShiftSchedulesRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListShiftSchedulesResponse ListShiftSchedulesResponse
     */
    public function listShiftSchedulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->shiftScheduleName)) {
            $body['ShiftScheduleName'] = $request->shiftScheduleName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListShiftSchedules',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListShiftSchedulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of shift schedules in Operation Center.
     *  *
     * @param ListShiftSchedulesRequest $request ListShiftSchedulesRequest
     *
     * @return ListShiftSchedulesResponse ListShiftSchedulesResponse
     */
    public function listShiftSchedules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listShiftSchedulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
     *  *
     * @param ListSuccessInstanceAmountRequest $request ListSuccessInstanceAmountRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSuccessInstanceAmountResponse ListSuccessInstanceAmountResponse
     */
    public function listSuccessInstanceAmountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListSuccessInstanceAmount',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSuccessInstanceAmountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
     *  *
     * @param ListSuccessInstanceAmountRequest $request ListSuccessInstanceAmountRequest
     *
     * @return ListSuccessInstanceAmountResponse ListSuccessInstanceAmountResponse
     */
    public function listSuccessInstanceAmount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSuccessInstanceAmountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of table levels. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param ListTableLevelRequest $request ListTableLevelRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTableLevelResponse ListTableLevelResponse
     */
    public function listTableLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListTableLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of table levels. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param ListTableLevelRequest $request ListTableLevelRequest
     *
     * @return ListTableLevelResponse ListTableLevelResponse
     */
    public function listTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTableLevelWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of table themes. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param ListTableThemeRequest $request ListTableThemeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTableThemeResponse ListTableThemeResponse
     */
    public function listTableThemeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListTableTheme',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of table themes. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param ListTableThemeRequest $request ListTableThemeRequest
     *
     * @return ListTableThemeResponse ListTableThemeResponse
     */
    public function listTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTableThemeWithOptions($request, $runtime);
    }

    /**
     * @summary 分页获取租户下面的数据源类型粒度的表名称
     *  *
     * @param ListTablesRequest $request ListTablesRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTablesResponse ListTablesResponse
     */
    public function listTablesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListTables',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTablesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 分页获取租户下面的数据源类型粒度的表名称
     *  *
     * @param ListTablesRequest $request ListTablesRequest
     *
     * @return ListTablesResponse ListTablesResponse
     */
    public function listTables($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTablesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries events.
     *  *
     * @param ListTopicsRequest $request ListTopicsRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTopicsResponse ListTopicsResponse
     */
    public function listTopicsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginTime)) {
            $body['BeginTime'] = $request->beginTime;
        }
        if (!Utils::isUnset($request->endTime)) {
            $body['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->topicStatuses)) {
            $body['TopicStatuses'] = $request->topicStatuses;
        }
        if (!Utils::isUnset($request->topicTypes)) {
            $body['TopicTypes'] = $request->topicTypes;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListTopics',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTopicsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries events.
     *  *
     * @param ListTopicsRequest $request ListTopicsRequest
     *
     * @return ListTopicsResponse ListTopicsResponse
     */
    public function listTopics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTopicsWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a directory to the left-side navigation pane of DataAnalysis.
     *  *
     * @param MountDirectoryRequest $request MountDirectoryRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return MountDirectoryResponse MountDirectoryResponse
     */
    public function mountDirectoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->targetId)) {
            $body['TargetId'] = $request->targetId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $body['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->targetUserId)) {
            $body['TargetUserId'] = $request->targetUserId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'MountDirectory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return MountDirectoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a directory to the left-side navigation pane of DataAnalysis.
     *  *
     * @param MountDirectoryRequest $request MountDirectoryRequest
     *
     * @return MountDirectoryResponse MountDirectoryResponse
     */
    public function mountDirectory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->mountDirectoryWithOptions($request, $runtime);
    }

    /**
     * @summary Undeploys a node.
     *  *
     * @param OfflineNodeRequest $request OfflineNodeRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return OfflineNodeResponse OfflineNodeResponse
     */
    public function offlineNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'OfflineNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OfflineNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Undeploys a node.
     *  *
     * @param OfflineNodeRequest $request OfflineNodeRequest
     *
     * @return OfflineNodeResponse OfflineNodeResponse
     */
    public function offlineNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->offlineNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Publishes an API.
     *  *
     * @param PublishDataServiceApiRequest $request PublishDataServiceApiRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return PublishDataServiceApiResponse PublishDataServiceApiResponse
     */
    public function publishDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'PublishDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublishDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Publishes an API.
     *  *
     * @param PublishDataServiceApiRequest $request PublishDataServiceApiRequest
     *
     * @return PublishDataServiceApiResponse PublishDataServiceApiResponse
     */
    public function publishDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publishDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the execution results of an asynchronous task.
     *  *
     * @description DataWorks allows you to call only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a batch synchronization task or the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To create or update a real-time synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) or [GenerateDISyncTaskConfigForUpdating](https://help.aliyun.com/document_detail/383464.html) operation to obtain the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask or UpdateDISyncTask operation and use the parameters as request parameters to create or update a real-time synchronization task. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
     *  *
     * @param QueryDISyncTaskConfigProcessResultRequest $request QueryDISyncTaskConfigProcessResultRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryDISyncTaskConfigProcessResultResponse QueryDISyncTaskConfigProcessResultResponse
     */
    public function queryDISyncTaskConfigProcessResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->asyncProcessId)) {
            $query['AsyncProcessId'] = $request->asyncProcessId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryDISyncTaskConfigProcessResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryDISyncTaskConfigProcessResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the execution results of an asynchronous task.
     *  *
     * @description DataWorks allows you to call only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a batch synchronization task or the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To create or update a real-time synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) or [GenerateDISyncTaskConfigForUpdating](https://help.aliyun.com/document_detail/383464.html) operation to obtain the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask or UpdateDISyncTask operation and use the parameters as request parameters to create or update a real-time synchronization task. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
     *  *
     * @param QueryDISyncTaskConfigProcessResultRequest $request QueryDISyncTaskConfigProcessResultRequest
     *
     * @return QueryDISyncTaskConfigProcessResultResponse QueryDISyncTaskConfigProcessResultResponse
     */
    public function queryDISyncTaskConfigProcessResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryDISyncTaskConfigProcessResultWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the default data category and data sensitivity level template defined by Data Security Guard.
     *  *
     * @param QueryDefaultTemplateRequest $request QueryDefaultTemplateRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryDefaultTemplateResponse QueryDefaultTemplateResponse
     */
    public function queryDefaultTemplateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryDefaultTemplate',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryDefaultTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the default data category and data sensitivity level template defined by Data Security Guard.
     *  *
     * @param QueryDefaultTemplateRequest $request QueryDefaultTemplateRequest
     *
     * @return QueryDefaultTemplateResponse QueryDefaultTemplateResponse
     */
    public function queryDefaultTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryDefaultTemplateWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about objects that are created in Data Modeling by using fast modeling language (FML) statements.
     *  *
     * @description *   Each time you call this API operation, you must use FML statements to query information about objects that are created in Data Modeling.
     * *   The information about the objects can be queried by page, except for data layers, business processes, and data domains. You can add an offset to the end of an FML statement. The num LIMIT num statement specifies the offset when the information about the objects is queried, and the number of pages to return each time. The offset value must be a multiple of the number of pages.
     * *   A maximum of 1,000 entries can be returned each time you call this API operation.
     *  *
     * @param QueryPublicModelEngineRequest $request QueryPublicModelEngineRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryPublicModelEngineResponse QueryPublicModelEngineResponse
     */
    public function queryPublicModelEngineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->text)) {
            $body['Text'] = $request->text;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryPublicModelEngine',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryPublicModelEngineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about objects that are created in Data Modeling by using fast modeling language (FML) statements.
     *  *
     * @description *   Each time you call this API operation, you must use FML statements to query information about objects that are created in Data Modeling.
     * *   The information about the objects can be queried by page, except for data layers, business processes, and data domains. You can add an offset to the end of an FML statement. The num LIMIT num statement specifies the offset when the information about the objects is queried, and the number of pages to return each time. The offset value must be a multiple of the number of pages.
     * *   A maximum of 1,000 entries can be returned each time you call this API operation.
     *  *
     * @param QueryPublicModelEngineRequest $request QueryPublicModelEngineRequest
     *
     * @return QueryPublicModelEngineResponse QueryPublicModelEngineResponse
     */
    public function queryPublicModelEngine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryPublicModelEngineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the type of a sensitive data identification rule.
     *  *
     * @param QueryRecognizeDataByRuleTypeRequest $request QueryRecognizeDataByRuleTypeRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryRecognizeDataByRuleTypeResponse QueryRecognizeDataByRuleTypeResponse
     */
    public function queryRecognizeDataByRuleTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->recognizeRulesType)) {
            $body['RecognizeRulesType'] = $request->recognizeRulesType;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryRecognizeDataByRuleType',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryRecognizeDataByRuleTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the type of a sensitive data identification rule.
     *  *
     * @param QueryRecognizeDataByRuleTypeRequest $request QueryRecognizeDataByRuleTypeRequest
     *
     * @return QueryRecognizeDataByRuleTypeResponse QueryRecognizeDataByRuleTypeResponse
     */
    public function queryRecognizeDataByRuleType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecognizeDataByRuleTypeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a specified sensitive field in Data Security Guard.
     *  *
     * @param QueryRecognizeRuleDetailRequest $request QueryRecognizeRuleDetailRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryRecognizeRuleDetailResponse QueryRecognizeRuleDetailResponse
     */
    public function queryRecognizeRuleDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryRecognizeRuleDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryRecognizeRuleDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a specified sensitive field in Data Security Guard.
     *  *
     * @param QueryRecognizeRuleDetailRequest $request QueryRecognizeRuleDetailRequest
     *
     * @return QueryRecognizeRuleDetailResponse QueryRecognizeRuleDetailResponse
     */
    public function queryRecognizeRuleDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecognizeRuleDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the built-in sensitive data identification rule that is used to configure a sensitive field.
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryRecognizeRulesTypeResponse QueryRecognizeRulesTypeResponse
     */
    public function queryRecognizeRulesTypeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'QueryRecognizeRulesType',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryRecognizeRulesTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the built-in sensitive data identification rule that is used to configure a sensitive field.
     *  *
     * @return QueryRecognizeRulesTypeResponse QueryRecognizeRulesTypeResponse
     */
    public function queryRecognizeRulesType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecognizeRulesTypeWithOptions($runtime);
    }

    /**
     * @summary Queries data categories.
     *  *
     * @param QuerySensClassificationRequest $request QuerySensClassificationRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return QuerySensClassificationResponse QuerySensClassificationResponse
     */
    public function querySensClassificationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QuerySensClassification',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QuerySensClassificationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries data categories.
     *  *
     * @param QuerySensClassificationRequest $request QuerySensClassificationRequest
     *
     * @return QuerySensClassificationResponse QuerySensClassificationResponse
     */
    public function querySensClassification($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySensClassificationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries data sensitivity levels in Data Security Guard.
     *  *
     * @param QuerySensLevelRequest $request QuerySensLevelRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return QuerySensLevelResponse QuerySensLevelResponse
     */
    public function querySensLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['tenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QuerySensLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QuerySensLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries data sensitivity levels in Data Security Guard.
     *  *
     * @param QuerySensLevelRequest $request QuerySensLevelRequest
     *
     * @return QuerySensLevelResponse QuerySensLevelResponse
     */
    public function querySensLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySensLevelWithOptions($request, $runtime);
    }

    /**
     * @summary Queries sensitive data identification rules.
     *  *
     * @param QuerySensNodeInfoRequest $request QuerySensNodeInfoRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return QuerySensNodeInfoResponse QuerySensNodeInfoResponse
     */
    public function querySensNodeInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->pageNo)) {
            $body['PageNo'] = $request->pageNo;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        if (!Utils::isUnset($request->status)) {
            $body['status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QuerySensNodeInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QuerySensNodeInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries sensitive data identification rules.
     *  *
     * @param QuerySensNodeInfoRequest $request QuerySensNodeInfoRequest
     *
     * @return QuerySensNodeInfoResponse QuerySensNodeInfoResponse
     */
    public function querySensNodeInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySensNodeInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Registers the lineage between self-managed entities to DataWorks.
     *  *
     * @description This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
     *  *
     * @param RegisterLineageRelationRequest $tmpReq  RegisterLineageRelationRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return RegisterLineageRelationResponse RegisterLineageRelationResponse
     */
    public function registerLineageRelationWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new RegisterLineageRelationShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->lineageRelationRegisterVO)) {
            $request->lineageRelationRegisterVOShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->lineageRelationRegisterVO, 'LineageRelationRegisterVO', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->lineageRelationRegisterVOShrink)) {
            $body['LineageRelationRegisterVO'] = $request->lineageRelationRegisterVOShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RegisterLineageRelation',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RegisterLineageRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Registers the lineage between self-managed entities to DataWorks.
     *  *
     * @description This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
     *  *
     * @param RegisterLineageRelationRequest $request RegisterLineageRelationRequest
     *
     * @return RegisterLineageRelationResponse RegisterLineageRelationResponse
     */
    public function registerLineageRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->registerLineageRelationWithOptions($request, $runtime);
    }

    /**
     * @summary Removes tags from an entity. Only entities of the maxcompute-table type are supported.
     *  *
     * @param RemoveEntityTagsRequest $tmpReq  RemoveEntityTagsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveEntityTagsResponse RemoveEntityTagsResponse
     */
    public function removeEntityTagsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new RemoveEntityTagsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tagKeys)) {
            $request->tagKeysShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tagKeys, 'TagKeys', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $body = [];
        if (!Utils::isUnset($request->tagKeysShrink)) {
            $body['TagKeys'] = $request->tagKeysShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RemoveEntityTags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveEntityTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes tags from an entity. Only entities of the maxcompute-table type are supported.
     *  *
     * @param RemoveEntityTagsRequest $request RemoveEntityTagsRequest
     *
     * @return RemoveEntityTagsResponse RemoveEntityTagsResponse
     */
    public function removeEntityTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeEntityTagsWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a role from a user in a DataWorks workspace.
     *  *
     * @param RemoveProjectMemberFromRoleRequest $request RemoveProjectMemberFromRoleRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveProjectMemberFromRoleResponse RemoveProjectMemberFromRoleResponse
     */
    public function removeProjectMemberFromRoleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->roleCode)) {
            $query['RoleCode'] = $request->roleCode;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveProjectMemberFromRole',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveProjectMemberFromRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a role from a user in a DataWorks workspace.
     *  *
     * @param RemoveProjectMemberFromRoleRequest $request RemoveProjectMemberFromRoleRequest
     *
     * @return RemoveProjectMemberFromRoleResponse RemoveProjectMemberFromRoleResponse
     */
    public function removeProjectMemberFromRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeProjectMemberFromRoleWithOptions($request, $runtime);
    }

    /**
     * @summary Restarts an instance.
     *  *
     * @param RestartInstanceRequest $request RestartInstanceRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return RestartInstanceResponse RestartInstanceResponse
     */
    public function restartInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RestartInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RestartInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Restarts an instance.
     *  *
     * @param RestartInstanceRequest $request RestartInstanceRequest
     *
     * @return RestartInstanceResponse RestartInstanceResponse
     */
    public function restartInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Resumes a suspended instance.
     *  *
     * @param ResumeInstanceRequest $request ResumeInstanceRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ResumeInstanceResponse ResumeInstanceResponse
     */
    public function resumeInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ResumeInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ResumeInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Resumes a suspended instance.
     *  *
     * @param ResumeInstanceRequest $request ResumeInstanceRequest
     *
     * @return ResumeInstanceResponse ResumeInstanceResponse
     */
    public function resumeInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resumeInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Revokes permissions on table fields from a user.
     *  *
     * @param RevokeColumnPermissionRequest $request RevokeColumnPermissionRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return RevokeColumnPermissionResponse RevokeColumnPermissionResponse
     */
    public function revokeColumnPermissionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->columns)) {
            $query['Columns'] = $request->columns;
        }
        if (!Utils::isUnset($request->maxComputeProjectName)) {
            $query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }
        if (!Utils::isUnset($request->revokeUserId)) {
            $query['RevokeUserId'] = $request->revokeUserId;
        }
        if (!Utils::isUnset($request->revokeUserName)) {
            $query['RevokeUserName'] = $request->revokeUserName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->workspaceId)) {
            $query['WorkspaceId'] = $request->workspaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RevokeColumnPermission',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RevokeColumnPermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Revokes permissions on table fields from a user.
     *  *
     * @param RevokeColumnPermissionRequest $request RevokeColumnPermissionRequest
     *
     * @return RevokeColumnPermissionResponse RevokeColumnPermissionResponse
     */
    public function revokeColumnPermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeColumnPermissionWithOptions($request, $runtime);
    }

    /**
     * @summary Revokes permissions on a table from a user.
     *  *
     * @param RevokeTablePermissionRequest $request RevokeTablePermissionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return RevokeTablePermissionResponse RevokeTablePermissionResponse
     */
    public function revokeTablePermissionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->actions)) {
            $query['Actions'] = $request->actions;
        }
        if (!Utils::isUnset($request->maxComputeProjectName)) {
            $query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }
        if (!Utils::isUnset($request->revokeUserId)) {
            $query['RevokeUserId'] = $request->revokeUserId;
        }
        if (!Utils::isUnset($request->revokeUserName)) {
            $query['RevokeUserName'] = $request->revokeUserName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->workspaceId)) {
            $query['WorkspaceId'] = $request->workspaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RevokeTablePermission',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RevokeTablePermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Revokes permissions on a table from a user.
     *  *
     * @param RevokeTablePermissionRequest $request RevokeTablePermissionRequest
     *
     * @return RevokeTablePermissionResponse RevokeTablePermissionResponse
     */
    public function revokeTablePermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeTablePermissionWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a workflow to backfill data.
     *  *
     * @description For more information about data backfill, see [Backfill data](https://help.aliyun.com/document_detail/137937.html).
     *  *
     * @param RunCycleDagNodesRequest $request RunCycleDagNodesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return RunCycleDagNodesResponse RunCycleDagNodesResponse
     */
    public function runCycleDagNodesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertNoticeType)) {
            $body['AlertNoticeType'] = $request->alertNoticeType;
        }
        if (!Utils::isUnset($request->alertType)) {
            $body['AlertType'] = $request->alertType;
        }
        if (!Utils::isUnset($request->bizBeginTime)) {
            $body['BizBeginTime'] = $request->bizBeginTime;
        }
        if (!Utils::isUnset($request->bizEndTime)) {
            $body['BizEndTime'] = $request->bizEndTime;
        }
        if (!Utils::isUnset($request->concurrentRuns)) {
            $body['ConcurrentRuns'] = $request->concurrentRuns;
        }
        if (!Utils::isUnset($request->endBizDate)) {
            $body['EndBizDate'] = $request->endBizDate;
        }
        if (!Utils::isUnset($request->excludeNodeIds)) {
            $body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }
        if (!Utils::isUnset($request->includeNodeIds)) {
            $body['IncludeNodeIds'] = $request->includeNodeIds;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nodeParams)) {
            $body['NodeParams'] = $request->nodeParams;
        }
        if (!Utils::isUnset($request->parallelism)) {
            $body['Parallelism'] = $request->parallelism;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->rootNodeId)) {
            $body['RootNodeId'] = $request->rootNodeId;
        }
        if (!Utils::isUnset($request->startBizDate)) {
            $body['StartBizDate'] = $request->startBizDate;
        }
        if (!Utils::isUnset($request->startFutureInstanceImmediately)) {
            $body['StartFutureInstanceImmediately'] = $request->startFutureInstanceImmediately;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RunCycleDagNodes',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RunCycleDagNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a workflow to backfill data.
     *  *
     * @description For more information about data backfill, see [Backfill data](https://help.aliyun.com/document_detail/137937.html).
     *  *
     * @param RunCycleDagNodesRequest $request RunCycleDagNodesRequest
     *
     * @return RunCycleDagNodesResponse RunCycleDagNodesResponse
     */
    public function runCycleDagNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runCycleDagNodesWithOptions($request, $runtime);
    }

    /**
     * @summary Runs nodes in a manually triggered workflow. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find a manually triggered workflow in Operation Center only after the manually triggered workflow is committed and deployed.
     *  *
     * @param RunManualDagNodesRequest $request RunManualDagNodesRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return RunManualDagNodesResponse RunManualDagNodesResponse
     */
    public function runManualDagNodesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->dagParameters)) {
            $body['DagParameters'] = $request->dagParameters;
        }
        if (!Utils::isUnset($request->endBizDate)) {
            $body['EndBizDate'] = $request->endBizDate;
        }
        if (!Utils::isUnset($request->excludeNodeIds)) {
            $body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }
        if (!Utils::isUnset($request->flowName)) {
            $body['FlowName'] = $request->flowName;
        }
        if (!Utils::isUnset($request->includeNodeIds)) {
            $body['IncludeNodeIds'] = $request->includeNodeIds;
        }
        if (!Utils::isUnset($request->nodeParameters)) {
            $body['NodeParameters'] = $request->nodeParameters;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->startBizDate)) {
            $body['StartBizDate'] = $request->startBizDate;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RunManualDagNodes',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RunManualDagNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Runs nodes in a manually triggered workflow. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find a manually triggered workflow in Operation Center only after the manually triggered workflow is committed and deployed.
     *  *
     * @param RunManualDagNodesRequest $request RunManualDagNodesRequest
     *
     * @return RunManualDagNodesResponse RunManualDagNodesResponse
     */
    public function runManualDagNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runManualDagNodesWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a workflow to perform smoke testing.
     *  *
     * @param RunSmokeTestRequest $request RunSmokeTestRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return RunSmokeTestResponse RunSmokeTestResponse
     */
    public function runSmokeTestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeParams)) {
            $body['NodeParams'] = $request->nodeParams;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RunSmokeTest',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RunSmokeTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a workflow to perform smoke testing.
     *  *
     * @param RunSmokeTestRequest $request RunSmokeTestRequest
     *
     * @return RunSmokeTestResponse RunSmokeTestResponse
     */
    public function runSmokeTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runSmokeTestWithOptions($request, $runtime);
    }

    /**
     * @summary Runs a manually triggered node.
     *  *
     * @param RunTriggerNodeRequest $request RunTriggerNodeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return RunTriggerNodeResponse RunTriggerNodeResponse
     */
    public function runTriggerNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->cycleTime)) {
            $body['CycleTime'] = $request->cycleTime;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RunTriggerNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RunTriggerNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Runs a manually triggered node.
     *  *
     * @param RunTriggerNodeRequest $request RunTriggerNodeRequest
     *
     * @return RunTriggerNodeResponse RunTriggerNodeResponse
     */
    public function runTriggerNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runTriggerNodeWithOptions($request, $runtime);
    }

    /**
     * @summary Saves the test results of an API.
     *  *
     * @param SaveDataServiceApiTestResultRequest $request SaveDataServiceApiTestResultRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return SaveDataServiceApiTestResultResponse SaveDataServiceApiTestResultResponse
     */
    public function saveDataServiceApiTestResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->autoGenerate)) {
            $body['AutoGenerate'] = $request->autoGenerate;
        }
        if (!Utils::isUnset($request->failResultSample)) {
            $body['FailResultSample'] = $request->failResultSample;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->resultSample)) {
            $body['ResultSample'] = $request->resultSample;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SaveDataServiceApiTestResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SaveDataServiceApiTestResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Saves the test results of an API.
     *  *
     * @param SaveDataServiceApiTestResultRequest $request SaveDataServiceApiTestResultRequest
     *
     * @return SaveDataServiceApiTestResultResponse SaveDataServiceApiTestResultResponse
     */
    public function saveDataServiceApiTestResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveDataServiceApiTestResultWithOptions($request, $runtime);
    }

    /**
     * @summary Checks whether input data contains sensitive data.
     *  *
     * @param ScanSensitiveDataRequest $request ScanSensitiveDataRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ScanSensitiveDataResponse ScanSensitiveDataResponse
     */
    public function scanSensitiveDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ScanSensitiveData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ScanSensitiveDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Checks whether input data contains sensitive data.
     *  *
     * @param ScanSensitiveDataRequest $request ScanSensitiveDataRequest
     *
     * @return ScanSensitiveDataResponse ScanSensitiveDataResponse
     */
    public function scanSensitiveData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->scanSensitiveDataWithOptions($request, $runtime);
    }

    /**
     * @summary Queries metatables based on specific conditions.
     *  *
     * @description You can call this operation to query only metatables in a MaxCompute or E-MapReduce (EMR) compute engine.
     *  *
     * @param SearchMetaTablesRequest $request SearchMetaTablesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return SearchMetaTablesResponse SearchMetaTablesResponse
     */
    public function searchMetaTablesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->entityType)) {
            $query['EntityType'] = $request->entityType;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SearchMetaTables',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SearchMetaTablesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries metatables based on specific conditions.
     *  *
     * @description You can call this operation to query only metatables in a MaxCompute or E-MapReduce (EMR) compute engine.
     *  *
     * @param SearchMetaTablesRequest $request SearchMetaTablesRequest
     *
     * @return SearchMetaTablesResponse SearchMetaTablesResponse
     */
    public function searchMetaTables($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->searchMetaTablesWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI SearchNodesByOutput is deprecated
     *  *
     * @summary Queries a node based on the output.
     *  *
     * Deprecated
     *
     * @param SearchNodesByOutputRequest $request SearchNodesByOutputRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return SearchNodesByOutputResponse SearchNodesByOutputResponse
     */
    public function searchNodesByOutputWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->outputs)) {
            $body['Outputs'] = $request->outputs;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SearchNodesByOutput',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SearchNodesByOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI SearchNodesByOutput is deprecated
     *  *
     * @summary Queries a node based on the output.
     *  *
     * Deprecated
     *
     * @param SearchNodesByOutputRequest $request SearchNodesByOutputRequest
     *
     * @return SearchNodesByOutputResponse SearchNodesByOutputResponse
     */
    public function searchNodesByOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->searchNodesByOutputWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI SetDataSourceShare is deprecated
     *  *
     * @summary Shares a data source to a specific DataWorks workspace or a specific user.
     *  *
     * Deprecated
     *
     * @param SetDataSourceShareRequest $request SetDataSourceShareRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return SetDataSourceShareResponse SetDataSourceShareResponse
     */
    public function setDataSourceShareWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->datasourceName)) {
            $query['DatasourceName'] = $request->datasourceName;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectPermissions)) {
            $query['ProjectPermissions'] = $request->projectPermissions;
        }
        if (!Utils::isUnset($request->userPermissions)) {
            $query['UserPermissions'] = $request->userPermissions;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetDataSourceShare',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetDataSourceShareResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI SetDataSourceShare is deprecated
     *  *
     * @summary Shares a data source to a specific DataWorks workspace or a specific user.
     *  *
     * Deprecated
     *
     * @param SetDataSourceShareRequest $request SetDataSourceShareRequest
     *
     * @return SetDataSourceShareResponse SetDataSourceShareResponse
     */
    public function setDataSourceShare($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setDataSourceShareWithOptions($request, $runtime);
    }

    /**
     * @summary Configures tags for an entity. Only entities of the maxcompute-table type are supported.
     *  *
     * @param SetEntityTagsRequest $tmpReq  SetEntityTagsRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return SetEntityTagsResponse SetEntityTagsResponse
     */
    public function setEntityTagsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new SetEntityTagsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $body = [];
        if (!Utils::isUnset($request->tagsShrink)) {
            $body['Tags'] = $request->tagsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SetEntityTags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetEntityTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Configures tags for an entity. Only entities of the maxcompute-table type are supported.
     *  *
     * @param SetEntityTagsRequest $request SetEntityTagsRequest
     *
     * @return SetEntityTagsResponse SetEntityTagsResponse
     */
    public function setEntityTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setEntityTagsWithOptions($request, $runtime);
    }

    /**
     * @summary Sets the state of a failed instance to successful.
     *  *
     * @param SetSuccessInstanceRequest $request SetSuccessInstanceRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return SetSuccessInstanceResponse SetSuccessInstanceResponse
     */
    public function setSuccessInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SetSuccessInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetSuccessInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Sets the state of a failed instance to successful.
     *  *
     * @param SetSuccessInstanceRequest $request SetSuccessInstanceRequest
     *
     * @return SetSuccessInstanceResponse SetSuccessInstanceResponse
     */
    public function setSuccessInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSuccessInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Starts a synchronization task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @param StartDIJobRequest $tmpReq  StartDIJobRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return StartDIJobResponse StartDIJobResponse
     */
    public function startDIJobWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new StartDIJobShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->realtimeStartSettings)) {
            $request->realtimeStartSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->realtimeStartSettings, 'RealtimeStartSettings', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->forceToRerun)) {
            $body['ForceToRerun'] = $request->forceToRerun;
        }
        if (!Utils::isUnset($request->realtimeStartSettingsShrink)) {
            $body['RealtimeStartSettings'] = $request->realtimeStartSettingsShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'StartDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a synchronization task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *  *
     * @param StartDIJobRequest $request StartDIJobRequest
     *
     * @return StartDIJobResponse StartDIJobResponse
     */
    public function startDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary Starts a real-time synchronization task or a synchronization solution.
     *  *
     * @param StartDISyncInstanceRequest $request StartDISyncInstanceRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return StartDISyncInstanceResponse StartDISyncInstanceResponse
     */
    public function startDISyncInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->startParam)) {
            $query['StartParam'] = $request->startParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartDISyncInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartDISyncInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a real-time synchronization task or a synchronization solution.
     *  *
     * @param StartDISyncInstanceRequest $request StartDISyncInstanceRequest
     *
     * @return StartDISyncInstanceResponse StartDISyncInstanceResponse
     */
    public function startDISyncInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDISyncInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Starts a migration task.
     *  *
     * @param StartMigrationRequest $request StartMigrationRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return StartMigrationResponse StartMigrationResponse
     */
    public function startMigrationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->migrationId)) {
            $body['MigrationId'] = $request->migrationId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'StartMigration',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartMigrationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Starts a migration task.
     *  *
     * @param StartMigrationRequest $request StartMigrationRequest
     *
     * @return StartMigrationResponse StartMigrationResponse
     */
    public function startMigration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startMigrationWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a new-version synchronization task. The following type of synchronization task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *  *
     * @param StopDIJobRequest $request StopDIJobRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return StopDIJobResponse StopDIJobResponse
     */
    public function stopDIJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'StopDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StopDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a new-version synchronization task. The following type of synchronization task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *  *
     * @param StopDIJobRequest $request StopDIJobRequest
     *
     * @return StopDIJobResponse StopDIJobResponse
     */
    public function stopDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary Stops a real-time synchronization task.
     *  *
     * @param StopDISyncInstanceRequest $request StopDISyncInstanceRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return StopDISyncInstanceResponse StopDISyncInstanceResponse
     */
    public function stopDISyncInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StopDISyncInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StopDISyncInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Stops a real-time synchronization task.
     *  *
     * @param StopDISyncInstanceRequest $request StopDISyncInstanceRequest
     *
     * @return StopDISyncInstanceResponse StopDISyncInstanceResponse
     */
    public function stopDISyncInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopDISyncInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Terminates an instance.
     *  *
     * @param StopInstanceRequest $request StopInstanceRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return StopInstanceResponse StopInstanceResponse
     */
    public function stopInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'StopInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StopInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Terminates an instance.
     *  *
     * @param StopInstanceRequest $request StopInstanceRequest
     *
     * @return StopInstanceResponse StopInstanceResponse
     */
    public function stopInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Submits an API in DataService Studio.
     *  *
     * @param SubmitDataServiceApiRequest $request SubmitDataServiceApiRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return SubmitDataServiceApiResponse SubmitDataServiceApiResponse
     */
    public function submitDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SubmitDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SubmitDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Submits an API in DataService Studio.
     *  *
     * @param SubmitDataServiceApiRequest $request SubmitDataServiceApiRequest
     *
     * @return SubmitDataServiceApiResponse SubmitDataServiceApiResponse
     */
    public function submitDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Commits a file to the development environment of the scheduling system to generate a task.
     *  *
     * @param SubmitFileRequest $request SubmitFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return SubmitFileResponse SubmitFileResponse
     */
    public function submitFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->skipAllDeployFileExtensions)) {
            $body['SkipAllDeployFileExtensions'] = $request->skipAllDeployFileExtensions;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SubmitFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SubmitFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Commits a file to the development environment of the scheduling system to generate a task.
     *  *
     * @param SubmitFileRequest $request SubmitFileRequest
     *
     * @return SubmitFileResponse SubmitFileResponse
     */
    public function submitFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitFileWithOptions($request, $runtime);
    }

    /**
     * @summary Suspends an instance.
     *  *
     * @param SuspendInstanceRequest $request SuspendInstanceRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return SuspendInstanceResponse SuspendInstanceResponse
     */
    public function suspendInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SuspendInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SuspendInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Suspends an instance.
     *  *
     * @param SuspendInstanceRequest $request SuspendInstanceRequest
     *
     * @return SuspendInstanceResponse SuspendInstanceResponse
     */
    public function suspendInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->suspendInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Undeploys a real-time synchronization task.
     *  *
     * @param TerminateDISyncInstanceRequest $request TerminateDISyncInstanceRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return TerminateDISyncInstanceResponse TerminateDISyncInstanceResponse
     */
    public function terminateDISyncInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'TerminateDISyncInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TerminateDISyncInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Undeploys a real-time synchronization task.
     *  *
     * @param TerminateDISyncInstanceRequest $request TerminateDISyncInstanceRequest
     *
     * @return TerminateDISyncInstanceResponse TerminateDISyncInstanceResponse
     */
    public function terminateDISyncInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->terminateDISyncInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Tests a DataService Studio API in asynchronous mode. You can call the GetDataServiceApiTest operation to query the test result.
     *  *
     * @param TestDataServiceApiRequest $request TestDataServiceApiRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return TestDataServiceApiResponse TestDataServiceApiResponse
     */
    public function testDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->apiId)) {
            $query['ApiId'] = $request->apiId;
        }
        $body = [];
        if (!Utils::isUnset($request->bodyContent)) {
            $body['BodyContent'] = $request->bodyContent;
        }
        if (!Utils::isUnset($request->bodyParams)) {
            $body['BodyParams'] = $request->bodyParams;
        }
        if (!Utils::isUnset($request->headParams)) {
            $body['HeadParams'] = $request->headParams;
        }
        if (!Utils::isUnset($request->pathParams)) {
            $body['PathParams'] = $request->pathParams;
        }
        if (!Utils::isUnset($request->queryParam)) {
            $body['QueryParam'] = $request->queryParam;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'TestDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TestDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Tests a DataService Studio API in asynchronous mode. You can call the GetDataServiceApiTest operation to query the test result.
     *  *
     * @param TestDataServiceApiRequest $request TestDataServiceApiRequest
     *
     * @return TestDataServiceApiResponse TestDataServiceApiResponse
     */
    public function testDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->testDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Tests the network connectivity between a data source and a resource group.
     *  *
     * @param TestNetworkConnectionRequest $request TestNetworkConnectionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return TestNetworkConnectionResponse TestNetworkConnectionResponse
     */
    public function testNetworkConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->datasourceName)) {
            $query['DatasourceName'] = $request->datasourceName;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->resourceGroup)) {
            $query['ResourceGroup'] = $request->resourceGroup;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'TestNetworkConnection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TestNetworkConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Tests the network connectivity between a data source and a resource group.
     *  *
     * @param TestNetworkConnectionRequest $request TestNetworkConnectionRequest
     *
     * @return TestNetworkConnectionResponse TestNetworkConnectionResponse
     */
    public function testNetworkConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->testNetworkConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the ranking of the running durations of instances.
     *  *
     * @param TopTenElapsedTimeInstanceRequest $request TopTenElapsedTimeInstanceRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return TopTenElapsedTimeInstanceResponse TopTenElapsedTimeInstanceResponse
     */
    public function topTenElapsedTimeInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'TopTenElapsedTimeInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TopTenElapsedTimeInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the ranking of the running durations of instances.
     *  *
     * @param TopTenElapsedTimeInstanceRequest $request TopTenElapsedTimeInstanceRequest
     *
     * @return TopTenElapsedTimeInstanceResponse TopTenElapsedTimeInstanceResponse
     */
    public function topTenElapsedTimeInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->topTenElapsedTimeInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the ranking of nodes on which errors occur within the previous month.
     *  *
     * @param TopTenErrorTimesInstanceRequest $request TopTenErrorTimesInstanceRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return TopTenErrorTimesInstanceResponse TopTenErrorTimesInstanceResponse
     */
    public function topTenErrorTimesInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'TopTenErrorTimesInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TopTenErrorTimesInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the ranking of nodes on which errors occur within the previous month.
     *  *
     * @param TopTenErrorTimesInstanceRequest $request TopTenErrorTimesInstanceRequest
     *
     * @return TopTenErrorTimesInstanceResponse TopTenErrorTimesInstanceResponse
     */
    public function topTenErrorTimesInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->topTenErrorTimesInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a directory from the left-side navigation pane of DataAnalysis.
     *  *
     * @param UmountDirectoryRequest $request UmountDirectoryRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return UmountDirectoryResponse UmountDirectoryResponse
     */
    public function umountDirectoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->targetId)) {
            $body['TargetId'] = $request->targetId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $body['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->targetUserId)) {
            $body['TargetUserId'] = $request->targetUserId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UmountDirectory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UmountDirectoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a directory from the left-side navigation pane of DataAnalysis.
     *  *
     * @param UmountDirectoryRequest $request UmountDirectoryRequest
     *
     * @return UmountDirectoryResponse UmountDirectoryResponse
     */
    public function umountDirectory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->umountDirectoryWithOptions($request, $runtime);
    }

    /**
     * @summary 更新基线
     *  *
     * @param UpdateBaselineRequest $tmpReq  UpdateBaselineRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateBaselineResponse UpdateBaselineResponse
     */
    public function updateBaselineWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateBaselineShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->alertSettings)) {
            $request->alertSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->alertSettings, 'AlertSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->overtimeSettings)) {
            $request->overtimeSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->overtimeSettings, 'OvertimeSettings', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->alertEnabled)) {
            $body['AlertEnabled'] = $request->alertEnabled;
        }
        if (!Utils::isUnset($request->alertMarginThreshold)) {
            $body['AlertMarginThreshold'] = $request->alertMarginThreshold;
        }
        if (!Utils::isUnset($request->alertSettingsShrink)) {
            $body['AlertSettings'] = $request->alertSettingsShrink;
        }
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->baselineName)) {
            $body['BaselineName'] = $request->baselineName;
        }
        if (!Utils::isUnset($request->baselineType)) {
            $body['BaselineType'] = $request->baselineType;
        }
        if (!Utils::isUnset($request->enabled)) {
            $body['Enabled'] = $request->enabled;
        }
        if (!Utils::isUnset($request->nodeIds)) {
            $body['NodeIds'] = $request->nodeIds;
        }
        if (!Utils::isUnset($request->overtimeSettingsShrink)) {
            $body['OvertimeSettings'] = $request->overtimeSettingsShrink;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->removeNodeIds)) {
            $body['RemoveNodeIds'] = $request->removeNodeIds;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 更新基线
     *  *
     * @param UpdateBaselineRequest $request UpdateBaselineRequest
     *
     * @return UpdateBaselineResponse UpdateBaselineResponse
     */
    public function updateBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBaselineWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a workflow.
     *  *
     * @param UpdateBusinessRequest $request UpdateBusinessRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateBusinessResponse UpdateBusinessResponse
     */
    public function updateBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessId)) {
            $body['BusinessId'] = $request->businessId;
        }
        if (!Utils::isUnset($request->businessName)) {
            $body['BusinessName'] = $request->businessName;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a workflow.
     *  *
     * @param UpdateBusinessRequest $request UpdateBusinessRequest
     *
     * @return UpdateBusinessResponse UpdateBusinessResponse
     */
    public function updateBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBusinessWithOptions($request, $runtime);
    }

    /**
     * @summary 更新集群的配置信息
     *  *
     * @param UpdateClusterConfigsRequest $tmpReq  UpdateClusterConfigsRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateClusterConfigsResponse UpdateClusterConfigsResponse
     */
    public function updateClusterConfigsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateClusterConfigsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->configValues)) {
            $request->configValuesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->configValues, 'ConfigValues', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->configType)) {
            $query['ConfigType'] = $request->configType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $body = [];
        if (!Utils::isUnset($request->configValuesShrink)) {
            $body['ConfigValues'] = $request->configValuesShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateClusterConfigs',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateClusterConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 更新集群的配置信息
     *  *
     * @param UpdateClusterConfigsRequest $request UpdateClusterConfigsRequest
     *
     * @return UpdateClusterConfigsResponse UpdateClusterConfigsResponse
     */
    public function updateClusterConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateClusterConfigsWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI UpdateConnection is deprecated
     *  *
     * @summary Updates a data source.
     *  *
     * Deprecated
     *
     * @param UpdateConnectionRequest $request UpdateConnectionRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateConnectionResponse UpdateConnectionResponse
     */
    public function updateConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->connectionId)) {
            $query['ConnectionId'] = $request->connectionId;
        }
        if (!Utils::isUnset($request->content)) {
            $query['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateConnection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'PUT',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI UpdateConnection is deprecated
     *  *
     * @summary Updates a data source.
     *  *
     * Deprecated
     *
     * @param UpdateConnectionRequest $request UpdateConnectionRequest
     *
     * @return UpdateConnectionResponse UpdateConnectionResponse
     */
    public function updateConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary Updates an alert rule for a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks that can be used for real-time data synchronization. You must update all fields in the alert rule.
     *  *
     * @param UpdateDIAlarmRuleRequest $tmpReq  UpdateDIAlarmRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDIAlarmRuleResponse UpdateDIAlarmRuleResponse
     */
    public function updateDIAlarmRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateDIAlarmRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->notificationSettings)) {
            $request->notificationSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->notificationSettings, 'NotificationSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->triggerConditions)) {
            $request->triggerConditionsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->triggerConditions, 'TriggerConditions', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->DIAlarmRuleId)) {
            $body['DIAlarmRuleId'] = $request->DIAlarmRuleId;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->enabled)) {
            $body['Enabled'] = $request->enabled;
        }
        if (!Utils::isUnset($request->metricType)) {
            $body['MetricType'] = $request->metricType;
        }
        if (!Utils::isUnset($request->notificationSettingsShrink)) {
            $body['NotificationSettings'] = $request->notificationSettingsShrink;
        }
        if (!Utils::isUnset($request->triggerConditionsShrink)) {
            $body['TriggerConditions'] = $request->triggerConditionsShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateDIAlarmRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates an alert rule for a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *  *
     * @description You can configure alert rules only for tasks that can be used for real-time data synchronization. You must update all fields in the alert rule.
     *  *
     * @param UpdateDIAlarmRuleRequest $request UpdateDIAlarmRuleRequest
     *
     * @return UpdateDIAlarmRuleResponse UpdateDIAlarmRuleResponse
     */
    public function updateDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *  *
     * @param UpdateDIJobRequest $tmpReq  UpdateDIJobRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDIJobResponse UpdateDIJobResponse
     */
    public function updateDIJobWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateDIJobShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->jobSettings)) {
            $request->jobSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->jobSettings, 'JobSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->resourceSettings)) {
            $request->resourceSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->resourceSettings, 'ResourceSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->tableMappings)) {
            $request->tableMappingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tableMappings, 'TableMappings', 'json');
        }
        if (!Utils::isUnset($tmpReq->transformationRules)) {
            $request->transformationRulesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->transformationRules, 'TransformationRules', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->jobSettingsShrink)) {
            $body['JobSettings'] = $request->jobSettingsShrink;
        }
        if (!Utils::isUnset($request->resourceSettingsShrink)) {
            $body['ResourceSettings'] = $request->resourceSettingsShrink;
        }
        if (!Utils::isUnset($request->tableMappingsShrink)) {
            $body['TableMappings'] = $request->tableMappingsShrink;
        }
        if (!Utils::isUnset($request->transformationRulesShrink)) {
            $body['TransformationRules'] = $request->transformationRulesShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *  *
     * @param UpdateDIJobRequest $request UpdateDIJobRequest
     *
     * @return UpdateDIJobResponse UpdateDIJobResponse
     */
    public function updateDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the default global configuration of synchronization solutions in a DataWorks workspace.
     *  *
     * @description DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *  *
     * @param UpdateDIProjectConfigRequest $request UpdateDIProjectConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDIProjectConfigResponse UpdateDIProjectConfigResponse
     */
    public function updateDIProjectConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destinationType)) {
            $query['DestinationType'] = $request->destinationType;
        }
        if (!Utils::isUnset($request->projectConfig)) {
            $query['ProjectConfig'] = $request->projectConfig;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->sourceType)) {
            $query['SourceType'] = $request->sourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateDIProjectConfig',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDIProjectConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the default global configuration of synchronization solutions in a DataWorks workspace.
     *  *
     * @description DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *  *
     * @param UpdateDIProjectConfigRequest $request UpdateDIProjectConfigRequest
     *
     * @return UpdateDIProjectConfigResponse UpdateDIProjectConfigResponse
     */
    public function updateDIProjectConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDIProjectConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a data synchronization task.
     *  *
     * @param UpdateDISyncTaskRequest $request UpdateDISyncTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDISyncTaskResponse UpdateDISyncTaskResponse
     */
    public function updateDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskContent)) {
            $query['TaskContent'] = $request->taskContent;
        }
        if (!Utils::isUnset($request->taskParam)) {
            $query['TaskParam'] = $request->taskParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a data synchronization task.
     *  *
     * @param UpdateDISyncTaskRequest $request UpdateDISyncTaskRequest
     *
     * @return UpdateDISyncTaskResponse UpdateDISyncTaskResponse
     */
    public function updateDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the information about an API in the development state in DataService Studio.
     *  *
     * @param UpdateDataServiceApiRequest $request UpdateDataServiceApiRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDataServiceApiResponse UpdateDataServiceApiResponse
     */
    public function updateDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiDescription)) {
            $body['ApiDescription'] = $request->apiDescription;
        }
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->apiPath)) {
            $body['ApiPath'] = $request->apiPath;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->protocols)) {
            $body['Protocols'] = $request->protocols;
        }
        if (!Utils::isUnset($request->registrationDetails)) {
            $body['RegistrationDetails'] = $request->registrationDetails;
        }
        if (!Utils::isUnset($request->requestMethod)) {
            $body['RequestMethod'] = $request->requestMethod;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $body['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->responseContentType)) {
            $body['ResponseContentType'] = $request->responseContentType;
        }
        if (!Utils::isUnset($request->scriptDetails)) {
            $body['ScriptDetails'] = $request->scriptDetails;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        if (!Utils::isUnset($request->timeout)) {
            $body['Timeout'] = $request->timeout;
        }
        if (!Utils::isUnset($request->visibleRange)) {
            $body['VisibleRange'] = $request->visibleRange;
        }
        if (!Utils::isUnset($request->wizardDetails)) {
            $body['WizardDetails'] = $request->wizardDetails;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the information about an API in the development state in DataService Studio.
     *  *
     * @param UpdateDataServiceApiRequest $request UpdateDataServiceApiRequest
     *
     * @return UpdateDataServiceApiResponse UpdateDataServiceApiResponse
     */
    public function updateDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a data source.
     *  *
     * @param UpdateDataSourceRequest $request UpdateDataSourceRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDataSourceResponse UpdateDataSourceResponse
     */
    public function updateDataSourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->content)) {
            $query['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->dataSourceId)) {
            $query['DataSourceId'] = $request->dataSourceId;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateDataSource',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'PUT',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a data source.
     *  *
     * @param UpdateDataSourceRequest $request UpdateDataSourceRequest
     *
     * @return UpdateDataSourceResponse UpdateDataSourceResponse
     */
    public function updateDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDataSourceWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a file.
     *  *
     * @description When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
     *  *
     * @param UpdateFileRequest $request UpdateFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileResponse UpdateFileResponse
     */
    public function updateFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->advancedSettings)) {
            $body['AdvancedSettings'] = $request->advancedSettings;
        }
        if (!Utils::isUnset($request->applyScheduleImmediately)) {
            $body['ApplyScheduleImmediately'] = $request->applyScheduleImmediately;
        }
        if (!Utils::isUnset($request->autoParsing)) {
            $body['AutoParsing'] = $request->autoParsing;
        }
        if (!Utils::isUnset($request->autoRerunIntervalMillis)) {
            $body['AutoRerunIntervalMillis'] = $request->autoRerunIntervalMillis;
        }
        if (!Utils::isUnset($request->autoRerunTimes)) {
            $body['AutoRerunTimes'] = $request->autoRerunTimes;
        }
        if (!Utils::isUnset($request->connectionName)) {
            $body['ConnectionName'] = $request->connectionName;
        }
        if (!Utils::isUnset($request->content)) {
            $body['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->cronExpress)) {
            $body['CronExpress'] = $request->cronExpress;
        }
        if (!Utils::isUnset($request->cycleType)) {
            $body['CycleType'] = $request->cycleType;
        }
        if (!Utils::isUnset($request->dependentNodeIdList)) {
            $body['DependentNodeIdList'] = $request->dependentNodeIdList;
        }
        if (!Utils::isUnset($request->dependentType)) {
            $body['DependentType'] = $request->dependentType;
        }
        if (!Utils::isUnset($request->endEffectDate)) {
            $body['EndEffectDate'] = $request->endEffectDate;
        }
        if (!Utils::isUnset($request->fileDescription)) {
            $body['FileDescription'] = $request->fileDescription;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->fileName)) {
            $body['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->ignoreParentSkipRunningProperty)) {
            $body['IgnoreParentSkipRunningProperty'] = $request->ignoreParentSkipRunningProperty;
        }
        if (!Utils::isUnset($request->inputList)) {
            $body['InputList'] = $request->inputList;
        }
        if (!Utils::isUnset($request->inputParameters)) {
            $body['InputParameters'] = $request->inputParameters;
        }
        if (!Utils::isUnset($request->outputList)) {
            $body['OutputList'] = $request->outputList;
        }
        if (!Utils::isUnset($request->outputParameters)) {
            $body['OutputParameters'] = $request->outputParameters;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->paraValue)) {
            $body['ParaValue'] = $request->paraValue;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->rerunMode)) {
            $body['RerunMode'] = $request->rerunMode;
        }
        if (!Utils::isUnset($request->resourceGroupIdentifier)) {
            $body['ResourceGroupIdentifier'] = $request->resourceGroupIdentifier;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        if (!Utils::isUnset($request->startEffectDate)) {
            $body['StartEffectDate'] = $request->startEffectDate;
        }
        if (!Utils::isUnset($request->startImmediately)) {
            $body['StartImmediately'] = $request->startImmediately;
        }
        if (!Utils::isUnset($request->stop)) {
            $body['Stop'] = $request->stop;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a file.
     *  *
     * @description When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
     *  *
     * @param UpdateFileRequest $request UpdateFileRequest
     *
     * @return UpdateFileResponse UpdateFileResponse
     */
    public function updateFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a folder.
     *  *
     * @param UpdateFolderRequest $request UpdateFolderRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFolderResponse UpdateFolderResponse
     */
    public function updateFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->folderName)) {
            $body['FolderName'] = $request->folderName;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a folder.
     *  *
     * @param UpdateFolderRequest $request UpdateFolderRequest
     *
     * @return UpdateFolderResponse UpdateFolderResponse
     */
    public function updateFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Returns the check result of an extension point event to DataStudio after the extension point event is triggered during data development and checked by an extension.
     *  *
     * @param UpdateIDEEventResultRequest $request UpdateIDEEventResultRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateIDEEventResultResponse UpdateIDEEventResultResponse
     */
    public function updateIDEEventResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->checkResult)) {
            $body['CheckResult'] = $request->checkResult;
        }
        if (!Utils::isUnset($request->checkResultTip)) {
            $body['CheckResultTip'] = $request->checkResultTip;
        }
        if (!Utils::isUnset($request->extensionCode)) {
            $body['ExtensionCode'] = $request->extensionCode;
        }
        if (!Utils::isUnset($request->messageId)) {
            $body['MessageId'] = $request->messageId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateIDEEventResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateIDEEventResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Returns the check result of an extension point event to DataStudio after the extension point event is triggered during data development and checked by an extension.
     *  *
     * @param UpdateIDEEventResultRequest $request UpdateIDEEventResultRequest
     *
     * @return UpdateIDEEventResultResponse UpdateIDEEventResultResponse
     */
    public function updateIDEEventResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateIDEEventResultWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a category.
     *  *
     * @param UpdateMetaCategoryRequest $request UpdateMetaCategoryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMetaCategoryResponse UpdateMetaCategoryResponse
     */
    public function updateMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->categoryId)) {
            $body['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a category.
     *  *
     * @param UpdateMetaCategoryRequest $request UpdateMetaCategoryRequest
     *
     * @return UpdateMetaCategoryResponse UpdateMetaCategoryResponse
     */
    public function updateMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the name and comment of a collection.
     *  *
     * @description Only the name and comment of a collection can be updated.
     *  *
     * @param UpdateMetaCollectionRequest $request UpdateMetaCollectionRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMetaCollectionResponse UpdateMetaCollectionResponse
     */
    public function updateMetaCollectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->comment)) {
            $query['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateMetaCollection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMetaCollectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the name and comment of a collection.
     *  *
     * @description Only the name and comment of a collection can be updated.
     *  *
     * @param UpdateMetaCollectionRequest $request UpdateMetaCollectionRequest
     *
     * @return UpdateMetaCollectionResponse UpdateMetaCollectionResponse
     */
    public function updateMetaCollection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaCollectionWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the metadata information about a table.
     *  *
     * @param UpdateMetaTableRequest $request UpdateMetaTableRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMetaTableResponse UpdateMetaTableResponse
     */
    public function updateMetaTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->caption)) {
            $query['Caption'] = $request->caption;
        }
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->newOwnerId)) {
            $query['NewOwnerId'] = $request->newOwnerId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->visibility)) {
            $query['Visibility'] = $request->visibility;
        }
        $body = [];
        if (!Utils::isUnset($request->addedLabels)) {
            $body['AddedLabels'] = $request->addedLabels;
        }
        if (!Utils::isUnset($request->removedLabels)) {
            $body['RemovedLabels'] = $request->removedLabels;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateMetaTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMetaTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the metadata information about a table.
     *  *
     * @param UpdateMetaTableRequest $request UpdateMetaTableRequest
     *
     * @return UpdateMetaTableResponse UpdateMetaTableResponse
     */
    public function updateMetaTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaTableWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the instructions on how to use a table. If no instruction on how to use the table is available, the instructions that are configured by calling this operation are added.
     *  *
     * @param UpdateMetaTableIntroWikiRequest $request UpdateMetaTableIntroWikiRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMetaTableIntroWikiResponse UpdateMetaTableIntroWikiResponse
     */
    public function updateMetaTableIntroWikiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $body = [];
        if (!Utils::isUnset($request->content)) {
            $body['Content'] = $request->content;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateMetaTableIntroWiki',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMetaTableIntroWikiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the instructions on how to use a table. If no instruction on how to use the table is available, the instructions that are configured by calling this operation are added.
     *  *
     * @param UpdateMetaTableIntroWikiRequest $request UpdateMetaTableIntroWikiRequest
     *
     * @return UpdateMetaTableIntroWikiResponse UpdateMetaTableIntroWikiResponse
     */
    public function updateMetaTableIntroWiki($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaTableIntroWikiWithOptions($request, $runtime);
    }

    /**
     * @summary Changes the owner of a node.
     *  *
     * @param UpdateNodeOwnerRequest $request UpdateNodeOwnerRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateNodeOwnerResponse UpdateNodeOwnerResponse
     */
    public function updateNodeOwnerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->userId)) {
            $body['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateNodeOwner',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateNodeOwnerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Changes the owner of a node.
     *  *
     * @param UpdateNodeOwnerRequest $request UpdateNodeOwnerRequest
     *
     * @return UpdateNodeOwnerResponse UpdateNodeOwnerResponse
     */
    public function updateNodeOwner($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNodeOwnerWithOptions($request, $runtime);
    }

    /**
     * @summary Freezes or unfreezes a node.
     *  *
     * @param UpdateNodeRunModeRequest $request UpdateNodeRunModeRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateNodeRunModeResponse UpdateNodeRunModeResponse
     */
    public function updateNodeRunModeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateNodeRunMode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateNodeRunModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Freezes or unfreezes a node.
     *  *
     * @param UpdateNodeRunModeRequest $request UpdateNodeRunModeRequest
     *
     * @return UpdateNodeRunModeResponse UpdateNodeRunModeResponse
     */
    public function updateNodeRunMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNodeRunModeWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a subscription relationship.
     *  *
     * @param UpdateQualityFollowerRequest $request UpdateQualityFollowerRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateQualityFollowerResponse UpdateQualityFollowerResponse
     */
    public function updateQualityFollowerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alarmMode)) {
            $body['AlarmMode'] = $request->alarmMode;
        }
        if (!Utils::isUnset($request->follower)) {
            $body['Follower'] = $request->follower;
        }
        if (!Utils::isUnset($request->followerId)) {
            $body['FollowerId'] = $request->followerId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateQualityFollower',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a subscription relationship.
     *  *
     * @param UpdateQualityFollowerRequest $request UpdateQualityFollowerRequest
     *
     * @return UpdateQualityFollowerResponse UpdateQualityFollowerResponse
     */
    public function updateQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a monitoring rule.
     *  *
     * @param UpdateQualityRuleRequest $request UpdateQualityRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateQualityRuleResponse UpdateQualityRuleResponse
     */
    public function updateQualityRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->blockType)) {
            $body['BlockType'] = $request->blockType;
        }
        if (!Utils::isUnset($request->checker)) {
            $body['Checker'] = $request->checker;
        }
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->criticalThreshold)) {
            $body['CriticalThreshold'] = $request->criticalThreshold;
        }
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->expectValue)) {
            $body['ExpectValue'] = $request->expectValue;
        }
        if (!Utils::isUnset($request->id)) {
            $body['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->methodName)) {
            $body['MethodName'] = $request->methodName;
        }
        if (!Utils::isUnset($request->openSwitch)) {
            $body['OpenSwitch'] = $request->openSwitch;
        }
        if (!Utils::isUnset($request->operator)) {
            $body['Operator'] = $request->operator;
        }
        if (!Utils::isUnset($request->predictType)) {
            $body['PredictType'] = $request->predictType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->property)) {
            $body['Property'] = $request->property;
        }
        if (!Utils::isUnset($request->propertyType)) {
            $body['PropertyType'] = $request->propertyType;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $body['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $body['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->taskSetting)) {
            $body['TaskSetting'] = $request->taskSetting;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->trend)) {
            $body['Trend'] = $request->trend;
        }
        if (!Utils::isUnset($request->warningThreshold)) {
            $body['WarningThreshold'] = $request->warningThreshold;
        }
        if (!Utils::isUnset($request->whereCondition)) {
            $body['WhereCondition'] = $request->whereCondition;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateQualityRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a monitoring rule.
     *  *
     * @param UpdateQualityRuleRequest $request UpdateQualityRuleRequest
     *
     * @return UpdateQualityRuleResponse UpdateQualityRuleResponse
     */
    public function updateQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateQualityRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies a custom alert rule.
     *  *
     * @param UpdateRemindRequest $request UpdateRemindRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateRemindResponse UpdateRemindResponse
     */
    public function updateRemindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertInterval)) {
            $body['AlertInterval'] = $request->alertInterval;
        }
        if (!Utils::isUnset($request->alertMethods)) {
            $body['AlertMethods'] = $request->alertMethods;
        }
        if (!Utils::isUnset($request->alertTargets)) {
            $body['AlertTargets'] = $request->alertTargets;
        }
        if (!Utils::isUnset($request->alertUnit)) {
            $body['AlertUnit'] = $request->alertUnit;
        }
        if (!Utils::isUnset($request->baselineIds)) {
            $body['BaselineIds'] = $request->baselineIds;
        }
        if (!Utils::isUnset($request->bizProcessIds)) {
            $body['BizProcessIds'] = $request->bizProcessIds;
        }
        if (!Utils::isUnset($request->detail)) {
            $body['Detail'] = $request->detail;
        }
        if (!Utils::isUnset($request->dndEnd)) {
            $body['DndEnd'] = $request->dndEnd;
        }
        if (!Utils::isUnset($request->maxAlertTimes)) {
            $body['MaxAlertTimes'] = $request->maxAlertTimes;
        }
        if (!Utils::isUnset($request->nodeIds)) {
            $body['NodeIds'] = $request->nodeIds;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->remindId)) {
            $body['RemindId'] = $request->remindId;
        }
        if (!Utils::isUnset($request->remindName)) {
            $body['RemindName'] = $request->remindName;
        }
        if (!Utils::isUnset($request->remindType)) {
            $body['RemindType'] = $request->remindType;
        }
        if (!Utils::isUnset($request->remindUnit)) {
            $body['RemindUnit'] = $request->remindUnit;
        }
        if (!Utils::isUnset($request->robotUrls)) {
            $body['RobotUrls'] = $request->robotUrls;
        }
        if (!Utils::isUnset($request->useFlag)) {
            $body['UseFlag'] = $request->useFlag;
        }
        if (!Utils::isUnset($request->webhooks)) {
            $body['Webhooks'] = $request->webhooks;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateRemind',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies a custom alert rule.
     *  *
     * @param UpdateRemindRequest $request UpdateRemindRequest
     *
     * @return UpdateRemindResponse UpdateRemindResponse
     */
    public function updateRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateRemindWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a MaxCompute table.
     *  *
     * @param UpdateTableRequest $request UpdateTableRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableResponse UpdateTableResponse
     */
    public function updateTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->comment)) {
            $query['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->createIfNotExists)) {
            $query['CreateIfNotExists'] = $request->createIfNotExists;
        }
        if (!Utils::isUnset($request->externalTableType)) {
            $query['ExternalTableType'] = $request->externalTableType;
        }
        if (!Utils::isUnset($request->hasPart)) {
            $query['HasPart'] = $request->hasPart;
        }
        if (!Utils::isUnset($request->isView)) {
            $query['IsView'] = $request->isView;
        }
        if (!Utils::isUnset($request->lifeCycle)) {
            $query['LifeCycle'] = $request->lifeCycle;
        }
        if (!Utils::isUnset($request->location)) {
            $query['Location'] = $request->location;
        }
        if (!Utils::isUnset($request->logicalLevelId)) {
            $query['LogicalLevelId'] = $request->logicalLevelId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicsLevelId)) {
            $query['PhysicsLevelId'] = $request->physicsLevelId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->visibility)) {
            $query['Visibility'] = $request->visibility;
        }
        $body = [];
        if (!Utils::isUnset($request->columns)) {
            $body['Columns'] = $request->columns;
        }
        if (!Utils::isUnset($request->endpoint)) {
            $body['Endpoint'] = $request->endpoint;
        }
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->themes)) {
            $body['Themes'] = $request->themes;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a MaxCompute table.
     *  *
     * @param UpdateTableRequest $request UpdateTableRequest
     *
     * @return UpdateTableResponse UpdateTableResponse
     */
    public function updateTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the fields in a MaxCompute table.
     *  *
     * @param UpdateTableAddColumnRequest $request UpdateTableAddColumnRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableAddColumnResponse UpdateTableAddColumnResponse
     */
    public function updateTableAddColumnWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $body = [];
        if (!Utils::isUnset($request->column)) {
            $body['Column'] = $request->column;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateTableAddColumn',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableAddColumnResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the fields in a MaxCompute table.
     *  *
     * @param UpdateTableAddColumnRequest $request UpdateTableAddColumnRequest
     *
     * @return UpdateTableAddColumnResponse UpdateTableAddColumnResponse
     */
    public function updateTableAddColumn($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableAddColumnWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param UpdateTableLevelRequest $request UpdateTableLevelRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableLevelResponse UpdateTableLevelResponse
     */
    public function updateTableLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->levelId)) {
            $query['LevelId'] = $request->levelId;
        }
        if (!Utils::isUnset($request->levelType)) {
            $query['LevelType'] = $request->levelType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTableLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param UpdateTableLevelRequest $request UpdateTableLevelRequest
     *
     * @return UpdateTableLevelResponse UpdateTableLevelResponse
     */
    public function updateTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableLevelWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the information about a table, such as the table folder, level, and category.
     *  *
     * @param UpdateTableModelInfoRequest $request UpdateTableModelInfoRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableModelInfoResponse UpdateTableModelInfoResponse
     */
    public function updateTableModelInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->firstLevelThemeId)) {
            $query['FirstLevelThemeId'] = $request->firstLevelThemeId;
        }
        if (!Utils::isUnset($request->levelId)) {
            $query['LevelId'] = $request->levelId;
        }
        if (!Utils::isUnset($request->levelType)) {
            $query['LevelType'] = $request->levelType;
        }
        if (!Utils::isUnset($request->secondLevelThemeId)) {
            $query['SecondLevelThemeId'] = $request->secondLevelThemeId;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTableModelInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableModelInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the information about a table, such as the table folder, level, and category.
     *  *
     * @param UpdateTableModelInfoRequest $request UpdateTableModelInfoRequest
     *
     * @return UpdateTableModelInfoResponse UpdateTableModelInfoResponse
     */
    public function updateTableModelInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableModelInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param UpdateTableThemeRequest $request UpdateTableThemeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableThemeResponse UpdateTableThemeResponse
     */
    public function updateTableThemeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->themeId)) {
            $query['ThemeId'] = $request->themeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTableTheme',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *  *
     * @param UpdateTableThemeRequest $request UpdateTableThemeRequest
     *
     * @return UpdateTableThemeResponse UpdateTableThemeResponse
     */
    public function updateTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableThemeWithOptions($request, $runtime);
    }

    /**
     * @param UpdateUdfFileRequest $request UpdateUdfFileRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateUdfFileResponse UpdateUdfFileResponse
     */
    public function updateUdfFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->className)) {
            $body['ClassName'] = $request->className;
        }
        if (!Utils::isUnset($request->cmdDescription)) {
            $body['CmdDescription'] = $request->cmdDescription;
        }
        if (!Utils::isUnset($request->example)) {
            $body['Example'] = $request->example;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->functionType)) {
            $body['FunctionType'] = $request->functionType;
        }
        if (!Utils::isUnset($request->parameterDescription)) {
            $body['ParameterDescription'] = $request->parameterDescription;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->resources)) {
            $body['Resources'] = $request->resources;
        }
        if (!Utils::isUnset($request->returnValue)) {
            $body['ReturnValue'] = $request->returnValue;
        }
        if (!Utils::isUnset($request->udfDescription)) {
            $body['UdfDescription'] = $request->udfDescription;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateUdfFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateUdfFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateUdfFileRequest $request UpdateUdfFileRequest
     *
     * @return UpdateUdfFileResponse UpdateUdfFileResponse
     */
    public function updateUdfFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateUdfFileWithOptions($request, $runtime);
    }

    /**
     * @summary Returns the processing result sent by an extension after a process in Operation Center is blocked by the extension.
     *  *
     * @param UpdateWorkbenchEventResultRequest $request UpdateWorkbenchEventResultRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateWorkbenchEventResultResponse UpdateWorkbenchEventResultResponse
     */
    public function updateWorkbenchEventResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkResult)) {
            $query['CheckResult'] = $request->checkResult;
        }
        if (!Utils::isUnset($request->checkResultTip)) {
            $query['CheckResultTip'] = $request->checkResultTip;
        }
        if (!Utils::isUnset($request->extensionCode)) {
            $query['ExtensionCode'] = $request->extensionCode;
        }
        if (!Utils::isUnset($request->messageId)) {
            $query['MessageId'] = $request->messageId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateWorkbenchEventResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateWorkbenchEventResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Returns the processing result sent by an extension after a process in Operation Center is blocked by the extension.
     *  *
     * @param UpdateWorkbenchEventResultRequest $request UpdateWorkbenchEventResultRequest
     *
     * @return UpdateWorkbenchEventResultResponse UpdateWorkbenchEventResultResponse
     */
    public function updateWorkbenchEventResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateWorkbenchEventResultWithOptions($request, $runtime);
    }
}
