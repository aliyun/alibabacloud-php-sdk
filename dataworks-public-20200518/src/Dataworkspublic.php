<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Dataworkspublic\V20200518;

use AlibabaCloud\Endpoint\Endpoint;
use AlibabaCloud\OpenApiUtil\OpenApiUtilClient;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AbolishDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AbolishDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddMetaCollectionEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddMetaCollectionEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddProjectMemberToRoleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddProjectMemberToRoleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddRecognizeRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddRecognizeRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddToMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddToMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ApprovePermissionApplyOrderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ApprovePermissionApplyOrderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CallbackExtensionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CallbackExtensionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ChangeResourceManagerResourceGroupRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ChangeResourceManagerResourceGroupResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckFileDeploymentRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckFileDeploymentResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaPartitionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaPartitionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagComplementRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagComplementResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiAuthorityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiAuthorityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceGroupRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceGroupResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataSourceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataSourceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIAlarmRuleShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIJobShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateExportMigrationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateExportMigrationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateImportMigrationAdvanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateImportMigrationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateImportMigrationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateManualDagRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateManualDagResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCollectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCollectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreatePermissionApplyOrderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreatePermissionApplyOrderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectMemberRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectMemberResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRelativeNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRelativeNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateResourceFileAdvanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateResourceFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateResourceFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateUdfFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateUdfFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiAuthorityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiAuthorityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataSourceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataSourceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFromMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFromMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteLineageRelationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteLineageRelationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteProjectMemberRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteProjectMemberResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRelativeNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRelativeNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRecognizeRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRecognizeRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DesensitizeDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DesensitizeDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanAddOrUpdateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanAddOrUpdateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanAddOrUpdateShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanDeleteRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanDeleteResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanDeleteShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanQueryListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanQueryListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanUpdateStatusRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanUpdateStatusResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanUpdateStatusShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgPlatformQueryProjectsAndSchemaFromMetaRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgPlatformQueryProjectsAndSchemaFromMetaResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQueryDefaultTemplatesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQueryDefaultTemplatesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQuerySensResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQuerySensResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgRunSensIdentifyRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgRunSensIdentifyResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgRunSensIdentifyShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneAddOrUpdateSceneRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneAddOrUpdateSceneResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneAddOrUpdateSceneShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgScenedDeleteSceneRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgScenedDeleteSceneResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgScenedDeleteSceneShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneQuerySceneListByNameRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneQuerySceneListByNameResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgStopSensIdentifyRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgStopSensIdentifyResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupAddOrUpdateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupAddOrUpdateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupAddOrUpdateShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupDeleteRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupDeleteResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupDeleteShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupGetOdpsRoleGroupsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupGetOdpsRoleGroupsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupQueryListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupQueryListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupQueryUserListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListAddOrUpdateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListAddOrUpdateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListAddOrUpdateShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListDeleteListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListDeleteListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListDeleteListShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListQueryListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListQueryListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EditRecognizeRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EditRecognizeRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EstablishRelationTableToBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EstablishRelationTableToBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ExportDataSourcesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ExportDataSourcesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForCreatingRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForCreatingResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForUpdatingRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForUpdatingResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetAlertMessageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetAlertMessageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineConfigRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineConfigResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineKeyPathRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineKeyPathResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineStatusRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineStatusResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDagRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDagResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApplicationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApplicationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceGroupRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceGroupResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServicePublishedApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServicePublishedApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataSourceMetaRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataSourceMetaResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDDLJobStatusRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDDLJobStatusResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDeploymentRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDeploymentResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncInstanceInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncInstanceInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetExtensionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetExtensionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileTypeStatisticRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileTypeStatisticResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileVersionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileVersionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetIDEEventDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetIDEEventDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceConsumeTimeRankRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceConsumeTimeRankResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceCountTrendRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceCountTrendResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceErrorRankRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceErrorRankResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceLogRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceLogResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusCountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusCountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusStatisticRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusStatisticResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetManualDagInstancesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetManualDagInstancesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCollectionDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCollectionDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaColumnLineageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaColumnLineageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBTableListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBTableListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableBasicInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableBasicInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableChangeLogRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableChangeLogResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableColumnRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableColumnResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableFullInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableFullInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableIntroWikiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableIntroWikiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableLineageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableLineageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableListByCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableListByCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTablePartitionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTablePartitionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTablePartitionShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableProducingTasksRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableProducingTasksResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableThemeLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableThemeLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationProcessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationProcessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationSummaryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationSummaryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeChildrenRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeChildrenResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeCodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeCodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeOnBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeOnBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeParentsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeParentsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeTypeListInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeTypeListInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpRiskDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpRiskDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpSensitiveDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpSensitiveDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOptionValueForProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOptionValueForProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetPermissionApplyOrderDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetPermissionApplyOrderDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSensitiveDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSensitiveDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSuccessInstanceTrendRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSuccessInstanceTrendResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicInfluenceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicInfluenceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ImportDataSourcesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ImportDataSourcesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListAlertMessagesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListAlertMessagesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineConfigsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineConfigsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselinesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselinesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineStatusesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineStatusesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListCalcEnginesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListCalcEnginesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListConnectionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListConnectionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiAuthoritiesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiAuthoritiesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApisRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApisResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApplicationsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApplicationsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceAuthorizedApisRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceAuthorizedApisResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceFoldersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceFoldersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceGroupsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceGroupsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServicePublishedApisRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServicePublishedApisResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataSourcesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataSourcesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDeploymentsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDeploymentsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIAlarmRulesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIAlarmRulesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIJobsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIJobsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIProjectConfigRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIProjectConfigResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEnabledExtensionsForProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEnabledExtensionsForProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntitiesByTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntitiesByTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntitiesByTagsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntityTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntityTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListExtensionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListExtensionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFilesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFilesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileTypeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileTypeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileVersionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileVersionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFoldersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFoldersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInnerNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInnerNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceAmountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceAmountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceHistoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceHistoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstancesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstancesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListLineageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListLineageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListManualDagInstancesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListManualDagInstancesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionEntitiesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionEntitiesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaDBRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaDBResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMigrationsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMigrationsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeInputOrOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeInputOrOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeIORequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeIOResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListPermissionApplyOrdersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListPermissionApplyOrdersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProgramTypeCountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProgramTypeCountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectIdsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectIdsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectMembersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectMembersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectRolesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectRolesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityRulesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityRulesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRefDISyncTasksRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRefDISyncTasksResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRemindsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRemindsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListResourceGroupsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListResourceGroupsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListResourceGroupsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftPersonnelsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftPersonnelsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftSchedulesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftSchedulesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListSuccessInstanceAmountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListSuccessInstanceAmountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTopicsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTopicsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\MountDirectoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\MountDirectoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\OfflineNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\OfflineNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\PublishDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\PublishDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDefaultTemplateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDefaultTemplateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDISyncTaskConfigProcessResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDISyncTaskConfigProcessResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryPublicModelEngineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryPublicModelEngineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeDataByRuleTypeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeDataByRuleTypeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeRuleDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeRuleDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeRulesTypeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensClassificationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensClassificationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensNodeInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensNodeInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RegisterLineageRelationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RegisterLineageRelationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RegisterLineageRelationShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveEntityTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveEntityTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveEntityTagsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveProjectMemberFromRoleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveProjectMemberFromRoleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RestartInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RestartInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ResumeInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ResumeInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeColumnPermissionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeColumnPermissionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeTablePermissionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeTablePermissionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunCycleDagNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunCycleDagNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunManualDagNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunManualDagNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunSmokeTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunSmokeTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunTriggerNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunTriggerNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SaveDataServiceApiTestResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SaveDataServiceApiTestResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ScanSensitiveDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ScanSensitiveDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchMetaTablesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchMetaTablesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchNodesByOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchNodesByOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetDataSourceShareRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetDataSourceShareResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetEntityTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetEntityTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetEntityTagsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetSuccessInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetSuccessInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDIJobShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDISyncInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDISyncInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartMigrationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartMigrationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDISyncInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDISyncInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SuspendInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SuspendInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TerminateDISyncInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TerminateDISyncInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestNetworkConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestNetworkConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenElapsedTimeInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenElapsedTimeInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenErrorTimesInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenErrorTimesInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UmountDirectoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UmountDirectoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBaselineShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataSourceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataSourceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIAlarmRuleShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIJobShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIProjectConfigRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIProjectConfigResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateIDEEventResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateIDEEventResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCollectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCollectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableIntroWikiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableIntroWikiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeOwnerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeOwnerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeRunModeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeRunModeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableAddColumnRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableAddColumnResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableModelInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableModelInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateUdfFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateUdfFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateWorkbenchEventResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateWorkbenchEventResultResponse;
use AlibabaCloud\SDK\OpenPlatform\V20191219\Models\AuthorizeFileUploadRequest;
use AlibabaCloud\SDK\OpenPlatform\V20191219\Models\AuthorizeFileUploadResponse;
use AlibabaCloud\SDK\OpenPlatform\V20191219\OpenPlatform;
use AlibabaCloud\SDK\OSS\OSS;
use AlibabaCloud\SDK\OSS\OSS\PostObjectRequest;
use AlibabaCloud\SDK\OSS\OSS\PostObjectRequest\header;
use AlibabaCloud\Tea\FileForm\FileForm\FileField;
use AlibabaCloud\Tea\Utils\Utils;
use AlibabaCloud\Tea\Utils\Utils\RuntimeOptions;
use Darabonba\OpenApi\Models\Config;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;

class Dataworkspublic extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap  = [
            'ap-northeast-1'        => 'dataworks.ap-northeast-1.aliyuncs.com',
            'ap-south-1'            => 'dataworks.ap-south-1.aliyuncs.com',
            'ap-southeast-1'        => 'dataworks.ap-southeast-1.aliyuncs.com',
            'ap-southeast-2'        => 'dataworks.ap-southeast-2.aliyuncs.com',
            'ap-southeast-3'        => 'dataworks.ap-southeast-3.aliyuncs.com',
            'ap-southeast-5'        => 'dataworks.ap-southeast-5.aliyuncs.com',
            'cn-beijing'            => 'dataworks.cn-beijing.aliyuncs.com',
            'cn-chengdu'            => 'dataworks.cn-chengdu.aliyuncs.com',
            'cn-hangzhou'           => 'dataworks.cn-hangzhou.aliyuncs.com',
            'cn-hongkong'           => 'dataworks.cn-hongkong.aliyuncs.com',
            'cn-huhehaote'          => 'dataworks.aliyuncs.com',
            'cn-qingdao'            => 'dataworks.aliyuncs.com',
            'cn-shanghai'           => 'dataworks.cn-shanghai.aliyuncs.com',
            'cn-shenzhen'           => 'dataworks.cn-shenzhen.aliyuncs.com',
            'cn-zhangjiakou'        => 'dataworks.aliyuncs.com',
            'eu-central-1'          => 'dataworks.eu-central-1.aliyuncs.com',
            'eu-west-1'             => 'dataworks.eu-west-1.aliyuncs.com',
            'me-east-1'             => 'dataworks.me-east-1.aliyuncs.com',
            'us-east-1'             => 'dataworks.us-east-1.aliyuncs.com',
            'us-west-1'             => 'dataworks.us-west-1.aliyuncs.com',
            'cn-hangzhou-finance'   => 'dataworks.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'dataworks.aliyuncs.com',
            'cn-shanghai-finance-1' => 'dataworks.aliyuncs.com',
            'cn-north-2-gov-1'      => 'dataworks.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('dataworks-public', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (!Utils::empty_($endpoint)) {
            return $endpoint;
        }
        if (!Utils::isUnset($endpointMap) && !Utils::empty_(@$endpointMap[$regionId])) {
            return @$endpointMap[$regionId];
        }

        return Endpoint::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * @summary Unpublishes a DataService Studio API.
     *  *
     * @param AbolishDataServiceApiRequest $request AbolishDataServiceApiRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return AbolishDataServiceApiResponse AbolishDataServiceApiResponse
     */
    public function abolishDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'AbolishDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AbolishDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Unpublishes a DataService Studio API.
     *  *
     * @param AbolishDataServiceApiRequest $request AbolishDataServiceApiRequest
     *
     * @return AbolishDataServiceApiResponse AbolishDataServiceApiResponse
     */
    public function abolishDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->abolishDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Adds an entity to a collection.
     *  *
     * @param AddMetaCollectionEntityRequest $request AddMetaCollectionEntityRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return AddMetaCollectionEntityResponse AddMetaCollectionEntityResponse
     */
    public function addMetaCollectionEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->collectionQualifiedName)) {
            $query['CollectionQualifiedName'] = $request->collectionQualifiedName;
        }
        if (!Utils::isUnset($request->entityQualifiedName)) {
            $query['EntityQualifiedName'] = $request->entityQualifiedName;
        }
        if (!Utils::isUnset($request->remark)) {
            $query['Remark'] = $request->remark;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddMetaCollectionEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddMetaCollectionEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds an entity to a collection.
     *  *
     * @param AddMetaCollectionEntityRequest $request AddMetaCollectionEntityRequest
     *
     * @return AddMetaCollectionEntityResponse AddMetaCollectionEntityResponse
     */
    public function addMetaCollectionEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addMetaCollectionEntityWithOptions($request, $runtime);
    }

    /**
     * @summary For more information about how to add your Alibaba Cloud account or a RAM user as a member of a DataWorks workspace, see [Add a member to a DataWorks workspace](https://help.aliyun.com/document_detail/136941.html).
     *  *
     * @description The ID of the DataWorks workspace. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID.
     *  *
     * @param AddProjectMemberToRoleRequest $request AddProjectMemberToRoleRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return AddProjectMemberToRoleResponse AddProjectMemberToRoleResponse
     */
    public function addProjectMemberToRoleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->roleCode)) {
            $query['RoleCode'] = $request->roleCode;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddProjectMemberToRole',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddProjectMemberToRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary For more information about how to add your Alibaba Cloud account or a RAM user as a member of a DataWorks workspace, see [Add a member to a DataWorks workspace](https://help.aliyun.com/document_detail/136941.html).
     *  *
     * @description The ID of the DataWorks workspace. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID.
     *  *
     * @param AddProjectMemberToRoleRequest $request AddProjectMemberToRoleRequest
     *
     * @return AddProjectMemberToRoleResponse AddProjectMemberToRoleResponse
     */
    public function addProjectMemberToRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addProjectMemberToRoleWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param AddRecognizeRuleRequest $request AddRecognizeRuleRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return AddRecognizeRuleResponse AddRecognizeRuleResponse
     */
    public function addRecognizeRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->accountName)) {
            $body['AccountName'] = $request->accountName;
        }
        if (!Utils::isUnset($request->colExclude)) {
            $body['ColExclude'] = $request->colExclude;
        }
        if (!Utils::isUnset($request->colScan)) {
            $body['ColScan'] = $request->colScan;
        }
        if (!Utils::isUnset($request->commentScan)) {
            $body['CommentScan'] = $request->commentScan;
        }
        if (!Utils::isUnset($request->contentScan)) {
            $body['ContentScan'] = $request->contentScan;
        }
        if (!Utils::isUnset($request->hitThreshold)) {
            $body['HitThreshold'] = $request->hitThreshold;
        }
        if (!Utils::isUnset($request->level)) {
            $body['Level'] = $request->level;
        }
        if (!Utils::isUnset($request->levelName)) {
            $body['LevelName'] = $request->levelName;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeParent)) {
            $body['NodeParent'] = $request->nodeParent;
        }
        if (!Utils::isUnset($request->operationType)) {
            $body['OperationType'] = $request->operationType;
        }
        if (!Utils::isUnset($request->recognizeRules)) {
            $body['RecognizeRules'] = $request->recognizeRules;
        }
        if (!Utils::isUnset($request->recognizeRulesType)) {
            $body['RecognizeRulesType'] = $request->recognizeRulesType;
        }
        if (!Utils::isUnset($request->sensitiveDescription)) {
            $body['SensitiveDescription'] = $request->sensitiveDescription;
        }
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'AddRecognizeRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddRecognizeRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param AddRecognizeRuleRequest $request AddRecognizeRuleRequest
     *
     * @return AddRecognizeRuleResponse AddRecognizeRuleResponse
     */
    public function addRecognizeRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addRecognizeRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Adds a metatable to a specified category.
     *  *
     * @param AddToMetaCategoryRequest $request AddToMetaCategoryRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return AddToMetaCategoryResponse AddToMetaCategoryResponse
     */
    public function addToMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'AddToMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return AddToMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Adds a metatable to a specified category.
     *  *
     * @param AddToMetaCategoryRequest $request AddToMetaCategoryRequest
     *
     * @return AddToMetaCategoryResponse AddToMetaCategoryResponse
     */
    public function addToMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addToMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @param ApprovePermissionApplyOrderRequest $request ApprovePermissionApplyOrderRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ApprovePermissionApplyOrderResponse ApprovePermissionApplyOrderResponse
     */
    public function approvePermissionApplyOrderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->approveAction)) {
            $query['ApproveAction'] = $request->approveAction;
        }
        if (!Utils::isUnset($request->approveComment)) {
            $query['ApproveComment'] = $request->approveComment;
        }
        if (!Utils::isUnset($request->flowId)) {
            $query['FlowId'] = $request->flowId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ApprovePermissionApplyOrder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ApprovePermissionApplyOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ApprovePermissionApplyOrderRequest $request ApprovePermissionApplyOrderRequest
     *
     * @return ApprovePermissionApplyOrderResponse ApprovePermissionApplyOrderResponse
     */
    public function approvePermissionApplyOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->approvePermissionApplyOrderWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param CallbackExtensionRequest $request CallbackExtensionRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CallbackExtensionResponse CallbackExtensionResponse
     */
    public function callbackExtensionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->checkMessage)) {
            $body['CheckMessage'] = $request->checkMessage;
        }
        if (!Utils::isUnset($request->checkResult)) {
            $body['CheckResult'] = $request->checkResult;
        }
        if (!Utils::isUnset($request->extensionCode)) {
            $body['ExtensionCode'] = $request->extensionCode;
        }
        if (!Utils::isUnset($request->messageId)) {
            $body['MessageId'] = $request->messageId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CallbackExtension',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CallbackExtensionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param CallbackExtensionRequest $request CallbackExtensionRequest
     *
     * @return CallbackExtensionResponse CallbackExtensionResponse
     */
    public function callbackExtension($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->callbackExtensionWithOptions($request, $runtime);
    }

    /**
     * @summary Modifies the resource group that you specify when you activate DataWorks or purchase a DataWorks exclusive resource group.
     *  *
     * @param ChangeResourceManagerResourceGroupRequest $request ChangeResourceManagerResourceGroupRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return ChangeResourceManagerResourceGroupResponse ChangeResourceManagerResourceGroupResponse
     */
    public function changeResourceManagerResourceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->resourceId)) {
            $query['ResourceId'] = $request->resourceId;
        }
        if (!Utils::isUnset($request->resourceManagerResourceGroupId)) {
            $query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }
        if (!Utils::isUnset($request->resourceType)) {
            $query['ResourceType'] = $request->resourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ChangeResourceManagerResourceGroup',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ChangeResourceManagerResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Modifies the resource group that you specify when you activate DataWorks or purchase a DataWorks exclusive resource group.
     *  *
     * @param ChangeResourceManagerResourceGroupRequest $request ChangeResourceManagerResourceGroupRequest
     *
     * @return ChangeResourceManagerResourceGroupResponse ChangeResourceManagerResourceGroupResponse
     */
    public function changeResourceManagerResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeResourceManagerResourceGroupWithOptions($request, $runtime);
    }

    /**
     * @param CheckFileDeploymentRequest $request CheckFileDeploymentRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckFileDeploymentResponse CheckFileDeploymentResponse
     */
    public function checkFileDeploymentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->checkDetailUrl)) {
            $body['CheckDetailUrl'] = $request->checkDetailUrl;
        }
        if (!Utils::isUnset($request->checkerInstanceId)) {
            $body['CheckerInstanceId'] = $request->checkerInstanceId;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CheckFileDeployment',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckFileDeploymentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CheckFileDeploymentRequest $request CheckFileDeploymentRequest
     *
     * @return CheckFileDeploymentResponse CheckFileDeploymentResponse
     */
    public function checkFileDeployment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkFileDeploymentWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CheckMetaPartition**.
     *  *
     * @param CheckMetaPartitionRequest $request CheckMetaPartitionRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckMetaPartitionResponse CheckMetaPartitionResponse
     */
    public function checkMetaPartitionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->partition)) {
            $query['Partition'] = $request->partition;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckMetaPartition',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckMetaPartitionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CheckMetaPartition**.
     *  *
     * @param CheckMetaPartitionRequest $request CheckMetaPartitionRequest
     *
     * @return CheckMetaPartitionResponse CheckMetaPartitionResponse
     */
    public function checkMetaPartition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkMetaPartitionWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CheckMetaTable**.
     *  *
     * @param CheckMetaTableRequest $request CheckMetaTableRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CheckMetaTableResponse CheckMetaTableResponse
     */
    public function checkMetaTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CheckMetaTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CheckMetaTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CheckMetaTable**.
     *  *
     * @param CheckMetaTableRequest $request CheckMetaTableRequest
     *
     * @return CheckMetaTableResponse CheckMetaTableResponse
     */
    public function checkMetaTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkMetaTableWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param CreateBaselineRequest $request CreateBaselineRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateBaselineResponse CreateBaselineResponse
     */
    public function createBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertMarginThreshold)) {
            $body['AlertMarginThreshold'] = $request->alertMarginThreshold;
        }
        if (!Utils::isUnset($request->baselineName)) {
            $body['BaselineName'] = $request->baselineName;
        }
        if (!Utils::isUnset($request->baselineType)) {
            $body['BaselineType'] = $request->baselineType;
        }
        if (!Utils::isUnset($request->nodeIds)) {
            $body['NodeIds'] = $request->nodeIds;
        }
        if (!Utils::isUnset($request->overtimeSettings)) {
            $body['OvertimeSettings'] = $request->overtimeSettings;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param CreateBaselineRequest $request CreateBaselineRequest
     *
     * @return CreateBaselineResponse CreateBaselineResponse
     */
    public function createBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBaselineWithOptions($request, $runtime);
    }

    /**
     * @param CreateBusinessRequest $request CreateBusinessRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateBusinessResponse CreateBusinessResponse
     */
    public function createBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessName)) {
            $body['BusinessName'] = $request->businessName;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->useType)) {
            $body['UseType'] = $request->useType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateBusinessRequest $request CreateBusinessRequest
     *
     * @return CreateBusinessResponse CreateBusinessResponse
     */
    public function createBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBusinessWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateConnection is deprecated
     *  *
     * @summary 
     *  *
     * Deprecated
     *
     * @param CreateConnectionRequest $request CreateConnectionRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateConnectionResponse CreateConnectionResponse
     */
    public function createConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->connectionType)) {
            $query['ConnectionType'] = $request->connectionType;
        }
        if (!Utils::isUnset($request->content)) {
            $query['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->subType)) {
            $query['SubType'] = $request->subType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateConnection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateConnection is deprecated
     *  *
     * @summary 
     *  *
     * Deprecated
     *
     * @param CreateConnectionRequest $request CreateConnectionRequest
     *
     * @return CreateConnectionResponse CreateConnectionResponse
     */
    public function createConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param CreateDIAlarmRuleRequest $tmpReq  CreateDIAlarmRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDIAlarmRuleResponse CreateDIAlarmRuleResponse
     */
    public function createDIAlarmRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateDIAlarmRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->notificationSettings)) {
            $request->notificationSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->notificationSettings, 'NotificationSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->triggerConditions)) {
            $request->triggerConditionsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->triggerConditions, 'TriggerConditions', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->enabled)) {
            $body['Enabled'] = $request->enabled;
        }
        if (!Utils::isUnset($request->metricType)) {
            $body['MetricType'] = $request->metricType;
        }
        if (!Utils::isUnset($request->notificationSettingsShrink)) {
            $body['NotificationSettings'] = $request->notificationSettingsShrink;
        }
        if (!Utils::isUnset($request->triggerConditionsShrink)) {
            $body['TriggerConditions'] = $request->triggerConditionsShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDIAlarmRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param CreateDIAlarmRuleRequest $request CreateDIAlarmRuleRequest
     *
     * @return CreateDIAlarmRuleResponse CreateDIAlarmRuleResponse
     */
    public function createDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param CreateDIJobRequest $tmpReq  CreateDIJobRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDIJobResponse CreateDIJobResponse
     */
    public function createDIJobWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateDIJobShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->destinationDataSourceSettings)) {
            $request->destinationDataSourceSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->destinationDataSourceSettings, 'DestinationDataSourceSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->jobSettings)) {
            $request->jobSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->jobSettings, 'JobSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->resourceSettings)) {
            $request->resourceSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->resourceSettings, 'ResourceSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->sourceDataSourceSettings)) {
            $request->sourceDataSourceSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->sourceDataSourceSettings, 'SourceDataSourceSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->tableMappings)) {
            $request->tableMappingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tableMappings, 'TableMappings', 'json');
        }
        if (!Utils::isUnset($tmpReq->transformationRules)) {
            $request->transformationRulesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->transformationRules, 'TransformationRules', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->systemDebug)) {
            $query['SystemDebug'] = $request->systemDebug;
        }
        $body = [];
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->destinationDataSourceSettingsShrink)) {
            $body['DestinationDataSourceSettings'] = $request->destinationDataSourceSettingsShrink;
        }
        if (!Utils::isUnset($request->destinationDataSourceType)) {
            $body['DestinationDataSourceType'] = $request->destinationDataSourceType;
        }
        if (!Utils::isUnset($request->jobName)) {
            $body['JobName'] = $request->jobName;
        }
        if (!Utils::isUnset($request->jobSettingsShrink)) {
            $body['JobSettings'] = $request->jobSettingsShrink;
        }
        if (!Utils::isUnset($request->migrationType)) {
            $body['MigrationType'] = $request->migrationType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->resourceSettingsShrink)) {
            $body['ResourceSettings'] = $request->resourceSettingsShrink;
        }
        if (!Utils::isUnset($request->sourceDataSourceSettingsShrink)) {
            $body['SourceDataSourceSettings'] = $request->sourceDataSourceSettingsShrink;
        }
        if (!Utils::isUnset($request->sourceDataSourceType)) {
            $body['SourceDataSourceType'] = $request->sourceDataSourceType;
        }
        if (!Utils::isUnset($request->tableMappingsShrink)) {
            $body['TableMappings'] = $request->tableMappingsShrink;
        }
        if (!Utils::isUnset($request->transformationRulesShrink)) {
            $body['TransformationRules'] = $request->transformationRulesShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param CreateDIJobRequest $request CreateDIJobRequest
     *
     * @return CreateDIJobResponse CreateDIJobResponse
     */
    public function createDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a data synchronization task.
     *  *
     * @param CreateDISyncTaskRequest $request CreateDISyncTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDISyncTaskResponse CreateDISyncTaskResponse
     */
    public function createDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskContent)) {
            $query['TaskContent'] = $request->taskContent;
        }
        if (!Utils::isUnset($request->taskName)) {
            $query['TaskName'] = $request->taskName;
        }
        if (!Utils::isUnset($request->taskParam)) {
            $query['TaskParam'] = $request->taskParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a data synchronization task.
     *  *
     * @param CreateDISyncTaskRequest $request CreateDISyncTaskRequest
     *
     * @return CreateDISyncTaskResponse CreateDISyncTaskResponse
     */
    public function createDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateDagComplement is deprecated
     *  *
     * Deprecated
     *
     * @param CreateDagComplementRequest $request CreateDagComplementRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDagComplementResponse CreateDagComplementResponse
     */
    public function createDagComplementWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizBeginTime)) {
            $body['BizBeginTime'] = $request->bizBeginTime;
        }
        if (!Utils::isUnset($request->bizEndTime)) {
            $body['BizEndTime'] = $request->bizEndTime;
        }
        if (!Utils::isUnset($request->endBizDate)) {
            $body['EndBizDate'] = $request->endBizDate;
        }
        if (!Utils::isUnset($request->excludeNodeIds)) {
            $body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }
        if (!Utils::isUnset($request->includeNodeIds)) {
            $body['IncludeNodeIds'] = $request->includeNodeIds;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nodeParams)) {
            $body['NodeParams'] = $request->nodeParams;
        }
        if (!Utils::isUnset($request->parallelism)) {
            $body['Parallelism'] = $request->parallelism;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->rootNodeId)) {
            $body['RootNodeId'] = $request->rootNodeId;
        }
        if (!Utils::isUnset($request->startBizDate)) {
            $body['StartBizDate'] = $request->startBizDate;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDagComplement',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDagComplementResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateDagComplement is deprecated
     *  *
     * Deprecated
     *
     * @param CreateDagComplementRequest $request CreateDagComplementRequest
     *
     * @return CreateDagComplementResponse CreateDagComplementResponse
     */
    public function createDagComplement($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDagComplementWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateDagTest is deprecated
     *  *
     * Deprecated
     *
     * @param CreateDagTestRequest $request CreateDagTestRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDagTestResponse CreateDagTestResponse
     */
    public function createDagTestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeParams)) {
            $body['NodeParams'] = $request->nodeParams;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDagTest',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDagTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateDagTest is deprecated
     *  *
     * Deprecated
     *
     * @param CreateDagTestRequest $request CreateDagTestRequest
     *
     * @return CreateDagTestResponse CreateDagTestResponse
     */
    public function createDagTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDagTestWithOptions($request, $runtime);
    }

    /**
     * @param CreateDataServiceApiRequest $request CreateDataServiceApiRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataServiceApiResponse CreateDataServiceApiResponse
     */
    public function createDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiDescription)) {
            $body['ApiDescription'] = $request->apiDescription;
        }
        if (!Utils::isUnset($request->apiMode)) {
            $body['ApiMode'] = $request->apiMode;
        }
        if (!Utils::isUnset($request->apiName)) {
            $body['ApiName'] = $request->apiName;
        }
        if (!Utils::isUnset($request->apiPath)) {
            $body['ApiPath'] = $request->apiPath;
        }
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->protocols)) {
            $body['Protocols'] = $request->protocols;
        }
        if (!Utils::isUnset($request->registrationDetails)) {
            $body['RegistrationDetails'] = $request->registrationDetails;
        }
        if (!Utils::isUnset($request->requestContentType)) {
            $body['RequestContentType'] = $request->requestContentType;
        }
        if (!Utils::isUnset($request->requestMethod)) {
            $body['RequestMethod'] = $request->requestMethod;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $body['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->responseContentType)) {
            $body['ResponseContentType'] = $request->responseContentType;
        }
        if (!Utils::isUnset($request->scriptDetails)) {
            $body['ScriptDetails'] = $request->scriptDetails;
        }
        if (!Utils::isUnset($request->sqlMode)) {
            $body['SqlMode'] = $request->sqlMode;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        if (!Utils::isUnset($request->timeout)) {
            $body['Timeout'] = $request->timeout;
        }
        if (!Utils::isUnset($request->visibleRange)) {
            $body['VisibleRange'] = $request->visibleRange;
        }
        if (!Utils::isUnset($request->wizardDetails)) {
            $body['WizardDetails'] = $request->wizardDetails;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateDataServiceApiRequest $request CreateDataServiceApiRequest
     *
     * @return CreateDataServiceApiResponse CreateDataServiceApiResponse
     */
    public function createDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Grants the access permissions on an API in DataService Studio.
     *  *
     * @param CreateDataServiceApiAuthorityRequest $request CreateDataServiceApiAuthorityRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataServiceApiAuthorityResponse CreateDataServiceApiAuthorityResponse
     */
    public function createDataServiceApiAuthorityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->authorizedProjectId)) {
            $body['AuthorizedProjectId'] = $request->authorizedProjectId;
        }
        if (!Utils::isUnset($request->endTime)) {
            $body['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDataServiceApiAuthority',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataServiceApiAuthorityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Grants the access permissions on an API in DataService Studio.
     *  *
     * @param CreateDataServiceApiAuthorityRequest $request CreateDataServiceApiAuthorityRequest
     *
     * @return CreateDataServiceApiAuthorityResponse CreateDataServiceApiAuthorityResponse
     */
    public function createDataServiceApiAuthority($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceApiAuthorityWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a folder in DataService Studio.
     *  *
     * @param CreateDataServiceFolderRequest $request CreateDataServiceFolderRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataServiceFolderResponse CreateDataServiceFolderResponse
     */
    public function createDataServiceFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderName)) {
            $body['FolderName'] = $request->folderName;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->parentId)) {
            $body['ParentId'] = $request->parentId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDataServiceFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataServiceFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a folder in DataService Studio.
     *  *
     * @param CreateDataServiceFolderRequest $request CreateDataServiceFolderRequest
     *
     * @return CreateDataServiceFolderResponse CreateDataServiceFolderResponse
     */
    public function createDataServiceFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a business process.
     *  *
     * @param CreateDataServiceGroupRequest $request CreateDataServiceGroupRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataServiceGroupResponse CreateDataServiceGroupResponse
     */
    public function createDataServiceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiGatewayGroupId)) {
            $body['ApiGatewayGroupId'] = $request->apiGatewayGroupId;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->groupName)) {
            $body['GroupName'] = $request->groupName;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateDataServiceGroup',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataServiceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a business process.
     *  *
     * @param CreateDataServiceGroupRequest $request CreateDataServiceGroupRequest
     *
     * @return CreateDataServiceGroupResponse CreateDataServiceGroupResponse
     */
    public function createDataServiceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param CreateDataSourceRequest $request CreateDataSourceRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateDataSourceResponse CreateDataSourceResponse
     */
    public function createDataSourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->content)) {
            $query['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->subType)) {
            $query['SubType'] = $request->subType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateDataSource',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param CreateDataSourceRequest $request CreateDataSourceRequest
     *
     * @return CreateDataSourceResponse CreateDataSourceResponse
     */
    public function createDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataSourceWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param CreateExportMigrationRequest $request CreateExportMigrationRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateExportMigrationResponse CreateExportMigrationResponse
     */
    public function createExportMigrationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->exportMode)) {
            $body['ExportMode'] = $request->exportMode;
        }
        if (!Utils::isUnset($request->exportObjectStatus)) {
            $body['ExportObjectStatus'] = $request->exportObjectStatus;
        }
        if (!Utils::isUnset($request->incrementalSince)) {
            $body['IncrementalSince'] = $request->incrementalSince;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateExportMigration',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateExportMigrationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param CreateExportMigrationRequest $request CreateExportMigrationRequest
     *
     * @return CreateExportMigrationResponse CreateExportMigrationResponse
     */
    public function createExportMigration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExportMigrationWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a file in DataStudio. You cannot call this operation to create files for Data Integration nodes.
     *  *
     * @param CreateFileRequest $request CreateFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFileResponse CreateFileResponse
     */
    public function createFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->advancedSettings)) {
            $body['AdvancedSettings'] = $request->advancedSettings;
        }
        if (!Utils::isUnset($request->autoParsing)) {
            $body['AutoParsing'] = $request->autoParsing;
        }
        if (!Utils::isUnset($request->autoRerunIntervalMillis)) {
            $body['AutoRerunIntervalMillis'] = $request->autoRerunIntervalMillis;
        }
        if (!Utils::isUnset($request->autoRerunTimes)) {
            $body['AutoRerunTimes'] = $request->autoRerunTimes;
        }
        if (!Utils::isUnset($request->connectionName)) {
            $body['ConnectionName'] = $request->connectionName;
        }
        if (!Utils::isUnset($request->content)) {
            $body['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->createFolderIfNotExists)) {
            $body['CreateFolderIfNotExists'] = $request->createFolderIfNotExists;
        }
        if (!Utils::isUnset($request->cronExpress)) {
            $body['CronExpress'] = $request->cronExpress;
        }
        if (!Utils::isUnset($request->cycleType)) {
            $body['CycleType'] = $request->cycleType;
        }
        if (!Utils::isUnset($request->dependentNodeIdList)) {
            $body['DependentNodeIdList'] = $request->dependentNodeIdList;
        }
        if (!Utils::isUnset($request->dependentType)) {
            $body['DependentType'] = $request->dependentType;
        }
        if (!Utils::isUnset($request->endEffectDate)) {
            $body['EndEffectDate'] = $request->endEffectDate;
        }
        if (!Utils::isUnset($request->fileDescription)) {
            $body['FileDescription'] = $request->fileDescription;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileName)) {
            $body['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->fileType)) {
            $body['FileType'] = $request->fileType;
        }
        if (!Utils::isUnset($request->ignoreParentSkipRunningProperty)) {
            $body['IgnoreParentSkipRunningProperty'] = $request->ignoreParentSkipRunningProperty;
        }
        if (!Utils::isUnset($request->inputList)) {
            $body['InputList'] = $request->inputList;
        }
        if (!Utils::isUnset($request->inputParameters)) {
            $body['InputParameters'] = $request->inputParameters;
        }
        if (!Utils::isUnset($request->outputParameters)) {
            $body['OutputParameters'] = $request->outputParameters;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->paraValue)) {
            $body['ParaValue'] = $request->paraValue;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->rerunMode)) {
            $body['RerunMode'] = $request->rerunMode;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $body['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->resourceGroupIdentifier)) {
            $body['ResourceGroupIdentifier'] = $request->resourceGroupIdentifier;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        if (!Utils::isUnset($request->startEffectDate)) {
            $body['StartEffectDate'] = $request->startEffectDate;
        }
        if (!Utils::isUnset($request->startImmediately)) {
            $body['StartImmediately'] = $request->startImmediately;
        }
        if (!Utils::isUnset($request->stop)) {
            $body['Stop'] = $request->stop;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a file in DataStudio. You cannot call this operation to create files for Data Integration nodes.
     *  *
     * @param CreateFileRequest $request CreateFileRequest
     *
     * @return CreateFileResponse CreateFileResponse
     */
    public function createFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CreateFolder**.
     *  *
     * @param CreateFolderRequest $request CreateFolderRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateFolderResponse CreateFolderResponse
     */
    public function createFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderPath)) {
            $body['FolderPath'] = $request->folderPath;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CreateFolder**.
     *  *
     * @param CreateFolderRequest $request CreateFolderRequest
     *
     * @return CreateFolderResponse CreateFolderResponse
     */
    public function createFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFolderWithOptions($request, $runtime);
    }

    /**
     * @description The import package must be uploaded. Example of the upload method:
     * Config config = new Config();
     * config.setAccessKeyId(accessId);
     * config.setAccessKeySecret(accessKey);
     * config.setEndpoint(popEndpoint);
     * config.setRegionId(regionId);
     * Client client = new Client(config);
     * CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
     * request.setName("test_migration_api_" + System.currentTimeMillis());
     * request.setProjectId(123456L);
     * request.setPackageType("DATAWORKS_MODEL");
     * request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
     * RuntimeOptions runtime = new RuntimeOptions();
     * CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
     * ...
     *  *
     * @param CreateImportMigrationRequest $request CreateImportMigrationRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateImportMigrationResponse CreateImportMigrationResponse
     */
    public function createImportMigrationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->calculateEngineMap)) {
            $body['CalculateEngineMap'] = $request->calculateEngineMap;
        }
        if (!Utils::isUnset($request->commitRule)) {
            $body['CommitRule'] = $request->commitRule;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->packageFile)) {
            $body['PackageFile'] = $request->packageFile;
        }
        if (!Utils::isUnset($request->packageType)) {
            $body['PackageType'] = $request->packageType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->resourceGroupMap)) {
            $body['ResourceGroupMap'] = $request->resourceGroupMap;
        }
        if (!Utils::isUnset($request->workspaceMap)) {
            $body['WorkspaceMap'] = $request->workspaceMap;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateImportMigration',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateImportMigrationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description The import package must be uploaded. Example of the upload method:
     * Config config = new Config();
     * config.setAccessKeyId(accessId);
     * config.setAccessKeySecret(accessKey);
     * config.setEndpoint(popEndpoint);
     * config.setRegionId(regionId);
     * Client client = new Client(config);
     * CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
     * request.setName("test_migration_api_" + System.currentTimeMillis());
     * request.setProjectId(123456L);
     * request.setPackageType("DATAWORKS_MODEL");
     * request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
     * RuntimeOptions runtime = new RuntimeOptions();
     * CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
     * ...
     *  *
     * @param CreateImportMigrationRequest $request CreateImportMigrationRequest
     *
     * @return CreateImportMigrationResponse CreateImportMigrationResponse
     */
    public function createImportMigration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createImportMigrationWithOptions($request, $runtime);
    }

    /**
     * @param CreateImportMigrationAdvanceRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CreateImportMigrationResponse
     */
    public function createImportMigrationAdvance($request, $runtime)
    {
        // Step 0: init client
        $accessKeyId          = $this->_credential->getAccessKeyId();
        $accessKeySecret      = $this->_credential->getAccessKeySecret();
        $securityToken        = $this->_credential->getSecurityToken();
        $credentialType       = $this->_credential->getType();
        $openPlatformEndpoint = $this->_openPlatformEndpoint;
        if (Utils::empty_($openPlatformEndpoint)) {
            $openPlatformEndpoint = 'openplatform.aliyuncs.com';
        }
        if (Utils::isUnset($credentialType)) {
            $credentialType = 'access_key';
        }
        $authConfig = new Config([
            'accessKeyId'     => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'securityToken'   => $securityToken,
            'type'            => $credentialType,
            'endpoint'        => $openPlatformEndpoint,
            'protocol'        => $this->_protocol,
            'regionId'        => $this->_regionId,
        ]);
        $authClient  = new OpenPlatform($authConfig);
        $authRequest = new AuthorizeFileUploadRequest([
            'product'  => 'dataworks-public',
            'regionId' => $this->_regionId,
        ]);
        $authResponse = new AuthorizeFileUploadResponse([]);
        $ossConfig    = new \AlibabaCloud\SDK\OSS\OSS\Config([
            'accessKeyId'     => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'type'            => 'access_key',
            'protocol'        => $this->_protocol,
            'regionId'        => $this->_regionId,
        ]);
        $ossClient     = new OSS($ossConfig);
        $fileObj       = new FileField([]);
        $ossHeader     = new header([]);
        $uploadRequest = new PostObjectRequest([]);
        $ossRuntime    = new \AlibabaCloud\Tea\OSSUtils\OSSUtils\RuntimeOptions([]);
        OpenApiUtilClient::convert($runtime, $ossRuntime);
        $createImportMigrationReq = new CreateImportMigrationRequest([]);
        OpenApiUtilClient::convert($request, $createImportMigrationReq);
        if (!Utils::isUnset($request->packageFileObject)) {
            $authResponse           = $authClient->authorizeFileUploadWithOptions($authRequest, $runtime);
            $ossConfig->accessKeyId = $authResponse->body->accessKeyId;
            $ossConfig->endpoint    = OpenApiUtilClient::getEndpoint($authResponse->body->endpoint, $authResponse->body->useAccelerate, $this->_endpointType);
            $ossClient              = new OSS($ossConfig);
            $fileObj                = new FileField([
                'filename'    => $authResponse->body->objectKey,
                'content'     => $request->packageFileObject,
                'contentType' => '',
            ]);
            $ossHeader = new header([
                'accessKeyId'         => $authResponse->body->accessKeyId,
                'policy'              => $authResponse->body->encodedPolicy,
                'signature'           => $authResponse->body->signature,
                'key'                 => $authResponse->body->objectKey,
                'file'                => $fileObj,
                'successActionStatus' => '201',
            ]);
            $uploadRequest = new PostObjectRequest([
                'bucketName' => $authResponse->body->bucket,
                'header'     => $ossHeader,
            ]);
            $ossClient->postObject($uploadRequest, $ossRuntime);
            $createImportMigrationReq->packageFile = 'http://' . $authResponse->body->bucket . '.' . $authResponse->body->endpoint . '/' . $authResponse->body->objectKey . '';
        }

        return $this->createImportMigrationWithOptions($createImportMigrationReq, $runtime);
    }

    /**
     * @deprecated OpenAPI CreateManualDag is deprecated
     *  *
     * Deprecated
     *
     * @param CreateManualDagRequest $request CreateManualDagRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateManualDagResponse CreateManualDagResponse
     */
    public function createManualDagWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->dagParameters)) {
            $body['DagParameters'] = $request->dagParameters;
        }
        if (!Utils::isUnset($request->excludeNodeIds)) {
            $body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }
        if (!Utils::isUnset($request->flowName)) {
            $body['FlowName'] = $request->flowName;
        }
        if (!Utils::isUnset($request->includeNodeIds)) {
            $body['IncludeNodeIds'] = $request->includeNodeIds;
        }
        if (!Utils::isUnset($request->nodeParameters)) {
            $body['NodeParameters'] = $request->nodeParameters;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateManualDag',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateManualDagResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI CreateManualDag is deprecated
     *  *
     * Deprecated
     *
     * @param CreateManualDagRequest $request CreateManualDagRequest
     *
     * @return CreateManualDagResponse CreateManualDagResponse
     */
    public function createManualDag($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createManualDagWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a category.
     *  *
     * @param CreateMetaCategoryRequest $request CreateMetaCategoryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMetaCategoryResponse CreateMetaCategoryResponse
     */
    public function createMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->parentId)) {
            $body['ParentId'] = $request->parentId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a category.
     *  *
     * @param CreateMetaCategoryRequest $request CreateMetaCategoryRequest
     *
     * @return CreateMetaCategoryResponse CreateMetaCategoryResponse
     */
    public function createMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a collection.
     *  *
     * @description Collections are classified into various types. The names of collections of the same type must be different.
     *  *
     * @param CreateMetaCollectionRequest $request CreateMetaCollectionRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateMetaCollectionResponse CreateMetaCollectionResponse
     */
    public function createMetaCollectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->collectionType)) {
            $query['CollectionType'] = $request->collectionType;
        }
        if (!Utils::isUnset($request->comment)) {
            $query['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->parentQualifiedName)) {
            $query['ParentQualifiedName'] = $request->parentQualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateMetaCollection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateMetaCollectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a collection.
     *  *
     * @description Collections are classified into various types. The names of collections of the same type must be different.
     *  *
     * @param CreateMetaCollectionRequest $request CreateMetaCollectionRequest
     *
     * @return CreateMetaCollectionResponse CreateMetaCollectionResponse
     */
    public function createMetaCollection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMetaCollectionWithOptions($request, $runtime);
    }

    /**
     * @param CreatePermissionApplyOrderRequest $request CreatePermissionApplyOrderRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return CreatePermissionApplyOrderResponse CreatePermissionApplyOrderResponse
     */
    public function createPermissionApplyOrderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->applyObject)) {
            $query['ApplyObject'] = $request->applyObject;
        }
        if (!Utils::isUnset($request->applyReason)) {
            $query['ApplyReason'] = $request->applyReason;
        }
        if (!Utils::isUnset($request->applyUserIds)) {
            $query['ApplyUserIds'] = $request->applyUserIds;
        }
        if (!Utils::isUnset($request->deadline)) {
            $query['Deadline'] = $request->deadline;
        }
        if (!Utils::isUnset($request->engineType)) {
            $query['EngineType'] = $request->engineType;
        }
        if (!Utils::isUnset($request->maxComputeProjectName)) {
            $query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }
        if (!Utils::isUnset($request->orderType)) {
            $query['OrderType'] = $request->orderType;
        }
        if (!Utils::isUnset($request->workspaceId)) {
            $query['WorkspaceId'] = $request->workspaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreatePermissionApplyOrder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreatePermissionApplyOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreatePermissionApplyOrderRequest $request CreatePermissionApplyOrderRequest
     *
     * @return CreatePermissionApplyOrderResponse CreatePermissionApplyOrderResponse
     */
    public function createPermissionApplyOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPermissionApplyOrderWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param CreateProjectRequest $tmpReq  CreateProjectRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateProjectResponse CreateProjectResponse
     */
    public function createProjectWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new CreateProjectShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->disableDevelopment)) {
            $query['DisableDevelopment'] = $request->disableDevelopment;
        }
        if (!Utils::isUnset($request->isAllowDownload)) {
            $query['IsAllowDownload'] = $request->isAllowDownload;
        }
        if (!Utils::isUnset($request->projectDescription)) {
            $query['ProjectDescription'] = $request->projectDescription;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $query['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->projectMode)) {
            $query['ProjectMode'] = $request->projectMode;
        }
        if (!Utils::isUnset($request->projectName)) {
            $query['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->resourceManagerResourceGroupId)) {
            $query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }
        if (!Utils::isUnset($request->tagsShrink)) {
            $query['Tags'] = $request->tagsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateProject',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param CreateProjectRequest $request CreateProjectRequest
     *
     * @return CreateProjectResponse CreateProjectResponse
     */
    public function createProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createProjectWithOptions($request, $runtime);
    }

    /**
     * @param CreateProjectMemberRequest $request CreateProjectMemberRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateProjectMemberResponse CreateProjectMemberResponse
     */
    public function createProjectMemberWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->roleCode)) {
            $query['RoleCode'] = $request->roleCode;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateProjectMember',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateProjectMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateProjectMemberRequest $request CreateProjectMemberRequest
     *
     * @return CreateProjectMemberResponse CreateProjectMemberResponse
     */
    public function createProjectMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createProjectMemberWithOptions($request, $runtime);
    }

    /**
     * @param CreateQualityEntityRequest $request CreateQualityEntityRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateQualityEntityResponse CreateQualityEntityResponse
     */
    public function createQualityEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->entityLevel)) {
            $body['EntityLevel'] = $request->entityLevel;
        }
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->matchExpression)) {
            $body['MatchExpression'] = $request->matchExpression;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $body['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateQualityEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateQualityEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateQualityEntityRequest $request CreateQualityEntityRequest
     *
     * @return CreateQualityEntityResponse CreateQualityEntityResponse
     */
    public function createQualityEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityEntityWithOptions($request, $runtime);
    }

    /**
     * @param CreateQualityFollowerRequest $request CreateQualityFollowerRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateQualityFollowerResponse CreateQualityFollowerResponse
     */
    public function createQualityFollowerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alarmMode)) {
            $body['AlarmMode'] = $request->alarmMode;
        }
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->follower)) {
            $body['Follower'] = $request->follower;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateQualityFollower',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateQualityFollowerRequest $request CreateQualityFollowerRequest
     *
     * @return CreateQualityFollowerResponse CreateQualityFollowerResponse
     */
    public function createQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * @param CreateQualityRelativeNodeRequest $request CreateQualityRelativeNodeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateQualityRelativeNodeResponse CreateQualityRelativeNodeResponse
     */
    public function createQualityRelativeNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->matchExpression)) {
            $body['MatchExpression'] = $request->matchExpression;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $body['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->targetNodeProjectId)) {
            $body['TargetNodeProjectId'] = $request->targetNodeProjectId;
        }
        if (!Utils::isUnset($request->targetNodeProjectName)) {
            $body['TargetNodeProjectName'] = $request->targetNodeProjectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateQualityRelativeNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateQualityRelativeNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateQualityRelativeNodeRequest $request CreateQualityRelativeNodeRequest
     *
     * @return CreateQualityRelativeNodeResponse CreateQualityRelativeNodeResponse
     */
    public function createQualityRelativeNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityRelativeNodeWithOptions($request, $runtime);
    }

    /**
     * @param CreateQualityRuleRequest $request CreateQualityRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateQualityRuleResponse CreateQualityRuleResponse
     */
    public function createQualityRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->blockType)) {
            $body['BlockType'] = $request->blockType;
        }
        if (!Utils::isUnset($request->checker)) {
            $body['Checker'] = $request->checker;
        }
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->criticalThreshold)) {
            $body['CriticalThreshold'] = $request->criticalThreshold;
        }
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->expectValue)) {
            $body['ExpectValue'] = $request->expectValue;
        }
        if (!Utils::isUnset($request->methodName)) {
            $body['MethodName'] = $request->methodName;
        }
        if (!Utils::isUnset($request->operator)) {
            $body['Operator'] = $request->operator;
        }
        if (!Utils::isUnset($request->predictType)) {
            $body['PredictType'] = $request->predictType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->property)) {
            $body['Property'] = $request->property;
        }
        if (!Utils::isUnset($request->propertyType)) {
            $body['PropertyType'] = $request->propertyType;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $body['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $body['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->taskSetting)) {
            $body['TaskSetting'] = $request->taskSetting;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->trend)) {
            $body['Trend'] = $request->trend;
        }
        if (!Utils::isUnset($request->warningThreshold)) {
            $body['WarningThreshold'] = $request->warningThreshold;
        }
        if (!Utils::isUnset($request->whereCondition)) {
            $body['WhereCondition'] = $request->whereCondition;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateQualityRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateQualityRuleRequest $request CreateQualityRuleRequest
     *
     * @return CreateQualityRuleResponse CreateQualityRuleResponse
     */
    public function createQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityRuleWithOptions($request, $runtime);
    }

    /**
     * @param CreateRemindRequest $request CreateRemindRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateRemindResponse CreateRemindResponse
     */
    public function createRemindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertInterval)) {
            $body['AlertInterval'] = $request->alertInterval;
        }
        if (!Utils::isUnset($request->alertMethods)) {
            $body['AlertMethods'] = $request->alertMethods;
        }
        if (!Utils::isUnset($request->alertTargets)) {
            $body['AlertTargets'] = $request->alertTargets;
        }
        if (!Utils::isUnset($request->alertUnit)) {
            $body['AlertUnit'] = $request->alertUnit;
        }
        if (!Utils::isUnset($request->baselineIds)) {
            $body['BaselineIds'] = $request->baselineIds;
        }
        if (!Utils::isUnset($request->bizProcessIds)) {
            $body['BizProcessIds'] = $request->bizProcessIds;
        }
        if (!Utils::isUnset($request->detail)) {
            $body['Detail'] = $request->detail;
        }
        if (!Utils::isUnset($request->dndEnd)) {
            $body['DndEnd'] = $request->dndEnd;
        }
        if (!Utils::isUnset($request->maxAlertTimes)) {
            $body['MaxAlertTimes'] = $request->maxAlertTimes;
        }
        if (!Utils::isUnset($request->nodeIds)) {
            $body['NodeIds'] = $request->nodeIds;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->remindName)) {
            $body['RemindName'] = $request->remindName;
        }
        if (!Utils::isUnset($request->remindType)) {
            $body['RemindType'] = $request->remindType;
        }
        if (!Utils::isUnset($request->remindUnit)) {
            $body['RemindUnit'] = $request->remindUnit;
        }
        if (!Utils::isUnset($request->robotUrls)) {
            $body['RobotUrls'] = $request->robotUrls;
        }
        if (!Utils::isUnset($request->webhooks)) {
            $body['Webhooks'] = $request->webhooks;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateRemind',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateRemindRequest $request CreateRemindRequest
     *
     * @return CreateRemindResponse CreateRemindResponse
     */
    public function createRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRemindWithOptions($request, $runtime);
    }

    /**
     * @summary jarpyarhivefile
     *  *
     * @param CreateResourceFileRequest $request CreateResourceFileRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateResourceFileResponse CreateResourceFileResponse
     */
    public function createResourceFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->content)) {
            $body['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->fileDescription)) {
            $body['FileDescription'] = $request->fileDescription;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileName)) {
            $body['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->fileType)) {
            $body['FileType'] = $request->fileType;
        }
        if (!Utils::isUnset($request->originResourceName)) {
            $body['OriginResourceName'] = $request->originResourceName;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->registerToCalcEngine)) {
            $body['RegisterToCalcEngine'] = $request->registerToCalcEngine;
        }
        if (!Utils::isUnset($request->resourceFile)) {
            $body['ResourceFile'] = $request->resourceFile;
        }
        if (!Utils::isUnset($request->storageURL)) {
            $body['StorageURL'] = $request->storageURL;
        }
        if (!Utils::isUnset($request->uploadMode)) {
            $body['UploadMode'] = $request->uploadMode;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateResourceFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateResourceFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary jarpyarhivefile
     *  *
     * @param CreateResourceFileRequest $request CreateResourceFileRequest
     *
     * @return CreateResourceFileResponse CreateResourceFileResponse
     */
    public function createResourceFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createResourceFileWithOptions($request, $runtime);
    }

    /**
     * @param CreateResourceFileAdvanceRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateResourceFileResponse
     */
    public function createResourceFileAdvance($request, $runtime)
    {
        // Step 0: init client
        $accessKeyId          = $this->_credential->getAccessKeyId();
        $accessKeySecret      = $this->_credential->getAccessKeySecret();
        $securityToken        = $this->_credential->getSecurityToken();
        $credentialType       = $this->_credential->getType();
        $openPlatformEndpoint = $this->_openPlatformEndpoint;
        if (Utils::empty_($openPlatformEndpoint)) {
            $openPlatformEndpoint = 'openplatform.aliyuncs.com';
        }
        if (Utils::isUnset($credentialType)) {
            $credentialType = 'access_key';
        }
        $authConfig = new Config([
            'accessKeyId'     => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'securityToken'   => $securityToken,
            'type'            => $credentialType,
            'endpoint'        => $openPlatformEndpoint,
            'protocol'        => $this->_protocol,
            'regionId'        => $this->_regionId,
        ]);
        $authClient  = new OpenPlatform($authConfig);
        $authRequest = new AuthorizeFileUploadRequest([
            'product'  => 'dataworks-public',
            'regionId' => $this->_regionId,
        ]);
        $authResponse = new AuthorizeFileUploadResponse([]);
        $ossConfig    = new \AlibabaCloud\SDK\OSS\OSS\Config([
            'accessKeyId'     => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'type'            => 'access_key',
            'protocol'        => $this->_protocol,
            'regionId'        => $this->_regionId,
        ]);
        $ossClient     = new OSS($ossConfig);
        $fileObj       = new FileField([]);
        $ossHeader     = new header([]);
        $uploadRequest = new PostObjectRequest([]);
        $ossRuntime    = new \AlibabaCloud\Tea\OSSUtils\OSSUtils\RuntimeOptions([]);
        OpenApiUtilClient::convert($runtime, $ossRuntime);
        $createResourceFileReq = new CreateResourceFileRequest([]);
        OpenApiUtilClient::convert($request, $createResourceFileReq);
        if (!Utils::isUnset($request->resourceFileObject)) {
            $authResponse           = $authClient->authorizeFileUploadWithOptions($authRequest, $runtime);
            $ossConfig->accessKeyId = $authResponse->body->accessKeyId;
            $ossConfig->endpoint    = OpenApiUtilClient::getEndpoint($authResponse->body->endpoint, $authResponse->body->useAccelerate, $this->_endpointType);
            $ossClient              = new OSS($ossConfig);
            $fileObj                = new FileField([
                'filename'    => $authResponse->body->objectKey,
                'content'     => $request->resourceFileObject,
                'contentType' => '',
            ]);
            $ossHeader = new header([
                'accessKeyId'         => $authResponse->body->accessKeyId,
                'policy'              => $authResponse->body->encodedPolicy,
                'signature'           => $authResponse->body->signature,
                'key'                 => $authResponse->body->objectKey,
                'file'                => $fileObj,
                'successActionStatus' => '201',
            ]);
            $uploadRequest = new PostObjectRequest([
                'bucketName' => $authResponse->body->bucket,
                'header'     => $ossHeader,
            ]);
            $ossClient->postObject($uploadRequest, $ossRuntime);
            $createResourceFileReq->resourceFile = 'http://' . $authResponse->body->bucket . '.' . $authResponse->body->endpoint . '/' . $authResponse->body->objectKey . '';
        }

        return $this->createResourceFileWithOptions($createResourceFileReq, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CreateTable**.
     *  *
     * @param CreateTableRequest $request CreateTableRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateTableResponse CreateTableResponse
     */
    public function createTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->comment)) {
            $query['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->externalTableType)) {
            $query['ExternalTableType'] = $request->externalTableType;
        }
        if (!Utils::isUnset($request->hasPart)) {
            $query['HasPart'] = $request->hasPart;
        }
        if (!Utils::isUnset($request->isView)) {
            $query['IsView'] = $request->isView;
        }
        if (!Utils::isUnset($request->lifeCycle)) {
            $query['LifeCycle'] = $request->lifeCycle;
        }
        if (!Utils::isUnset($request->location)) {
            $query['Location'] = $request->location;
        }
        if (!Utils::isUnset($request->logicalLevelId)) {
            $query['LogicalLevelId'] = $request->logicalLevelId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicsLevelId)) {
            $query['PhysicsLevelId'] = $request->physicsLevelId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->visibility)) {
            $query['Visibility'] = $request->visibility;
        }
        $body = [];
        if (!Utils::isUnset($request->columns)) {
            $body['Columns'] = $request->columns;
        }
        if (!Utils::isUnset($request->endpoint)) {
            $body['Endpoint'] = $request->endpoint;
        }
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->themes)) {
            $body['Themes'] = $request->themes;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **CreateTable**.
     *  *
     * @param CreateTableRequest $request CreateTableRequest
     *
     * @return CreateTableResponse CreateTableResponse
     */
    public function createTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTableWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the DataWorks workspace.
     *  *
     * @param CreateTableLevelRequest $request CreateTableLevelRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateTableLevelResponse CreateTableLevelResponse
     */
    public function createTableLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->levelType)) {
            $query['LevelType'] = $request->levelType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateTableLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the DataWorks workspace.
     *  *
     * @param CreateTableLevelRequest $request CreateTableLevelRequest
     *
     * @return CreateTableLevelResponse CreateTableLevelResponse
     */
    public function createTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTableLevelWithOptions($request, $runtime);
    }

    /**
     * @summary Creates a table folder. This API operation will be replaced soon. We recommend that you do not call this API operation.
     *  *
     * @param CreateTableThemeRequest $request CreateTableThemeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateTableThemeResponse CreateTableThemeResponse
     */
    public function createTableThemeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->level)) {
            $query['Level'] = $request->level;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->parentId)) {
            $query['ParentId'] = $request->parentId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'CreateTableTheme',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Creates a table folder. This API operation will be replaced soon. We recommend that you do not call this API operation.
     *  *
     * @param CreateTableThemeRequest $request CreateTableThemeRequest
     *
     * @return CreateTableThemeResponse CreateTableThemeResponse
     */
    public function createTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTableThemeWithOptions($request, $runtime);
    }

    /**
     * @param CreateUdfFileRequest $request CreateUdfFileRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return CreateUdfFileResponse CreateUdfFileResponse
     */
    public function createUdfFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->className)) {
            $body['ClassName'] = $request->className;
        }
        if (!Utils::isUnset($request->cmdDescription)) {
            $body['CmdDescription'] = $request->cmdDescription;
        }
        if (!Utils::isUnset($request->createFolderIfNotExists)) {
            $body['CreateFolderIfNotExists'] = $request->createFolderIfNotExists;
        }
        if (!Utils::isUnset($request->example)) {
            $body['Example'] = $request->example;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileName)) {
            $body['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->functionType)) {
            $body['FunctionType'] = $request->functionType;
        }
        if (!Utils::isUnset($request->parameterDescription)) {
            $body['ParameterDescription'] = $request->parameterDescription;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->resources)) {
            $body['Resources'] = $request->resources;
        }
        if (!Utils::isUnset($request->returnValue)) {
            $body['ReturnValue'] = $request->returnValue;
        }
        if (!Utils::isUnset($request->udfDescription)) {
            $body['UdfDescription'] = $request->udfDescription;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'CreateUdfFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return CreateUdfFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param CreateUdfFileRequest $request CreateUdfFileRequest
     *
     * @return CreateUdfFileResponse CreateUdfFileResponse
     */
    public function createUdfFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUdfFileWithOptions($request, $runtime);
    }

    /**
     * @param DeleteBaselineRequest $request DeleteBaselineRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBaselineResponse DeleteBaselineResponse
     */
    public function deleteBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteBaselineRequest $request DeleteBaselineRequest
     *
     * @return DeleteBaselineResponse DeleteBaselineResponse
     */
    public function deleteBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBaselineWithOptions($request, $runtime);
    }

    /**
     * @param DeleteBusinessRequest $request DeleteBusinessRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteBusinessResponse DeleteBusinessResponse
     */
    public function deleteBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessId)) {
            $body['BusinessId'] = $request->businessId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteBusinessRequest $request DeleteBusinessRequest
     *
     * @return DeleteBusinessResponse DeleteBusinessResponse
     */
    public function deleteBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBusinessWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI DeleteConnection is deprecated
     *  *
     * @summary 
     *  *
     * Deprecated
     *
     * @param DeleteConnectionRequest $request DeleteConnectionRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteConnectionResponse DeleteConnectionResponse
     */
    public function deleteConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->connectionId)) {
            $query['ConnectionId'] = $request->connectionId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteConnection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI DeleteConnection is deprecated
     *  *
     * @summary 
     *  *
     * Deprecated
     *
     * @param DeleteConnectionRequest $request DeleteConnectionRequest
     *
     * @return DeleteConnectionResponse DeleteConnectionResponse
     */
    public function deleteConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DeleteDIAlarmRuleRequest $request DeleteDIAlarmRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDIAlarmRuleResponse DeleteDIAlarmRuleResponse
     */
    public function deleteDIAlarmRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIAlarmRuleId)) {
            $body['DIAlarmRuleId'] = $request->DIAlarmRuleId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteDIAlarmRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DeleteDIAlarmRuleRequest $request DeleteDIAlarmRuleRequest
     *
     * @return DeleteDIAlarmRuleResponse DeleteDIAlarmRuleResponse
     */
    public function deleteDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DeleteDIJobRequest $request DeleteDIJobRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDIJobResponse DeleteDIJobResponse
     */
    public function deleteDIJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DeleteDIJobRequest $request DeleteDIJobRequest
     *
     * @return DeleteDIJobResponse DeleteDIJobResponse
     */
    public function deleteDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param DeleteDISyncTaskRequest $request DeleteDISyncTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDISyncTaskResponse DeleteDISyncTaskResponse
     */
    public function deleteDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param DeleteDISyncTaskRequest $request DeleteDISyncTaskRequest
     *
     * @return DeleteDISyncTaskResponse DeleteDISyncTaskResponse
     */
    public function deleteDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an API in DataService Studio.
     *  *
     * @param DeleteDataServiceApiRequest $request DeleteDataServiceApiRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDataServiceApiResponse DeleteDataServiceApiResponse
     */
    public function deleteDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an API in DataService Studio.
     *  *
     * @param DeleteDataServiceApiRequest $request DeleteDataServiceApiRequest
     *
     * @return DeleteDataServiceApiResponse DeleteDataServiceApiResponse
     */
    public function deleteDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary Revokes the access permissions on an API.
     *  *
     * @param DeleteDataServiceApiAuthorityRequest $request DeleteDataServiceApiAuthorityRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDataServiceApiAuthorityResponse DeleteDataServiceApiAuthorityResponse
     */
    public function deleteDataServiceApiAuthorityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->authorizedProjectId)) {
            $body['AuthorizedProjectId'] = $request->authorizedProjectId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteDataServiceApiAuthority',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDataServiceApiAuthorityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Revokes the access permissions on an API.
     *  *
     * @param DeleteDataServiceApiAuthorityRequest $request DeleteDataServiceApiAuthorityRequest
     *
     * @return DeleteDataServiceApiAuthorityResponse DeleteDataServiceApiAuthorityResponse
     */
    public function deleteDataServiceApiAuthority($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDataServiceApiAuthorityWithOptions($request, $runtime);
    }

    /**
     * @param DeleteDataSourceRequest $request DeleteDataSourceRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteDataSourceResponse DeleteDataSourceResponse
     */
    public function deleteDataSourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dataSourceId)) {
            $query['DataSourceId'] = $request->dataSourceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteDataSource',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteDataSourceRequest $request DeleteDataSourceRequest
     *
     * @return DeleteDataSourceResponse DeleteDataSourceResponse
     */
    public function deleteDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDataSourceWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param DeleteFileRequest $request DeleteFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFileResponse DeleteFileResponse
     */
    public function deleteFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param DeleteFileRequest $request DeleteFileRequest
     *
     * @return DeleteFileResponse DeleteFileResponse
     */
    public function deleteFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFileWithOptions($request, $runtime);
    }

    /**
     * @param DeleteFolderRequest $request DeleteFolderRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFolderResponse DeleteFolderResponse
     */
    public function deleteFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteFolderRequest $request DeleteFolderRequest
     *
     * @return DeleteFolderResponse DeleteFolderResponse
     */
    public function deleteFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Removes a metatable from a specified category.
     *  *
     * @param DeleteFromMetaCategoryRequest $request DeleteFromMetaCategoryRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteFromMetaCategoryResponse DeleteFromMetaCategoryResponse
     */
    public function deleteFromMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteFromMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteFromMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Removes a metatable from a specified category.
     *  *
     * @param DeleteFromMetaCategoryRequest $request DeleteFromMetaCategoryRequest
     *
     * @return DeleteFromMetaCategoryResponse DeleteFromMetaCategoryResponse
     */
    public function deleteFromMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFromMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary , 
     *  *
     * @param DeleteLineageRelationRequest $request DeleteLineageRelationRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteLineageRelationResponse DeleteLineageRelationResponse
     */
    public function deleteLineageRelationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destEntityQualifiedName)) {
            $query['DestEntityQualifiedName'] = $request->destEntityQualifiedName;
        }
        if (!Utils::isUnset($request->relationshipGuid)) {
            $query['RelationshipGuid'] = $request->relationshipGuid;
        }
        if (!Utils::isUnset($request->srcEntityQualifiedName)) {
            $query['SrcEntityQualifiedName'] = $request->srcEntityQualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteLineageRelation',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteLineageRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary , 
     *  *
     * @param DeleteLineageRelationRequest $request DeleteLineageRelationRequest
     *
     * @return DeleteLineageRelationResponse DeleteLineageRelationResponse
     */
    public function deleteLineageRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLineageRelationWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a category.
     *  *
     * @param DeleteMetaCategoryRequest $request DeleteMetaCategoryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMetaCategoryResponse DeleteMetaCategoryResponse
     */
    public function deleteMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a category.
     *  *
     * @param DeleteMetaCategoryRequest $request DeleteMetaCategoryRequest
     *
     * @return DeleteMetaCategoryResponse DeleteMetaCategoryResponse
     */
    public function deleteMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a collection.
     *  *
     * @param DeleteMetaCollectionRequest $request DeleteMetaCollectionRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMetaCollectionResponse DeleteMetaCollectionResponse
     */
    public function deleteMetaCollectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMetaCollection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMetaCollectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a collection.
     *  *
     * @param DeleteMetaCollectionRequest $request DeleteMetaCollectionRequest
     *
     * @return DeleteMetaCollectionResponse DeleteMetaCollectionResponse
     */
    public function deleteMetaCollection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMetaCollectionWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes an entity from a collection.
     *  *
     * @param DeleteMetaCollectionEntityRequest $request DeleteMetaCollectionEntityRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteMetaCollectionEntityResponse DeleteMetaCollectionEntityResponse
     */
    public function deleteMetaCollectionEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->collectionQualifiedName)) {
            $query['CollectionQualifiedName'] = $request->collectionQualifiedName;
        }
        if (!Utils::isUnset($request->entityQualifiedName)) {
            $query['EntityQualifiedName'] = $request->entityQualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteMetaCollectionEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteMetaCollectionEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes an entity from a collection.
     *  *
     * @param DeleteMetaCollectionEntityRequest $request DeleteMetaCollectionEntityRequest
     *
     * @return DeleteMetaCollectionEntityResponse DeleteMetaCollectionEntityResponse
     */
    public function deleteMetaCollectionEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMetaCollectionEntityWithOptions($request, $runtime);
    }

    /**
     * @param DeleteProjectMemberRequest $request DeleteProjectMemberRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteProjectMemberResponse DeleteProjectMemberResponse
     */
    public function deleteProjectMemberWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteProjectMember',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteProjectMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteProjectMemberRequest $request DeleteProjectMemberRequest
     *
     * @return DeleteProjectMemberResponse DeleteProjectMemberResponse
     */
    public function deleteProjectMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteProjectMemberWithOptions($request, $runtime);
    }

    /**
     * @param DeleteQualityEntityRequest $request DeleteQualityEntityRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteQualityEntityResponse DeleteQualityEntityResponse
     */
    public function deleteQualityEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteQualityEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteQualityEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteQualityEntityRequest $request DeleteQualityEntityRequest
     *
     * @return DeleteQualityEntityResponse DeleteQualityEntityResponse
     */
    public function deleteQualityEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityEntityWithOptions($request, $runtime);
    }

    /**
     * @description In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transformation, load (ETL). Thereby, Data Quality automatically blocks the nodes that involve dirty data to stop dirty data from spreading downstream. This prevents nodes from producing unexpected dirty data that affects normal use and business decisions. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule described by the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors in a timely manner. For more information, see [Configure monitoring rules for MaxCompute](https://help.aliyun.com/document_detail/73690.html).
     *  *
     * @param DeleteQualityFollowerRequest $request DeleteQualityFollowerRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteQualityFollowerResponse DeleteQualityFollowerResponse
     */
    public function deleteQualityFollowerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->followerId)) {
            $body['FollowerId'] = $request->followerId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteQualityFollower',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transformation, load (ETL). Thereby, Data Quality automatically blocks the nodes that involve dirty data to stop dirty data from spreading downstream. This prevents nodes from producing unexpected dirty data that affects normal use and business decisions. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule described by the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors in a timely manner. For more information, see [Configure monitoring rules for MaxCompute](https://help.aliyun.com/document_detail/73690.html).
     *  *
     * @param DeleteQualityFollowerRequest $request DeleteQualityFollowerRequest
     *
     * @return DeleteQualityFollowerResponse DeleteQualityFollowerResponse
     */
    public function deleteQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * @param DeleteQualityRelativeNodeRequest $request DeleteQualityRelativeNodeRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteQualityRelativeNodeResponse DeleteQualityRelativeNodeResponse
     */
    public function deleteQualityRelativeNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->matchExpression)) {
            $body['MatchExpression'] = $request->matchExpression;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $body['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->targetNodeProjectId)) {
            $body['TargetNodeProjectId'] = $request->targetNodeProjectId;
        }
        if (!Utils::isUnset($request->targetNodeProjectName)) {
            $body['TargetNodeProjectName'] = $request->targetNodeProjectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteQualityRelativeNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteQualityRelativeNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteQualityRelativeNodeRequest $request DeleteQualityRelativeNodeRequest
     *
     * @return DeleteQualityRelativeNodeResponse DeleteQualityRelativeNodeResponse
     */
    public function deleteQualityRelativeNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityRelativeNodeWithOptions($request, $runtime);
    }

    /**
     * @param DeleteQualityRuleRequest $request DeleteQualityRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteQualityRuleResponse DeleteQualityRuleResponse
     */
    public function deleteQualityRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $body['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteQualityRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteQualityRuleRequest $request DeleteQualityRuleRequest
     *
     * @return DeleteQualityRuleResponse DeleteQualityRuleResponse
     */
    public function deleteQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityRuleWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DeleteRecognizeRuleRequest $request DeleteRecognizeRuleRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRecognizeRuleResponse DeleteRecognizeRuleResponse
     */
    public function deleteRecognizeRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->sensitiveId)) {
            $body['SensitiveId'] = $request->sensitiveId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteRecognizeRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteRecognizeRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DeleteRecognizeRuleRequest $request DeleteRecognizeRuleRequest
     *
     * @return DeleteRecognizeRuleResponse DeleteRecognizeRuleResponse
     */
    public function deleteRecognizeRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRecognizeRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Deletes a custom alert rule.
     *  *
     * @param DeleteRemindRequest $request DeleteRemindRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteRemindResponse DeleteRemindResponse
     */
    public function deleteRemindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->remindId)) {
            $body['RemindId'] = $request->remindId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeleteRemind',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Deletes a custom alert rule.
     *  *
     * @param DeleteRemindRequest $request DeleteRemindRequest
     *
     * @return DeleteRemindResponse DeleteRemindResponse
     */
    public function deleteRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRemindWithOptions($request, $runtime);
    }

    /**
     * @param DeleteTableRequest $request DeleteTableRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTableResponse DeleteTableResponse
     */
    public function deleteTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteTableRequest $request DeleteTableRequest
     *
     * @return DeleteTableResponse DeleteTableResponse
     */
    public function deleteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTableWithOptions($request, $runtime);
    }

    /**
     * @param DeleteTableLevelRequest $request DeleteTableLevelRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTableLevelResponse DeleteTableLevelResponse
     */
    public function deleteTableLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->levelId)) {
            $query['LevelId'] = $request->levelId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTableLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteTableLevelRequest $request DeleteTableLevelRequest
     *
     * @return DeleteTableLevelResponse DeleteTableLevelResponse
     */
    public function deleteTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTableLevelWithOptions($request, $runtime);
    }

    /**
     * @param DeleteTableThemeRequest $request DeleteTableThemeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeleteTableThemeResponse DeleteTableThemeResponse
     */
    public function deleteTableThemeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->themeId)) {
            $query['ThemeId'] = $request->themeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeleteTableTheme',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeleteTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeleteTableThemeRequest $request DeleteTableThemeRequest
     *
     * @return DeleteTableThemeResponse DeleteTableThemeResponse
     */
    public function deleteTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTableThemeWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **DeployDISyncTask**.
     *  *
     * @param DeployDISyncTaskRequest $request DeployDISyncTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return DeployDISyncTaskResponse DeployDISyncTaskResponse
     */
    public function deployDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DeployDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeployDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **DeployDISyncTask**.
     *  *
     * @param DeployDISyncTaskRequest $request DeployDISyncTaskRequest
     *
     * @return DeployDISyncTaskResponse DeployDISyncTaskResponse
     */
    public function deployDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deployDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @param DeployFileRequest $request DeployFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return DeployFileResponse DeployFileResponse
     */
    public function deployFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DeployFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DeployFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DeployFileRequest $request DeployFileRequest
     *
     * @return DeployFileResponse DeployFileResponse
     */
    public function deployFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deployFileWithOptions($request, $runtime);
    }

    /**
     * @param DesensitizeDataRequest $request DesensitizeDataRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return DesensitizeDataResponse DesensitizeDataResponse
     */
    public function desensitizeDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DesensitizeData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DesensitizeDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DesensitizeDataRequest $request DesensitizeDataRequest
     *
     * @return DesensitizeDataResponse DesensitizeDataResponse
     */
    public function desensitizeData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->desensitizeDataWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgDesensPlanAddOrUpdateRequest $tmpReq  DsgDesensPlanAddOrUpdateRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgDesensPlanAddOrUpdateResponse DsgDesensPlanAddOrUpdateResponse
     */
    public function dsgDesensPlanAddOrUpdateWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgDesensPlanAddOrUpdateShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->desensRules)) {
            $request->desensRulesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->desensRules, 'DesensRules', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->desensRulesShrink)) {
            $query['DesensRules'] = $request->desensRulesShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgDesensPlanAddOrUpdate',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgDesensPlanAddOrUpdateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgDesensPlanAddOrUpdateRequest $request DsgDesensPlanAddOrUpdateRequest
     *
     * @return DsgDesensPlanAddOrUpdateResponse DsgDesensPlanAddOrUpdateResponse
     */
    public function dsgDesensPlanAddOrUpdate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanAddOrUpdateWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgDesensPlanDeleteRequest $tmpReq  DsgDesensPlanDeleteRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgDesensPlanDeleteResponse DsgDesensPlanDeleteResponse
     */
    public function dsgDesensPlanDeleteWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgDesensPlanDeleteShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        if (!Utils::isUnset($request->sceneCode)) {
            $query['SceneCode'] = $request->sceneCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgDesensPlanDelete',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgDesensPlanDeleteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgDesensPlanDeleteRequest $request DsgDesensPlanDeleteRequest
     *
     * @return DsgDesensPlanDeleteResponse DsgDesensPlanDeleteResponse
     */
    public function dsgDesensPlanDelete($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanDeleteWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgDesensPlanQueryListRequest $request DsgDesensPlanQueryListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgDesensPlanQueryListResponse DsgDesensPlanQueryListResponse
     */
    public function dsgDesensPlanQueryListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgDesensPlanQueryList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgDesensPlanQueryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgDesensPlanQueryListRequest $request DsgDesensPlanQueryListRequest
     *
     * @return DsgDesensPlanQueryListResponse DsgDesensPlanQueryListResponse
     */
    public function dsgDesensPlanQueryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanQueryListWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgDesensPlanUpdateStatusRequest $tmpReq  DsgDesensPlanUpdateStatusRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgDesensPlanUpdateStatusResponse DsgDesensPlanUpdateStatusResponse
     */
    public function dsgDesensPlanUpdateStatusWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgDesensPlanUpdateStatusShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        if (!Utils::isUnset($request->sceneCode)) {
            $query['SceneCode'] = $request->sceneCode;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgDesensPlanUpdateStatus',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgDesensPlanUpdateStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgDesensPlanUpdateStatusRequest $request DsgDesensPlanUpdateStatusRequest
     *
     * @return DsgDesensPlanUpdateStatusResponse DsgDesensPlanUpdateStatusResponse
     */
    public function dsgDesensPlanUpdateStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanUpdateStatusWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgPlatformQueryProjectsAndSchemaFromMetaRequest $request DsgPlatformQueryProjectsAndSchemaFromMetaRequest
     * @param RuntimeOptions                                   $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgPlatformQueryProjectsAndSchemaFromMetaResponse DsgPlatformQueryProjectsAndSchemaFromMetaResponse
     */
    public function dsgPlatformQueryProjectsAndSchemaFromMetaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgPlatformQueryProjectsAndSchemaFromMeta',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgPlatformQueryProjectsAndSchemaFromMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgPlatformQueryProjectsAndSchemaFromMetaRequest $request DsgPlatformQueryProjectsAndSchemaFromMetaRequest
     *
     * @return DsgPlatformQueryProjectsAndSchemaFromMetaResponse DsgPlatformQueryProjectsAndSchemaFromMetaResponse
     */
    public function dsgPlatformQueryProjectsAndSchemaFromMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgPlatformQueryProjectsAndSchemaFromMetaWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgQueryDefaultTemplatesRequest $request DsgQueryDefaultTemplatesRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgQueryDefaultTemplatesResponse DsgQueryDefaultTemplatesResponse
     */
    public function dsgQueryDefaultTemplatesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgQueryDefaultTemplates',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgQueryDefaultTemplatesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgQueryDefaultTemplatesRequest $request DsgQueryDefaultTemplatesRequest
     *
     * @return DsgQueryDefaultTemplatesResponse DsgQueryDefaultTemplatesResponse
     */
    public function dsgQueryDefaultTemplates($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgQueryDefaultTemplatesWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgQuerySensResultRequest $request DsgQuerySensResultRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgQuerySensResultResponse DsgQuerySensResultResponse
     */
    public function dsgQuerySensResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->col)) {
            $body['Col'] = $request->col;
        }
        if (!Utils::isUnset($request->dbType)) {
            $body['DbType'] = $request->dbType;
        }
        if (!Utils::isUnset($request->level)) {
            $body['Level'] = $request->level;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $body['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->order)) {
            $body['Order'] = $request->order;
        }
        if (!Utils::isUnset($request->orderField)) {
            $body['OrderField'] = $request->orderField;
        }
        if (!Utils::isUnset($request->pageNo)) {
            $body['PageNo'] = $request->pageNo;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->schemaName)) {
            $body['SchemaName'] = $request->schemaName;
        }
        if (!Utils::isUnset($request->sensStatus)) {
            $body['SensStatus'] = $request->sensStatus;
        }
        if (!Utils::isUnset($request->sensitiveId)) {
            $body['SensitiveId'] = $request->sensitiveId;
        }
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->table)) {
            $body['Table'] = $request->table;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DsgQuerySensResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgQuerySensResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgQuerySensResultRequest $request DsgQuerySensResultRequest
     *
     * @return DsgQuerySensResultResponse DsgQuerySensResultResponse
     */
    public function dsgQuerySensResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgQuerySensResultWithOptions($request, $runtime);
    }

    /**
     * @param DsgRunSensIdentifyRequest $tmpReq  DsgRunSensIdentifyRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgRunSensIdentifyResponse DsgRunSensIdentifyResponse
     */
    public function dsgRunSensIdentifyWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgRunSensIdentifyShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->esMetaParams)) {
            $request->esMetaParamsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->esMetaParams, 'EsMetaParams', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->esMetaParamsShrink)) {
            $body['EsMetaParams'] = $request->esMetaParamsShrink;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DsgRunSensIdentify',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgRunSensIdentifyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DsgRunSensIdentifyRequest $request DsgRunSensIdentifyRequest
     *
     * @return DsgRunSensIdentifyResponse DsgRunSensIdentifyResponse
     */
    public function dsgRunSensIdentify($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgRunSensIdentifyWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgSceneAddOrUpdateSceneRequest $tmpReq  DsgSceneAddOrUpdateSceneRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgSceneAddOrUpdateSceneResponse DsgSceneAddOrUpdateSceneResponse
     */
    public function dsgSceneAddOrUpdateSceneWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgSceneAddOrUpdateSceneShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->scenes)) {
            $request->scenesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->scenes, 'scenes', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->scenesShrink)) {
            $query['scenes'] = $request->scenesShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgSceneAddOrUpdateScene',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgSceneAddOrUpdateSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgSceneAddOrUpdateSceneRequest $request DsgSceneAddOrUpdateSceneRequest
     *
     * @return DsgSceneAddOrUpdateSceneResponse DsgSceneAddOrUpdateSceneResponse
     */
    public function dsgSceneAddOrUpdateScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgSceneAddOrUpdateSceneWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgSceneQuerySceneListByNameRequest $request DsgSceneQuerySceneListByNameRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgSceneQuerySceneListByNameResponse DsgSceneQuerySceneListByNameResponse
     */
    public function dsgSceneQuerySceneListByNameWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgSceneQuerySceneListByName',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgSceneQuerySceneListByNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgSceneQuerySceneListByNameRequest $request DsgSceneQuerySceneListByNameRequest
     *
     * @return DsgSceneQuerySceneListByNameResponse DsgSceneQuerySceneListByNameResponse
     */
    public function dsgSceneQuerySceneListByName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgSceneQuerySceneListByNameWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgScenedDeleteSceneRequest $tmpReq  DsgScenedDeleteSceneRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgScenedDeleteSceneResponse DsgScenedDeleteSceneResponse
     */
    public function dsgScenedDeleteSceneWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgScenedDeleteSceneShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgScenedDeleteScene',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgScenedDeleteSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgScenedDeleteSceneRequest $request DsgScenedDeleteSceneRequest
     *
     * @return DsgScenedDeleteSceneResponse DsgScenedDeleteSceneResponse
     */
    public function dsgScenedDeleteScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgScenedDeleteSceneWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgStopSensIdentifyRequest $request DsgStopSensIdentifyRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgStopSensIdentifyResponse DsgStopSensIdentifyResponse
     */
    public function dsgStopSensIdentifyWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->jobId)) {
            $body['JobId'] = $request->jobId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'DsgStopSensIdentify',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgStopSensIdentifyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgStopSensIdentifyRequest $request DsgStopSensIdentifyRequest
     *
     * @return DsgStopSensIdentifyResponse DsgStopSensIdentifyResponse
     */
    public function dsgStopSensIdentify($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgStopSensIdentifyWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgUserGroupAddOrUpdateRequest $tmpReq  DsgUserGroupAddOrUpdateRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupAddOrUpdateResponse DsgUserGroupAddOrUpdateResponse
     */
    public function dsgUserGroupAddOrUpdateWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgUserGroupAddOrUpdateShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->userGroups)) {
            $request->userGroupsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->userGroups, 'UserGroups', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->userGroupsShrink)) {
            $query['UserGroups'] = $request->userGroupsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgUserGroupAddOrUpdate',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupAddOrUpdateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgUserGroupAddOrUpdateRequest $request DsgUserGroupAddOrUpdateRequest
     *
     * @return DsgUserGroupAddOrUpdateResponse DsgUserGroupAddOrUpdateResponse
     */
    public function dsgUserGroupAddOrUpdate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupAddOrUpdateWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgUserGroupDeleteRequest $tmpReq  DsgUserGroupDeleteRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupDeleteResponse DsgUserGroupDeleteResponse
     */
    public function dsgUserGroupDeleteWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgUserGroupDeleteShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgUserGroupDelete',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupDeleteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgUserGroupDeleteRequest $request DsgUserGroupDeleteRequest
     *
     * @return DsgUserGroupDeleteResponse DsgUserGroupDeleteResponse
     */
    public function dsgUserGroupDelete($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupDeleteWithOptions($request, $runtime);
    }

    /**
     * @param DsgUserGroupGetOdpsRoleGroupsRequest $request DsgUserGroupGetOdpsRoleGroupsRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupGetOdpsRoleGroupsResponse DsgUserGroupGetOdpsRoleGroupsResponse
     */
    public function dsgUserGroupGetOdpsRoleGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgUserGroupGetOdpsRoleGroups',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupGetOdpsRoleGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param DsgUserGroupGetOdpsRoleGroupsRequest $request DsgUserGroupGetOdpsRoleGroupsRequest
     *
     * @return DsgUserGroupGetOdpsRoleGroupsResponse DsgUserGroupGetOdpsRoleGroupsResponse
     */
    public function dsgUserGroupGetOdpsRoleGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupGetOdpsRoleGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgUserGroupQueryListRequest $request DsgUserGroupQueryListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupQueryListResponse DsgUserGroupQueryListResponse
     */
    public function dsgUserGroupQueryListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgUserGroupQueryList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupQueryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgUserGroupQueryListRequest $request DsgUserGroupQueryListRequest
     *
     * @return DsgUserGroupQueryListResponse DsgUserGroupQueryListResponse
     */
    public function dsgUserGroupQueryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupQueryListWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgUserGroupQueryUserListResponse DsgUserGroupQueryUserListResponse
     */
    public function dsgUserGroupQueryUserListWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'DsgUserGroupQueryUserList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgUserGroupQueryUserListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @return DsgUserGroupQueryUserListResponse DsgUserGroupQueryUserListResponse
     */
    public function dsgUserGroupQueryUserList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupQueryUserListWithOptions($runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgWhiteListAddOrUpdateRequest $tmpReq  DsgWhiteListAddOrUpdateRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgWhiteListAddOrUpdateResponse DsgWhiteListAddOrUpdateResponse
     */
    public function dsgWhiteListAddOrUpdateWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgWhiteListAddOrUpdateShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->whiteLists)) {
            $request->whiteListsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->whiteLists, 'WhiteLists', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->whiteListsShrink)) {
            $query['WhiteLists'] = $request->whiteListsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgWhiteListAddOrUpdate',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgWhiteListAddOrUpdateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgWhiteListAddOrUpdateRequest $request DsgWhiteListAddOrUpdateRequest
     *
     * @return DsgWhiteListAddOrUpdateResponse DsgWhiteListAddOrUpdateResponse
     */
    public function dsgWhiteListAddOrUpdate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgWhiteListAddOrUpdateWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgWhiteListDeleteListRequest $tmpReq  DsgWhiteListDeleteListRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgWhiteListDeleteListResponse DsgWhiteListDeleteListResponse
     */
    public function dsgWhiteListDeleteListWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new DsgWhiteListDeleteListShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->ids)) {
            $request->idsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->idsShrink)) {
            $query['Ids'] = $request->idsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgWhiteListDeleteList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgWhiteListDeleteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgWhiteListDeleteListRequest $request DsgWhiteListDeleteListRequest
     *
     * @return DsgWhiteListDeleteListResponse DsgWhiteListDeleteListResponse
     */
    public function dsgWhiteListDeleteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgWhiteListDeleteListWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param DsgWhiteListQueryListRequest $request DsgWhiteListQueryListRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return DsgWhiteListQueryListResponse DsgWhiteListQueryListResponse
     */
    public function dsgWhiteListQueryListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'DsgWhiteListQueryList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return DsgWhiteListQueryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param DsgWhiteListQueryListRequest $request DsgWhiteListQueryListRequest
     *
     * @return DsgWhiteListQueryListResponse DsgWhiteListQueryListResponse
     */
    public function dsgWhiteListQueryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgWhiteListQueryListWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param EditRecognizeRuleRequest $request EditRecognizeRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return EditRecognizeRuleResponse EditRecognizeRuleResponse
     */
    public function editRecognizeRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->accountName)) {
            $body['AccountName'] = $request->accountName;
        }
        if (!Utils::isUnset($request->colExclude)) {
            $body['ColExclude'] = $request->colExclude;
        }
        if (!Utils::isUnset($request->colScan)) {
            $body['ColScan'] = $request->colScan;
        }
        if (!Utils::isUnset($request->commentScan)) {
            $body['CommentScan'] = $request->commentScan;
        }
        if (!Utils::isUnset($request->contentScan)) {
            $body['ContentScan'] = $request->contentScan;
        }
        if (!Utils::isUnset($request->hitThreshold)) {
            $body['HitThreshold'] = $request->hitThreshold;
        }
        if (!Utils::isUnset($request->levelName)) {
            $body['LevelName'] = $request->levelName;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeParent)) {
            $body['NodeParent'] = $request->nodeParent;
        }
        if (!Utils::isUnset($request->operationType)) {
            $body['OperationType'] = $request->operationType;
        }
        if (!Utils::isUnset($request->recognizeRules)) {
            $body['RecognizeRules'] = $request->recognizeRules;
        }
        if (!Utils::isUnset($request->recognizeRulesType)) {
            $body['RecognizeRulesType'] = $request->recognizeRulesType;
        }
        if (!Utils::isUnset($request->sensitiveDescription)) {
            $body['SensitiveDescription'] = $request->sensitiveDescription;
        }
        if (!Utils::isUnset($request->sensitiveId)) {
            $body['SensitiveId'] = $request->sensitiveId;
        }
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        if (!Utils::isUnset($request->level)) {
            $body['level'] = $request->level;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'EditRecognizeRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EditRecognizeRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param EditRecognizeRuleRequest $request EditRecognizeRuleRequest
     *
     * @return EditRecognizeRuleResponse EditRecognizeRuleResponse
     */
    public function editRecognizeRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->editRecognizeRuleWithOptions($request, $runtime);
    }

    /**
     * @param EstablishRelationTableToBusinessRequest $request EstablishRelationTableToBusinessRequest
     * @param RuntimeOptions                          $runtime runtime options for this request RuntimeOptions
     *
     * @return EstablishRelationTableToBusinessResponse EstablishRelationTableToBusinessResponse
     */
    public function establishRelationTableToBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessId)) {
            $body['BusinessId'] = $request->businessId;
        }
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $body['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'EstablishRelationTableToBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return EstablishRelationTableToBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param EstablishRelationTableToBusinessRequest $request EstablishRelationTableToBusinessRequest
     *
     * @return EstablishRelationTableToBusinessResponse EstablishRelationTableToBusinessResponse
     */
    public function establishRelationTableToBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->establishRelationTableToBusinessWithOptions($request, $runtime);
    }

    /**
     * @param ExportDataSourcesRequest $request ExportDataSourcesRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ExportDataSourcesResponse ExportDataSourcesResponse
     */
    public function exportDataSourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ExportDataSources',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ExportDataSourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ExportDataSourcesRequest $request ExportDataSourcesRequest
     *
     * @return ExportDataSourcesResponse ExportDataSourcesResponse
     */
    public function exportDataSources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportDataSourcesWithOptions($request, $runtime);
    }

    /**
     * @summary DataWorks allows you to use only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a batch synchronization node in Data Integration. To create a real-time synchronization node or a synchronization solution, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation and use the parameters as request parameters to create a real-time synchronization node or a synchronization solution in Data Integration.
     * DataWorks allows you to create real-time synchronization nodes and synchronization solutions in Data Integration only in asynchronous mode.
     *  *
     * @description The operation that you want to perform.
     *  *
     * @param GenerateDISyncTaskConfigForCreatingRequest $request GenerateDISyncTaskConfigForCreatingRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return GenerateDISyncTaskConfigForCreatingResponse GenerateDISyncTaskConfigForCreatingResponse
     */
    public function generateDISyncTaskConfigForCreatingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskParam)) {
            $query['TaskParam'] = $request->taskParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GenerateDISyncTaskConfigForCreating',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GenerateDISyncTaskConfigForCreatingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary DataWorks allows you to use only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a batch synchronization node in Data Integration. To create a real-time synchronization node or a synchronization solution, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation and use the parameters as request parameters to create a real-time synchronization node or a synchronization solution in Data Integration.
     * DataWorks allows you to create real-time synchronization nodes and synchronization solutions in Data Integration only in asynchronous mode.
     *  *
     * @description The operation that you want to perform.
     *  *
     * @param GenerateDISyncTaskConfigForCreatingRequest $request GenerateDISyncTaskConfigForCreatingRequest
     *
     * @return GenerateDISyncTaskConfigForCreatingResponse GenerateDISyncTaskConfigForCreatingResponse
     */
    public function generateDISyncTaskConfigForCreating($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateDISyncTaskConfigForCreatingWithOptions($request, $runtime);
    }

    /**
     * @summary DataWorks allows you to use only the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization node in Data Integration. To update a real-time synchronization node or a synchronization solution, you must first call the GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the UpdateDISyncTask operation and use the parameters as request parameters to update a real-time synchronization node or a synchronization solution in Data Integration. DataWorks allows you to update real-time synchronization nodes and synchronization solutions in Data Integration only in asynchronous mode.
     *  *
     * @description The operation that you want to perform.
     *  *
     * @param GenerateDISyncTaskConfigForUpdatingRequest $request GenerateDISyncTaskConfigForUpdatingRequest
     * @param RuntimeOptions                             $runtime runtime options for this request RuntimeOptions
     *
     * @return GenerateDISyncTaskConfigForUpdatingResponse GenerateDISyncTaskConfigForUpdatingResponse
     */
    public function generateDISyncTaskConfigForUpdatingWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clientToken)) {
            $query['ClientToken'] = $request->clientToken;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        if (!Utils::isUnset($request->taskParam)) {
            $query['TaskParam'] = $request->taskParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GenerateDISyncTaskConfigForUpdating',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GenerateDISyncTaskConfigForUpdatingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary DataWorks allows you to use only the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization node in Data Integration. To update a real-time synchronization node or a synchronization solution, you must first call the GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the UpdateDISyncTask operation and use the parameters as request parameters to update a real-time synchronization node or a synchronization solution in Data Integration. DataWorks allows you to update real-time synchronization nodes and synchronization solutions in Data Integration only in asynchronous mode.
     *  *
     * @description The operation that you want to perform.
     *  *
     * @param GenerateDISyncTaskConfigForUpdatingRequest $request GenerateDISyncTaskConfigForUpdatingRequest
     *
     * @return GenerateDISyncTaskConfigForUpdatingResponse GenerateDISyncTaskConfigForUpdatingResponse
     */
    public function generateDISyncTaskConfigForUpdating($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateDISyncTaskConfigForUpdatingWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param GetAlertMessageRequest $request GetAlertMessageRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetAlertMessageResponse GetAlertMessageResponse
     */
    public function getAlertMessageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertId)) {
            $body['AlertId'] = $request->alertId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetAlertMessage',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetAlertMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param GetAlertMessageRequest $request GetAlertMessageRequest
     *
     * @return GetAlertMessageResponse GetAlertMessageResponse
     */
    public function getAlertMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAlertMessageWithOptions($request, $runtime);
    }

    /**
     * @summary id
     *  *
     * @param GetBaselineRequest $request GetBaselineRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBaselineResponse GetBaselineResponse
     */
    public function getBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary id
     *  *
     * @param GetBaselineRequest $request GetBaselineRequest
     *
     * @return GetBaselineResponse GetBaselineResponse
     */
    public function getBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineWithOptions($request, $runtime);
    }

    /**
     * @param GetBaselineConfigRequest $request GetBaselineConfigRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBaselineConfigResponse GetBaselineConfigResponse
     */
    public function getBaselineConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBaselineConfig',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBaselineConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetBaselineConfigRequest $request GetBaselineConfigRequest
     *
     * @return GetBaselineConfigResponse GetBaselineConfigResponse
     */
    public function getBaselineConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineConfigWithOptions($request, $runtime);
    }

    /**
     * @summary The information about the events that are associated with the instance.
     *  *
     * @param GetBaselineKeyPathRequest $request GetBaselineKeyPathRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBaselineKeyPathResponse GetBaselineKeyPathResponse
     */
    public function getBaselineKeyPathWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->inGroupId)) {
            $body['InGroupId'] = $request->inGroupId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBaselineKeyPath',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBaselineKeyPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The information about the events that are associated with the instance.
     *  *
     * @param GetBaselineKeyPathRequest $request GetBaselineKeyPathRequest
     *
     * @return GetBaselineKeyPathResponse GetBaselineKeyPathResponse
     */
    public function getBaselineKeyPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineKeyPathWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a baseline instance.
     *  *
     * @param GetBaselineStatusRequest $request GetBaselineStatusRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBaselineStatusResponse GetBaselineStatusResponse
     */
    public function getBaselineStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->inGroupId)) {
            $body['InGroupId'] = $request->inGroupId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBaselineStatus',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBaselineStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a baseline instance.
     *  *
     * @param GetBaselineStatusRequest $request GetBaselineStatusRequest
     *
     * @return GetBaselineStatusResponse GetBaselineStatusResponse
     */
    public function getBaselineStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineStatusWithOptions($request, $runtime);
    }

    /**
     * @param GetBusinessRequest $request GetBusinessRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetBusinessResponse GetBusinessResponse
     */
    public function getBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessId)) {
            $body['BusinessId'] = $request->businessId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetBusinessRequest $request GetBusinessRequest
     *
     * @return GetBusinessResponse GetBusinessResponse
     */
    public function getBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBusinessWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the status of a table creation, update, or deletion task.
     *  *
     * @param GetDDLJobStatusRequest $request GetDDLJobStatusRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDDLJobStatusResponse GetDDLJobStatusResponse
     */
    public function getDDLJobStatusWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDDLJobStatus',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDDLJobStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the status of a table creation, update, or deletion task.
     *  *
     * @param GetDDLJobStatusRequest $request GetDDLJobStatusRequest
     *
     * @return GetDDLJobStatusResponse GetDDLJobStatusResponse
     */
    public function getDDLJobStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDDLJobStatusWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param GetDIAlarmRuleRequest $request GetDIAlarmRuleRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDIAlarmRuleResponse GetDIAlarmRuleResponse
     */
    public function getDIAlarmRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIAlarmRuleId)) {
            $body['DIAlarmRuleId'] = $request->DIAlarmRuleId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDIAlarmRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param GetDIAlarmRuleRequest $request GetDIAlarmRuleRequest
     *
     * @return GetDIAlarmRuleResponse GetDIAlarmRuleResponse
     */
    public function getDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param GetDIJobRequest $request GetDIJobRequest
     * @param RuntimeOptions  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDIJobResponse GetDIJobResponse
     */
    public function getDIJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->withDetails)) {
            $body['WithDetails'] = $request->withDetails;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param GetDIJobRequest $request GetDIJobRequest
     *
     * @return GetDIJobResponse GetDIJobResponse
     */
    public function getDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetDISyncInstanceInfo**.
     *  *
     * @param GetDISyncInstanceInfoRequest $request GetDISyncInstanceInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDISyncInstanceInfoResponse GetDISyncInstanceInfoResponse
     */
    public function getDISyncInstanceInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDISyncInstanceInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDISyncInstanceInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetDISyncInstanceInfo**.
     *  *
     * @param GetDISyncInstanceInfoRequest $request GetDISyncInstanceInfoRequest
     *
     * @return GetDISyncInstanceInfoResponse GetDISyncInstanceInfoResponse
     */
    public function getDISyncInstanceInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDISyncInstanceInfoWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetDISyncTask**.
     *  *
     * @param GetDISyncTaskRequest $request GetDISyncTaskRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDISyncTaskResponse GetDISyncTaskResponse
     */
    public function getDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetDISyncTask**.
     *  *
     * @param GetDISyncTaskRequest $request GetDISyncTaskRequest
     *
     * @return GetDISyncTaskResponse GetDISyncTaskResponse
     */
    public function getDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a directed acyclic graph (DAG) based on the ID of the DAG.
     *                   You can call the GetDag operation to query the details of the DAG for a manually triggered
     *                   workflow, a manually triggered node, or a data backfill instance. However, you cannot
     *                   query the details of the DAG for an auto triggered node or an auto triggered workflow.
     *  *
     * @description Supported DAG types:
     * *   MANUAL: the DAG for a manually triggered workflow.
     * *   SMOKE_TEST: the DAG for a smoke testing workflow.
     * *   SUPPLY_DATA: the DAG for a data backfill instance.
     * *   BUSINESS_PROCESS_DAG: the DAG for a one-time workflow.
     * Supported DAG states:
     * *   CREATED: The DAG is created.
     * *   RUNNING: The DAG is running.
     * *   FAILURE: The DAG fails to run.
     * *   SUCCESS: The DAG successfully runs.
     *  *
     * @param GetDagRequest  $request GetDagRequest
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDagResponse GetDagResponse
     */
    public function getDagWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->dagId)) {
            $body['DagId'] = $request->dagId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDag',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDagResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a directed acyclic graph (DAG) based on the ID of the DAG.
     *                   You can call the GetDag operation to query the details of the DAG for a manually triggered
     *                   workflow, a manually triggered node, or a data backfill instance. However, you cannot
     *                   query the details of the DAG for an auto triggered node or an auto triggered workflow.
     *  *
     * @description Supported DAG types:
     * *   MANUAL: the DAG for a manually triggered workflow.
     * *   SMOKE_TEST: the DAG for a smoke testing workflow.
     * *   SUPPLY_DATA: the DAG for a data backfill instance.
     * *   BUSINESS_PROCESS_DAG: the DAG for a one-time workflow.
     * Supported DAG states:
     * *   CREATED: The DAG is created.
     * *   RUNNING: The DAG is running.
     * *   FAILURE: The DAG fails to run.
     * *   SUCCESS: The DAG successfully runs.
     *  *
     * @param GetDagRequest $request GetDagRequest
     *
     * @return GetDagResponse GetDagResponse
     */
    public function getDag($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDagWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a DataService Studio API in the development state.
     *  *
     * @param GetDataServiceApiRequest $request GetDataServiceApiRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceApiResponse GetDataServiceApiResponse
     */
    public function getDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a DataService Studio API in the development state.
     *  *
     * @param GetDataServiceApiRequest $request GetDataServiceApiRequest
     *
     * @return GetDataServiceApiResponse GetDataServiceApiResponse
     */
    public function getDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @param GetDataServiceApiTestRequest $request GetDataServiceApiTestRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceApiTestResponse GetDataServiceApiTestResponse
     */
    public function getDataServiceApiTestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceApiTest',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceApiTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetDataServiceApiTestRequest $request GetDataServiceApiTestRequest
     *
     * @return GetDataServiceApiTestResponse GetDataServiceApiTestResponse
     */
    public function getDataServiceApiTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceApiTestWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of an application.
     *  *
     * @param GetDataServiceApplicationRequest $request GetDataServiceApplicationRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceApplicationResponse GetDataServiceApplicationResponse
     */
    public function getDataServiceApplicationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->applicationId)) {
            $body['ApplicationId'] = $request->applicationId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceApplication',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceApplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of an application.
     *  *
     * @param GetDataServiceApplicationRequest $request GetDataServiceApplicationRequest
     *
     * @return GetDataServiceApplicationResponse GetDataServiceApplicationResponse
     */
    public function getDataServiceApplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceApplicationWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a folder.
     *  *
     * @param GetDataServiceFolderRequest $request GetDataServiceFolderRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceFolderResponse GetDataServiceFolderResponse
     */
    public function getDataServiceFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a folder.
     *  *
     * @param GetDataServiceFolderRequest $request GetDataServiceFolderRequest
     *
     * @return GetDataServiceFolderResponse GetDataServiceFolderResponse
     */
    public function getDataServiceFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a business process.
     *  *
     * @param GetDataServiceGroupRequest $request GetDataServiceGroupRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServiceGroupResponse GetDataServiceGroupResponse
     */
    public function getDataServiceGroupWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServiceGroup',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServiceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a business process.
     *  *
     * @param GetDataServiceGroupRequest $request GetDataServiceGroupRequest
     *
     * @return GetDataServiceGroupResponse GetDataServiceGroupResponse
     */
    public function getDataServiceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceGroupWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a DataService Studio API in the published state.
     *  *
     * @param GetDataServicePublishedApiRequest $request GetDataServicePublishedApiRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataServicePublishedApiResponse GetDataServicePublishedApiResponse
     */
    public function getDataServicePublishedApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDataServicePublishedApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataServicePublishedApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a DataService Studio API in the published state.
     *  *
     * @param GetDataServicePublishedApiRequest $request GetDataServicePublishedApiRequest
     *
     * @return GetDataServicePublishedApiResponse GetDataServicePublishedApiResponse
     */
    public function getDataServicePublishedApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServicePublishedApiWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetDataSourceMeta**.
     *  *
     * @param GetDataSourceMetaRequest $request GetDataSourceMetaRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDataSourceMetaResponse GetDataSourceMetaResponse
     */
    public function getDataSourceMetaWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->datasourceName)) {
            $query['DatasourceName'] = $request->datasourceName;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetDataSourceMeta',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDataSourceMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetDataSourceMeta**.
     *  *
     * @param GetDataSourceMetaRequest $request GetDataSourceMetaRequest
     *
     * @return GetDataSourceMetaResponse GetDataSourceMetaResponse
     */
    public function getDataSourceMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataSourceMetaWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a deployment task.
     *  *
     * @param GetDeploymentRequest $request GetDeploymentRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetDeploymentResponse GetDeploymentResponse
     */
    public function getDeploymentWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->deploymentId)) {
            $body['DeploymentId'] = $request->deploymentId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetDeployment',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetDeploymentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a deployment task.
     *  *
     * @param GetDeploymentRequest $request GetDeploymentRequest
     *
     * @return GetDeploymentResponse GetDeploymentResponse
     */
    public function getDeployment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDeploymentWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param GetExtensionRequest $request GetExtensionRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return GetExtensionResponse GetExtensionResponse
     */
    public function getExtensionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->extensionCode)) {
            $query['ExtensionCode'] = $request->extensionCode;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetExtension',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetExtensionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param GetExtensionRequest $request GetExtensionRequest
     *
     * @return GetExtensionResponse GetExtensionResponse
     */
    public function getExtension($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getExtensionWithOptions($request, $runtime);
    }

    /**
     * @param GetFileRequest $request GetFileRequest
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileResponse GetFileResponse
     */
    public function getFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetFileRequest $request GetFileRequest
     *
     * @return GetFileResponse GetFileResponse
     */
    public function getFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileWithOptions($request, $runtime);
    }

    /**
     * @param GetFileTypeStatisticRequest $request GetFileTypeStatisticRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileTypeStatisticResponse GetFileTypeStatisticResponse
     */
    public function getFileTypeStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetFileTypeStatistic',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileTypeStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetFileTypeStatisticRequest $request GetFileTypeStatisticRequest
     *
     * @return GetFileTypeStatisticResponse GetFileTypeStatisticResponse
     */
    public function getFileTypeStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileTypeStatisticWithOptions($request, $runtime);
    }

    /**
     * @param GetFileVersionRequest $request GetFileVersionRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFileVersionResponse GetFileVersionResponse
     */
    public function getFileVersionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->fileVersion)) {
            $body['FileVersion'] = $request->fileVersion;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetFileVersion',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFileVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetFileVersionRequest $request GetFileVersionRequest
     *
     * @return GetFileVersionResponse GetFileVersionResponse
     */
    public function getFileVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileVersionWithOptions($request, $runtime);
    }

    /**
     * @param GetFolderRequest $request GetFolderRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetFolderResponse GetFolderResponse
     */
    public function getFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->folderPath)) {
            $body['FolderPath'] = $request->folderPath;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetFolderRequest $request GetFolderRequest
     *
     * @return GetFolderResponse GetFolderResponse
     */
    public function getFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFolderWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the data snapshot of an extension point based on the ID of an open message when the related extension point event is triggered.
     *  *
     * @param GetIDEEventDetailRequest $request GetIDEEventDetailRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetIDEEventDetailResponse GetIDEEventDetailResponse
     */
    public function getIDEEventDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->messageId)) {
            $body['MessageId'] = $request->messageId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetIDEEventDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetIDEEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the data snapshot of an extension point based on the ID of an open message when the related extension point event is triggered.
     *  *
     * @param GetIDEEventDetailRequest $request GetIDEEventDetailRequest
     *
     * @return GetIDEEventDetailResponse GetIDEEventDetailResponse
     */
    public function getIDEEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getIDEEventDetailWithOptions($request, $runtime);
    }

    /**
     * @param GetInstanceRequest $request GetInstanceRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceResponse GetInstanceResponse
     */
    public function getInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetInstanceRequest $request GetInstanceRequest
     *
     * @return GetInstanceResponse GetInstanceResponse
     */
    public function getInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetInstanceConsumeTimeRank is deprecated
     *  *
     * Deprecated
     *
     * @param GetInstanceConsumeTimeRankRequest $request GetInstanceConsumeTimeRankRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceConsumeTimeRankResponse GetInstanceConsumeTimeRankResponse
     */
    public function getInstanceConsumeTimeRankWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceConsumeTimeRank',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceConsumeTimeRankResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetInstanceConsumeTimeRank is deprecated
     *  *
     * Deprecated
     *
     * @param GetInstanceConsumeTimeRankRequest $request GetInstanceConsumeTimeRankRequest
     *
     * @return GetInstanceConsumeTimeRankResponse GetInstanceConsumeTimeRankResponse
     */
    public function getInstanceConsumeTimeRank($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceConsumeTimeRankWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetInstanceCountTrend is deprecated
     *  *
     * Deprecated
     *
     * @param GetInstanceCountTrendRequest $request GetInstanceCountTrendRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceCountTrendResponse GetInstanceCountTrendResponse
     */
    public function getInstanceCountTrendWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginDate)) {
            $body['BeginDate'] = $request->beginDate;
        }
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceCountTrend',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceCountTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetInstanceCountTrend is deprecated
     *  *
     * Deprecated
     *
     * @param GetInstanceCountTrendRequest $request GetInstanceCountTrendRequest
     *
     * @return GetInstanceCountTrendResponse GetInstanceCountTrendResponse
     */
    public function getInstanceCountTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceCountTrendWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetInstanceErrorRank is deprecated
     *  *
     * Deprecated
     *
     * @param GetInstanceErrorRankRequest $request GetInstanceErrorRankRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceErrorRankResponse GetInstanceErrorRankResponse
     */
    public function getInstanceErrorRankWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceErrorRank',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceErrorRankResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetInstanceErrorRank is deprecated
     *  *
     * Deprecated
     *
     * @param GetInstanceErrorRankRequest $request GetInstanceErrorRankRequest
     *
     * @return GetInstanceErrorRankResponse GetInstanceErrorRankResponse
     */
    public function getInstanceErrorRank($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceErrorRankWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the logs of an instance.
     *  *
     * @description You may not obtain the instance logs that were generated more than seven days ago.
     *  *
     * @param GetInstanceLogRequest $request GetInstanceLogRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceLogResponse GetInstanceLogResponse
     */
    public function getInstanceLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceHistoryId)) {
            $body['InstanceHistoryId'] = $request->instanceHistoryId;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceLog',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the logs of an instance.
     *  *
     * @description You may not obtain the instance logs that were generated more than seven days ago.
     *  *
     * @param GetInstanceLogRequest $request GetInstanceLogRequest
     *
     * @return GetInstanceLogResponse GetInstanceLogResponse
     */
    public function getInstanceLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceLogWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetInstanceStatusCount is deprecated
     *  *
     * Deprecated
     *
     * @param GetInstanceStatusCountRequest $request GetInstanceStatusCountRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceStatusCountResponse GetInstanceStatusCountResponse
     */
    public function getInstanceStatusCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceStatusCount',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceStatusCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetInstanceStatusCount is deprecated
     *  *
     * Deprecated
     *
     * @param GetInstanceStatusCountRequest $request GetInstanceStatusCountRequest
     *
     * @return GetInstanceStatusCountResponse GetInstanceStatusCountResponse
     */
    public function getInstanceStatusCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceStatusCountWithOptions($request, $runtime);
    }

    /**
     * @param GetInstanceStatusStatisticRequest $request GetInstanceStatusStatisticRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetInstanceStatusStatisticResponse GetInstanceStatusStatisticResponse
     */
    public function getInstanceStatusStatisticWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->dagType)) {
            $body['DagType'] = $request->dagType;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schedulerPeriod)) {
            $body['SchedulerPeriod'] = $request->schedulerPeriod;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetInstanceStatusStatistic',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetInstanceStatusStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetInstanceStatusStatisticRequest $request GetInstanceStatusStatisticRequest
     *
     * @return GetInstanceStatusStatisticResponse GetInstanceStatusStatisticResponse
     */
    public function getInstanceStatusStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceStatusStatisticWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetManualDagInstances is deprecated
     *  *
     * Deprecated
     *
     * @param GetManualDagInstancesRequest $request GetManualDagInstancesRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetManualDagInstancesResponse GetManualDagInstancesResponse
     */
    public function getManualDagInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->dagId)) {
            $body['DagId'] = $request->dagId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetManualDagInstances',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetManualDagInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetManualDagInstances is deprecated
     *  *
     * Deprecated
     *
     * @param GetManualDagInstancesRequest $request GetManualDagInstancesRequest
     *
     * @return GetManualDagInstancesResponse GetManualDagInstancesResponse
     */
    public function getManualDagInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getManualDagInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a category tree.
     *  *
     * @param GetMetaCategoryRequest $request GetMetaCategoryRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaCategoryResponse GetMetaCategoryResponse
     */
    public function getMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentCategoryId)) {
            $query['ParentCategoryId'] = $request->parentCategoryId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a category tree.
     *  *
     * @param GetMetaCategoryRequest $request GetMetaCategoryRequest
     *
     * @return GetMetaCategoryResponse GetMetaCategoryResponse
     */
    public function getMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a collection.
     *  *
     * @param GetMetaCollectionDetailRequest $request GetMetaCollectionDetailRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaCollectionDetailResponse GetMetaCollectionDetailResponse
     */
    public function getMetaCollectionDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaCollectionDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaCollectionDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a collection.
     *  *
     * @param GetMetaCollectionDetailRequest $request GetMetaCollectionDetailRequest
     *
     * @return GetMetaCollectionDetailResponse GetMetaCollectionDetailResponse
     */
    public function getMetaCollectionDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaCollectionDetailWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the lineage of a field in a metatable.
     *  *
     * @param GetMetaColumnLineageRequest $request GetMetaColumnLineageRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaColumnLineageResponse GetMetaColumnLineageResponse
     */
    public function getMetaColumnLineageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->columnGuid)) {
            $query['ColumnGuid'] = $request->columnGuid;
        }
        if (!Utils::isUnset($request->columnName)) {
            $query['ColumnName'] = $request->columnName;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->direction)) {
            $query['Direction'] = $request->direction;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaColumnLineage',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaColumnLineageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the lineage of a field in a metatable.
     *  *
     * @param GetMetaColumnLineageRequest $request GetMetaColumnLineageRequest
     *
     * @return GetMetaColumnLineageResponse GetMetaColumnLineageResponse
     */
    public function getMetaColumnLineage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaColumnLineageWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the compute engine instance. Specify the ID in the Engine type.Engine name format.
     *  *
     * @description The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
     * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
     *  *
     * @param GetMetaDBInfoRequest $request GetMetaDBInfoRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaDBInfoResponse GetMetaDBInfoResponse
     */
    public function getMetaDBInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaDBInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaDBInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the compute engine instance. Specify the ID in the Engine type.Engine name format.
     *  *
     * @description The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
     * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
     *  *
     * @param GetMetaDBInfoRequest $request GetMetaDBInfoRequest
     *
     * @return GetMetaDBInfoResponse GetMetaDBInfoResponse
     */
    public function getMetaDBInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaDBInfoWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetMetaDBTableList**.
     *  *
     * @param GetMetaDBTableListRequest $request GetMetaDBTableListRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaDBTableListResponse GetMetaDBTableListResponse
     */
    public function getMetaDBTableListWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaDBTableList',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaDBTableListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetMetaDBTableList**.
     *  *
     * @param GetMetaDBTableListRequest $request GetMetaDBTableListRequest
     *
     * @return GetMetaDBTableListResponse GetMetaDBTableListResponse
     */
    public function getMetaDBTableList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaDBTableListWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the basic information about a metatable.
     *  *
     * @param GetMetaTableBasicInfoRequest $request GetMetaTableBasicInfoRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableBasicInfoResponse GetMetaTableBasicInfoResponse
     */
    public function getMetaTableBasicInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableBasicInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableBasicInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the basic information about a metatable.
     *  *
     * @param GetMetaTableBasicInfoRequest $request GetMetaTableBasicInfoRequest
     *
     * @return GetMetaTableBasicInfoResponse GetMetaTableBasicInfoResponse
     */
    public function getMetaTableBasicInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableBasicInfoWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetMetaTableChangeLog**.
     *  *
     * @param GetMetaTableChangeLogRequest $request GetMetaTableChangeLogRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableChangeLogResponse GetMetaTableChangeLogResponse
     */
    public function getMetaTableChangeLogWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->changeType)) {
            $body['ChangeType'] = $request->changeType;
        }
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->objectType)) {
            $body['ObjectType'] = $request->objectType;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startDate)) {
            $body['StartDate'] = $request->startDate;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $body['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableChangeLog',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableChangeLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetMetaTableChangeLog**.
     *  *
     * @param GetMetaTableChangeLogRequest $request GetMetaTableChangeLogRequest
     *
     * @return GetMetaTableChangeLogResponse GetMetaTableChangeLogResponse
     */
    public function getMetaTableChangeLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableChangeLogWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetMetaTableColumn**.
     *  *
     * @param GetMetaTableColumnRequest $request GetMetaTableColumnRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableColumnResponse GetMetaTableColumnResponse
     */
    public function getMetaTableColumnWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableColumn',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableColumnResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetMetaTableColumn**.
     *  *
     * @param GetMetaTableColumnRequest $request GetMetaTableColumnRequest
     *
     * @return GetMetaTableColumnResponse GetMetaTableColumnResponse
     */
    public function getMetaTableColumn($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableColumnWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the complete information about a metatable, including information about fields in the metatable.
     *  *
     * @param GetMetaTableFullInfoRequest $request GetMetaTableFullInfoRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableFullInfoResponse GetMetaTableFullInfoResponse
     */
    public function getMetaTableFullInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableFullInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableFullInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the complete information about a metatable, including information about fields in the metatable.
     *  *
     * @param GetMetaTableFullInfoRequest $request GetMetaTableFullInfoRequest
     *
     * @return GetMetaTableFullInfoResponse GetMetaTableFullInfoResponse
     */
    public function getMetaTableFullInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableFullInfoWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the instructions on how to use a metatable.
     *  *
     * @param GetMetaTableIntroWikiRequest $request GetMetaTableIntroWikiRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableIntroWikiResponse GetMetaTableIntroWikiResponse
     */
    public function getMetaTableIntroWikiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->wikiVersion)) {
            $query['WikiVersion'] = $request->wikiVersion;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableIntroWiki',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableIntroWikiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the instructions on how to use a metatable.
     *  *
     * @param GetMetaTableIntroWikiRequest $request GetMetaTableIntroWikiRequest
     *
     * @return GetMetaTableIntroWikiResponse GetMetaTableIntroWikiResponse
     */
    public function getMetaTableIntroWiki($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableIntroWikiWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetMetaTableLineage**.
     *  *
     * @param GetMetaTableLineageRequest $request GetMetaTableLineageRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableLineageResponse GetMetaTableLineageResponse
     */
    public function getMetaTableLineageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->direction)) {
            $query['Direction'] = $request->direction;
        }
        if (!Utils::isUnset($request->nextPrimaryKey)) {
            $query['NextPrimaryKey'] = $request->nextPrimaryKey;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableLineage',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableLineageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetMetaTableLineage**.
     *  *
     * @param GetMetaTableLineageRequest $request GetMetaTableLineageRequest
     *
     * @return GetMetaTableLineageResponse GetMetaTableLineageResponse
     */
    public function getMetaTableLineage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableLineageWithOptions($request, $runtime);
    }

    /**
     * @summary Queries metatables in a specified category.
     *  *
     * @param GetMetaTableListByCategoryRequest $request GetMetaTableListByCategoryRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableListByCategoryResponse GetMetaTableListByCategoryResponse
     */
    public function getMetaTableListByCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableListByCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableListByCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries metatables in a specified category.
     *  *
     * @param GetMetaTableListByCategoryRequest $request GetMetaTableListByCategoryRequest
     *
     * @return GetMetaTableListByCategoryResponse GetMetaTableListByCategoryResponse
     */
    public function getMetaTableListByCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableListByCategoryWithOptions($request, $runtime);
    }

    /**
     * @param GetMetaTableOutputRequest $request GetMetaTableOutputRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableOutputResponse GetMetaTableOutputResponse
     */
    public function getMetaTableOutputWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endDate)) {
            $query['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->startDate)) {
            $query['StartDate'] = $request->startDate;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->taskId)) {
            $query['TaskId'] = $request->taskId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableOutput',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetMetaTableOutputRequest $request GetMetaTableOutputRequest
     *
     * @return GetMetaTableOutputResponse GetMetaTableOutputResponse
     */
    public function getMetaTableOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableOutputWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the partitions of a metatable.
     *  *
     * @description You can call this operation to query only the partitions of a metatable in a MaxCompute or E-MapReduce (EMR) compute engine instance.
     *  *
     * @param GetMetaTablePartitionRequest $tmpReq  GetMetaTablePartitionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTablePartitionResponse GetMetaTablePartitionResponse
     */
    public function getMetaTablePartitionWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new GetMetaTablePartitionShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->sortCriterion)) {
            $request->sortCriterionShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->sortCriterion, 'SortCriterion', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->databaseName)) {
            $query['DatabaseName'] = $request->databaseName;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sortCriterionShrink)) {
            $query['SortCriterion'] = $request->sortCriterionShrink;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTablePartition',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTablePartitionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the partitions of a metatable.
     *  *
     * @description You can call this operation to query only the partitions of a metatable in a MaxCompute or E-MapReduce (EMR) compute engine instance.
     *  *
     * @param GetMetaTablePartitionRequest $request GetMetaTablePartitionRequest
     *
     * @return GetMetaTablePartitionResponse GetMetaTablePartitionResponse
     */
    public function getMetaTablePartition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTablePartitionWithOptions($request, $runtime);
    }

    /**
     * @summary Table
     *  *
     * @param GetMetaTableProducingTasksRequest $request GetMetaTableProducingTasksRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableProducingTasksResponse GetMetaTableProducingTasksResponse
     */
    public function getMetaTableProducingTasksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->dbName)) {
            $query['DbName'] = $request->dbName;
        }
        if (!Utils::isUnset($request->schemaName)) {
            $query['SchemaName'] = $request->schemaName;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableProducingTasks',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableProducingTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Table
     *  *
     * @param GetMetaTableProducingTasksRequest $request GetMetaTableProducingTasksRequest
     *
     * @return GetMetaTableProducingTasksResponse GetMetaTableProducingTasksResponse
     */
    public function getMetaTableProducingTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableProducingTasksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about table folders and table levels.
     *  *
     * @param GetMetaTableThemeLevelRequest $request GetMetaTableThemeLevelRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMetaTableThemeLevelResponse GetMetaTableThemeLevelResponse
     */
    public function getMetaTableThemeLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetMetaTableThemeLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMetaTableThemeLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about table folders and table levels.
     *  *
     * @param GetMetaTableThemeLevelRequest $request GetMetaTableThemeLevelRequest
     *
     * @return GetMetaTableThemeLevelResponse GetMetaTableThemeLevelResponse
     */
    public function getMetaTableThemeLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableThemeLevelWithOptions($request, $runtime);
    }

    /**
     * @param GetMigrationProcessRequest $request GetMigrationProcessRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMigrationProcessResponse GetMigrationProcessResponse
     */
    public function getMigrationProcessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->migrationId)) {
            $body['MigrationId'] = $request->migrationId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetMigrationProcess',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMigrationProcessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetMigrationProcessRequest $request GetMigrationProcessRequest
     *
     * @return GetMigrationProcessResponse GetMigrationProcessResponse
     */
    public function getMigrationProcess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMigrationProcessWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about a migration task.
     *  *
     * @param GetMigrationSummaryRequest $request GetMigrationSummaryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetMigrationSummaryResponse GetMigrationSummaryResponse
     */
    public function getMigrationSummaryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->migrationId)) {
            $body['MigrationId'] = $request->migrationId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetMigrationSummary',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetMigrationSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about a migration task.
     *  *
     * @param GetMigrationSummaryRequest $request GetMigrationSummaryRequest
     *
     * @return GetMigrationSummaryResponse GetMigrationSummaryResponse
     */
    public function getMigrationSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMigrationSummaryWithOptions($request, $runtime);
    }

    /**
     * @summary Indicates whether the request is successful.
     *  *
     * @param GetNodeRequest $request GetNodeRequest
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeResponse GetNodeResponse
     */
    public function getNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Indicates whether the request is successful.
     *  *
     * @param GetNodeRequest $request GetNodeRequest
     *
     * @return GetNodeResponse GetNodeResponse
     */
    public function getNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeWithOptions($request, $runtime);
    }

    /**
     * @param GetNodeChildrenRequest $request GetNodeChildrenRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeChildrenResponse GetNodeChildrenResponse
     */
    public function getNodeChildrenWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeChildren',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeChildrenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetNodeChildrenRequest $request GetNodeChildrenRequest
     *
     * @return GetNodeChildrenResponse GetNodeChildrenResponse
     */
    public function getNodeChildren($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeChildrenWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the code of a node.
     *  *
     * @param GetNodeCodeRequest $request GetNodeCodeRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeCodeResponse GetNodeCodeResponse
     */
    public function getNodeCodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeCode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the code of a node.
     *  *
     * @param GetNodeCodeRequest $request GetNodeCodeRequest
     *
     * @return GetNodeCodeResponse GetNodeCodeResponse
     */
    public function getNodeCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeCodeWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetNodeOnBaseline is deprecated
     *  *
     * Deprecated
     *
     * @param GetNodeOnBaselineRequest $request GetNodeOnBaselineRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeOnBaselineResponse GetNodeOnBaselineResponse
     */
    public function getNodeOnBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeOnBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeOnBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetNodeOnBaseline is deprecated
     *  *
     * Deprecated
     *
     * @param GetNodeOnBaselineRequest $request GetNodeOnBaselineRequest
     *
     * @return GetNodeOnBaselineResponse GetNodeOnBaselineResponse
     */
    public function getNodeOnBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeOnBaselineWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the ancestor nodes of a node.
     *  *
     * @param GetNodeParentsRequest $request GetNodeParentsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeParentsResponse GetNodeParentsResponse
     */
    public function getNodeParentsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeParents',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeParentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the ancestor nodes of a node.
     *  *
     * @param GetNodeParentsRequest $request GetNodeParentsRequest
     *
     * @return GetNodeParentsResponse GetNodeParentsResponse
     */
    public function getNodeParents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeParentsWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetNodeTypeListInfo is deprecated
     *  *
     * Deprecated
     *
     * @param GetNodeTypeListInfoRequest $request GetNodeTypeListInfoRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return GetNodeTypeListInfoResponse GetNodeTypeListInfoResponse
     */
    public function getNodeTypeListInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->locale)) {
            $body['Locale'] = $request->locale;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetNodeTypeListInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetNodeTypeListInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetNodeTypeListInfo is deprecated
     *  *
     * Deprecated
     *
     * @param GetNodeTypeListInfoRequest $request GetNodeTypeListInfoRequest
     *
     * @return GetNodeTypeListInfoResponse GetNodeTypeListInfoResponse
     */
    public function getNodeTypeListInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeTypeListInfoWithOptions($request, $runtime);
    }

    /**
     * @param GetOpRiskDataRequest $request GetOpRiskDataRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpRiskDataResponse GetOpRiskDataResponse
     */
    public function getOpRiskDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpRiskData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpRiskDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetOpRiskDataRequest $request GetOpRiskDataRequest
     *
     * @return GetOpRiskDataResponse GetOpRiskDataResponse
     */
    public function getOpRiskData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpRiskDataWithOptions($request, $runtime);
    }

    /**
     * @param GetOpSensitiveDataRequest $request GetOpSensitiveDataRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOpSensitiveDataResponse GetOpSensitiveDataResponse
     */
    public function getOpSensitiveDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetOpSensitiveData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOpSensitiveDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetOpSensitiveDataRequest $request GetOpSensitiveDataRequest
     *
     * @return GetOpSensitiveDataResponse GetOpSensitiveDataResponse
     */
    public function getOpSensitiveData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpSensitiveDataWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetOptionValueForProject**.
     *  *
     * @param GetOptionValueForProjectRequest $request GetOptionValueForProjectRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetOptionValueForProjectResponse GetOptionValueForProjectResponse
     */
    public function getOptionValueForProjectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->extensionCode)) {
            $body['ExtensionCode'] = $request->extensionCode;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetOptionValueForProject',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetOptionValueForProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **GetOptionValueForProject**.
     *  *
     * @param GetOptionValueForProjectRequest $request GetOptionValueForProjectRequest
     *
     * @return GetOptionValueForProjectResponse GetOptionValueForProjectResponse
     */
    public function getOptionValueForProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOptionValueForProjectWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details about a permission request order.
     *  *
     * @param GetPermissionApplyOrderDetailRequest $request GetPermissionApplyOrderDetailRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return GetPermissionApplyOrderDetailResponse GetPermissionApplyOrderDetailResponse
     */
    public function getPermissionApplyOrderDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->flowId)) {
            $query['FlowId'] = $request->flowId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetPermissionApplyOrderDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetPermissionApplyOrderDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details about a permission request order.
     *  *
     * @param GetPermissionApplyOrderDetailRequest $request GetPermissionApplyOrderDetailRequest
     *
     * @return GetPermissionApplyOrderDetailResponse GetPermissionApplyOrderDetailResponse
     */
    public function getPermissionApplyOrderDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPermissionApplyOrderDetailWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param GetProjectRequest $request GetProjectRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return GetProjectResponse GetProjectResponse
     */
    public function getProjectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $query['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetProject',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param GetProjectRequest $request GetProjectRequest
     *
     * @return GetProjectResponse GetProjectResponse
     */
    public function getProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getProjectWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetProjectDetail is deprecated
     *  *
     * @summary 
     *  *
     * Deprecated
     *
     * @param GetProjectDetailRequest $request GetProjectDetailRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetProjectDetailResponse GetProjectDetailResponse
     */
    public function getProjectDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetProjectDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetProjectDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetProjectDetail is deprecated
     *  *
     * @summary 
     *  *
     * Deprecated
     *
     * @param GetProjectDetailRequest $request GetProjectDetailRequest
     *
     * @return GetProjectDetailResponse GetProjectDetailResponse
     */
    public function getProjectDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getProjectDetailWithOptions($request, $runtime);
    }

    /**
     * @param GetQualityEntityRequest $request GetQualityEntityRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetQualityEntityResponse GetQualityEntityResponse
     */
    public function getQualityEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->matchExpression)) {
            $body['MatchExpression'] = $request->matchExpression;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $body['TableName'] = $request->tableName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetQualityEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetQualityEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetQualityEntityRequest $request GetQualityEntityRequest
     *
     * @return GetQualityEntityResponse GetQualityEntityResponse
     */
    public function getQualityEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getQualityEntityWithOptions($request, $runtime);
    }

    /**
     * @param GetQualityFollowerRequest $request GetQualityFollowerRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return GetQualityFollowerResponse GetQualityFollowerResponse
     */
    public function getQualityFollowerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetQualityFollower',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetQualityFollowerRequest $request GetQualityFollowerRequest
     *
     * @return GetQualityFollowerResponse GetQualityFollowerResponse
     */
    public function getQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * @param GetQualityRuleRequest $request GetQualityRuleRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return GetQualityRuleResponse GetQualityRuleResponse
     */
    public function getQualityRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $body['RuleId'] = $request->ruleId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetQualityRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetQualityRuleRequest $request GetQualityRuleRequest
     *
     * @return GetQualityRuleResponse GetQualityRuleResponse
     */
    public function getQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getQualityRuleWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the details of a custom alert rule.
     *  *
     * @description ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetRemind\\&type=RPC\\&version=2020-05-18)
     *  *
     * @param GetRemindRequest $request GetRemindRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return GetRemindResponse GetRemindResponse
     */
    public function getRemindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->remindId)) {
            $body['RemindId'] = $request->remindId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetRemind',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the details of a custom alert rule.
     *  *
     * @description ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetRemind\\&type=RPC\\&version=2020-05-18)
     *  *
     * @param GetRemindRequest $request GetRemindRequest
     *
     * @return GetRemindResponse GetRemindResponse
     */
    public function getRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRemindWithOptions($request, $runtime);
    }

    /**
     * @param GetSensitiveDataRequest $request GetSensitiveDataRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSensitiveDataResponse GetSensitiveDataResponse
     */
    public function getSensitiveDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'GetSensitiveData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSensitiveDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetSensitiveDataRequest $request GetSensitiveDataRequest
     *
     * @return GetSensitiveDataResponse GetSensitiveDataResponse
     */
    public function getSensitiveData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSensitiveDataWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI GetSuccessInstanceTrend is deprecated
     *  *
     * Deprecated
     *
     * @param GetSuccessInstanceTrendRequest $request GetSuccessInstanceTrendRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return GetSuccessInstanceTrendResponse GetSuccessInstanceTrendResponse
     */
    public function getSuccessInstanceTrendWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetSuccessInstanceTrend',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetSuccessInstanceTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI GetSuccessInstanceTrend is deprecated
     *  *
     * Deprecated
     *
     * @param GetSuccessInstanceTrendRequest $request GetSuccessInstanceTrendRequest
     *
     * @return GetSuccessInstanceTrendResponse GetSuccessInstanceTrendResponse
     */
    public function getSuccessInstanceTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSuccessInstanceTrendWithOptions($request, $runtime);
    }

    /**
     * @description ****
     *  *
     * @param GetTopicRequest $request GetTopicRequest
     * @param RuntimeOptions  $runtime runtime options for this request RuntimeOptions
     *
     * @return GetTopicResponse GetTopicResponse
     */
    public function getTopicWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->topicId)) {
            $body['TopicId'] = $request->topicId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetTopic',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetTopicResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description ****
     *  *
     * @param GetTopicRequest $request GetTopicRequest
     *
     * @return GetTopicResponse GetTopicResponse
     */
    public function getTopic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTopicWithOptions($request, $runtime);
    }

    /**
     * @param GetTopicInfluenceRequest $request GetTopicInfluenceRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return GetTopicInfluenceResponse GetTopicInfluenceResponse
     */
    public function getTopicInfluenceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->topicId)) {
            $body['TopicId'] = $request->topicId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'GetTopicInfluence',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return GetTopicInfluenceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param GetTopicInfluenceRequest $request GetTopicInfluenceRequest
     *
     * @return GetTopicInfluenceResponse GetTopicInfluenceResponse
     */
    public function getTopicInfluence($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTopicInfluenceWithOptions($request, $runtime);
    }

    /**
     * @description You can import self-managed data sources or data sources that are exported from other Dataworks workspaces to a specified DataWorks workspace.
     * *   To import a self-managed data source to DataWorks, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](https://help.aliyun.com/document_detail/181656.html).
     * *   For more information about how to export data sources from DataWorks workspaces to on-premises devices, see [ExportDataSources](https://help.aliyun.com/document_detail/279570.html).
     *  *
     * @param ImportDataSourcesRequest $request ImportDataSourcesRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ImportDataSourcesResponse ImportDataSourcesResponse
     */
    public function importDataSourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->dataSources)) {
            $query['DataSources'] = $request->dataSources;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ImportDataSources',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ImportDataSourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description You can import self-managed data sources or data sources that are exported from other Dataworks workspaces to a specified DataWorks workspace.
     * *   To import a self-managed data source to DataWorks, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](https://help.aliyun.com/document_detail/181656.html).
     * *   For more information about how to export data sources from DataWorks workspaces to on-premises devices, see [ExportDataSources](https://help.aliyun.com/document_detail/279570.html).
     *  *
     * @param ImportDataSourcesRequest $request ImportDataSourcesRequest
     *
     * @return ImportDataSourcesResponse ImportDataSourcesResponse
     */
    public function importDataSources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->importDataSourcesWithOptions($request, $runtime);
    }

    /**
     * @param ListAlertMessagesRequest $request ListAlertMessagesRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListAlertMessagesResponse ListAlertMessagesResponse
     */
    public function listAlertMessagesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertMethods)) {
            $body['AlertMethods'] = $request->alertMethods;
        }
        if (!Utils::isUnset($request->alertRuleTypes)) {
            $body['AlertRuleTypes'] = $request->alertRuleTypes;
        }
        if (!Utils::isUnset($request->alertUser)) {
            $body['AlertUser'] = $request->alertUser;
        }
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->beginTime)) {
            $body['BeginTime'] = $request->beginTime;
        }
        if (!Utils::isUnset($request->endTime)) {
            $body['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remindId)) {
            $body['RemindId'] = $request->remindId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListAlertMessages',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListAlertMessagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListAlertMessagesRequest $request ListAlertMessagesRequest
     *
     * @return ListAlertMessagesResponse ListAlertMessagesResponse
     */
    public function listAlertMessages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAlertMessagesWithOptions($request, $runtime);
    }

    /**
     * @param ListBaselineConfigsRequest $request ListBaselineConfigsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBaselineConfigsResponse ListBaselineConfigsResponse
     */
    public function listBaselineConfigsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineTypes)) {
            $body['BaselineTypes'] = $request->baselineTypes;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->searchText)) {
            $body['SearchText'] = $request->searchText;
        }
        if (!Utils::isUnset($request->useflag)) {
            $body['Useflag'] = $request->useflag;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListBaselineConfigs',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBaselineConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListBaselineConfigsRequest $request ListBaselineConfigsRequest
     *
     * @return ListBaselineConfigsResponse ListBaselineConfigsResponse
     */
    public function listBaselineConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselineConfigsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries baseline instances.
     *  *
     * @param ListBaselineStatusesRequest $request ListBaselineStatusesRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBaselineStatusesResponse ListBaselineStatusesResponse
     */
    public function listBaselineStatusesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineTypes)) {
            $body['BaselineTypes'] = $request->baselineTypes;
        }
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->finishStatus)) {
            $body['FinishStatus'] = $request->finishStatus;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->searchText)) {
            $body['SearchText'] = $request->searchText;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        if (!Utils::isUnset($request->topicId)) {
            $body['TopicId'] = $request->topicId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListBaselineStatuses',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBaselineStatusesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries baseline instances.
     *  *
     * @param ListBaselineStatusesRequest $request ListBaselineStatusesRequest
     *
     * @return ListBaselineStatusesResponse ListBaselineStatusesResponse
     */
    public function listBaselineStatuses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselineStatusesWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ListBaselinesRequest $request ListBaselinesRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBaselinesResponse ListBaselinesResponse
     */
    public function listBaselinesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineTypes)) {
            $body['BaselineTypes'] = $request->baselineTypes;
        }
        if (!Utils::isUnset($request->enable)) {
            $body['Enable'] = $request->enable;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->searchText)) {
            $body['SearchText'] = $request->searchText;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListBaselines',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBaselinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ListBaselinesRequest $request ListBaselinesRequest
     *
     * @return ListBaselinesResponse ListBaselinesResponse
     */
    public function listBaselines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselinesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries workflows.
     *  *
     * @param ListBusinessRequest $request ListBusinessRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListBusinessResponse ListBusinessResponse
     */
    public function listBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries workflows.
     *  *
     * @param ListBusinessRequest $request ListBusinessRequest
     *
     * @return ListBusinessResponse ListBusinessResponse
     */
    public function listBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBusinessWithOptions($request, $runtime);
    }

    /**
     * @summary Queries compute engine instances.
     *  *
     * @param ListCalcEnginesRequest $request ListCalcEnginesRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListCalcEnginesResponse ListCalcEnginesResponse
     */
    public function listCalcEnginesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->calcEngineType)) {
            $query['CalcEngineType'] = $request->calcEngineType;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListCalcEngines',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListCalcEnginesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries compute engine instances.
     *  *
     * @param ListCalcEnginesRequest $request ListCalcEnginesRequest
     *
     * @return ListCalcEnginesResponse ListCalcEnginesResponse
     */
    public function listCalcEngines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCalcEnginesWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ListConnections is deprecated
     *  *
     * @summary 
     *  *
     * Deprecated
     *
     * @param ListConnectionsRequest $request ListConnectionsRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListConnectionsResponse ListConnectionsResponse
     */
    public function listConnectionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListConnections',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ListConnections is deprecated
     *  *
     * @summary 
     *  *
     * Deprecated
     *
     * @param ListConnectionsRequest $request ListConnectionsRequest
     *
     * @return ListConnectionsResponse ListConnectionsResponse
     */
    public function listConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listConnectionsWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ListDIAlarmRulesRequest $request ListDIAlarmRulesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDIAlarmRulesResponse ListDIAlarmRulesResponse
     */
    public function listDIAlarmRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDIAlarmRules',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDIAlarmRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ListDIAlarmRulesRequest $request ListDIAlarmRulesRequest
     *
     * @return ListDIAlarmRulesResponse ListDIAlarmRulesResponse
     */
    public function listDIAlarmRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDIAlarmRulesWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ListDIJobsRequest $request ListDIJobsRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDIJobsResponse ListDIJobsResponse
     */
    public function listDIJobsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->destinationDataSourceType)) {
            $body['DestinationDataSourceType'] = $request->destinationDataSourceType;
        }
        if (!Utils::isUnset($request->jobName)) {
            $body['JobName'] = $request->jobName;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->sourceDataSourceType)) {
            $body['SourceDataSourceType'] = $request->sourceDataSourceType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDIJobs',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDIJobsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ListDIJobsRequest $request ListDIJobsRequest
     *
     * @return ListDIJobsResponse ListDIJobsResponse
     */
    public function listDIJobs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDIJobsWithOptions($request, $runtime);
    }

    /**
     * @description DataWorks allows you to set the default global configuration for only the processing rules of DDL messages in sync solutions. After you configure the **processing rules of DDL messages** in sync solutions, the configuration is set as the default global configuration and applies to all real-time sync nodes. You can also modify the **processing rules of DDL messages** based on your business requirements. For more information, see [Sync solutions](https://help.aliyun.com/document_detail/199008.html).
     *  *
     * @param ListDIProjectConfigRequest $request ListDIProjectConfigRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDIProjectConfigResponse ListDIProjectConfigResponse
     */
    public function listDIProjectConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destinationType)) {
            $query['DestinationType'] = $request->destinationType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->sourceType)) {
            $query['SourceType'] = $request->sourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListDIProjectConfig',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDIProjectConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description DataWorks allows you to set the default global configuration for only the processing rules of DDL messages in sync solutions. After you configure the **processing rules of DDL messages** in sync solutions, the configuration is set as the default global configuration and applies to all real-time sync nodes. You can also modify the **processing rules of DDL messages** based on your business requirements. For more information, see [Sync solutions](https://help.aliyun.com/document_detail/199008.html).
     *  *
     * @param ListDIProjectConfigRequest $request ListDIProjectConfigRequest
     *
     * @return ListDIProjectConfigResponse ListDIProjectConfigResponse
     */
    public function listDIProjectConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDIProjectConfigWithOptions($request, $runtime);
    }

    /**
     * @summary Supported DAG types:
     * *   MANUAL: the DAG for a manually triggered workflow.
     * *   SMOKE_TEST: the DAG for a smoke testing workflow.
     * *   SUPPLY_DATA: the DAG for a data backfill instance.
     * *   BUSINESS_PROCESS_DAG: the DAG for a one-time workflow.
     * Supported DAG states:
     * *   CREATED: The DAG is created.
     * *   RUNNING: The DAG is running.
     * *   FAILURE: The DAG fails to run.
     * *   SUCCESS: The DAG successfully runs.
     *  *
     * @description The operation that you want to perform. Set the value to **ListDags**.
     *  *
     * @param ListDagsRequest $request ListDagsRequest
     * @param RuntimeOptions  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDagsResponse ListDagsResponse
     */
    public function listDagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->opSeq)) {
            $body['OpSeq'] = $request->opSeq;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Supported DAG types:
     * *   MANUAL: the DAG for a manually triggered workflow.
     * *   SMOKE_TEST: the DAG for a smoke testing workflow.
     * *   SUPPLY_DATA: the DAG for a data backfill instance.
     * *   BUSINESS_PROCESS_DAG: the DAG for a one-time workflow.
     * Supported DAG states:
     * *   CREATED: The DAG is created.
     * *   RUNNING: The DAG is running.
     * *   FAILURE: The DAG fails to run.
     * *   SUCCESS: The DAG successfully runs.
     *  *
     * @description The operation that you want to perform. Set the value to **ListDags**.
     *  *
     * @param ListDagsRequest $request ListDagsRequest
     *
     * @return ListDagsResponse ListDagsResponse
     */
    public function listDags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDagsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the APIs on which other users are granted the access permissions.
     *  *
     * @param ListDataServiceApiAuthoritiesRequest $request ListDataServiceApiAuthoritiesRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceApiAuthoritiesResponse ListDataServiceApiAuthoritiesResponse
     */
    public function listDataServiceApiAuthoritiesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $body = [];
        if (!Utils::isUnset($request->apiNameKeyword)) {
            $body['ApiNameKeyword'] = $request->apiNameKeyword;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceApiAuthorities',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceApiAuthoritiesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the APIs on which other users are granted the access permissions.
     *  *
     * @param ListDataServiceApiAuthoritiesRequest $request ListDataServiceApiAuthoritiesRequest
     *
     * @return ListDataServiceApiAuthoritiesResponse ListDataServiceApiAuthoritiesResponse
     */
    public function listDataServiceApiAuthorities($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApiAuthoritiesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the test records of a DataService Studio API. This API operation allows you to query only the test records that are generated within the last month.
     *  *
     * @param ListDataServiceApiTestRequest $request ListDataServiceApiTestRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceApiTestResponse ListDataServiceApiTestResponse
     */
    public function listDataServiceApiTestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceApiTest',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceApiTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the test records of a DataService Studio API. This API operation allows you to query only the test records that are generated within the last month.
     *  *
     * @param ListDataServiceApiTestRequest $request ListDataServiceApiTestRequest
     *
     * @return ListDataServiceApiTestResponse ListDataServiceApiTestResponse
     */
    public function listDataServiceApiTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApiTestWithOptions($request, $runtime);
    }

    /**
     * @summary Queries a list of APIs in the development state.
     *  *
     * @param ListDataServiceApisRequest $request ListDataServiceApisRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceApisResponse ListDataServiceApisResponse
     */
    public function listDataServiceApisWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiNameKeyword)) {
            $body['ApiNameKeyword'] = $request->apiNameKeyword;
        }
        if (!Utils::isUnset($request->apiPathKeyword)) {
            $body['ApiPathKeyword'] = $request->apiPathKeyword;
        }
        if (!Utils::isUnset($request->creatorId)) {
            $body['CreatorId'] = $request->creatorId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceApis',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceApisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries a list of APIs in the development state.
     *  *
     * @param ListDataServiceApisRequest $request ListDataServiceApisRequest
     *
     * @return ListDataServiceApisResponse ListDataServiceApisResponse
     */
    public function listDataServiceApis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApisWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the basic information of applications.
     *  *
     * @param ListDataServiceApplicationsRequest $request ListDataServiceApplicationsRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceApplicationsResponse ListDataServiceApplicationsResponse
     */
    public function listDataServiceApplicationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectIdList)) {
            $body['ProjectIdList'] = $request->projectIdList;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceApplications',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceApplicationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the basic information of applications.
     *  *
     * @param ListDataServiceApplicationsRequest $request ListDataServiceApplicationsRequest
     *
     * @return ListDataServiceApplicationsResponse ListDataServiceApplicationsResponse
     */
    public function listDataServiceApplications($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApplicationsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the APIs that you are authorized to access.
     *  *
     * @param ListDataServiceAuthorizedApisRequest $request ListDataServiceAuthorizedApisRequest
     * @param RuntimeOptions                       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceAuthorizedApisResponse ListDataServiceAuthorizedApisResponse
     */
    public function listDataServiceAuthorizedApisWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $body = [];
        if (!Utils::isUnset($request->apiNameKeyword)) {
            $body['ApiNameKeyword'] = $request->apiNameKeyword;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceAuthorizedApis',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceAuthorizedApisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the APIs that you are authorized to access.
     *  *
     * @param ListDataServiceAuthorizedApisRequest $request ListDataServiceAuthorizedApisRequest
     *
     * @return ListDataServiceAuthorizedApisResponse ListDataServiceAuthorizedApisResponse
     */
    public function listDataServiceAuthorizedApis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceAuthorizedApisWithOptions($request, $runtime);
    }

    /**
     * @summary Queries folders.
     *  *
     * @param ListDataServiceFoldersRequest $request ListDataServiceFoldersRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceFoldersResponse ListDataServiceFoldersResponse
     */
    public function listDataServiceFoldersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderNameKeyword)) {
            $body['FolderNameKeyword'] = $request->folderNameKeyword;
        }
        if (!Utils::isUnset($request->groupId)) {
            $body['GroupId'] = $request->groupId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceFolders',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceFoldersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries folders.
     *  *
     * @param ListDataServiceFoldersRequest $request ListDataServiceFoldersRequest
     *
     * @return ListDataServiceFoldersResponse ListDataServiceFoldersResponse
     */
    public function listDataServiceFolders($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceFoldersWithOptions($request, $runtime);
    }

    /**
     * @summary Queries business processes.
     *  *
     * @param ListDataServiceGroupsRequest $request ListDataServiceGroupsRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServiceGroupsResponse ListDataServiceGroupsResponse
     */
    public function listDataServiceGroupsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->groupNameKeyword)) {
            $body['GroupNameKeyword'] = $request->groupNameKeyword;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServiceGroups',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServiceGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries business processes.
     *  *
     * @param ListDataServiceGroupsRequest $request ListDataServiceGroupsRequest
     *
     * @return ListDataServiceGroupsResponse ListDataServiceGroupsResponse
     */
    public function listDataServiceGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the information about APIs in the published state.
     *  *
     * @param ListDataServicePublishedApisRequest $request ListDataServicePublishedApisRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataServicePublishedApisResponse ListDataServicePublishedApisResponse
     */
    public function listDataServicePublishedApisWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiNameKeyword)) {
            $body['ApiNameKeyword'] = $request->apiNameKeyword;
        }
        if (!Utils::isUnset($request->apiPathKeyword)) {
            $body['ApiPathKeyword'] = $request->apiPathKeyword;
        }
        if (!Utils::isUnset($request->creatorId)) {
            $body['CreatorId'] = $request->creatorId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDataServicePublishedApis',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataServicePublishedApisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the information about APIs in the published state.
     *  *
     * @param ListDataServicePublishedApisRequest $request ListDataServicePublishedApisRequest
     *
     * @return ListDataServicePublishedApisResponse ListDataServicePublishedApisResponse
     */
    public function listDataServicePublishedApis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServicePublishedApisWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ListDataSourcesRequest $request ListDataSourcesRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDataSourcesResponse ListDataSourcesResponse
     */
    public function listDataSourcesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListDataSources',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDataSourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ListDataSourcesRequest $request ListDataSourcesRequest
     *
     * @return ListDataSourcesResponse ListDataSourcesResponse
     */
    public function listDataSources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataSourcesWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ListDeploymentsRequest $request ListDeploymentsRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListDeploymentsResponse ListDeploymentsResponse
     */
    public function listDeploymentsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->creator)) {
            $body['Creator'] = $request->creator;
        }
        if (!Utils::isUnset($request->endCreateTime)) {
            $body['EndCreateTime'] = $request->endCreateTime;
        }
        if (!Utils::isUnset($request->endExecuteTime)) {
            $body['EndExecuteTime'] = $request->endExecuteTime;
        }
        if (!Utils::isUnset($request->executor)) {
            $body['Executor'] = $request->executor;
        }
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListDeployments',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListDeploymentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ListDeploymentsRequest $request ListDeploymentsRequest
     *
     * @return ListDeploymentsResponse ListDeploymentsResponse
     */
    public function listDeployments($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDeploymentsWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListEnabledExtensionsForProject**.
     *  *
     * @param ListEnabledExtensionsForProjectRequest $request ListEnabledExtensionsForProjectRequest
     * @param RuntimeOptions                         $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEnabledExtensionsForProjectResponse ListEnabledExtensionsForProjectResponse
     */
    public function listEnabledExtensionsForProjectWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->eventCode)) {
            $body['EventCode'] = $request->eventCode;
        }
        if (!Utils::isUnset($request->fileType)) {
            $body['FileType'] = $request->fileType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListEnabledExtensionsForProject',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListEnabledExtensionsForProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListEnabledExtensionsForProject**.
     *  *
     * @param ListEnabledExtensionsForProjectRequest $request ListEnabledExtensionsForProjectRequest
     *
     * @return ListEnabledExtensionsForProjectResponse ListEnabledExtensionsForProjectResponse
     */
    public function listEnabledExtensionsForProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEnabledExtensionsForProjectWithOptions($request, $runtime);
    }

    /**
     * @summary List entities by tags
     *  *
     * @param ListEntitiesByTagsRequest $tmpReq  ListEntitiesByTagsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEntitiesByTagsResponse ListEntitiesByTagsResponse
     */
    public function listEntitiesByTagsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListEntitiesByTagsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListEntitiesByTags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListEntitiesByTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary List entities by tags
     *  *
     * @param ListEntitiesByTagsRequest $request ListEntitiesByTagsRequest
     *
     * @return ListEntitiesByTagsResponse ListEntitiesByTagsResponse
     */
    public function listEntitiesByTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEntitiesByTagsWithOptions($request, $runtime);
    }

    /**
     * @summary List entity tags by given qualified name
     *  *
     * @param ListEntityTagsRequest $request ListEntityTagsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListEntityTagsResponse ListEntityTagsResponse
     */
    public function listEntityTagsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListEntityTags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListEntityTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary List entity tags by given qualified name
     *  *
     * @param ListEntityTagsRequest $request ListEntityTagsRequest
     *
     * @return ListEntityTagsResponse ListEntityTagsResponse
     */
    public function listEntityTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEntityTagsWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListExtensions**.
     *  *
     * @param ListExtensionsRequest $request ListExtensionsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListExtensionsResponse ListExtensionsResponse
     */
    public function listExtensionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListExtensions',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListExtensionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListExtensions**.
     *  *
     * @param ListExtensionsRequest $request ListExtensionsRequest
     *
     * @return ListExtensionsResponse ListExtensionsResponse
     */
    public function listExtensions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listExtensionsWithOptions($request, $runtime);
    }

    /**
     * @param ListFileTypeRequest $request ListFileTypeRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileTypeResponse ListFileTypeResponse
     */
    public function listFileTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->locale)) {
            $body['Locale'] = $request->locale;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListFileType',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListFileTypeRequest $request ListFileTypeRequest
     *
     * @return ListFileTypeResponse ListFileTypeResponse
     */
    public function listFileType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileTypeWithOptions($request, $runtime);
    }

    /**
     * @param ListFileVersionsRequest $request ListFileVersionsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFileVersionsResponse ListFileVersionsResponse
     */
    public function listFileVersionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListFileVersions',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFileVersionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListFileVersionsRequest $request ListFileVersionsRequest
     *
     * @return ListFileVersionsResponse ListFileVersionsResponse
     */
    public function listFileVersions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileVersionsWithOptions($request, $runtime);
    }

    /**
     * @param ListFilesRequest $request ListFilesRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFilesResponse ListFilesResponse
     */
    public function listFilesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->exactFileName)) {
            $body['ExactFileName'] = $request->exactFileName;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileIdIn)) {
            $body['FileIdIn'] = $request->fileIdIn;
        }
        if (!Utils::isUnset($request->fileTypes)) {
            $body['FileTypes'] = $request->fileTypes;
        }
        if (!Utils::isUnset($request->keyword)) {
            $body['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->needAbsoluteFolderPath)) {
            $body['NeedAbsoluteFolderPath'] = $request->needAbsoluteFolderPath;
        }
        if (!Utils::isUnset($request->needContent)) {
            $body['NeedContent'] = $request->needContent;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->useType)) {
            $body['UseType'] = $request->useType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListFiles',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListFilesRequest $request ListFilesRequest
     *
     * @return ListFilesResponse ListFilesResponse
     */
    public function listFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFilesWithOptions($request, $runtime);
    }

    /**
     * @param ListFoldersRequest $request ListFoldersRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListFoldersResponse ListFoldersResponse
     */
    public function listFoldersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentFolderPath)) {
            $body['ParentFolderPath'] = $request->parentFolderPath;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListFolders',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListFoldersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListFoldersRequest $request ListFoldersRequest
     *
     * @return ListFoldersResponse ListFoldersResponse
     */
    public function listFolders($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFoldersWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListInnerNodes**.
     *  *
     * @param ListInnerNodesRequest $request ListInnerNodesRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInnerNodesResponse ListInnerNodesResponse
     */
    public function listInnerNodesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeName)) {
            $body['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->outerNodeId)) {
            $body['OuterNodeId'] = $request->outerNodeId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->programType)) {
            $body['ProgramType'] = $request->programType;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListInnerNodes',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInnerNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListInnerNodes**.
     *  *
     * @param ListInnerNodesRequest $request ListInnerNodesRequest
     *
     * @return ListInnerNodesResponse ListInnerNodesResponse
     */
    public function listInnerNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInnerNodesWithOptions($request, $runtime);
    }

    /**
     * @param ListInstanceAmountRequest $request ListInstanceAmountRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceAmountResponse ListInstanceAmountResponse
     */
    public function listInstanceAmountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginDate)) {
            $body['BeginDate'] = $request->beginDate;
        }
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceAmount',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceAmountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListInstanceAmountRequest $request ListInstanceAmountRequest
     *
     * @return ListInstanceAmountResponse ListInstanceAmountResponse
     */
    public function listInstanceAmount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceAmountWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListInstanceHistory**.
     *  *
     * @param ListInstanceHistoryRequest $request ListInstanceHistoryRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstanceHistoryResponse ListInstanceHistoryResponse
     */
    public function listInstanceHistoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListInstanceHistory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstanceHistoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListInstanceHistory**.
     *  *
     * @param ListInstanceHistoryRequest $request ListInstanceHistoryRequest
     *
     * @return ListInstanceHistoryResponse ListInstanceHistoryResponse
     */
    public function listInstanceHistory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceHistoryWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the directed acyclic graph (DAG). You can set this parameter to the value of the DagId parameter returned by the [RunCycleDagNodes](https://help.aliyun.com/document_detail/212961.html), [RunSmokeTest](https://help.aliyun.com/document_detail/212949.html), or [RunManualDagNodes](https://help.aliyun.com/document_detail/212830.html) operation based on your business requirements. The RunManualDagNodes operation is used to backfill data, the RunSmokeTest operation is used to perform smoke testing, and the RunManualDagNodes operation is used to run nodes in a manually triggered workflow.
     *  *
     * @param ListInstancesRequest $request ListInstancesRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return ListInstancesResponse ListInstancesResponse
     */
    public function listInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginBizdate)) {
            $body['BeginBizdate'] = $request->beginBizdate;
        }
        if (!Utils::isUnset($request->bizName)) {
            $body['BizName'] = $request->bizName;
        }
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->dagId)) {
            $body['DagId'] = $request->dagId;
        }
        if (!Utils::isUnset($request->endBizdate)) {
            $body['EndBizdate'] = $request->endBizdate;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $body['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->orderBy)) {
            $body['OrderBy'] = $request->orderBy;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->programType)) {
            $body['ProgramType'] = $request->programType;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->status)) {
            $body['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListInstances',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the directed acyclic graph (DAG). You can set this parameter to the value of the DagId parameter returned by the [RunCycleDagNodes](https://help.aliyun.com/document_detail/212961.html), [RunSmokeTest](https://help.aliyun.com/document_detail/212949.html), or [RunManualDagNodes](https://help.aliyun.com/document_detail/212830.html) operation based on your business requirements. The RunManualDagNodes operation is used to backfill data, the RunSmokeTest operation is used to perform smoke testing, and the RunManualDagNodes operation is used to run nodes in a manually triggered workflow.
     *  *
     * @param ListInstancesRequest $request ListInstancesRequest
     *
     * @return ListInstancesResponse ListInstancesResponse
     */
    public function listInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary V2, 
     *  *
     * @param ListLineageRequest $request ListLineageRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListLineageResponse ListLineageResponse
     */
    public function listLineageWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->direction)) {
            $query['Direction'] = $request->direction;
        }
        if (!Utils::isUnset($request->entityQualifiedName)) {
            $query['EntityQualifiedName'] = $request->entityQualifiedName;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListLineage',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListLineageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary V2, 
     *  *
     * @param ListLineageRequest $request ListLineageRequest
     *
     * @return ListLineageResponse ListLineageResponse
     */
    public function listLineage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLineageWithOptions($request, $runtime);
    }

    /**
     * @param ListManualDagInstancesRequest $request ListManualDagInstancesRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return ListManualDagInstancesResponse ListManualDagInstancesResponse
     */
    public function listManualDagInstancesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->dagId)) {
            $body['DagId'] = $request->dagId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListManualDagInstances',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListManualDagInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListManualDagInstancesRequest $request ListManualDagInstancesRequest
     *
     * @return ListManualDagInstancesResponse ListManualDagInstancesResponse
     */
    public function listManualDagInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listManualDagInstancesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the entities in a collection.
     *  *
     * @param ListMetaCollectionEntitiesRequest $request ListMetaCollectionEntitiesRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMetaCollectionEntitiesResponse ListMetaCollectionEntitiesResponse
     */
    public function listMetaCollectionEntitiesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->collectionQualifiedName)) {
            $query['CollectionQualifiedName'] = $request->collectionQualifiedName;
        }
        if (!Utils::isUnset($request->entityType)) {
            $query['EntityType'] = $request->entityType;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListMetaCollectionEntities',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMetaCollectionEntitiesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the entities in a collection.
     *  *
     * @param ListMetaCollectionEntitiesRequest $request ListMetaCollectionEntitiesRequest
     *
     * @return ListMetaCollectionEntitiesResponse ListMetaCollectionEntitiesResponse
     */
    public function listMetaCollectionEntities($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMetaCollectionEntitiesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries information about collections. Collections include data albums that are displayed on the DataMap page and categories that are created in the data albums. You can call this API operation to query collections by type.
     *  *
     * @description The type can be ALBUM or ALBUM_CATEGORY. ALBUM indicates data albums. ALBUM_CATEGORY indicates categories.
     *  *
     * @param ListMetaCollectionsRequest $request ListMetaCollectionsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMetaCollectionsResponse ListMetaCollectionsResponse
     */
    public function listMetaCollectionsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->administrator)) {
            $query['Administrator'] = $request->administrator;
        }
        if (!Utils::isUnset($request->collectionType)) {
            $query['CollectionType'] = $request->collectionType;
        }
        if (!Utils::isUnset($request->creator)) {
            $query['Creator'] = $request->creator;
        }
        if (!Utils::isUnset($request->follower)) {
            $query['Follower'] = $request->follower;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->nextToken)) {
            $query['NextToken'] = $request->nextToken;
        }
        if (!Utils::isUnset($request->orderBy)) {
            $query['OrderBy'] = $request->orderBy;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->parentQualifiedName)) {
            $query['ParentQualifiedName'] = $request->parentQualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListMetaCollections',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMetaCollectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries information about collections. Collections include data albums that are displayed on the DataMap page and categories that are created in the data albums. You can call this API operation to query collections by type.
     *  *
     * @description The type can be ALBUM or ALBUM_CATEGORY. ALBUM indicates data albums. ALBUM_CATEGORY indicates categories.
     *  *
     * @param ListMetaCollectionsRequest $request ListMetaCollectionsRequest
     *
     * @return ListMetaCollectionsResponse ListMetaCollectionsResponse
     */
    public function listMetaCollections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMetaCollectionsWithOptions($request, $runtime);
    }

    /**
     * @param ListMetaDBRequest $request ListMetaDBRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMetaDBResponse ListMetaDBResponse
     */
    public function listMetaDBWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListMetaDB',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMetaDBResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListMetaDBRequest $request ListMetaDBRequest
     *
     * @return ListMetaDBResponse ListMetaDBResponse
     */
    public function listMetaDB($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMetaDBWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListMigrations**.
     *  *
     * @param ListMigrationsRequest $request ListMigrationsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListMigrationsResponse ListMigrationsResponse
     */
    public function listMigrationsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->migrationType)) {
            $body['MigrationType'] = $request->migrationType;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListMigrations',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListMigrationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListMigrations**.
     *  *
     * @param ListMigrationsRequest $request ListMigrationsRequest
     *
     * @return ListMigrationsResponse ListMigrationsResponse
     */
    public function listMigrations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMigrationsWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ListNodeIO is deprecated
     *  *
     * Deprecated
     *
     * @param ListNodeIORequest $request ListNodeIORequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodeIOResponse ListNodeIOResponse
     */
    public function listNodeIOWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->ioType)) {
            $body['IoType'] = $request->ioType;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodeIO',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodeIOResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ListNodeIO is deprecated
     *  *
     * Deprecated
     *
     * @param ListNodeIORequest $request ListNodeIORequest
     *
     * @return ListNodeIOResponse ListNodeIOResponse
     */
    public function listNodeIO($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodeIOWithOptions($request, $runtime);
    }

    /**
     * @param ListNodeInputOrOutputRequest $request ListNodeInputOrOutputRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodeInputOrOutputResponse ListNodeInputOrOutputResponse
     */
    public function listNodeInputOrOutputWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->ioType)) {
            $body['IoType'] = $request->ioType;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodeInputOrOutput',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodeInputOrOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListNodeInputOrOutputRequest $request ListNodeInputOrOutputRequest
     *
     * @return ListNodeInputOrOutputResponse ListNodeInputOrOutputResponse
     */
    public function listNodeInputOrOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodeInputOrOutputWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the workspace.
     *  *
     * @param ListNodesRequest $request ListNodesRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodesResponse ListNodesResponse
     */
    public function listNodesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizName)) {
            $body['BizName'] = $request->bizName;
        }
        if (!Utils::isUnset($request->nodeName)) {
            $body['NodeName'] = $request->nodeName;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->programType)) {
            $body['ProgramType'] = $request->programType;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodes',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the workspace.
     *  *
     * @param ListNodesRequest $request ListNodesRequest
     *
     * @return ListNodesResponse ListNodesResponse
     */
    public function listNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodesWithOptions($request, $runtime);
    }

    /**
     * @param ListNodesByBaselineRequest $request ListNodesByBaselineRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodesByBaselineResponse ListNodesByBaselineResponse
     */
    public function listNodesByBaselineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodesByBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodesByBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListNodesByBaselineRequest $request ListNodesByBaselineRequest
     *
     * @return ListNodesByBaselineResponse ListNodesByBaselineResponse
     */
    public function listNodesByBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodesByBaselineWithOptions($request, $runtime);
    }

    /**
     * @param ListNodesByOutputRequest $request ListNodesByOutputRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ListNodesByOutputResponse ListNodesByOutputResponse
     */
    public function listNodesByOutputWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->outputs)) {
            $body['Outputs'] = $request->outputs;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListNodesByOutput',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListNodesByOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListNodesByOutputRequest $request ListNodesByOutputRequest
     *
     * @return ListNodesByOutputResponse ListNodesByOutputResponse
     */
    public function listNodesByOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodesByOutputWithOptions($request, $runtime);
    }

    /**
     * @param ListPermissionApplyOrdersRequest $request ListPermissionApplyOrdersRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListPermissionApplyOrdersResponse ListPermissionApplyOrdersResponse
     */
    public function listPermissionApplyOrdersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->endTime)) {
            $query['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->engineType)) {
            $query['EngineType'] = $request->engineType;
        }
        if (!Utils::isUnset($request->flowStatus)) {
            $query['FlowStatus'] = $request->flowStatus;
        }
        if (!Utils::isUnset($request->maxComputeProjectName)) {
            $query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }
        if (!Utils::isUnset($request->orderType)) {
            $query['OrderType'] = $request->orderType;
        }
        if (!Utils::isUnset($request->pageNum)) {
            $query['PageNum'] = $request->pageNum;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->queryType)) {
            $query['QueryType'] = $request->queryType;
        }
        if (!Utils::isUnset($request->startTime)) {
            $query['StartTime'] = $request->startTime;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->workspaceId)) {
            $query['WorkspaceId'] = $request->workspaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListPermissionApplyOrders',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListPermissionApplyOrdersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListPermissionApplyOrdersRequest $request ListPermissionApplyOrdersRequest
     *
     * @return ListPermissionApplyOrdersResponse ListPermissionApplyOrdersResponse
     */
    public function listPermissionApplyOrders($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPermissionApplyOrdersWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI ListProgramTypeCount is deprecated
     *  *
     * Deprecated
     *
     * @param ListProgramTypeCountRequest $request ListProgramTypeCountRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProgramTypeCountResponse ListProgramTypeCountResponse
     */
    public function listProgramTypeCountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListProgramTypeCount',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProgramTypeCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI ListProgramTypeCount is deprecated
     *  *
     * Deprecated
     *
     * @param ListProgramTypeCountRequest $request ListProgramTypeCountRequest
     *
     * @return ListProgramTypeCountResponse ListProgramTypeCountResponse
     */
    public function listProgramTypeCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProgramTypeCountWithOptions($request, $runtime);
    }

    /**
     * @description For example, an Alibaba Cloud account can assume the developer, O&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
     *  *
     * @param ListProjectIdsRequest $request ListProjectIdsRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProjectIdsResponse ListProjectIdsResponse
     */
    public function listProjectIdsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListProjectIds',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProjectIdsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description For example, an Alibaba Cloud account can assume the developer, O&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
     *  *
     * @param ListProjectIdsRequest $request ListProjectIdsRequest
     *
     * @return ListProjectIdsResponse ListProjectIdsResponse
     */
    public function listProjectIds($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectIdsWithOptions($request, $runtime);
    }

    /**
     * @summary Queries members in a DataWorks workspace.
     *  *
     * @param ListProjectMembersRequest $request ListProjectMembersRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProjectMembersResponse ListProjectMembersResponse
     */
    public function listProjectMembersWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListProjectMembers',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProjectMembersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries members in a DataWorks workspace.
     *  *
     * @param ListProjectMembersRequest $request ListProjectMembersRequest
     *
     * @return ListProjectMembersResponse ListProjectMembersResponse
     */
    public function listProjectMembers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectMembersWithOptions($request, $runtime);
    }

    /**
     * @summary A topic is added to describe how to call the ListProjectRoles operation to query all roles in a workspace.
     *  *
     * @description ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=ListProjectRoles\\&type=RPC\\&version=2020-05-18)
     *  *
     * @param ListProjectRolesRequest $request ListProjectRolesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProjectRolesResponse ListProjectRolesResponse
     */
    public function listProjectRolesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListProjectRoles',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProjectRolesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary A topic is added to describe how to call the ListProjectRoles operation to query all roles in a workspace.
     *  *
     * @description ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=ListProjectRoles\\&type=RPC\\&version=2020-05-18)
     *  *
     * @param ListProjectRolesRequest $request ListProjectRolesRequest
     *
     * @return ListProjectRolesResponse ListProjectRolesResponse
     */
    public function listProjectRoles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectRolesWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ListProjectsRequest $tmpReq  ListProjectsRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return ListProjectsResponse ListProjectsResponse
     */
    public function listProjectsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListProjectsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->resourceManagerResourceGroupId)) {
            $query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }
        if (!Utils::isUnset($request->tagsShrink)) {
            $query['Tags'] = $request->tagsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListProjects',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListProjectsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ListProjectsRequest $request ListProjectsRequest
     *
     * @return ListProjectsResponse ListProjectsResponse
     */
    public function listProjects($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectsWithOptions($request, $runtime);
    }

    /**
     * @description ****
     *  *
     * @param ListQualityResultsByEntityRequest $request ListQualityResultsByEntityRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListQualityResultsByEntityResponse ListQualityResultsByEntityResponse
     */
    public function listQualityResultsByEntityWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->startDate)) {
            $body['StartDate'] = $request->startDate;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListQualityResultsByEntity',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListQualityResultsByEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description ****
     *  *
     * @param ListQualityResultsByEntityRequest $request ListQualityResultsByEntityRequest
     *
     * @return ListQualityResultsByEntityResponse ListQualityResultsByEntityResponse
     */
    public function listQualityResultsByEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQualityResultsByEntityWithOptions($request, $runtime);
    }

    /**
     * @param ListQualityResultsByRuleRequest $request ListQualityResultsByRuleRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return ListQualityResultsByRuleResponse ListQualityResultsByRuleResponse
     */
    public function listQualityResultsByRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->endDate)) {
            $body['EndDate'] = $request->endDate;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->ruleId)) {
            $body['RuleId'] = $request->ruleId;
        }
        if (!Utils::isUnset($request->startDate)) {
            $body['StartDate'] = $request->startDate;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListQualityResultsByRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListQualityResultsByRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListQualityResultsByRuleRequest $request ListQualityResultsByRuleRequest
     *
     * @return ListQualityResultsByRuleResponse ListQualityResultsByRuleResponse
     */
    public function listQualityResultsByRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQualityResultsByRuleWithOptions($request, $runtime);
    }

    /**
     * @param ListQualityRulesRequest $request ListQualityRulesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return ListQualityRulesResponse ListQualityRulesResponse
     */
    public function listQualityRulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListQualityRules',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListQualityRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListQualityRulesRequest $request ListQualityRulesRequest
     *
     * @return ListQualityRulesResponse ListQualityRulesResponse
     */
    public function listQualityRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQualityRulesWithOptions($request, $runtime);
    }

    /**
     * @param ListRefDISyncTasksRequest $request ListRefDISyncTasksRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListRefDISyncTasksResponse ListRefDISyncTasksResponse
     */
    public function listRefDISyncTasksWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->datasourceName)) {
            $query['DatasourceName'] = $request->datasourceName;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->refType)) {
            $query['RefType'] = $request->refType;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListRefDISyncTasks',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListRefDISyncTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ListRefDISyncTasksRequest $request ListRefDISyncTasksRequest
     *
     * @return ListRefDISyncTasksResponse ListRefDISyncTasksResponse
     */
    public function listRefDISyncTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRefDISyncTasksWithOptions($request, $runtime);
    }

    /**
     * @summary Queries custom alert rules.
     *  *
     * @param ListRemindsRequest $request ListRemindsRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return ListRemindsResponse ListRemindsResponse
     */
    public function listRemindsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertTarget)) {
            $body['AlertTarget'] = $request->alertTarget;
        }
        if (!Utils::isUnset($request->founder)) {
            $body['Founder'] = $request->founder;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->remindTypes)) {
            $body['RemindTypes'] = $request->remindTypes;
        }
        if (!Utils::isUnset($request->searchText)) {
            $body['SearchText'] = $request->searchText;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListReminds',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListRemindsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries custom alert rules.
     *  *
     * @param ListRemindsRequest $request ListRemindsRequest
     *
     * @return ListRemindsResponse ListRemindsResponse
     */
    public function listReminds($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRemindsWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param ListResourceGroupsRequest $tmpReq  ListResourceGroupsRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListResourceGroupsResponse ListResourceGroupsResponse
     */
    public function listResourceGroupsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new ListResourceGroupsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->bizExtKey)) {
            $query['BizExtKey'] = $request->bizExtKey;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->resourceGroupType)) {
            $query['ResourceGroupType'] = $request->resourceGroupType;
        }
        if (!Utils::isUnset($request->resourceManagerResourceGroupId)) {
            $query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }
        if (!Utils::isUnset($request->tagsShrink)) {
            $query['Tags'] = $request->tagsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListResourceGroups',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListResourceGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param ListResourceGroupsRequest $request ListResourceGroupsRequest
     *
     * @return ListResourceGroupsResponse ListResourceGroupsResponse
     */
    public function listResourceGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listResourceGroupsWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListShiftPersonnels**.
     *  *
     * @param ListShiftPersonnelsRequest $request ListShiftPersonnelsRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return ListShiftPersonnelsResponse ListShiftPersonnelsResponse
     */
    public function listShiftPersonnelsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginTime)) {
            $body['BeginTime'] = $request->beginTime;
        }
        if (!Utils::isUnset($request->endTime)) {
            $body['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->shiftPersonUID)) {
            $body['ShiftPersonUID'] = $request->shiftPersonUID;
        }
        if (!Utils::isUnset($request->shiftScheduleIdentifier)) {
            $body['ShiftScheduleIdentifier'] = $request->shiftScheduleIdentifier;
        }
        if (!Utils::isUnset($request->userType)) {
            $body['UserType'] = $request->userType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListShiftPersonnels',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListShiftPersonnelsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListShiftPersonnels**.
     *  *
     * @param ListShiftPersonnelsRequest $request ListShiftPersonnelsRequest
     *
     * @return ListShiftPersonnelsResponse ListShiftPersonnelsResponse
     */
    public function listShiftPersonnels($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listShiftPersonnelsWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListShiftSchedules**.
     *  *
     * @param ListShiftSchedulesRequest $request ListShiftSchedulesRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return ListShiftSchedulesResponse ListShiftSchedulesResponse
     */
    public function listShiftSchedulesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->shiftScheduleName)) {
            $body['ShiftScheduleName'] = $request->shiftScheduleName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListShiftSchedules',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListShiftSchedulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **ListShiftSchedules**.
     *  *
     * @param ListShiftSchedulesRequest $request ListShiftSchedulesRequest
     *
     * @return ListShiftSchedulesResponse ListShiftSchedulesResponse
     */
    public function listShiftSchedules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listShiftSchedulesWithOptions($request, $runtime);
    }

    /**
     * @summary Queries the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
     *  *
     * @param ListSuccessInstanceAmountRequest $request ListSuccessInstanceAmountRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return ListSuccessInstanceAmountResponse ListSuccessInstanceAmountResponse
     */
    public function listSuccessInstanceAmountWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListSuccessInstanceAmount',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListSuccessInstanceAmountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
     *  *
     * @param ListSuccessInstanceAmountRequest $request ListSuccessInstanceAmountRequest
     *
     * @return ListSuccessInstanceAmountResponse ListSuccessInstanceAmountResponse
     */
    public function listSuccessInstanceAmount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSuccessInstanceAmountWithOptions($request, $runtime);
    }

    /**
     * @summary Queries table levels. This API operation will be replaced soon. We recommend that you do not call this API operation.
     *  *
     * @param ListTableLevelRequest $request ListTableLevelRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTableLevelResponse ListTableLevelResponse
     */
    public function listTableLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListTableLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries table levels. This API operation will be replaced soon. We recommend that you do not call this API operation.
     *  *
     * @param ListTableLevelRequest $request ListTableLevelRequest
     *
     * @return ListTableLevelResponse ListTableLevelResponse
     */
    public function listTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTableLevelWithOptions($request, $runtime);
    }

    /**
     * @summary Queries table folders. This API operation will be replaced soon. We recommend that you do not call this API operation.
     *  *
     * @param ListTableThemeRequest $request ListTableThemeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTableThemeResponse ListTableThemeResponse
     */
    public function listTableThemeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ListTableTheme',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries table folders. This API operation will be replaced soon. We recommend that you do not call this API operation.
     *  *
     * @param ListTableThemeRequest $request ListTableThemeRequest
     *
     * @return ListTableThemeResponse ListTableThemeResponse
     */
    public function listTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTableThemeWithOptions($request, $runtime);
    }

    /**
     * @summary Queries events.
     *  *
     * @param ListTopicsRequest $request ListTopicsRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return ListTopicsResponse ListTopicsResponse
     */
    public function listTopicsWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->beginTime)) {
            $body['BeginTime'] = $request->beginTime;
        }
        if (!Utils::isUnset($request->endTime)) {
            $body['EndTime'] = $request->endTime;
        }
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $body['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->topicStatuses)) {
            $body['TopicStatuses'] = $request->topicStatuses;
        }
        if (!Utils::isUnset($request->topicTypes)) {
            $body['TopicTypes'] = $request->topicTypes;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ListTopics',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ListTopicsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Queries events.
     *  *
     * @param ListTopicsRequest $request ListTopicsRequest
     *
     * @return ListTopicsResponse ListTopicsResponse
     */
    public function listTopics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTopicsWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the directory that you want to add to the left-side navigation pane of DataAnalysis. This parameter is used together with the TargetType parameter.
     * For example, if you set the TargetType parameter to META_ALBUM, you must set the TargetId parameter to the ID of the related data album. You can call the [ListMetaCollections](https://help.aliyun.com/document_detail/469938.html) operation to obtain the ID of the data album. The ID is indicated by the QualifiedName parameter.
     *  *
     * @param MountDirectoryRequest $request MountDirectoryRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return MountDirectoryResponse MountDirectoryResponse
     */
    public function mountDirectoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->targetId)) {
            $body['TargetId'] = $request->targetId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $body['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->targetUserId)) {
            $body['TargetUserId'] = $request->targetUserId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'MountDirectory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return MountDirectoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the directory that you want to add to the left-side navigation pane of DataAnalysis. This parameter is used together with the TargetType parameter.
     * For example, if you set the TargetType parameter to META_ALBUM, you must set the TargetId parameter to the ID of the related data album. You can call the [ListMetaCollections](https://help.aliyun.com/document_detail/469938.html) operation to obtain the ID of the data album. The ID is indicated by the QualifiedName parameter.
     *  *
     * @param MountDirectoryRequest $request MountDirectoryRequest
     *
     * @return MountDirectoryResponse MountDirectoryResponse
     */
    public function mountDirectory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->mountDirectoryWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **OfflineNode**.
     *  *
     * @param OfflineNodeRequest $request OfflineNodeRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return OfflineNodeResponse OfflineNodeResponse
     */
    public function offlineNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'OfflineNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return OfflineNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **OfflineNode**.
     *  *
     * @param OfflineNodeRequest $request OfflineNodeRequest
     *
     * @return OfflineNodeResponse OfflineNodeResponse
     */
    public function offlineNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->offlineNodeWithOptions($request, $runtime);
    }

    /**
     * @param PublishDataServiceApiRequest $request PublishDataServiceApiRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return PublishDataServiceApiResponse PublishDataServiceApiResponse
     */
    public function publishDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'PublishDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return PublishDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param PublishDataServiceApiRequest $request PublishDataServiceApiRequest
     *
     * @return PublishDataServiceApiResponse PublishDataServiceApiResponse
     */
    public function publishDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publishDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary DataWorks allows you to call only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) or [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to create or update a batch synchronization node in Data Integration. To create or update a real-time synchronization node or a synchronization solution, you must first call the GenerateDISyncTaskConfigForCreating or GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask or UpdateDISyncTask operation and use the parameters as request parameters to create or update a real-time synchronization node or a synchronization solution.
     * DataWorks allows you to create or update real-time synchronization nodes and synchronization solutions in Data Integration only in asynchronous mode.
     *  *
     * @description The operation that you want to perform.
     *  *
     * @param QueryDISyncTaskConfigProcessResultRequest $request QueryDISyncTaskConfigProcessResultRequest
     * @param RuntimeOptions                            $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryDISyncTaskConfigProcessResultResponse QueryDISyncTaskConfigProcessResultResponse
     */
    public function queryDISyncTaskConfigProcessResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->asyncProcessId)) {
            $query['AsyncProcessId'] = $request->asyncProcessId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'QueryDISyncTaskConfigProcessResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryDISyncTaskConfigProcessResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary DataWorks allows you to call only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) or [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to create or update a batch synchronization node in Data Integration. To create or update a real-time synchronization node or a synchronization solution, you must first call the GenerateDISyncTaskConfigForCreating or GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask or UpdateDISyncTask operation and use the parameters as request parameters to create or update a real-time synchronization node or a synchronization solution.
     * DataWorks allows you to create or update real-time synchronization nodes and synchronization solutions in Data Integration only in asynchronous mode.
     *  *
     * @description The operation that you want to perform.
     *  *
     * @param QueryDISyncTaskConfigProcessResultRequest $request QueryDISyncTaskConfigProcessResultRequest
     *
     * @return QueryDISyncTaskConfigProcessResultResponse QueryDISyncTaskConfigProcessResultResponse
     */
    public function queryDISyncTaskConfigProcessResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryDISyncTaskConfigProcessResultWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param QueryDefaultTemplateRequest $request QueryDefaultTemplateRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryDefaultTemplateResponse QueryDefaultTemplateResponse
     */
    public function queryDefaultTemplateWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryDefaultTemplate',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryDefaultTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param QueryDefaultTemplateRequest $request QueryDefaultTemplateRequest
     *
     * @return QueryDefaultTemplateResponse QueryDefaultTemplateResponse
     */
    public function queryDefaultTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryDefaultTemplateWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param QueryPublicModelEngineRequest $request QueryPublicModelEngineRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryPublicModelEngineResponse QueryPublicModelEngineResponse
     */
    public function queryPublicModelEngineWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->text)) {
            $body['Text'] = $request->text;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryPublicModelEngine',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryPublicModelEngineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param QueryPublicModelEngineRequest $request QueryPublicModelEngineRequest
     *
     * @return QueryPublicModelEngineResponse QueryPublicModelEngineResponse
     */
    public function queryPublicModelEngine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryPublicModelEngineWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param QueryRecognizeDataByRuleTypeRequest $request QueryRecognizeDataByRuleTypeRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryRecognizeDataByRuleTypeResponse QueryRecognizeDataByRuleTypeResponse
     */
    public function queryRecognizeDataByRuleTypeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->recognizeRulesType)) {
            $body['RecognizeRulesType'] = $request->recognizeRulesType;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryRecognizeDataByRuleType',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryRecognizeDataByRuleTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param QueryRecognizeDataByRuleTypeRequest $request QueryRecognizeDataByRuleTypeRequest
     *
     * @return QueryRecognizeDataByRuleTypeResponse QueryRecognizeDataByRuleTypeResponse
     */
    public function queryRecognizeDataByRuleType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecognizeDataByRuleTypeWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param QueryRecognizeRuleDetailRequest $request QueryRecognizeRuleDetailRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryRecognizeRuleDetailResponse QueryRecognizeRuleDetailResponse
     */
    public function queryRecognizeRuleDetailWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QueryRecognizeRuleDetail',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryRecognizeRuleDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param QueryRecognizeRuleDetailRequest $request QueryRecognizeRuleDetailRequest
     *
     * @return QueryRecognizeRuleDetailResponse QueryRecognizeRuleDetailResponse
     */
    public function queryRecognizeRuleDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecognizeRuleDetailWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param RuntimeOptions $runtime runtime options for this request RuntimeOptions
     *
     * @return QueryRecognizeRulesTypeResponse QueryRecognizeRulesTypeResponse
     */
    public function queryRecognizeRulesTypeWithOptions($runtime)
    {
        $req    = new OpenApiRequest([]);
        $params = new Params([
            'action'      => 'QueryRecognizeRulesType',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QueryRecognizeRulesTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @return QueryRecognizeRulesTypeResponse QueryRecognizeRulesTypeResponse
     */
    public function queryRecognizeRulesType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecognizeRulesTypeWithOptions($runtime);
    }

    /**
     * @summary 
     *  *
     * @param QuerySensClassificationRequest $request QuerySensClassificationRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return QuerySensClassificationResponse QuerySensClassificationResponse
     */
    public function querySensClassificationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QuerySensClassification',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QuerySensClassificationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param QuerySensClassificationRequest $request QuerySensClassificationRequest
     *
     * @return QuerySensClassificationResponse QuerySensClassificationResponse
     */
    public function querySensClassification($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySensClassificationWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param QuerySensLevelRequest $request QuerySensLevelRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return QuerySensLevelResponse QuerySensLevelResponse
     */
    public function querySensLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['tenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QuerySensLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QuerySensLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param QuerySensLevelRequest $request QuerySensLevelRequest
     *
     * @return QuerySensLevelResponse QuerySensLevelResponse
     */
    public function querySensLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySensLevelWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param QuerySensNodeInfoRequest $request QuerySensNodeInfoRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return QuerySensNodeInfoResponse QuerySensNodeInfoResponse
     */
    public function querySensNodeInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->pageNo)) {
            $body['PageNo'] = $request->pageNo;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $body['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->sensitiveName)) {
            $body['SensitiveName'] = $request->sensitiveName;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        if (!Utils::isUnset($request->status)) {
            $body['status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'QuerySensNodeInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return QuerySensNodeInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param QuerySensNodeInfoRequest $request QuerySensNodeInfoRequest
     *
     * @return QuerySensNodeInfoResponse QuerySensNodeInfoResponse
     */
    public function querySensNodeInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySensNodeInfoWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param RegisterLineageRelationRequest $tmpReq  RegisterLineageRelationRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return RegisterLineageRelationResponse RegisterLineageRelationResponse
     */
    public function registerLineageRelationWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new RegisterLineageRelationShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->lineageRelationRegisterVO)) {
            $request->lineageRelationRegisterVOShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->lineageRelationRegisterVO, 'LineageRelationRegisterVO', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->lineageRelationRegisterVOShrink)) {
            $body['LineageRelationRegisterVO'] = $request->lineageRelationRegisterVOShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RegisterLineageRelation',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RegisterLineageRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param RegisterLineageRelationRequest $request RegisterLineageRelationRequest
     *
     * @return RegisterLineageRelationResponse RegisterLineageRelationResponse
     */
    public function registerLineageRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->registerLineageRelationWithOptions($request, $runtime);
    }

    /**
     * @summary Remove entity tags by given qualified name and tag keys
     *  *
     * @param RemoveEntityTagsRequest $tmpReq  RemoveEntityTagsRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveEntityTagsResponse RemoveEntityTagsResponse
     */
    public function removeEntityTagsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new RemoveEntityTagsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tagKeys)) {
            $request->tagKeysShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tagKeys, 'TagKeys', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $body = [];
        if (!Utils::isUnset($request->tagKeysShrink)) {
            $body['TagKeys'] = $request->tagKeysShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RemoveEntityTags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveEntityTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Remove entity tags by given qualified name and tag keys
     *  *
     * @param RemoveEntityTagsRequest $request RemoveEntityTagsRequest
     *
     * @return RemoveEntityTagsResponse RemoveEntityTagsResponse
     */
    public function removeEntityTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeEntityTagsWithOptions($request, $runtime);
    }

    /**
     * @param RemoveProjectMemberFromRoleRequest $request RemoveProjectMemberFromRoleRequest
     * @param RuntimeOptions                     $runtime runtime options for this request RuntimeOptions
     *
     * @return RemoveProjectMemberFromRoleResponse RemoveProjectMemberFromRoleResponse
     */
    public function removeProjectMemberFromRoleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->roleCode)) {
            $query['RoleCode'] = $request->roleCode;
        }
        if (!Utils::isUnset($request->userId)) {
            $query['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RemoveProjectMemberFromRole',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RemoveProjectMemberFromRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param RemoveProjectMemberFromRoleRequest $request RemoveProjectMemberFromRoleRequest
     *
     * @return RemoveProjectMemberFromRoleResponse RemoveProjectMemberFromRoleResponse
     */
    public function removeProjectMemberFromRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeProjectMemberFromRoleWithOptions($request, $runtime);
    }

    /**
     * @summary Restarts an instance.
     *  *
     * @param RestartInstanceRequest $request RestartInstanceRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return RestartInstanceResponse RestartInstanceResponse
     */
    public function restartInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RestartInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RestartInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Restarts an instance.
     *  *
     * @param RestartInstanceRequest $request RestartInstanceRequest
     *
     * @return RestartInstanceResponse RestartInstanceResponse
     */
    public function restartInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Resumes a suspended instance.
     *  *
     * @param ResumeInstanceRequest $request ResumeInstanceRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return ResumeInstanceResponse ResumeInstanceResponse
     */
    public function resumeInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'ResumeInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ResumeInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Resumes a suspended instance.
     *  *
     * @param ResumeInstanceRequest $request ResumeInstanceRequest
     *
     * @return ResumeInstanceResponse ResumeInstanceResponse
     */
    public function resumeInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resumeInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary The ID of the region where the MaxCompute project that contains the destination fields resides. For example, the ID of the China (Shanghai) region is cn-shanghai, and that of the China (Zhangjiakou) region is cn-zhangjiakou. The system automatically determines the value of this parameter based on the endpoint used to call the operation.
     *  *
     * @param RevokeColumnPermissionRequest $request RevokeColumnPermissionRequest
     * @param RuntimeOptions                $runtime runtime options for this request RuntimeOptions
     *
     * @return RevokeColumnPermissionResponse RevokeColumnPermissionResponse
     */
    public function revokeColumnPermissionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->columns)) {
            $query['Columns'] = $request->columns;
        }
        if (!Utils::isUnset($request->maxComputeProjectName)) {
            $query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }
        if (!Utils::isUnset($request->revokeUserId)) {
            $query['RevokeUserId'] = $request->revokeUserId;
        }
        if (!Utils::isUnset($request->revokeUserName)) {
            $query['RevokeUserName'] = $request->revokeUserName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->workspaceId)) {
            $query['WorkspaceId'] = $request->workspaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RevokeColumnPermission',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RevokeColumnPermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The ID of the region where the MaxCompute project that contains the destination fields resides. For example, the ID of the China (Shanghai) region is cn-shanghai, and that of the China (Zhangjiakou) region is cn-zhangjiakou. The system automatically determines the value of this parameter based on the endpoint used to call the operation.
     *  *
     * @param RevokeColumnPermissionRequest $request RevokeColumnPermissionRequest
     *
     * @return RevokeColumnPermissionResponse RevokeColumnPermissionResponse
     */
    public function revokeColumnPermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeColumnPermissionWithOptions($request, $runtime);
    }

    /**
     * @param RevokeTablePermissionRequest $request RevokeTablePermissionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return RevokeTablePermissionResponse RevokeTablePermissionResponse
     */
    public function revokeTablePermissionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->actions)) {
            $query['Actions'] = $request->actions;
        }
        if (!Utils::isUnset($request->maxComputeProjectName)) {
            $query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }
        if (!Utils::isUnset($request->revokeUserId)) {
            $query['RevokeUserId'] = $request->revokeUserId;
        }
        if (!Utils::isUnset($request->revokeUserName)) {
            $query['RevokeUserName'] = $request->revokeUserName;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->workspaceId)) {
            $query['WorkspaceId'] = $request->workspaceId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'RevokeTablePermission',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RevokeTablePermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param RevokeTablePermissionRequest $request RevokeTablePermissionRequest
     *
     * @return RevokeTablePermissionResponse RevokeTablePermissionResponse
     */
    public function revokeTablePermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeTablePermissionWithOptions($request, $runtime);
    }

    /**
     * @description For more information about data backfill, see [Backfill data](https://help.aliyun.com/document_detail/137937.html).
     *  *
     * @param RunCycleDagNodesRequest $request RunCycleDagNodesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return RunCycleDagNodesResponse RunCycleDagNodesResponse
     */
    public function runCycleDagNodesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertNoticeType)) {
            $body['AlertNoticeType'] = $request->alertNoticeType;
        }
        if (!Utils::isUnset($request->alertType)) {
            $body['AlertType'] = $request->alertType;
        }
        if (!Utils::isUnset($request->bizBeginTime)) {
            $body['BizBeginTime'] = $request->bizBeginTime;
        }
        if (!Utils::isUnset($request->bizEndTime)) {
            $body['BizEndTime'] = $request->bizEndTime;
        }
        if (!Utils::isUnset($request->concurrentRuns)) {
            $body['ConcurrentRuns'] = $request->concurrentRuns;
        }
        if (!Utils::isUnset($request->endBizDate)) {
            $body['EndBizDate'] = $request->endBizDate;
        }
        if (!Utils::isUnset($request->excludeNodeIds)) {
            $body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }
        if (!Utils::isUnset($request->includeNodeIds)) {
            $body['IncludeNodeIds'] = $request->includeNodeIds;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nodeParams)) {
            $body['NodeParams'] = $request->nodeParams;
        }
        if (!Utils::isUnset($request->parallelism)) {
            $body['Parallelism'] = $request->parallelism;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->rootNodeId)) {
            $body['RootNodeId'] = $request->rootNodeId;
        }
        if (!Utils::isUnset($request->startBizDate)) {
            $body['StartBizDate'] = $request->startBizDate;
        }
        if (!Utils::isUnset($request->startFutureInstanceImmediately)) {
            $body['StartFutureInstanceImmediately'] = $request->startFutureInstanceImmediately;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RunCycleDagNodes',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RunCycleDagNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description For more information about data backfill, see [Backfill data](https://help.aliyun.com/document_detail/137937.html).
     *  *
     * @param RunCycleDagNodesRequest $request RunCycleDagNodesRequest
     *
     * @return RunCycleDagNodesResponse RunCycleDagNodesResponse
     */
    public function runCycleDagNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runCycleDagNodesWithOptions($request, $runtime);
    }

    /**
     * @summary The region ID. For example, the ID of the China (Shanghai) region is cn-shanghai, and that of the China (Zhangjiakou) region is cn-zhangjiakou. The system automatically determines the value of this parameter based on the endpoint used to call the operation.
     *  *
     * @param RunManualDagNodesRequest $request RunManualDagNodesRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return RunManualDagNodesResponse RunManualDagNodesResponse
     */
    public function runManualDagNodesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->dagParameters)) {
            $body['DagParameters'] = $request->dagParameters;
        }
        if (!Utils::isUnset($request->endBizDate)) {
            $body['EndBizDate'] = $request->endBizDate;
        }
        if (!Utils::isUnset($request->excludeNodeIds)) {
            $body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }
        if (!Utils::isUnset($request->flowName)) {
            $body['FlowName'] = $request->flowName;
        }
        if (!Utils::isUnset($request->includeNodeIds)) {
            $body['IncludeNodeIds'] = $request->includeNodeIds;
        }
        if (!Utils::isUnset($request->nodeParameters)) {
            $body['NodeParameters'] = $request->nodeParameters;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->startBizDate)) {
            $body['StartBizDate'] = $request->startBizDate;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RunManualDagNodes',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RunManualDagNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The region ID. For example, the ID of the China (Shanghai) region is cn-shanghai, and that of the China (Zhangjiakou) region is cn-zhangjiakou. The system automatically determines the value of this parameter based on the endpoint used to call the operation.
     *  *
     * @param RunManualDagNodesRequest $request RunManualDagNodesRequest
     *
     * @return RunManualDagNodesResponse RunManualDagNodesResponse
     */
    public function runManualDagNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runManualDagNodesWithOptions($request, $runtime);
    }

    /**
     * @param RunSmokeTestRequest $request RunSmokeTestRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return RunSmokeTestResponse RunSmokeTestResponse
     */
    public function runSmokeTestWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->bizdate)) {
            $body['Bizdate'] = $request->bizdate;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->nodeParams)) {
            $body['NodeParams'] = $request->nodeParams;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RunSmokeTest',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RunSmokeTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param RunSmokeTestRequest $request RunSmokeTestRequest
     *
     * @return RunSmokeTestResponse RunSmokeTestResponse
     */
    public function runSmokeTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runSmokeTestWithOptions($request, $runtime);
    }

    /**
     * @param RunTriggerNodeRequest $request RunTriggerNodeRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return RunTriggerNodeResponse RunTriggerNodeResponse
     */
    public function runTriggerNodeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->appId)) {
            $body['AppId'] = $request->appId;
        }
        if (!Utils::isUnset($request->bizDate)) {
            $body['BizDate'] = $request->bizDate;
        }
        if (!Utils::isUnset($request->cycleTime)) {
            $body['CycleTime'] = $request->cycleTime;
        }
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'RunTriggerNode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return RunTriggerNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param RunTriggerNodeRequest $request RunTriggerNodeRequest
     *
     * @return RunTriggerNodeResponse RunTriggerNodeResponse
     */
    public function runTriggerNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runTriggerNodeWithOptions($request, $runtime);
    }

    /**
     * @summary api
     *  *
     * @param SaveDataServiceApiTestResultRequest $request SaveDataServiceApiTestResultRequest
     * @param RuntimeOptions                      $runtime runtime options for this request RuntimeOptions
     *
     * @return SaveDataServiceApiTestResultResponse SaveDataServiceApiTestResultResponse
     */
    public function saveDataServiceApiTestResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->autoGenerate)) {
            $body['AutoGenerate'] = $request->autoGenerate;
        }
        if (!Utils::isUnset($request->failResultSample)) {
            $body['FailResultSample'] = $request->failResultSample;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->resultSample)) {
            $body['ResultSample'] = $request->resultSample;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SaveDataServiceApiTestResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SaveDataServiceApiTestResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary api
     *  *
     * @param SaveDataServiceApiTestResultRequest $request SaveDataServiceApiTestResultRequest
     *
     * @return SaveDataServiceApiTestResultResponse SaveDataServiceApiTestResultResponse
     */
    public function saveDataServiceApiTestResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveDataServiceApiTestResultWithOptions($request, $runtime);
    }

    /**
     * @param ScanSensitiveDataRequest $request ScanSensitiveDataRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return ScanSensitiveDataResponse ScanSensitiveDataResponse
     */
    public function scanSensitiveDataWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = OpenApiUtilClient::query(Utils::toMap($request));
        $req   = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'ScanSensitiveData',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'GET',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return ScanSensitiveDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param ScanSensitiveDataRequest $request ScanSensitiveDataRequest
     *
     * @return ScanSensitiveDataResponse ScanSensitiveDataResponse
     */
    public function scanSensitiveData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->scanSensitiveDataWithOptions($request, $runtime);
    }

    /**
     * @summary For more information about the example on how to use the SearchMetaTables operation, see [Examples of DataWorks API operations](https://developer.aliyun.com/article/780879?groupCode=dataworks).
     *  *
     * @description The operation that you want to perform. Set the value to **SearchMetaTables**.
     *  *
     * @param SearchMetaTablesRequest $request SearchMetaTablesRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return SearchMetaTablesResponse SearchMetaTablesResponse
     */
    public function searchMetaTablesWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->clusterId)) {
            $query['ClusterId'] = $request->clusterId;
        }
        if (!Utils::isUnset($request->dataSourceType)) {
            $query['DataSourceType'] = $request->dataSourceType;
        }
        if (!Utils::isUnset($request->entityType)) {
            $query['EntityType'] = $request->entityType;
        }
        if (!Utils::isUnset($request->keyword)) {
            $query['Keyword'] = $request->keyword;
        }
        if (!Utils::isUnset($request->pageNumber)) {
            $query['PageNumber'] = $request->pageNumber;
        }
        if (!Utils::isUnset($request->pageSize)) {
            $query['PageSize'] = $request->pageSize;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SearchMetaTables',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SearchMetaTablesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary For more information about the example on how to use the SearchMetaTables operation, see [Examples of DataWorks API operations](https://developer.aliyun.com/article/780879?groupCode=dataworks).
     *  *
     * @description The operation that you want to perform. Set the value to **SearchMetaTables**.
     *  *
     * @param SearchMetaTablesRequest $request SearchMetaTablesRequest
     *
     * @return SearchMetaTablesResponse SearchMetaTablesResponse
     */
    public function searchMetaTables($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->searchMetaTablesWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI SearchNodesByOutput is deprecated
     *  *
     * Deprecated
     *
     * @param SearchNodesByOutputRequest $request SearchNodesByOutputRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return SearchNodesByOutputResponse SearchNodesByOutputResponse
     */
    public function searchNodesByOutputWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->outputs)) {
            $body['Outputs'] = $request->outputs;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SearchNodesByOutput',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SearchNodesByOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI SearchNodesByOutput is deprecated
     *  *
     * Deprecated
     *
     * @param SearchNodesByOutputRequest $request SearchNodesByOutputRequest
     *
     * @return SearchNodesByOutputResponse SearchNodesByOutputResponse
     */
    public function searchNodesByOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->searchNodesByOutputWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI SetDataSourceShare is deprecated
     *  *
     * Deprecated
     *
     * @param SetDataSourceShareRequest $request SetDataSourceShareRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return SetDataSourceShareResponse SetDataSourceShareResponse
     */
    public function setDataSourceShareWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->datasourceName)) {
            $query['DatasourceName'] = $request->datasourceName;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectPermissions)) {
            $query['ProjectPermissions'] = $request->projectPermissions;
        }
        if (!Utils::isUnset($request->userPermissions)) {
            $query['UserPermissions'] = $request->userPermissions;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'SetDataSourceShare',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetDataSourceShareResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI SetDataSourceShare is deprecated
     *  *
     * Deprecated
     *
     * @param SetDataSourceShareRequest $request SetDataSourceShareRequest
     *
     * @return SetDataSourceShareResponse SetDataSourceShareResponse
     */
    public function setDataSourceShare($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setDataSourceShareWithOptions($request, $runtime);
    }

    /**
     * @summary Set entity tags by given qualified name and tags
     *  *
     * @param SetEntityTagsRequest $tmpReq  SetEntityTagsRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return SetEntityTagsResponse SetEntityTagsResponse
     */
    public function setEntityTagsWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new SetEntityTagsShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->tags)) {
            $request->tagsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }
        $query = [];
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $body = [];
        if (!Utils::isUnset($request->tagsShrink)) {
            $body['Tags'] = $request->tagsShrink;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SetEntityTags',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetEntityTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Set entity tags by given qualified name and tags
     *  *
     * @param SetEntityTagsRequest $request SetEntityTagsRequest
     *
     * @return SetEntityTagsResponse SetEntityTagsResponse
     */
    public function setEntityTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setEntityTagsWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **SetSuccessInstance**.
     *  *
     * @param SetSuccessInstanceRequest $request SetSuccessInstanceRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return SetSuccessInstanceResponse SetSuccessInstanceResponse
     */
    public function setSuccessInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SetSuccessInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SetSuccessInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **SetSuccessInstance**.
     *  *
     * @param SetSuccessInstanceRequest $request SetSuccessInstanceRequest
     *
     * @return SetSuccessInstanceResponse SetSuccessInstanceResponse
     */
    public function setSuccessInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSuccessInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param StartDIJobRequest $tmpReq  StartDIJobRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return StartDIJobResponse StartDIJobResponse
     */
    public function startDIJobWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new StartDIJobShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->realtimeStartSettings)) {
            $request->realtimeStartSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->realtimeStartSettings, 'RealtimeStartSettings', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->forceToRerun)) {
            $body['ForceToRerun'] = $request->forceToRerun;
        }
        if (!Utils::isUnset($request->realtimeStartSettingsShrink)) {
            $body['RealtimeStartSettings'] = $request->realtimeStartSettingsShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'StartDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param StartDIJobRequest $request StartDIJobRequest
     *
     * @return StartDIJobResponse StartDIJobResponse
     */
    public function startDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param StartDISyncInstanceRequest $request StartDISyncInstanceRequest
     * @param RuntimeOptions             $runtime runtime options for this request RuntimeOptions
     *
     * @return StartDISyncInstanceResponse StartDISyncInstanceResponse
     */
    public function startDISyncInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->startParam)) {
            $query['StartParam'] = $request->startParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StartDISyncInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartDISyncInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param StartDISyncInstanceRequest $request StartDISyncInstanceRequest
     *
     * @return StartDISyncInstanceResponse StartDISyncInstanceResponse
     */
    public function startDISyncInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDISyncInstanceWithOptions($request, $runtime);
    }

    /**
     * @param StartMigrationRequest $request StartMigrationRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return StartMigrationResponse StartMigrationResponse
     */
    public function startMigrationWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->migrationId)) {
            $body['MigrationId'] = $request->migrationId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'StartMigration',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StartMigrationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param StartMigrationRequest $request StartMigrationRequest
     *
     * @return StartMigrationResponse StartMigrationResponse
     */
    public function startMigration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startMigrationWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param StopDIJobRequest $request StopDIJobRequest
     * @param RuntimeOptions   $runtime runtime options for this request RuntimeOptions
     *
     * @return StopDIJobResponse StopDIJobResponse
     */
    public function stopDIJobWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'StopDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StopDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param StopDIJobRequest $request StopDIJobRequest
     *
     * @return StopDIJobResponse StopDIJobResponse
     */
    public function stopDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param StopDISyncInstanceRequest $request StopDISyncInstanceRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return StopDISyncInstanceResponse StopDISyncInstanceResponse
     */
    public function stopDISyncInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'StopDISyncInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StopDISyncInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param StopDISyncInstanceRequest $request StopDISyncInstanceRequest
     *
     * @return StopDISyncInstanceResponse StopDISyncInstanceResponse
     */
    public function stopDISyncInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopDISyncInstanceWithOptions($request, $runtime);
    }

    /**
     * @param StopInstanceRequest $request StopInstanceRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return StopInstanceResponse StopInstanceResponse
     */
    public function stopInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'StopInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return StopInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param StopInstanceRequest $request StopInstanceRequest
     *
     * @return StopInstanceResponse StopInstanceResponse
     */
    public function stopInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary APi
     *  *
     * @param SubmitDataServiceApiRequest $request SubmitDataServiceApiRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return SubmitDataServiceApiResponse SubmitDataServiceApiResponse
     */
    public function submitDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SubmitDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SubmitDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary APi
     *  *
     * @param SubmitDataServiceApiRequest $request SubmitDataServiceApiRequest
     *
     * @return SubmitDataServiceApiResponse SubmitDataServiceApiResponse
     */
    public function submitDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **SubmitFile**.
     *  *
     * @param SubmitFileRequest $request SubmitFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return SubmitFileResponse SubmitFileResponse
     */
    public function submitFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->skipAllDeployFileExtensions)) {
            $body['SkipAllDeployFileExtensions'] = $request->skipAllDeployFileExtensions;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SubmitFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SubmitFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **SubmitFile**.
     *  *
     * @param SubmitFileRequest $request SubmitFileRequest
     *
     * @return SubmitFileResponse SubmitFileResponse
     */
    public function submitFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitFileWithOptions($request, $runtime);
    }

    /**
     * @summary Suspends an instance.
     *  *
     * @param SuspendInstanceRequest $request SuspendInstanceRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return SuspendInstanceResponse SuspendInstanceResponse
     */
    public function suspendInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->instanceId)) {
            $body['InstanceId'] = $request->instanceId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'SuspendInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return SuspendInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Suspends an instance.
     *  *
     * @param SuspendInstanceRequest $request SuspendInstanceRequest
     *
     * @return SuspendInstanceResponse SuspendInstanceResponse
     */
    public function suspendInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->suspendInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **TerminateDISyncInstance**.
     *  *
     * @param TerminateDISyncInstanceRequest $request TerminateDISyncInstanceRequest
     * @param RuntimeOptions                 $runtime runtime options for this request RuntimeOptions
     *
     * @return TerminateDISyncInstanceResponse TerminateDISyncInstanceResponse
     */
    public function terminateDISyncInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'TerminateDISyncInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TerminateDISyncInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **TerminateDISyncInstance**.
     *  *
     * @param TerminateDISyncInstanceRequest $request TerminateDISyncInstanceRequest
     *
     * @return TerminateDISyncInstanceResponse TerminateDISyncInstanceResponse
     */
    public function terminateDISyncInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->terminateDISyncInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary Tests a DataService Studio API in asynchronous mode. You can call the GetDataServiceApiTest operation to query the test result.
     *  *
     * @param TestDataServiceApiRequest $request TestDataServiceApiRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return TestDataServiceApiResponse TestDataServiceApiResponse
     */
    public function testDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->apiId)) {
            $query['ApiId'] = $request->apiId;
        }
        $body = [];
        if (!Utils::isUnset($request->bodyContent)) {
            $body['BodyContent'] = $request->bodyContent;
        }
        if (!Utils::isUnset($request->bodyParams)) {
            $body['BodyParams'] = $request->bodyParams;
        }
        if (!Utils::isUnset($request->headParams)) {
            $body['HeadParams'] = $request->headParams;
        }
        if (!Utils::isUnset($request->pathParams)) {
            $body['PathParams'] = $request->pathParams;
        }
        if (!Utils::isUnset($request->queryParam)) {
            $body['QueryParam'] = $request->queryParam;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'TestDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TestDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Tests a DataService Studio API in asynchronous mode. You can call the GetDataServiceApiTest operation to query the test result.
     *  *
     * @param TestDataServiceApiRequest $request TestDataServiceApiRequest
     *
     * @return TestDataServiceApiResponse TestDataServiceApiResponse
     */
    public function testDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->testDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @param TestNetworkConnectionRequest $request TestNetworkConnectionRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return TestNetworkConnectionResponse TestNetworkConnectionResponse
     */
    public function testNetworkConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->datasourceName)) {
            $query['DatasourceName'] = $request->datasourceName;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->resourceGroup)) {
            $query['ResourceGroup'] = $request->resourceGroup;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'TestNetworkConnection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TestNetworkConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param TestNetworkConnectionRequest $request TestNetworkConnectionRequest
     *
     * @return TestNetworkConnectionResponse TestNetworkConnectionResponse
     */
    public function testNetworkConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->testNetworkConnectionWithOptions($request, $runtime);
    }

    /**
     * @param TopTenElapsedTimeInstanceRequest $request TopTenElapsedTimeInstanceRequest
     * @param RuntimeOptions                   $runtime runtime options for this request RuntimeOptions
     *
     * @return TopTenElapsedTimeInstanceResponse TopTenElapsedTimeInstanceResponse
     */
    public function topTenElapsedTimeInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'TopTenElapsedTimeInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TopTenElapsedTimeInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param TopTenElapsedTimeInstanceRequest $request TopTenElapsedTimeInstanceRequest
     *
     * @return TopTenElapsedTimeInstanceResponse TopTenElapsedTimeInstanceResponse
     */
    public function topTenElapsedTimeInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->topTenElapsedTimeInstanceWithOptions($request, $runtime);
    }

    /**
     * @param TopTenErrorTimesInstanceRequest $request TopTenErrorTimesInstanceRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return TopTenErrorTimesInstanceResponse TopTenErrorTimesInstanceResponse
     */
    public function topTenErrorTimesInstanceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'TopTenErrorTimesInstance',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return TopTenErrorTimesInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param TopTenErrorTimesInstanceRequest $request TopTenErrorTimesInstanceRequest
     *
     * @return TopTenErrorTimesInstanceResponse TopTenErrorTimesInstanceResponse
     */
    public function topTenErrorTimesInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->topTenErrorTimesInstanceWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param UmountDirectoryRequest $request UmountDirectoryRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return UmountDirectoryResponse UmountDirectoryResponse
     */
    public function umountDirectoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->targetId)) {
            $body['TargetId'] = $request->targetId;
        }
        if (!Utils::isUnset($request->targetType)) {
            $body['TargetType'] = $request->targetType;
        }
        if (!Utils::isUnset($request->targetUserId)) {
            $body['TargetUserId'] = $request->targetUserId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UmountDirectory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UmountDirectoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param UmountDirectoryRequest $request UmountDirectoryRequest
     *
     * @return UmountDirectoryResponse UmountDirectoryResponse
     */
    public function umountDirectory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->umountDirectoryWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param UpdateBaselineRequest $tmpReq  UpdateBaselineRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateBaselineResponse UpdateBaselineResponse
     */
    public function updateBaselineWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateBaselineShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->alertSettings)) {
            $request->alertSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->alertSettings, 'AlertSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->overtimeSettings)) {
            $request->overtimeSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->overtimeSettings, 'OvertimeSettings', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->alertEnabled)) {
            $body['AlertEnabled'] = $request->alertEnabled;
        }
        if (!Utils::isUnset($request->alertMarginThreshold)) {
            $body['AlertMarginThreshold'] = $request->alertMarginThreshold;
        }
        if (!Utils::isUnset($request->alertSettingsShrink)) {
            $body['AlertSettings'] = $request->alertSettingsShrink;
        }
        if (!Utils::isUnset($request->baselineId)) {
            $body['BaselineId'] = $request->baselineId;
        }
        if (!Utils::isUnset($request->baselineName)) {
            $body['BaselineName'] = $request->baselineName;
        }
        if (!Utils::isUnset($request->baselineType)) {
            $body['BaselineType'] = $request->baselineType;
        }
        if (!Utils::isUnset($request->enabled)) {
            $body['Enabled'] = $request->enabled;
        }
        if (!Utils::isUnset($request->nodeIds)) {
            $body['NodeIds'] = $request->nodeIds;
        }
        if (!Utils::isUnset($request->overtimeSettingsShrink)) {
            $body['OvertimeSettings'] = $request->overtimeSettingsShrink;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->priority)) {
            $body['Priority'] = $request->priority;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->removeNodeIds)) {
            $body['RemoveNodeIds'] = $request->removeNodeIds;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateBaseline',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param UpdateBaselineRequest $request UpdateBaselineRequest
     *
     * @return UpdateBaselineResponse UpdateBaselineResponse
     */
    public function updateBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBaselineWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a workflow.
     *  *
     * @param UpdateBusinessRequest $request UpdateBusinessRequest
     * @param RuntimeOptions        $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateBusinessResponse UpdateBusinessResponse
     */
    public function updateBusinessWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->businessId)) {
            $body['BusinessId'] = $request->businessId;
        }
        if (!Utils::isUnset($request->businessName)) {
            $body['BusinessName'] = $request->businessName;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateBusiness',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a workflow.
     *  *
     * @param UpdateBusinessRequest $request UpdateBusinessRequest
     *
     * @return UpdateBusinessResponse UpdateBusinessResponse
     */
    public function updateBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBusinessWithOptions($request, $runtime);
    }

    /**
     * @deprecated OpenAPI UpdateConnection is deprecated
     *  *
     * Deprecated
     *
     * @param UpdateConnectionRequest $request UpdateConnectionRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateConnectionResponse UpdateConnectionResponse
     */
    public function updateConnectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->connectionId)) {
            $query['ConnectionId'] = $request->connectionId;
        }
        if (!Utils::isUnset($request->content)) {
            $query['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateConnection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'PUT',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @deprecated OpenAPI UpdateConnection is deprecated
     *  *
     * Deprecated
     *
     * @param UpdateConnectionRequest $request UpdateConnectionRequest
     *
     * @return UpdateConnectionResponse UpdateConnectionResponse
     */
    public function updateConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateConnectionWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param UpdateDIAlarmRuleRequest $tmpReq  UpdateDIAlarmRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDIAlarmRuleResponse UpdateDIAlarmRuleResponse
     */
    public function updateDIAlarmRuleWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateDIAlarmRuleShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->notificationSettings)) {
            $request->notificationSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->notificationSettings, 'NotificationSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->triggerConditions)) {
            $request->triggerConditionsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->triggerConditions, 'TriggerConditions', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->DIAlarmRuleId)) {
            $body['DIAlarmRuleId'] = $request->DIAlarmRuleId;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->enabled)) {
            $body['Enabled'] = $request->enabled;
        }
        if (!Utils::isUnset($request->metricType)) {
            $body['MetricType'] = $request->metricType;
        }
        if (!Utils::isUnset($request->notificationSettingsShrink)) {
            $body['NotificationSettings'] = $request->notificationSettingsShrink;
        }
        if (!Utils::isUnset($request->triggerConditionsShrink)) {
            $body['TriggerConditions'] = $request->triggerConditionsShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateDIAlarmRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param UpdateDIAlarmRuleRequest $request UpdateDIAlarmRuleRequest
     *
     * @return UpdateDIAlarmRuleResponse UpdateDIAlarmRuleResponse
     */
    public function updateDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param UpdateDIJobRequest $tmpReq  UpdateDIJobRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDIJobResponse UpdateDIJobResponse
     */
    public function updateDIJobWithOptions($tmpReq, $runtime)
    {
        Utils::validateModel($tmpReq);
        $request = new UpdateDIJobShrinkRequest([]);
        OpenApiUtilClient::convert($tmpReq, $request);
        if (!Utils::isUnset($tmpReq->jobSettings)) {
            $request->jobSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->jobSettings, 'JobSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->resourceSettings)) {
            $request->resourceSettingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->resourceSettings, 'ResourceSettings', 'json');
        }
        if (!Utils::isUnset($tmpReq->tableMappings)) {
            $request->tableMappingsShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->tableMappings, 'TableMappings', 'json');
        }
        if (!Utils::isUnset($tmpReq->transformationRules)) {
            $request->transformationRulesShrink = OpenApiUtilClient::arrayToStringWithSpecifiedStyle($tmpReq->transformationRules, 'TransformationRules', 'json');
        }
        $body = [];
        if (!Utils::isUnset($request->DIJobId)) {
            $body['DIJobId'] = $request->DIJobId;
        }
        if (!Utils::isUnset($request->description)) {
            $body['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->jobSettingsShrink)) {
            $body['JobSettings'] = $request->jobSettingsShrink;
        }
        if (!Utils::isUnset($request->resourceSettingsShrink)) {
            $body['ResourceSettings'] = $request->resourceSettingsShrink;
        }
        if (!Utils::isUnset($request->tableMappingsShrink)) {
            $body['TableMappings'] = $request->tableMappingsShrink;
        }
        if (!Utils::isUnset($request->transformationRulesShrink)) {
            $body['TransformationRules'] = $request->transformationRulesShrink;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateDIJob',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param UpdateDIJobRequest $request UpdateDIJobRequest
     *
     * @return UpdateDIJobResponse UpdateDIJobResponse
     */
    public function updateDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDIJobWithOptions($request, $runtime);
    }

    /**
     * @summary DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization nodes in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *  *
     * @description The operation that you want to perform. Set the value to **UpdateDIProjectConfig**.
     *  *
     * @param UpdateDIProjectConfigRequest $request UpdateDIProjectConfigRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDIProjectConfigResponse UpdateDIProjectConfigResponse
     */
    public function updateDIProjectConfigWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->destinationType)) {
            $query['DestinationType'] = $request->destinationType;
        }
        if (!Utils::isUnset($request->projectConfig)) {
            $query['ProjectConfig'] = $request->projectConfig;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->sourceType)) {
            $query['SourceType'] = $request->sourceType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateDIProjectConfig',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDIProjectConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization nodes in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *  *
     * @description The operation that you want to perform. Set the value to **UpdateDIProjectConfig**.
     *  *
     * @param UpdateDIProjectConfigRequest $request UpdateDIProjectConfigRequest
     *
     * @return UpdateDIProjectConfigResponse UpdateDIProjectConfigResponse
     */
    public function updateDIProjectConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDIProjectConfigWithOptions($request, $runtime);
    }

    /**
     * @param UpdateDISyncTaskRequest $request UpdateDISyncTaskRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDISyncTaskResponse UpdateDISyncTaskResponse
     */
    public function updateDISyncTaskWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->fileId)) {
            $query['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->taskContent)) {
            $query['TaskContent'] = $request->taskContent;
        }
        if (!Utils::isUnset($request->taskParam)) {
            $query['TaskParam'] = $request->taskParam;
        }
        if (!Utils::isUnset($request->taskType)) {
            $query['TaskType'] = $request->taskType;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateDISyncTask',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateDISyncTaskRequest $request UpdateDISyncTaskRequest
     *
     * @return UpdateDISyncTaskResponse UpdateDISyncTaskResponse
     */
    public function updateDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the information about an API in the development state in DataService Studio.
     *  *
     * @param UpdateDataServiceApiRequest $request UpdateDataServiceApiRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDataServiceApiResponse UpdateDataServiceApiResponse
     */
    public function updateDataServiceApiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->apiDescription)) {
            $body['ApiDescription'] = $request->apiDescription;
        }
        if (!Utils::isUnset($request->apiId)) {
            $body['ApiId'] = $request->apiId;
        }
        if (!Utils::isUnset($request->apiPath)) {
            $body['ApiPath'] = $request->apiPath;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->protocols)) {
            $body['Protocols'] = $request->protocols;
        }
        if (!Utils::isUnset($request->registrationDetails)) {
            $body['RegistrationDetails'] = $request->registrationDetails;
        }
        if (!Utils::isUnset($request->requestMethod)) {
            $body['RequestMethod'] = $request->requestMethod;
        }
        if (!Utils::isUnset($request->resourceGroupId)) {
            $body['ResourceGroupId'] = $request->resourceGroupId;
        }
        if (!Utils::isUnset($request->responseContentType)) {
            $body['ResponseContentType'] = $request->responseContentType;
        }
        if (!Utils::isUnset($request->scriptDetails)) {
            $body['ScriptDetails'] = $request->scriptDetails;
        }
        if (!Utils::isUnset($request->tenantId)) {
            $body['TenantId'] = $request->tenantId;
        }
        if (!Utils::isUnset($request->timeout)) {
            $body['Timeout'] = $request->timeout;
        }
        if (!Utils::isUnset($request->visibleRange)) {
            $body['VisibleRange'] = $request->visibleRange;
        }
        if (!Utils::isUnset($request->wizardDetails)) {
            $body['WizardDetails'] = $request->wizardDetails;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateDataServiceApi',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the information about an API in the development state in DataService Studio.
     *  *
     * @param UpdateDataServiceApiRequest $request UpdateDataServiceApiRequest
     *
     * @return UpdateDataServiceApiResponse UpdateDataServiceApiResponse
     */
    public function updateDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * @param UpdateDataSourceRequest $request UpdateDataSourceRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateDataSourceResponse UpdateDataSourceResponse
     */
    public function updateDataSourceWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->content)) {
            $query['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->dataSourceId)) {
            $query['DataSourceId'] = $request->dataSourceId;
        }
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->status)) {
            $query['Status'] = $request->status;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateDataSource',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'PUT',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateDataSourceRequest $request UpdateDataSourceRequest
     *
     * @return UpdateDataSourceResponse UpdateDataSourceResponse
     */
    public function updateDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDataSourceWithOptions($request, $runtime);
    }

    /**
     * @description When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
     *  *
     * @param UpdateFileRequest $request UpdateFileRequest
     * @param RuntimeOptions    $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFileResponse UpdateFileResponse
     */
    public function updateFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->advancedSettings)) {
            $body['AdvancedSettings'] = $request->advancedSettings;
        }
        if (!Utils::isUnset($request->autoParsing)) {
            $body['AutoParsing'] = $request->autoParsing;
        }
        if (!Utils::isUnset($request->autoRerunIntervalMillis)) {
            $body['AutoRerunIntervalMillis'] = $request->autoRerunIntervalMillis;
        }
        if (!Utils::isUnset($request->autoRerunTimes)) {
            $body['AutoRerunTimes'] = $request->autoRerunTimes;
        }
        if (!Utils::isUnset($request->connectionName)) {
            $body['ConnectionName'] = $request->connectionName;
        }
        if (!Utils::isUnset($request->content)) {
            $body['Content'] = $request->content;
        }
        if (!Utils::isUnset($request->cronExpress)) {
            $body['CronExpress'] = $request->cronExpress;
        }
        if (!Utils::isUnset($request->cycleType)) {
            $body['CycleType'] = $request->cycleType;
        }
        if (!Utils::isUnset($request->dependentNodeIdList)) {
            $body['DependentNodeIdList'] = $request->dependentNodeIdList;
        }
        if (!Utils::isUnset($request->dependentType)) {
            $body['DependentType'] = $request->dependentType;
        }
        if (!Utils::isUnset($request->endEffectDate)) {
            $body['EndEffectDate'] = $request->endEffectDate;
        }
        if (!Utils::isUnset($request->fileDescription)) {
            $body['FileDescription'] = $request->fileDescription;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->fileName)) {
            $body['FileName'] = $request->fileName;
        }
        if (!Utils::isUnset($request->ignoreParentSkipRunningProperty)) {
            $body['IgnoreParentSkipRunningProperty'] = $request->ignoreParentSkipRunningProperty;
        }
        if (!Utils::isUnset($request->inputList)) {
            $body['InputList'] = $request->inputList;
        }
        if (!Utils::isUnset($request->inputParameters)) {
            $body['InputParameters'] = $request->inputParameters;
        }
        if (!Utils::isUnset($request->outputList)) {
            $body['OutputList'] = $request->outputList;
        }
        if (!Utils::isUnset($request->outputParameters)) {
            $body['OutputParameters'] = $request->outputParameters;
        }
        if (!Utils::isUnset($request->owner)) {
            $body['Owner'] = $request->owner;
        }
        if (!Utils::isUnset($request->paraValue)) {
            $body['ParaValue'] = $request->paraValue;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->rerunMode)) {
            $body['RerunMode'] = $request->rerunMode;
        }
        if (!Utils::isUnset($request->resourceGroupIdentifier)) {
            $body['ResourceGroupIdentifier'] = $request->resourceGroupIdentifier;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        if (!Utils::isUnset($request->startEffectDate)) {
            $body['StartEffectDate'] = $request->startEffectDate;
        }
        if (!Utils::isUnset($request->startImmediately)) {
            $body['StartImmediately'] = $request->startImmediately;
        }
        if (!Utils::isUnset($request->stop)) {
            $body['Stop'] = $request->stop;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @description When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
     *  *
     * @param UpdateFileRequest $request UpdateFileRequest
     *
     * @return UpdateFileResponse UpdateFileResponse
     */
    public function updateFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileWithOptions($request, $runtime);
    }

    /**
     * @param UpdateFolderRequest $request UpdateFolderRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateFolderResponse UpdateFolderResponse
     */
    public function updateFolderWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->folderId)) {
            $body['FolderId'] = $request->folderId;
        }
        if (!Utils::isUnset($request->folderName)) {
            $body['FolderName'] = $request->folderName;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateFolder',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateFolderRequest $request UpdateFolderRequest
     *
     * @return UpdateFolderResponse UpdateFolderResponse
     */
    public function updateFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFolderWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param UpdateIDEEventResultRequest $request UpdateIDEEventResultRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateIDEEventResultResponse UpdateIDEEventResultResponse
     */
    public function updateIDEEventResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->checkResult)) {
            $body['CheckResult'] = $request->checkResult;
        }
        if (!Utils::isUnset($request->checkResultTip)) {
            $body['CheckResultTip'] = $request->checkResultTip;
        }
        if (!Utils::isUnset($request->extensionCode)) {
            $body['ExtensionCode'] = $request->extensionCode;
        }
        if (!Utils::isUnset($request->messageId)) {
            $body['MessageId'] = $request->messageId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateIDEEventResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateIDEEventResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform.
     *  *
     * @param UpdateIDEEventResultRequest $request UpdateIDEEventResultRequest
     *
     * @return UpdateIDEEventResultResponse UpdateIDEEventResultResponse
     */
    public function updateIDEEventResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateIDEEventResultWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a category.
     *  *
     * @param UpdateMetaCategoryRequest $request UpdateMetaCategoryRequest
     * @param RuntimeOptions            $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMetaCategoryResponse UpdateMetaCategoryResponse
     */
    public function updateMetaCategoryWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->categoryId)) {
            $body['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->name)) {
            $body['Name'] = $request->name;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateMetaCategory',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a category.
     *  *
     * @param UpdateMetaCategoryRequest $request UpdateMetaCategoryRequest
     *
     * @return UpdateMetaCategoryResponse UpdateMetaCategoryResponse
     */
    public function updateMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * @summary Updates a collection.
     *  *
     * @description Only the name and comment of a collection can be updated.
     *  *
     * @param UpdateMetaCollectionRequest $request UpdateMetaCollectionRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMetaCollectionResponse UpdateMetaCollectionResponse
     */
    public function updateMetaCollectionWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->comment)) {
            $query['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->qualifiedName)) {
            $query['QualifiedName'] = $request->qualifiedName;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateMetaCollection',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMetaCollectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates a collection.
     *  *
     * @description Only the name and comment of a collection can be updated.
     *  *
     * @param UpdateMetaCollectionRequest $request UpdateMetaCollectionRequest
     *
     * @return UpdateMetaCollectionResponse UpdateMetaCollectionResponse
     */
    public function updateMetaCollection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaCollectionWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the metadata information about a table.
     *  *
     * @param UpdateMetaTableRequest $request UpdateMetaTableRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMetaTableResponse UpdateMetaTableResponse
     */
    public function updateMetaTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->caption)) {
            $query['Caption'] = $request->caption;
        }
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->envType)) {
            $query['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->newOwnerId)) {
            $query['NewOwnerId'] = $request->newOwnerId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->visibility)) {
            $query['Visibility'] = $request->visibility;
        }
        $body = [];
        if (!Utils::isUnset($request->addedLabels)) {
            $body['AddedLabels'] = $request->addedLabels;
        }
        if (!Utils::isUnset($request->removedLabels)) {
            $body['RemovedLabels'] = $request->removedLabels;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateMetaTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMetaTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the metadata information about a table.
     *  *
     * @param UpdateMetaTableRequest $request UpdateMetaTableRequest
     *
     * @return UpdateMetaTableResponse UpdateMetaTableResponse
     */
    public function updateMetaTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaTableWithOptions($request, $runtime);
    }

    /**
     * @summary Updates the instructions on how to use a metatable. If no instruction on how to use the metatable is available, the instructions that are specified by calling this operation are added.
     *  *
     * @param UpdateMetaTableIntroWikiRequest $request UpdateMetaTableIntroWikiRequest
     * @param RuntimeOptions                  $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateMetaTableIntroWikiResponse UpdateMetaTableIntroWikiResponse
     */
    public function updateMetaTableIntroWikiWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $body = [];
        if (!Utils::isUnset($request->content)) {
            $body['Content'] = $request->content;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateMetaTableIntroWiki',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateMetaTableIntroWikiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary Updates the instructions on how to use a metatable. If no instruction on how to use the metatable is available, the instructions that are specified by calling this operation are added.
     *  *
     * @param UpdateMetaTableIntroWikiRequest $request UpdateMetaTableIntroWikiRequest
     *
     * @return UpdateMetaTableIntroWikiResponse UpdateMetaTableIntroWikiResponse
     */
    public function updateMetaTableIntroWiki($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaTableIntroWikiWithOptions($request, $runtime);
    }

    /**
     * @param UpdateNodeOwnerRequest $request UpdateNodeOwnerRequest
     * @param RuntimeOptions         $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateNodeOwnerResponse UpdateNodeOwnerResponse
     */
    public function updateNodeOwnerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->userId)) {
            $body['UserId'] = $request->userId;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateNodeOwner',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateNodeOwnerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateNodeOwnerRequest $request UpdateNodeOwnerRequest
     *
     * @return UpdateNodeOwnerResponse UpdateNodeOwnerResponse
     */
    public function updateNodeOwner($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNodeOwnerWithOptions($request, $runtime);
    }

    /**
     * @param UpdateNodeRunModeRequest $request UpdateNodeRunModeRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateNodeRunModeResponse UpdateNodeRunModeResponse
     */
    public function updateNodeRunModeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->nodeId)) {
            $body['NodeId'] = $request->nodeId;
        }
        if (!Utils::isUnset($request->projectEnv)) {
            $body['ProjectEnv'] = $request->projectEnv;
        }
        if (!Utils::isUnset($request->schedulerType)) {
            $body['SchedulerType'] = $request->schedulerType;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateNodeRunMode',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateNodeRunModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateNodeRunModeRequest $request UpdateNodeRunModeRequest
     *
     * @return UpdateNodeRunModeResponse UpdateNodeRunModeResponse
     */
    public function updateNodeRunMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNodeRunModeWithOptions($request, $runtime);
    }

    /**
     * @param UpdateQualityFollowerRequest $request UpdateQualityFollowerRequest
     * @param RuntimeOptions               $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateQualityFollowerResponse UpdateQualityFollowerResponse
     */
    public function updateQualityFollowerWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alarmMode)) {
            $body['AlarmMode'] = $request->alarmMode;
        }
        if (!Utils::isUnset($request->follower)) {
            $body['Follower'] = $request->follower;
        }
        if (!Utils::isUnset($request->followerId)) {
            $body['FollowerId'] = $request->followerId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateQualityFollower',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateQualityFollowerRequest $request UpdateQualityFollowerRequest
     *
     * @return UpdateQualityFollowerResponse UpdateQualityFollowerResponse
     */
    public function updateQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * @param UpdateQualityRuleRequest $request UpdateQualityRuleRequest
     * @param RuntimeOptions           $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateQualityRuleResponse UpdateQualityRuleResponse
     */
    public function updateQualityRuleWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->blockType)) {
            $body['BlockType'] = $request->blockType;
        }
        if (!Utils::isUnset($request->checker)) {
            $body['Checker'] = $request->checker;
        }
        if (!Utils::isUnset($request->comment)) {
            $body['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->criticalThreshold)) {
            $body['CriticalThreshold'] = $request->criticalThreshold;
        }
        if (!Utils::isUnset($request->entityId)) {
            $body['EntityId'] = $request->entityId;
        }
        if (!Utils::isUnset($request->expectValue)) {
            $body['ExpectValue'] = $request->expectValue;
        }
        if (!Utils::isUnset($request->id)) {
            $body['Id'] = $request->id;
        }
        if (!Utils::isUnset($request->methodName)) {
            $body['MethodName'] = $request->methodName;
        }
        if (!Utils::isUnset($request->openSwitch)) {
            $body['OpenSwitch'] = $request->openSwitch;
        }
        if (!Utils::isUnset($request->operator)) {
            $body['Operator'] = $request->operator;
        }
        if (!Utils::isUnset($request->predictType)) {
            $body['PredictType'] = $request->predictType;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectName)) {
            $body['ProjectName'] = $request->projectName;
        }
        if (!Utils::isUnset($request->property)) {
            $body['Property'] = $request->property;
        }
        if (!Utils::isUnset($request->propertyType)) {
            $body['PropertyType'] = $request->propertyType;
        }
        if (!Utils::isUnset($request->ruleName)) {
            $body['RuleName'] = $request->ruleName;
        }
        if (!Utils::isUnset($request->ruleType)) {
            $body['RuleType'] = $request->ruleType;
        }
        if (!Utils::isUnset($request->taskSetting)) {
            $body['TaskSetting'] = $request->taskSetting;
        }
        if (!Utils::isUnset($request->templateId)) {
            $body['TemplateId'] = $request->templateId;
        }
        if (!Utils::isUnset($request->trend)) {
            $body['Trend'] = $request->trend;
        }
        if (!Utils::isUnset($request->warningThreshold)) {
            $body['WarningThreshold'] = $request->warningThreshold;
        }
        if (!Utils::isUnset($request->whereCondition)) {
            $body['WhereCondition'] = $request->whereCondition;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateQualityRule',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateQualityRuleRequest $request UpdateQualityRuleRequest
     *
     * @return UpdateQualityRuleResponse UpdateQualityRuleResponse
     */
    public function updateQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateQualityRuleWithOptions($request, $runtime);
    }

    /**
     * @param UpdateRemindRequest $request UpdateRemindRequest
     * @param RuntimeOptions      $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateRemindResponse UpdateRemindResponse
     */
    public function updateRemindWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->alertInterval)) {
            $body['AlertInterval'] = $request->alertInterval;
        }
        if (!Utils::isUnset($request->alertMethods)) {
            $body['AlertMethods'] = $request->alertMethods;
        }
        if (!Utils::isUnset($request->alertTargets)) {
            $body['AlertTargets'] = $request->alertTargets;
        }
        if (!Utils::isUnset($request->alertUnit)) {
            $body['AlertUnit'] = $request->alertUnit;
        }
        if (!Utils::isUnset($request->baselineIds)) {
            $body['BaselineIds'] = $request->baselineIds;
        }
        if (!Utils::isUnset($request->bizProcessIds)) {
            $body['BizProcessIds'] = $request->bizProcessIds;
        }
        if (!Utils::isUnset($request->detail)) {
            $body['Detail'] = $request->detail;
        }
        if (!Utils::isUnset($request->dndEnd)) {
            $body['DndEnd'] = $request->dndEnd;
        }
        if (!Utils::isUnset($request->maxAlertTimes)) {
            $body['MaxAlertTimes'] = $request->maxAlertTimes;
        }
        if (!Utils::isUnset($request->nodeIds)) {
            $body['NodeIds'] = $request->nodeIds;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->remindId)) {
            $body['RemindId'] = $request->remindId;
        }
        if (!Utils::isUnset($request->remindName)) {
            $body['RemindName'] = $request->remindName;
        }
        if (!Utils::isUnset($request->remindType)) {
            $body['RemindType'] = $request->remindType;
        }
        if (!Utils::isUnset($request->remindUnit)) {
            $body['RemindUnit'] = $request->remindUnit;
        }
        if (!Utils::isUnset($request->robotUrls)) {
            $body['RobotUrls'] = $request->robotUrls;
        }
        if (!Utils::isUnset($request->useFlag)) {
            $body['UseFlag'] = $request->useFlag;
        }
        if (!Utils::isUnset($request->webhooks)) {
            $body['Webhooks'] = $request->webhooks;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateRemind',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateRemindRequest $request UpdateRemindRequest
     *
     * @return UpdateRemindResponse UpdateRemindResponse
     */
    public function updateRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateRemindWithOptions($request, $runtime);
    }

    /**
     * @summary The operation that you want to perform. Set the value to **UpdateTable**.
     *  *
     * @param UpdateTableRequest $request UpdateTableRequest
     * @param RuntimeOptions     $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableResponse UpdateTableResponse
     */
    public function updateTableWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->appGuid)) {
            $query['AppGuid'] = $request->appGuid;
        }
        if (!Utils::isUnset($request->categoryId)) {
            $query['CategoryId'] = $request->categoryId;
        }
        if (!Utils::isUnset($request->comment)) {
            $query['Comment'] = $request->comment;
        }
        if (!Utils::isUnset($request->createIfNotExists)) {
            $query['CreateIfNotExists'] = $request->createIfNotExists;
        }
        if (!Utils::isUnset($request->externalTableType)) {
            $query['ExternalTableType'] = $request->externalTableType;
        }
        if (!Utils::isUnset($request->hasPart)) {
            $query['HasPart'] = $request->hasPart;
        }
        if (!Utils::isUnset($request->isView)) {
            $query['IsView'] = $request->isView;
        }
        if (!Utils::isUnset($request->lifeCycle)) {
            $query['LifeCycle'] = $request->lifeCycle;
        }
        if (!Utils::isUnset($request->location)) {
            $query['Location'] = $request->location;
        }
        if (!Utils::isUnset($request->logicalLevelId)) {
            $query['LogicalLevelId'] = $request->logicalLevelId;
        }
        if (!Utils::isUnset($request->ownerId)) {
            $query['OwnerId'] = $request->ownerId;
        }
        if (!Utils::isUnset($request->physicsLevelId)) {
            $query['PhysicsLevelId'] = $request->physicsLevelId;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->schema)) {
            $query['Schema'] = $request->schema;
        }
        if (!Utils::isUnset($request->tableName)) {
            $query['TableName'] = $request->tableName;
        }
        if (!Utils::isUnset($request->visibility)) {
            $query['Visibility'] = $request->visibility;
        }
        $body = [];
        if (!Utils::isUnset($request->columns)) {
            $body['Columns'] = $request->columns;
        }
        if (!Utils::isUnset($request->endpoint)) {
            $body['Endpoint'] = $request->endpoint;
        }
        if (!Utils::isUnset($request->envType)) {
            $body['EnvType'] = $request->envType;
        }
        if (!Utils::isUnset($request->themes)) {
            $body['Themes'] = $request->themes;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateTable',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary The operation that you want to perform. Set the value to **UpdateTable**.
     *  *
     * @param UpdateTableRequest $request UpdateTableRequest
     *
     * @return UpdateTableResponse UpdateTableResponse
     */
    public function updateTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableWithOptions($request, $runtime);
    }

    /**
     * @param UpdateTableAddColumnRequest $request UpdateTableAddColumnRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableAddColumnResponse UpdateTableAddColumnResponse
     */
    public function updateTableAddColumnWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $body = [];
        if (!Utils::isUnset($request->column)) {
            $body['Column'] = $request->column;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
            'body'  => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateTableAddColumn',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableAddColumnResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateTableAddColumnRequest $request UpdateTableAddColumnRequest
     *
     * @return UpdateTableAddColumnResponse UpdateTableAddColumnResponse
     */
    public function updateTableAddColumn($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableAddColumnWithOptions($request, $runtime);
    }

    /**
     * @param UpdateTableLevelRequest $request UpdateTableLevelRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableLevelResponse UpdateTableLevelResponse
     */
    public function updateTableLevelWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->description)) {
            $query['Description'] = $request->description;
        }
        if (!Utils::isUnset($request->levelId)) {
            $query['LevelId'] = $request->levelId;
        }
        if (!Utils::isUnset($request->levelType)) {
            $query['LevelType'] = $request->levelType;
        }
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTableLevel',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateTableLevelRequest $request UpdateTableLevelRequest
     *
     * @return UpdateTableLevelResponse UpdateTableLevelResponse
     */
    public function updateTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableLevelWithOptions($request, $runtime);
    }

    /**
     * @param UpdateTableModelInfoRequest $request UpdateTableModelInfoRequest
     * @param RuntimeOptions              $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableModelInfoResponse UpdateTableModelInfoResponse
     */
    public function updateTableModelInfoWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->firstLevelThemeId)) {
            $query['FirstLevelThemeId'] = $request->firstLevelThemeId;
        }
        if (!Utils::isUnset($request->levelId)) {
            $query['LevelId'] = $request->levelId;
        }
        if (!Utils::isUnset($request->levelType)) {
            $query['LevelType'] = $request->levelType;
        }
        if (!Utils::isUnset($request->secondLevelThemeId)) {
            $query['SecondLevelThemeId'] = $request->secondLevelThemeId;
        }
        if (!Utils::isUnset($request->tableGuid)) {
            $query['TableGuid'] = $request->tableGuid;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTableModelInfo',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableModelInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateTableModelInfoRequest $request UpdateTableModelInfoRequest
     *
     * @return UpdateTableModelInfoResponse UpdateTableModelInfoResponse
     */
    public function updateTableModelInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableModelInfoWithOptions($request, $runtime);
    }

    /**
     * @param UpdateTableThemeRequest $request UpdateTableThemeRequest
     * @param RuntimeOptions          $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateTableThemeResponse UpdateTableThemeResponse
     */
    public function updateTableThemeWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->name)) {
            $query['Name'] = $request->name;
        }
        if (!Utils::isUnset($request->projectId)) {
            $query['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->themeId)) {
            $query['ThemeId'] = $request->themeId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateTableTheme',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateTableThemeRequest $request UpdateTableThemeRequest
     *
     * @return UpdateTableThemeResponse UpdateTableThemeResponse
     */
    public function updateTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableThemeWithOptions($request, $runtime);
    }

    /**
     * @param UpdateUdfFileRequest $request UpdateUdfFileRequest
     * @param RuntimeOptions       $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateUdfFileResponse UpdateUdfFileResponse
     */
    public function updateUdfFileWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $body = [];
        if (!Utils::isUnset($request->className)) {
            $body['ClassName'] = $request->className;
        }
        if (!Utils::isUnset($request->cmdDescription)) {
            $body['CmdDescription'] = $request->cmdDescription;
        }
        if (!Utils::isUnset($request->example)) {
            $body['Example'] = $request->example;
        }
        if (!Utils::isUnset($request->fileFolderPath)) {
            $body['FileFolderPath'] = $request->fileFolderPath;
        }
        if (!Utils::isUnset($request->fileId)) {
            $body['FileId'] = $request->fileId;
        }
        if (!Utils::isUnset($request->functionType)) {
            $body['FunctionType'] = $request->functionType;
        }
        if (!Utils::isUnset($request->parameterDescription)) {
            $body['ParameterDescription'] = $request->parameterDescription;
        }
        if (!Utils::isUnset($request->projectId)) {
            $body['ProjectId'] = $request->projectId;
        }
        if (!Utils::isUnset($request->projectIdentifier)) {
            $body['ProjectIdentifier'] = $request->projectIdentifier;
        }
        if (!Utils::isUnset($request->resources)) {
            $body['Resources'] = $request->resources;
        }
        if (!Utils::isUnset($request->returnValue)) {
            $body['ReturnValue'] = $request->returnValue;
        }
        if (!Utils::isUnset($request->udfDescription)) {
            $body['UdfDescription'] = $request->udfDescription;
        }
        $req = new OpenApiRequest([
            'body' => OpenApiUtilClient::parseToMap($body),
        ]);
        $params = new Params([
            'action'      => 'UpdateUdfFile',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateUdfFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param UpdateUdfFileRequest $request UpdateUdfFileRequest
     *
     * @return UpdateUdfFileResponse UpdateUdfFileResponse
     */
    public function updateUdfFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateUdfFileWithOptions($request, $runtime);
    }

    /**
     * @summary 
     *  *
     * @param UpdateWorkbenchEventResultRequest $request UpdateWorkbenchEventResultRequest
     * @param RuntimeOptions                    $runtime runtime options for this request RuntimeOptions
     *
     * @return UpdateWorkbenchEventResultResponse UpdateWorkbenchEventResultResponse
     */
    public function updateWorkbenchEventResultWithOptions($request, $runtime)
    {
        Utils::validateModel($request);
        $query = [];
        if (!Utils::isUnset($request->checkResult)) {
            $query['CheckResult'] = $request->checkResult;
        }
        if (!Utils::isUnset($request->checkResultTip)) {
            $query['CheckResultTip'] = $request->checkResultTip;
        }
        if (!Utils::isUnset($request->extensionCode)) {
            $query['ExtensionCode'] = $request->extensionCode;
        }
        if (!Utils::isUnset($request->messageId)) {
            $query['MessageId'] = $request->messageId;
        }
        $req = new OpenApiRequest([
            'query' => OpenApiUtilClient::query($query),
        ]);
        $params = new Params([
            'action'      => 'UpdateWorkbenchEventResult',
            'version'     => '2020-05-18',
            'protocol'    => 'HTTPS',
            'pathname'    => '/',
            'method'      => 'POST',
            'authType'    => 'AK',
            'style'       => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType'    => 'json',
        ]);

        return UpdateWorkbenchEventResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @summary 
     *  *
     * @param UpdateWorkbenchEventResultRequest $request UpdateWorkbenchEventResultRequest
     *
     * @return UpdateWorkbenchEventResultResponse UpdateWorkbenchEventResultResponse
     */
    public function updateWorkbenchEventResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateWorkbenchEventResultWithOptions($request, $runtime);
    }
}
