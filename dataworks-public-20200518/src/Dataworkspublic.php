<?php

// This file is auto-generated, don't edit it. Thanks.

namespace AlibabaCloud\SDK\Dataworkspublic\V20200518;

use AlibabaCloud\Dara\Models\RuntimeOptions;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AbolishDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AbolishDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddMetaCollectionEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddMetaCollectionEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddProjectMemberToRoleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddProjectMemberToRoleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddRecognizeRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddRecognizeRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddToMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\AddToMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ApprovePermissionApplyOrderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ApprovePermissionApplyOrderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CallbackExtensionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CallbackExtensionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ChangeResourceManagerResourceGroupRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ChangeResourceManagerResourceGroupResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckFileDeploymentRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckFileDeploymentResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaPartitionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaPartitionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CheckMetaTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagComplementRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagComplementResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDagTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiAuthorityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiAuthorityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceGroupRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataServiceGroupResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataSourceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDataSourceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIAlarmRuleShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDIJobShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateExportMigrationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateExportMigrationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateImportMigrationAdvanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateImportMigrationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateImportMigrationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateManualDagRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateManualDagResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCollectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateMetaCollectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreatePermissionApplyOrderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreatePermissionApplyOrderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectMemberRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectMemberResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateProjectShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRelativeNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRelativeNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateResourceFileAdvanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateResourceFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateResourceFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateUdfFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\CreateUdfFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiAuthorityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiAuthorityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataSourceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDataSourceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFromMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteFromMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteLineageRelationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteLineageRelationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteMetaCollectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteProjectMemberRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteProjectMemberResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRelativeNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRelativeNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRecognizeRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRecognizeRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeleteTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DeployFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DesensitizeDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DesensitizeDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanAddOrUpdateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanAddOrUpdateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanAddOrUpdateShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanDeleteRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanDeleteResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanDeleteShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanQueryListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanQueryListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanUpdateStatusRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanUpdateStatusResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgDesensPlanUpdateStatusShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgPlatformQueryProjectsAndSchemaFromMetaRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgPlatformQueryProjectsAndSchemaFromMetaResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQueryDefaultTemplatesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQueryDefaultTemplatesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQuerySensResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgQuerySensResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgRunSensIdentifyRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgRunSensIdentifyResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgRunSensIdentifyShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneAddOrUpdateSceneRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneAddOrUpdateSceneResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneAddOrUpdateSceneShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgScenedDeleteSceneRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgScenedDeleteSceneResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgScenedDeleteSceneShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneQuerySceneListByNameRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgSceneQuerySceneListByNameResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgStopSensIdentifyRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgStopSensIdentifyResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupAddOrUpdateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupAddOrUpdateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupAddOrUpdateShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupDeleteRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupDeleteResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupDeleteShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupGetOdpsRoleGroupsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupGetOdpsRoleGroupsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupQueryListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupQueryListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgUserGroupQueryUserListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListAddOrUpdateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListAddOrUpdateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListAddOrUpdateShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListDeleteListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListDeleteListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListDeleteListShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListQueryListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\DsgWhiteListQueryListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EditRecognizeRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EditRecognizeRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EstablishRelationTableToBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\EstablishRelationTableToBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ExportDataSourcesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ExportDataSourcesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForCreatingRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForCreatingResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForUpdatingRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GenerateDISyncTaskConfigForUpdatingResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetAlertMessageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetAlertMessageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineConfigRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineConfigResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineKeyPathRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineKeyPathResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineStatusRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBaselineStatusResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDagRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDagResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApiTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApplicationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceApplicationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceGroupRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServiceGroupResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServicePublishedApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataServicePublishedApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataSourceMetaRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDataSourceMetaResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDDLJobStatusRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDDLJobStatusResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDeploymentRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDeploymentResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncInstanceInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncInstanceInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetExtensionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetExtensionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileTypeStatisticRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileTypeStatisticResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileVersionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFileVersionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetIDEEventDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetIDEEventDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceConsumeTimeRankRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceConsumeTimeRankResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceCountTrendRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceCountTrendResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceErrorRankRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceErrorRankResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceLogRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceLogResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusCountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusCountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusStatisticRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetInstanceStatusStatisticResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetManualDagInstancesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetManualDagInstancesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCollectionDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaCollectionDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaColumnLineageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaColumnLineageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBTableListRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaDBTableListResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableBasicInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableBasicInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableChangeLogRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableChangeLogResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableColumnRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableColumnResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableFullInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableFullInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableIntroWikiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableIntroWikiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableLineageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableLineageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableListByCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableListByCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTablePartitionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTablePartitionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTablePartitionShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableProducingTasksRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableProducingTasksResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableThemeLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMetaTableThemeLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationProcessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationProcessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationSummaryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetMigrationSummaryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeChildrenRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeChildrenResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeCodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeCodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeOnBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeOnBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeParentsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeParentsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeTypeListInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetNodeTypeListInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpRiskDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpRiskDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpSensitiveDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOpSensitiveDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOptionValueForProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetOptionValueForProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetPermissionApplyOrderDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetPermissionApplyOrderDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSensitiveDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSensitiveDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSuccessInstanceTrendRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetSuccessInstanceTrendResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicInfluenceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicInfluenceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\GetTopicResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ImportDataSourcesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ImportDataSourcesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListAlertMessagesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListAlertMessagesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineConfigsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineConfigsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselinesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselinesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineStatusesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBaselineStatusesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListCalcEnginesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListCalcEnginesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListCheckProcessesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListCheckProcessesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListClusterConfigsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListClusterConfigsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListClustersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListClustersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListConnectionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListConnectionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiAuthoritiesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiAuthoritiesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApisRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApisResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApiTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApplicationsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceApplicationsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceAuthorizedApisRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceAuthorizedApisResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceFoldersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceFoldersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceGroupsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServiceGroupsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServicePublishedApisRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataServicePublishedApisResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataSourcesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDataSourcesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDeploymentsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDeploymentsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIAlarmRulesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIAlarmRulesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIJobsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIJobsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIProjectConfigRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListDIProjectConfigResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEnabledExtensionsForProjectRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEnabledExtensionsForProjectResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntitiesByTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntitiesByTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntitiesByTagsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntityTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListEntityTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListExtensionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListExtensionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFilesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFilesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileTypeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileTypeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileVersionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFileVersionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFoldersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListFoldersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInnerNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInnerNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceAmountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceAmountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceHistoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstanceHistoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstancesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListInstancesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListLineageRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListLineageResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListManualDagInstancesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListManualDagInstancesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMeasureDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMeasureDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionEntitiesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionEntitiesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaCollectionsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaDBRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMetaDBResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMigrationsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListMigrationsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeInputOrOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeInputOrOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeIORequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodeIOResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesByOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListPermissionApplyOrdersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListPermissionApplyOrdersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProgramTypeCountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProgramTypeCountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectIdsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectIdsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectMembersRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectMembersResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectRolesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectRolesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListProjectsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByEntityRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByEntityResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityResultsByRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityRulesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListQualityRulesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRefDISyncTasksRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRefDISyncTasksResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRemindsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListRemindsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListResourceGroupsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListResourceGroupsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListResourceGroupsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftPersonnelsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftPersonnelsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftSchedulesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListShiftSchedulesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListSuccessInstanceAmountRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListSuccessInstanceAmountResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTablesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTablesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTopicsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ListTopicsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\OfflineNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\OfflineNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\PublishDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\PublishDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDefaultTemplateRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDefaultTemplateResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDISyncTaskConfigProcessResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryDISyncTaskConfigProcessResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryPublicModelEngineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryPublicModelEngineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeDataByRuleTypeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeDataByRuleTypeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeRuleDetailRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeRuleDetailResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QueryRecognizeRulesTypeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensClassificationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensClassificationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensNodeInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\QuerySensNodeInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RegisterLineageRelationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RegisterLineageRelationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RegisterLineageRelationShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveEntityTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveEntityTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveEntityTagsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveProjectMemberFromRoleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RemoveProjectMemberFromRoleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RestartInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RestartInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ResumeInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ResumeInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeTablePermissionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RevokeTablePermissionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunCycleDagNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunCycleDagNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunManualDagNodesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunManualDagNodesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunSmokeTestRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunSmokeTestResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunTriggerNodeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\RunTriggerNodeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SaveDataServiceApiTestResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SaveDataServiceApiTestResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ScanSensitiveDataRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\ScanSensitiveDataResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchMetaTablesRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchMetaTablesResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchNodesByOutputRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SearchNodesByOutputResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetDataSourceShareRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetDataSourceShareResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetEntityTagsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetEntityTagsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetEntityTagsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetSuccessInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SetSuccessInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDIJobShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDISyncInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartDISyncInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartMigrationRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StartMigrationResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDISyncInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopDISyncInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\StopInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SubmitFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SuspendInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\SuspendInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TerminateDISyncInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TerminateDISyncInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestNetworkConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TestNetworkConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenElapsedTimeInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenElapsedTimeInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenErrorTimesInstanceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\TopTenErrorTimesInstanceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBaselineRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBaselineResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBaselineShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBusinessRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateBusinessResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateClusterConfigsRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateClusterConfigsResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateClusterConfigsShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateConnectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateConnectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataServiceApiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataServiceApiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataSourceRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDataSourceResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIAlarmRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIAlarmRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIAlarmRuleShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIJobRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIJobResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIJobShrinkRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIProjectConfigRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDIProjectConfigResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDISyncTaskRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateDISyncTaskResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFolderRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateFolderResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateIDEEventResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateIDEEventResultResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCategoryRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCategoryResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCollectionRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaCollectionResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableIntroWikiRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableIntroWikiResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateMetaTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeOwnerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeOwnerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeRunModeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateNodeRunModeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityFollowerRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityFollowerResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityRuleRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateQualityRuleResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateRemindRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateRemindResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableAddColumnRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableAddColumnResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableLevelRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableLevelResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableModelInfoRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableModelInfoResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableThemeRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateTableThemeResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateUdfFileRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateUdfFileResponse;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateWorkbenchEventResultRequest;
use AlibabaCloud\SDK\Dataworkspublic\V20200518\Models\UpdateWorkbenchEventResultResponse;
use AlibabaCloud\SDK\OpenPlatform\V20191219\Models\AuthorizeFileUploadRequest;
use AlibabaCloud\SDK\OpenPlatform\V20191219\Models\AuthorizeFileUploadResponse;
use AlibabaCloud\SDK\OpenPlatform\V20191219\OpenPlatform;
use AlibabaCloud\SDK\OSS\OSS;
use AlibabaCloud\SDK\OSS\OSS\PostObjectRequest;
use AlibabaCloud\SDK\OSS\OSS\PostObjectRequest\header;
use AlibabaCloud\Tea\FileForm\FileForm\FileField;
use Darabonba\OpenApi\Models\Config;
use Darabonba\OpenApi\Models\OpenApiRequest;
use Darabonba\OpenApi\Models\Params;
use Darabonba\OpenApi\OpenApiClient;
use Darabonba\OpenApi\Utils;

class Dataworkspublic extends OpenApiClient
{
    public function __construct($config)
    {
        parent::__construct($config);
        $this->_endpointRule = 'regional';
        $this->_endpointMap = [
            'ap-northeast-1' => 'dataworks.ap-northeast-1.aliyuncs.com',
            'ap-south-1' => 'dataworks.ap-south-1.aliyuncs.com',
            'ap-southeast-1' => 'dataworks.ap-southeast-1.aliyuncs.com',
            'ap-southeast-2' => 'dataworks.ap-southeast-2.aliyuncs.com',
            'ap-southeast-3' => 'dataworks.ap-southeast-3.aliyuncs.com',
            'ap-southeast-5' => 'dataworks.ap-southeast-5.aliyuncs.com',
            'cn-beijing' => 'dataworks.cn-beijing.aliyuncs.com',
            'cn-chengdu' => 'dataworks.cn-chengdu.aliyuncs.com',
            'cn-hangzhou' => 'dataworks.cn-hangzhou.aliyuncs.com',
            'cn-hongkong' => 'dataworks.cn-hongkong.aliyuncs.com',
            'cn-huhehaote' => 'dataworks.aliyuncs.com',
            'cn-qingdao' => 'dataworks.aliyuncs.com',
            'cn-shanghai' => 'dataworks.cn-shanghai.aliyuncs.com',
            'cn-shenzhen' => 'dataworks.cn-shenzhen.aliyuncs.com',
            'cn-zhangjiakou' => 'dataworks.aliyuncs.com',
            'eu-central-1' => 'dataworks.eu-central-1.aliyuncs.com',
            'eu-west-1' => 'dataworks.eu-west-1.aliyuncs.com',
            'me-east-1' => 'dataworks.me-east-1.aliyuncs.com',
            'us-east-1' => 'dataworks.us-east-1.aliyuncs.com',
            'us-west-1' => 'dataworks.us-west-1.aliyuncs.com',
            'cn-hangzhou-finance' => 'dataworks.aliyuncs.com',
            'cn-shenzhen-finance-1' => 'dataworks.aliyuncs.com',
            'cn-shanghai-finance-1' => 'dataworks.aliyuncs.com',
            'cn-north-2-gov-1' => 'dataworks.aliyuncs.com',
        ];
        $this->checkConfig($config);
        $this->_endpoint = $this->getEndpoint('dataworks-public', $this->_regionId, $this->_endpointRule, $this->_network, $this->_suffix, $this->_endpointMap, $this->_endpoint);
    }

    /**
     * @param string   $productId
     * @param string   $regionId
     * @param string   $endpointRule
     * @param string   $network
     * @param string   $suffix
     * @param string[] $endpointMap
     * @param string   $endpoint
     *
     * @return string
     */
    public function getEndpoint($productId, $regionId, $endpointRule, $network, $suffix, $endpointMap, $endpoint)
    {
        if (null !== $endpoint) {
            return $endpoint;
        }

        if (null !== $endpointMap && null !== @$endpointMap[$regionId]) {
            return @$endpointMap[$regionId];
        }

        return Utils::getEndpointRules($productId, $regionId, $endpointRule, $network, $suffix);
    }

    /**
     * Unpublishes a DataService Studio API.
     *
     * @param request - AbolishDataServiceApiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AbolishDataServiceApiResponse
     *
     * @param AbolishDataServiceApiRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return AbolishDataServiceApiResponse
     */
    public function abolishDataServiceApiWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'AbolishDataServiceApi',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AbolishDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Unpublishes a DataService Studio API.
     *
     * @param request - AbolishDataServiceApiRequest
     *
     * @returns AbolishDataServiceApiResponse
     *
     * @param AbolishDataServiceApiRequest $request
     *
     * @return AbolishDataServiceApiResponse
     */
    public function abolishDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->abolishDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * Adds an entity to a collection.
     *
     * @param request - AddMetaCollectionEntityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddMetaCollectionEntityResponse
     *
     * @param AddMetaCollectionEntityRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return AddMetaCollectionEntityResponse
     */
    public function addMetaCollectionEntityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->collectionQualifiedName) {
            @$query['CollectionQualifiedName'] = $request->collectionQualifiedName;
        }

        if (null !== $request->entityQualifiedName) {
            @$query['EntityQualifiedName'] = $request->entityQualifiedName;
        }

        if (null !== $request->remark) {
            @$query['Remark'] = $request->remark;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddMetaCollectionEntity',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddMetaCollectionEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds an entity to a collection.
     *
     * @param request - AddMetaCollectionEntityRequest
     *
     * @returns AddMetaCollectionEntityResponse
     *
     * @param AddMetaCollectionEntityRequest $request
     *
     * @return AddMetaCollectionEntityResponse
     */
    public function addMetaCollectionEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addMetaCollectionEntityWithOptions($request, $runtime);
    }

    /**
     * Assigns a role to a member of a DataWorks workspace. Before you call this operation, you must add your account to a DataWorks workspace as a member.
     *
     * @remarks
     *   For information about how to add an account to a DataWorks workspace as a member, see [Add workspace members and assign roles to them](https://help.aliyun.com/document_detail/136941.html).
     * *   If you assign a built-in workspace-level role to a member of a DataWorks workspace, the member is automatically granted the permissions of the mapped role of the MaxCompute compute engine in the development environment. For more information, see [Appendix: Mappings between the built-in workspace-level roles of DataWorks and the roles of MaxCompute](https://help.aliyun.com/document_detail/449397.html).
     *
     * @param request - AddProjectMemberToRoleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddProjectMemberToRoleResponse
     *
     * @param AddProjectMemberToRoleRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return AddProjectMemberToRoleResponse
     */
    public function addProjectMemberToRoleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->roleCode) {
            @$query['RoleCode'] = $request->roleCode;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddProjectMemberToRole',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddProjectMemberToRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Assigns a role to a member of a DataWorks workspace. Before you call this operation, you must add your account to a DataWorks workspace as a member.
     *
     * @remarks
     *   For information about how to add an account to a DataWorks workspace as a member, see [Add workspace members and assign roles to them](https://help.aliyun.com/document_detail/136941.html).
     * *   If you assign a built-in workspace-level role to a member of a DataWorks workspace, the member is automatically granted the permissions of the mapped role of the MaxCompute compute engine in the development environment. For more information, see [Appendix: Mappings between the built-in workspace-level roles of DataWorks and the roles of MaxCompute](https://help.aliyun.com/document_detail/449397.html).
     *
     * @param request - AddProjectMemberToRoleRequest
     *
     * @returns AddProjectMemberToRoleResponse
     *
     * @param AddProjectMemberToRoleRequest $request
     *
     * @return AddProjectMemberToRoleResponse
     */
    public function addProjectMemberToRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addProjectMemberToRoleWithOptions($request, $runtime);
    }

    /**
     * Adds a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
     *
     * @param request - AddRecognizeRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddRecognizeRuleResponse
     *
     * @param AddRecognizeRuleRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return AddRecognizeRuleResponse
     */
    public function addRecognizeRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->accountName) {
            @$body['AccountName'] = $request->accountName;
        }

        if (null !== $request->colExclude) {
            @$body['ColExclude'] = $request->colExclude;
        }

        if (null !== $request->colScan) {
            @$body['ColScan'] = $request->colScan;
        }

        if (null !== $request->commentScan) {
            @$body['CommentScan'] = $request->commentScan;
        }

        if (null !== $request->contentScan) {
            @$body['ContentScan'] = $request->contentScan;
        }

        if (null !== $request->hitThreshold) {
            @$body['HitThreshold'] = $request->hitThreshold;
        }

        if (null !== $request->level) {
            @$body['Level'] = $request->level;
        }

        if (null !== $request->levelName) {
            @$body['LevelName'] = $request->levelName;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->nodeParent) {
            @$body['NodeParent'] = $request->nodeParent;
        }

        if (null !== $request->operationType) {
            @$body['OperationType'] = $request->operationType;
        }

        if (null !== $request->recognizeRules) {
            @$body['RecognizeRules'] = $request->recognizeRules;
        }

        if (null !== $request->recognizeRulesType) {
            @$body['RecognizeRulesType'] = $request->recognizeRulesType;
        }

        if (null !== $request->sensitiveDescription) {
            @$body['SensitiveDescription'] = $request->sensitiveDescription;
        }

        if (null !== $request->sensitiveName) {
            @$body['SensitiveName'] = $request->sensitiveName;
        }

        if (null !== $request->status) {
            @$body['Status'] = $request->status;
        }

        if (null !== $request->templateId) {
            @$body['TemplateId'] = $request->templateId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'AddRecognizeRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddRecognizeRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
     *
     * @param request - AddRecognizeRuleRequest
     *
     * @returns AddRecognizeRuleResponse
     *
     * @param AddRecognizeRuleRequest $request
     *
     * @return AddRecognizeRuleResponse
     */
    public function addRecognizeRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addRecognizeRuleWithOptions($request, $runtime);
    }

    /**
     * Adds a metatable to a specified category.
     *
     * @param request - AddToMetaCategoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns AddToMetaCategoryResponse
     *
     * @param AddToMetaCategoryRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return AddToMetaCategoryResponse
     */
    public function addToMetaCategoryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->categoryId) {
            @$query['CategoryId'] = $request->categoryId;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'AddToMetaCategory',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return AddToMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a metatable to a specified category.
     *
     * @param request - AddToMetaCategoryRequest
     *
     * @returns AddToMetaCategoryResponse
     *
     * @param AddToMetaCategoryRequest $request
     *
     * @return AddToMetaCategoryResponse
     */
    public function addToMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->addToMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * Processes a permission request order.
     *
     * @param request - ApprovePermissionApplyOrderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ApprovePermissionApplyOrderResponse
     *
     * @param ApprovePermissionApplyOrderRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ApprovePermissionApplyOrderResponse
     */
    public function approvePermissionApplyOrderWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->approveAction) {
            @$query['ApproveAction'] = $request->approveAction;
        }

        if (null !== $request->approveComment) {
            @$query['ApproveComment'] = $request->approveComment;
        }

        if (null !== $request->flowId) {
            @$query['FlowId'] = $request->flowId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ApprovePermissionApplyOrder',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ApprovePermissionApplyOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Processes a permission request order.
     *
     * @param request - ApprovePermissionApplyOrderRequest
     *
     * @returns ApprovePermissionApplyOrderResponse
     *
     * @param ApprovePermissionApplyOrderRequest $request
     *
     * @return ApprovePermissionApplyOrderResponse
     */
    public function approvePermissionApplyOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->approvePermissionApplyOrderWithOptions($request, $runtime);
    }

    /**
     * Sends the processing result of an extension point event by an extension to DataWorks.
     *
     * @param request - CallbackExtensionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CallbackExtensionResponse
     *
     * @param CallbackExtensionRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CallbackExtensionResponse
     */
    public function callbackExtensionWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->checkMessage) {
            @$body['CheckMessage'] = $request->checkMessage;
        }

        if (null !== $request->checkResult) {
            @$body['CheckResult'] = $request->checkResult;
        }

        if (null !== $request->extensionCode) {
            @$body['ExtensionCode'] = $request->extensionCode;
        }

        if (null !== $request->messageId) {
            @$body['MessageId'] = $request->messageId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CallbackExtension',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CallbackExtensionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sends the processing result of an extension point event by an extension to DataWorks.
     *
     * @param request - CallbackExtensionRequest
     *
     * @returns CallbackExtensionResponse
     *
     * @param CallbackExtensionRequest $request
     *
     * @return CallbackExtensionResponse
     */
    public function callbackExtension($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->callbackExtensionWithOptions($request, $runtime);
    }

    /**
     * Changes the resource group to which a resource belongs.
     *
     * @param request - ChangeResourceManagerResourceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ChangeResourceManagerResourceGroupResponse
     *
     * @param ChangeResourceManagerResourceGroupRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return ChangeResourceManagerResourceGroupResponse
     */
    public function changeResourceManagerResourceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->resourceId) {
            @$query['ResourceId'] = $request->resourceId;
        }

        if (null !== $request->resourceManagerResourceGroupId) {
            @$query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }

        if (null !== $request->resourceType) {
            @$query['ResourceType'] = $request->resourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ChangeResourceManagerResourceGroup',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ChangeResourceManagerResourceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the resource group to which a resource belongs.
     *
     * @param request - ChangeResourceManagerResourceGroupRequest
     *
     * @returns ChangeResourceManagerResourceGroupResponse
     *
     * @param ChangeResourceManagerResourceGroupRequest $request
     *
     * @return ChangeResourceManagerResourceGroupResponse
     */
    public function changeResourceManagerResourceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->changeResourceManagerResourceGroupWithOptions($request, $runtime);
    }

    /**
     * Returns the check events of a file. After you commit your file that is created on the DataStudio page, the system checks the file and returns check events before the system deploys the file. You must determine whether the check can be continued based on the events. You can call this operation to return the check events for the file that you want to deploy to DataWorks.
     *
     * @param request - CheckFileDeploymentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckFileDeploymentResponse
     *
     * @param CheckFileDeploymentRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CheckFileDeploymentResponse
     */
    public function checkFileDeploymentWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->checkDetailUrl) {
            @$body['CheckDetailUrl'] = $request->checkDetailUrl;
        }

        if (null !== $request->checkerInstanceId) {
            @$body['CheckerInstanceId'] = $request->checkerInstanceId;
        }

        if (null !== $request->status) {
            @$body['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CheckFileDeployment',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckFileDeploymentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Returns the check events of a file. After you commit your file that is created on the DataStudio page, the system checks the file and returns check events before the system deploys the file. You must determine whether the check can be continued based on the events. You can call this operation to return the check events for the file that you want to deploy to DataWorks.
     *
     * @param request - CheckFileDeploymentRequest
     *
     * @returns CheckFileDeploymentResponse
     *
     * @param CheckFileDeploymentRequest $request
     *
     * @return CheckFileDeploymentResponse
     */
    public function checkFileDeployment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkFileDeploymentWithOptions($request, $runtime);
    }

    /**
     * Checks whether a partition in a MaxCompute metatable exists.
     *
     * @param request - CheckMetaPartitionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckMetaPartitionResponse
     *
     * @param CheckMetaPartitionRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CheckMetaPartitionResponse
     */
    public function checkMetaPartitionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->partition) {
            @$query['Partition'] = $request->partition;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckMetaPartition',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckMetaPartitionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether a partition in a MaxCompute metatable exists.
     *
     * @param request - CheckMetaPartitionRequest
     *
     * @returns CheckMetaPartitionResponse
     *
     * @param CheckMetaPartitionRequest $request
     *
     * @return CheckMetaPartitionResponse
     */
    public function checkMetaPartition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkMetaPartitionWithOptions($request, $runtime);
    }

    /**
     * Checks whether a metatable exists.
     *
     * @param request - CheckMetaTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CheckMetaTableResponse
     *
     * @param CheckMetaTableRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CheckMetaTableResponse
     */
    public function checkMetaTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CheckMetaTable',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CheckMetaTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether a metatable exists.
     *
     * @param request - CheckMetaTableRequest
     *
     * @returns CheckMetaTableResponse
     *
     * @param CheckMetaTableRequest $request
     *
     * @return CheckMetaTableResponse
     */
    public function checkMetaTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->checkMetaTableWithOptions($request, $runtime);
    }

    /**
     * Creates a baseline.
     *
     * @param request - CreateBaselineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBaselineResponse
     *
     * @param CreateBaselineRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateBaselineResponse
     */
    public function createBaselineWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alertMarginThreshold) {
            @$body['AlertMarginThreshold'] = $request->alertMarginThreshold;
        }

        if (null !== $request->baselineName) {
            @$body['BaselineName'] = $request->baselineName;
        }

        if (null !== $request->baselineType) {
            @$body['BaselineType'] = $request->baselineType;
        }

        if (null !== $request->nodeIds) {
            @$body['NodeIds'] = $request->nodeIds;
        }

        if (null !== $request->overtimeSettings) {
            @$body['OvertimeSettings'] = $request->overtimeSettings;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->priority) {
            @$body['Priority'] = $request->priority;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateBaseline',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a baseline.
     *
     * @param request - CreateBaselineRequest
     *
     * @returns CreateBaselineResponse
     *
     * @param CreateBaselineRequest $request
     *
     * @return CreateBaselineResponse
     */
    public function createBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBaselineWithOptions($request, $runtime);
    }

    /**
     * Creates a workflow in DataStudio.
     *
     * @param request - CreateBusinessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateBusinessResponse
     *
     * @param CreateBusinessRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return CreateBusinessResponse
     */
    public function createBusinessWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->businessName) {
            @$body['BusinessName'] = $request->businessName;
        }

        if (null !== $request->description) {
            @$body['Description'] = $request->description;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->useType) {
            @$body['UseType'] = $request->useType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateBusiness',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a workflow in DataStudio.
     *
     * @param request - CreateBusinessRequest
     *
     * @returns CreateBusinessResponse
     *
     * @param CreateBusinessRequest $request
     *
     * @return CreateBusinessResponse
     */
    public function createBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createBusinessWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Adds a data source.
     *
     * @deprecated OpenAPI CreateConnection is deprecated
     *
     * @param request - CreateConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateConnectionResponse
     *
     * @param CreateConnectionRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateConnectionResponse
     */
    public function createConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->connectionType) {
            @$query['ConnectionType'] = $request->connectionType;
        }

        if (null !== $request->content) {
            @$query['Content'] = $request->content;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->subType) {
            @$query['SubType'] = $request->subType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateConnection',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Adds a data source.
     *
     * @deprecated OpenAPI CreateConnection is deprecated
     *
     * @param request - CreateConnectionRequest
     *
     * @returns CreateConnectionResponse
     *
     * @param CreateConnectionRequest $request
     *
     * @return CreateConnectionResponse
     */
    public function createConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createConnectionWithOptions($request, $runtime);
    }

    /**
     * Creates an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *
     * @param tmpReq - CreateDIAlarmRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDIAlarmRuleResponse
     *
     * @param CreateDIAlarmRuleRequest $tmpReq
     * @param RuntimeOptions           $runtime
     *
     * @return CreateDIAlarmRuleResponse
     */
    public function createDIAlarmRuleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateDIAlarmRuleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->notificationSettings) {
            $request->notificationSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->notificationSettings, 'NotificationSettings', 'json');
        }

        if (null !== $tmpReq->triggerConditions) {
            $request->triggerConditionsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->triggerConditions, 'TriggerConditions', 'json');
        }

        $body = [];
        if (null !== $request->DIJobId) {
            @$body['DIJobId'] = $request->DIJobId;
        }

        if (null !== $request->description) {
            @$body['Description'] = $request->description;
        }

        if (null !== $request->enabled) {
            @$body['Enabled'] = $request->enabled;
        }

        if (null !== $request->metricType) {
            @$body['MetricType'] = $request->metricType;
        }

        if (null !== $request->notificationSettingsShrink) {
            @$body['NotificationSettings'] = $request->notificationSettingsShrink;
        }

        if (null !== $request->triggerConditionsShrink) {
            @$body['TriggerConditions'] = $request->triggerConditionsShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateDIAlarmRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *
     * @param request - CreateDIAlarmRuleRequest
     *
     * @returns CreateDIAlarmRuleResponse
     *
     * @param CreateDIAlarmRuleRequest $request
     *
     * @return CreateDIAlarmRuleResponse
     */
    public function createDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * Creates a new-version synchronization task. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres and batch synchronization of all data in a MySQL database to Hive.
     *
     * @param tmpReq - CreateDIJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDIJobResponse
     *
     * @param CreateDIJobRequest $tmpReq
     * @param RuntimeOptions     $runtime
     *
     * @return CreateDIJobResponse
     */
    public function createDIJobWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateDIJobShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->destinationDataSourceSettings) {
            $request->destinationDataSourceSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->destinationDataSourceSettings, 'DestinationDataSourceSettings', 'json');
        }

        if (null !== $tmpReq->jobSettings) {
            $request->jobSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->jobSettings, 'JobSettings', 'json');
        }

        if (null !== $tmpReq->resourceSettings) {
            $request->resourceSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->resourceSettings, 'ResourceSettings', 'json');
        }

        if (null !== $tmpReq->sourceDataSourceSettings) {
            $request->sourceDataSourceSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->sourceDataSourceSettings, 'SourceDataSourceSettings', 'json');
        }

        if (null !== $tmpReq->tableMappings) {
            $request->tableMappingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->tableMappings, 'TableMappings', 'json');
        }

        if (null !== $tmpReq->transformationRules) {
            $request->transformationRulesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->transformationRules, 'TransformationRules', 'json');
        }

        $query = [];
        if (null !== $request->systemDebug) {
            @$query['SystemDebug'] = $request->systemDebug;
        }

        $body = [];
        if (null !== $request->description) {
            @$body['Description'] = $request->description;
        }

        if (null !== $request->destinationDataSourceSettingsShrink) {
            @$body['DestinationDataSourceSettings'] = $request->destinationDataSourceSettingsShrink;
        }

        if (null !== $request->destinationDataSourceType) {
            @$body['DestinationDataSourceType'] = $request->destinationDataSourceType;
        }

        if (null !== $request->jobName) {
            @$body['JobName'] = $request->jobName;
        }

        if (null !== $request->jobSettingsShrink) {
            @$body['JobSettings'] = $request->jobSettingsShrink;
        }

        if (null !== $request->migrationType) {
            @$body['MigrationType'] = $request->migrationType;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->resourceSettingsShrink) {
            @$body['ResourceSettings'] = $request->resourceSettingsShrink;
        }

        if (null !== $request->sourceDataSourceSettingsShrink) {
            @$body['SourceDataSourceSettings'] = $request->sourceDataSourceSettingsShrink;
        }

        if (null !== $request->sourceDataSourceType) {
            @$body['SourceDataSourceType'] = $request->sourceDataSourceType;
        }

        if (null !== $request->tableMappingsShrink) {
            @$body['TableMappings'] = $request->tableMappingsShrink;
        }

        if (null !== $request->transformationRulesShrink) {
            @$body['TransformationRules'] = $request->transformationRulesShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateDIJob',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a new-version synchronization task. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres and batch synchronization of all data in a MySQL database to Hive.
     *
     * @param request - CreateDIJobRequest
     *
     * @returns CreateDIJobResponse
     *
     * @param CreateDIJobRequest $request
     *
     * @return CreateDIJobResponse
     */
    public function createDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDIJobWithOptions($request, $runtime);
    }

    /**
     * Creates a data synchronization task.
     *
     * @remarks
     * You cannot configure scheduling properties for a task by calling this operation. If you want to configure scheduling properties for a task, you can call the UpdateFile operation.[](~~2780137~~)
     *
     * @param request - CreateDISyncTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDISyncTaskResponse
     *
     * @param CreateDISyncTaskRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateDISyncTaskResponse
     */
    public function createDISyncTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskName) {
            @$query['TaskName'] = $request->taskName;
        }

        if (null !== $request->taskParam) {
            @$query['TaskParam'] = $request->taskParam;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $body = [];
        if (null !== $request->taskContent) {
            @$body['TaskContent'] = $request->taskContent;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateDISyncTask',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a data synchronization task.
     *
     * @remarks
     * You cannot configure scheduling properties for a task by calling this operation. If you want to configure scheduling properties for a task, you can call the UpdateFile operation.[](~~2780137~~)
     *
     * @param request - CreateDISyncTaskRequest
     *
     * @returns CreateDISyncTaskResponse
     *
     * @param CreateDISyncTaskRequest $request
     *
     * @return CreateDISyncTaskResponse
     */
    public function createDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDISyncTaskWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * @deprecated OpenAPI CreateDagComplement is deprecated
     *
     * @param request - CreateDagComplementRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDagComplementResponse
     *
     * @param CreateDagComplementRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateDagComplementResponse
     */
    public function createDagComplementWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->bizBeginTime) {
            @$body['BizBeginTime'] = $request->bizBeginTime;
        }

        if (null !== $request->bizEndTime) {
            @$body['BizEndTime'] = $request->bizEndTime;
        }

        if (null !== $request->endBizDate) {
            @$body['EndBizDate'] = $request->endBizDate;
        }

        if (null !== $request->excludeNodeIds) {
            @$body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }

        if (null !== $request->includeNodeIds) {
            @$body['IncludeNodeIds'] = $request->includeNodeIds;
        }

        if (null !== $request->name) {
            @$body['Name'] = $request->name;
        }

        if (null !== $request->nodeParams) {
            @$body['NodeParams'] = $request->nodeParams;
        }

        if (null !== $request->parallelism) {
            @$body['Parallelism'] = $request->parallelism;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->rootNodeId) {
            @$body['RootNodeId'] = $request->rootNodeId;
        }

        if (null !== $request->startBizDate) {
            @$body['StartBizDate'] = $request->startBizDate;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateDagComplement',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDagComplementResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * @deprecated OpenAPI CreateDagComplement is deprecated
     *
     * @param request - CreateDagComplementRequest
     *
     * @returns CreateDagComplementResponse
     *
     * @param CreateDagComplementRequest $request
     *
     * @return CreateDagComplementResponse
     */
    public function createDagComplement($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDagComplementWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * @deprecated OpenAPI CreateDagTest is deprecated
     *
     * @param request - CreateDagTestRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDagTestResponse
     *
     * @param CreateDagTestRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return CreateDagTestResponse
     */
    public function createDagTestWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->bizdate) {
            @$body['Bizdate'] = $request->bizdate;
        }

        if (null !== $request->name) {
            @$body['Name'] = $request->name;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->nodeParams) {
            @$body['NodeParams'] = $request->nodeParams;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateDagTest',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDagTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * @deprecated OpenAPI CreateDagTest is deprecated
     *
     * @param request - CreateDagTestRequest
     *
     * @returns CreateDagTestResponse
     *
     * @param CreateDagTestRequest $request
     *
     * @return CreateDagTestResponse
     */
    public function createDagTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDagTestWithOptions($request, $runtime);
    }

    /**
     * Creates an API.
     *
     * @param request - CreateDataServiceApiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDataServiceApiResponse
     *
     * @param CreateDataServiceApiRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateDataServiceApiResponse
     */
    public function createDataServiceApiWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiDescription) {
            @$body['ApiDescription'] = $request->apiDescription;
        }

        if (null !== $request->apiMode) {
            @$body['ApiMode'] = $request->apiMode;
        }

        if (null !== $request->apiName) {
            @$body['ApiName'] = $request->apiName;
        }

        if (null !== $request->apiPath) {
            @$body['ApiPath'] = $request->apiPath;
        }

        if (null !== $request->folderId) {
            @$body['FolderId'] = $request->folderId;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->protocols) {
            @$body['Protocols'] = $request->protocols;
        }

        if (null !== $request->registrationDetails) {
            @$body['RegistrationDetails'] = $request->registrationDetails;
        }

        if (null !== $request->requestContentType) {
            @$body['RequestContentType'] = $request->requestContentType;
        }

        if (null !== $request->requestMethod) {
            @$body['RequestMethod'] = $request->requestMethod;
        }

        if (null !== $request->resourceGroupId) {
            @$body['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->responseContentType) {
            @$body['ResponseContentType'] = $request->responseContentType;
        }

        if (null !== $request->scriptDetails) {
            @$body['ScriptDetails'] = $request->scriptDetails;
        }

        if (null !== $request->sqlMode) {
            @$body['SqlMode'] = $request->sqlMode;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        if (null !== $request->timeout) {
            @$body['Timeout'] = $request->timeout;
        }

        if (null !== $request->visibleRange) {
            @$body['VisibleRange'] = $request->visibleRange;
        }

        if (null !== $request->wizardDetails) {
            @$body['WizardDetails'] = $request->wizardDetails;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateDataServiceApi',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an API.
     *
     * @param request - CreateDataServiceApiRequest
     *
     * @returns CreateDataServiceApiResponse
     *
     * @param CreateDataServiceApiRequest $request
     *
     * @return CreateDataServiceApiResponse
     */
    public function createDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * Grants the access permissions on an API in DataService Studio.
     *
     * @param request - CreateDataServiceApiAuthorityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDataServiceApiAuthorityResponse
     *
     * @param CreateDataServiceApiAuthorityRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return CreateDataServiceApiAuthorityResponse
     */
    public function createDataServiceApiAuthorityWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->authorizedProjectId) {
            @$body['AuthorizedProjectId'] = $request->authorizedProjectId;
        }

        if (null !== $request->endTime) {
            @$body['EndTime'] = $request->endTime;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateDataServiceApiAuthority',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDataServiceApiAuthorityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Grants the access permissions on an API in DataService Studio.
     *
     * @param request - CreateDataServiceApiAuthorityRequest
     *
     * @returns CreateDataServiceApiAuthorityResponse
     *
     * @param CreateDataServiceApiAuthorityRequest $request
     *
     * @return CreateDataServiceApiAuthorityResponse
     */
    public function createDataServiceApiAuthority($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceApiAuthorityWithOptions($request, $runtime);
    }

    /**
     * Creates a folder in DataService Studio.
     *
     * @param request - CreateDataServiceFolderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDataServiceFolderResponse
     *
     * @param CreateDataServiceFolderRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return CreateDataServiceFolderResponse
     */
    public function createDataServiceFolderWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->folderName) {
            @$body['FolderName'] = $request->folderName;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->parentId) {
            @$body['ParentId'] = $request->parentId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateDataServiceFolder',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDataServiceFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a folder in DataService Studio.
     *
     * @param request - CreateDataServiceFolderRequest
     *
     * @returns CreateDataServiceFolderResponse
     *
     * @param CreateDataServiceFolderRequest $request
     *
     * @return CreateDataServiceFolderResponse
     */
    public function createDataServiceFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceFolderWithOptions($request, $runtime);
    }

    /**
     * Creates a business process.
     *
     * @param request - CreateDataServiceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDataServiceGroupResponse
     *
     * @param CreateDataServiceGroupRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return CreateDataServiceGroupResponse
     */
    public function createDataServiceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiGatewayGroupId) {
            @$body['ApiGatewayGroupId'] = $request->apiGatewayGroupId;
        }

        if (null !== $request->description) {
            @$body['Description'] = $request->description;
        }

        if (null !== $request->groupName) {
            @$body['GroupName'] = $request->groupName;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateDataServiceGroup',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDataServiceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a business process.
     *
     * @param request - CreateDataServiceGroupRequest
     *
     * @returns CreateDataServiceGroupResponse
     *
     * @param CreateDataServiceGroupRequest $request
     *
     * @return CreateDataServiceGroupResponse
     */
    public function createDataServiceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataServiceGroupWithOptions($request, $runtime);
    }

    /**
     * Adds a data source to DataWorks.
     *
     * @param request - CreateDataSourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateDataSourceResponse
     *
     * @param CreateDataSourceRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateDataSourceResponse
     */
    public function createDataSourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->content) {
            @$query['Content'] = $request->content;
        }

        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->subType) {
            @$query['SubType'] = $request->subType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateDataSource',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a data source to DataWorks.
     *
     * @param request - CreateDataSourceRequest
     *
     * @returns CreateDataSourceResponse
     *
     * @param CreateDataSourceRequest $request
     *
     * @return CreateDataSourceResponse
     */
    public function createDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createDataSourceWithOptions($request, $runtime);
    }

    /**
     * Creates an export task. You can use this operation to create an export task but cannot use this operation to start the created export task.
     *
     * @param request - CreateExportMigrationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateExportMigrationResponse
     *
     * @param CreateExportMigrationRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateExportMigrationResponse
     */
    public function createExportMigrationWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->description) {
            @$body['Description'] = $request->description;
        }

        if (null !== $request->exportMode) {
            @$body['ExportMode'] = $request->exportMode;
        }

        if (null !== $request->exportObjectStatus) {
            @$body['ExportObjectStatus'] = $request->exportObjectStatus;
        }

        if (null !== $request->incrementalSince) {
            @$body['IncrementalSince'] = $request->incrementalSince;
        }

        if (null !== $request->name) {
            @$body['Name'] = $request->name;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateExportMigration',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateExportMigrationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an export task. You can use this operation to create an export task but cannot use this operation to start the created export task.
     *
     * @param request - CreateExportMigrationRequest
     *
     * @returns CreateExportMigrationResponse
     *
     * @param CreateExportMigrationRequest $request
     *
     * @return CreateExportMigrationResponse
     */
    public function createExportMigration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createExportMigrationWithOptions($request, $runtime);
    }

    /**
     * Creates a file in DataStudio. You cannot call this operation to create files for Data Integration nodes.
     *
     * @param request - CreateFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateFileResponse
     *
     * @param CreateFileRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return CreateFileResponse
     */
    public function createFileWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->advancedSettings) {
            @$body['AdvancedSettings'] = $request->advancedSettings;
        }

        if (null !== $request->applyScheduleImmediately) {
            @$body['ApplyScheduleImmediately'] = $request->applyScheduleImmediately;
        }

        if (null !== $request->autoParsing) {
            @$body['AutoParsing'] = $request->autoParsing;
        }

        if (null !== $request->autoRerunIntervalMillis) {
            @$body['AutoRerunIntervalMillis'] = $request->autoRerunIntervalMillis;
        }

        if (null !== $request->autoRerunTimes) {
            @$body['AutoRerunTimes'] = $request->autoRerunTimes;
        }

        if (null !== $request->connectionName) {
            @$body['ConnectionName'] = $request->connectionName;
        }

        if (null !== $request->content) {
            @$body['Content'] = $request->content;
        }

        if (null !== $request->createFolderIfNotExists) {
            @$body['CreateFolderIfNotExists'] = $request->createFolderIfNotExists;
        }

        if (null !== $request->cronExpress) {
            @$body['CronExpress'] = $request->cronExpress;
        }

        if (null !== $request->cycleType) {
            @$body['CycleType'] = $request->cycleType;
        }

        if (null !== $request->dependentNodeIdList) {
            @$body['DependentNodeIdList'] = $request->dependentNodeIdList;
        }

        if (null !== $request->dependentType) {
            @$body['DependentType'] = $request->dependentType;
        }

        if (null !== $request->endEffectDate) {
            @$body['EndEffectDate'] = $request->endEffectDate;
        }

        if (null !== $request->fileDescription) {
            @$body['FileDescription'] = $request->fileDescription;
        }

        if (null !== $request->fileFolderPath) {
            @$body['FileFolderPath'] = $request->fileFolderPath;
        }

        if (null !== $request->fileName) {
            @$body['FileName'] = $request->fileName;
        }

        if (null !== $request->fileType) {
            @$body['FileType'] = $request->fileType;
        }

        if (null !== $request->ignoreParentSkipRunningProperty) {
            @$body['IgnoreParentSkipRunningProperty'] = $request->ignoreParentSkipRunningProperty;
        }

        if (null !== $request->imageId) {
            @$body['ImageId'] = $request->imageId;
        }

        if (null !== $request->inputList) {
            @$body['InputList'] = $request->inputList;
        }

        if (null !== $request->inputParameters) {
            @$body['InputParameters'] = $request->inputParameters;
        }

        if (null !== $request->outputParameters) {
            @$body['OutputParameters'] = $request->outputParameters;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->paraValue) {
            @$body['ParaValue'] = $request->paraValue;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->rerunMode) {
            @$body['RerunMode'] = $request->rerunMode;
        }

        if (null !== $request->resourceGroupId) {
            @$body['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->resourceGroupIdentifier) {
            @$body['ResourceGroupIdentifier'] = $request->resourceGroupIdentifier;
        }

        if (null !== $request->schedulerType) {
            @$body['SchedulerType'] = $request->schedulerType;
        }

        if (null !== $request->startEffectDate) {
            @$body['StartEffectDate'] = $request->startEffectDate;
        }

        if (null !== $request->startImmediately) {
            @$body['StartImmediately'] = $request->startImmediately;
        }

        if (null !== $request->stop) {
            @$body['Stop'] = $request->stop;
        }

        if (null !== $request->timeout) {
            @$body['Timeout'] = $request->timeout;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateFile',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a file in DataStudio. You cannot call this operation to create files for Data Integration nodes.
     *
     * @param request - CreateFileRequest
     *
     * @returns CreateFileResponse
     *
     * @param CreateFileRequest $request
     *
     * @return CreateFileResponse
     */
    public function createFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFileWithOptions($request, $runtime);
    }

    /**
     * The operation that you want to perform. Set the value to \\*\\*CreateFolder\\*\\*.
     *
     * @param request - CreateFolderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateFolderResponse
     *
     * @param CreateFolderRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CreateFolderResponse
     */
    public function createFolderWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->folderPath) {
            @$body['FolderPath'] = $request->folderPath;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateFolder',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * The operation that you want to perform. Set the value to \\*\\*CreateFolder\\*\\*.
     *
     * @param request - CreateFolderRequest
     *
     * @returns CreateFolderResponse
     *
     * @param CreateFolderRequest $request
     *
     * @return CreateFolderResponse
     */
    public function createFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createFolderWithOptions($request, $runtime);
    }

    /**
     * Creates an import task. The import task contains the import packages of data sources, nodes, and tables.
     *
     * @remarks
     * The import package must be uploaded. Example of the upload method:
     *         Config config = new Config();
     *         config.setAccessKeyId(accessId);
     *         config.setAccessKeySecret(accessKey);
     *         config.setEndpoint(popEndpoint);
     *         config.setRegionId(regionId);
     *
     *         Client client = new Client(config);
     *         CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
     *         request.setName("test_migration_api_" + System.currentTimeMillis());
     *         request.setProjectId(123456L);
     *         request.setPackageType("DATAWORKS_MODEL");
     *         request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
     *         RuntimeOptions runtime = new RuntimeOptions();
     *         CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
     *         ...
     *
     * @param request - CreateImportMigrationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateImportMigrationResponse
     *
     * @param CreateImportMigrationRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateImportMigrationResponse
     */
    public function createImportMigrationWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->calculateEngineMap) {
            @$body['CalculateEngineMap'] = $request->calculateEngineMap;
        }

        if (null !== $request->commitRule) {
            @$body['CommitRule'] = $request->commitRule;
        }

        if (null !== $request->description) {
            @$body['Description'] = $request->description;
        }

        if (null !== $request->name) {
            @$body['Name'] = $request->name;
        }

        if (null !== $request->packageFile) {
            @$body['PackageFile'] = $request->packageFile;
        }

        if (null !== $request->packageType) {
            @$body['PackageType'] = $request->packageType;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->resourceGroupMap) {
            @$body['ResourceGroupMap'] = $request->resourceGroupMap;
        }

        if (null !== $request->workspaceMap) {
            @$body['WorkspaceMap'] = $request->workspaceMap;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateImportMigration',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateImportMigrationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates an import task. The import task contains the import packages of data sources, nodes, and tables.
     *
     * @remarks
     * The import package must be uploaded. Example of the upload method:
     *         Config config = new Config();
     *         config.setAccessKeyId(accessId);
     *         config.setAccessKeySecret(accessKey);
     *         config.setEndpoint(popEndpoint);
     *         config.setRegionId(regionId);
     *
     *         Client client = new Client(config);
     *         CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
     *         request.setName("test_migration_api_" + System.currentTimeMillis());
     *         request.setProjectId(123456L);
     *         request.setPackageType("DATAWORKS_MODEL");
     *         request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
     *         RuntimeOptions runtime = new RuntimeOptions();
     *         CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
     *         ...
     *
     * @param request - CreateImportMigrationRequest
     *
     * @returns CreateImportMigrationResponse
     *
     * @param CreateImportMigrationRequest $request
     *
     * @return CreateImportMigrationResponse
     */
    public function createImportMigration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createImportMigrationWithOptions($request, $runtime);
    }

    /**
     * @param CreateImportMigrationAdvanceRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return CreateImportMigrationResponse
     */
    public function createImportMigrationAdvance($request, $runtime)
    {
        // Step 0: init client
        $accessKeyId = $this->_credential->getAccessKeyId();
        $accessKeySecret = $this->_credential->getAccessKeySecret();
        $securityToken = $this->_credential->getSecurityToken();
        $credentialType = $this->_credential->getType();
        $openPlatformEndpoint = $this->_openPlatformEndpoint;
        if (null === $openPlatformEndpoint) {
            $openPlatformEndpoint = 'openplatform.aliyuncs.com';
        }

        if (null === $credentialType) {
            $credentialType = 'access_key';
        }

        $authConfig = new Config([
            'accessKeyId' => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'securityToken' => $securityToken,
            'type' => $credentialType,
            'endpoint' => $openPlatformEndpoint,
            'protocol' => $this->_protocol,
            'regionId' => $this->_regionId,
        ]);
        $authClient = new OpenPlatform($authConfig);
        $authRequest = new AuthorizeFileUploadRequest([
            'product' => 'dataworks-public',
            'regionId' => $this->_regionId,
        ]);
        $authResponse = new AuthorizeFileUploadResponse([]);
        $ossConfig = new OSS\Config([
            'accessKeyId' => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'type' => 'access_key',
            'protocol' => $this->_protocol,
            'regionId' => $this->_regionId,
        ]);
        $ossClient = new OSS($ossConfig);
        $fileObj = new FileField([]);
        $ossHeader = new header([]);
        $uploadRequest = new PostObjectRequest([]);
        $ossRuntime = new \AlibabaCloud\Tea\OSSUtils\OSSUtils\RuntimeOptions([]);
        Utils::convert($runtime, $ossRuntime);
        $createImportMigrationReq = new CreateImportMigrationRequest([]);
        Utils::convert($request, $createImportMigrationReq);
        if (null !== $request->packageFileObject) {
            $authResponse = $authClient->authorizeFileUploadWithOptions($authRequest, $runtime);
            $ossConfig->accessKeyId = $authResponse->body->accessKeyId;
            $ossConfig->endpoint = Utils::getEndpoint($authResponse->body->endpoint, $authResponse->body->useAccelerate, $this->_endpointType);
            $ossClient = new OSS($ossConfig);
            $fileObj = new FileField([
                'filename' => $authResponse->body->objectKey,
                'content' => $request->packageFileObject,
                'contentType' => '',
            ]);
            $ossHeader = new header([
                'accessKeyId' => $authResponse->body->accessKeyId,
                'policy' => $authResponse->body->encodedPolicy,
                'signature' => $authResponse->body->signature,
                'key' => $authResponse->body->objectKey,
                'file' => $fileObj,
                'successActionStatus' => '201',
            ]);
            $uploadRequest = new PostObjectRequest([
                'bucketName' => $authResponse->body->bucket,
                'header' => $ossHeader,
            ]);
            $ossClient->postObject($uploadRequest, $ossRuntime);
            $createImportMigrationReq->packageFile = 'http://' . $authResponse->body->bucket . '.' . $authResponse->body->endpoint . '/' . $authResponse->body->objectKey . '';
        }

        return $this->createImportMigrationWithOptions($createImportMigrationReq, $runtime);
    }

    // Deprecated
    /**
     * Triggers a manually triggered workflow to run. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find the manually triggered workflow on the Operation Center page only after the manually triggered workflow is committed and deployed.
     *
     * @deprecated OpenAPI CreateManualDag is deprecated
     *
     * @param request - CreateManualDagRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateManualDagResponse
     *
     * @param CreateManualDagRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return CreateManualDagResponse
     */
    public function createManualDagWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->bizDate) {
            @$body['BizDate'] = $request->bizDate;
        }

        if (null !== $request->dagParameters) {
            @$body['DagParameters'] = $request->dagParameters;
        }

        if (null !== $request->excludeNodeIds) {
            @$body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }

        if (null !== $request->flowName) {
            @$body['FlowName'] = $request->flowName;
        }

        if (null !== $request->includeNodeIds) {
            @$body['IncludeNodeIds'] = $request->includeNodeIds;
        }

        if (null !== $request->nodeParameters) {
            @$body['NodeParameters'] = $request->nodeParameters;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateManualDag',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateManualDagResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Triggers a manually triggered workflow to run. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find the manually triggered workflow on the Operation Center page only after the manually triggered workflow is committed and deployed.
     *
     * @deprecated OpenAPI CreateManualDag is deprecated
     *
     * @param request - CreateManualDagRequest
     *
     * @returns CreateManualDagResponse
     *
     * @param CreateManualDagRequest $request
     *
     * @return CreateManualDagResponse
     */
    public function createManualDag($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createManualDagWithOptions($request, $runtime);
    }

    /**
     * Creates a category.
     *
     * @param request - CreateMetaCategoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMetaCategoryResponse
     *
     * @param CreateMetaCategoryRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CreateMetaCategoryResponse
     */
    public function createMetaCategoryWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->comment) {
            @$body['Comment'] = $request->comment;
        }

        if (null !== $request->name) {
            @$body['Name'] = $request->name;
        }

        if (null !== $request->parentId) {
            @$body['ParentId'] = $request->parentId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateMetaCategory',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a category.
     *
     * @param request - CreateMetaCategoryRequest
     *
     * @returns CreateMetaCategoryResponse
     *
     * @param CreateMetaCategoryRequest $request
     *
     * @return CreateMetaCategoryResponse
     */
    public function createMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * Creates a collection.
     *
     * @remarks
     * Collections are classified into various types. The names of collections of the same type must be different.
     *
     * @param request - CreateMetaCollectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateMetaCollectionResponse
     *
     * @param CreateMetaCollectionRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return CreateMetaCollectionResponse
     */
    public function createMetaCollectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->collectionType) {
            @$query['CollectionType'] = $request->collectionType;
        }

        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->parentQualifiedName) {
            @$query['ParentQualifiedName'] = $request->parentQualifiedName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateMetaCollection',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateMetaCollectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a collection.
     *
     * @remarks
     * Collections are classified into various types. The names of collections of the same type must be different.
     *
     * @param request - CreateMetaCollectionRequest
     *
     * @returns CreateMetaCollectionResponse
     *
     * @param CreateMetaCollectionRequest $request
     *
     * @return CreateMetaCollectionResponse
     */
    public function createMetaCollection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createMetaCollectionWithOptions($request, $runtime);
    }

    /**
     * Creates a permission request order.
     *
     * @param request - CreatePermissionApplyOrderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreatePermissionApplyOrderResponse
     *
     * @param CreatePermissionApplyOrderRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return CreatePermissionApplyOrderResponse
     */
    public function createPermissionApplyOrderWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->applyObject) {
            @$query['ApplyObject'] = $request->applyObject;
        }

        if (null !== $request->applyReason) {
            @$query['ApplyReason'] = $request->applyReason;
        }

        if (null !== $request->applyType) {
            @$query['ApplyType'] = $request->applyType;
        }

        if (null !== $request->applyUserIds) {
            @$query['ApplyUserIds'] = $request->applyUserIds;
        }

        if (null !== $request->catalogName) {
            @$query['CatalogName'] = $request->catalogName;
        }

        if (null !== $request->deadline) {
            @$query['Deadline'] = $request->deadline;
        }

        if (null !== $request->engineType) {
            @$query['EngineType'] = $request->engineType;
        }

        if (null !== $request->maxComputeProjectName) {
            @$query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }

        if (null !== $request->orderType) {
            @$query['OrderType'] = $request->orderType;
        }

        if (null !== $request->workspaceId) {
            @$query['WorkspaceId'] = $request->workspaceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreatePermissionApplyOrder',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreatePermissionApplyOrderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a permission request order.
     *
     * @param request - CreatePermissionApplyOrderRequest
     *
     * @returns CreatePermissionApplyOrderResponse
     *
     * @param CreatePermissionApplyOrderRequest $request
     *
     * @return CreatePermissionApplyOrderResponse
     */
    public function createPermissionApplyOrder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createPermissionApplyOrderWithOptions($request, $runtime);
    }

    /**
     * Creates a DataWorks workspace.
     *
     * @param tmpReq - CreateProjectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateProjectResponse
     *
     * @param CreateProjectRequest $tmpReq
     * @param RuntimeOptions       $runtime
     *
     * @return CreateProjectResponse
     */
    public function createProjectWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new CreateProjectShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->tags) {
            $request->tagsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }

        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->disableDevelopment) {
            @$query['DisableDevelopment'] = $request->disableDevelopment;
        }

        if (null !== $request->isAllowDownload) {
            @$query['IsAllowDownload'] = $request->isAllowDownload;
        }

        if (null !== $request->projectDescription) {
            @$query['ProjectDescription'] = $request->projectDescription;
        }

        if (null !== $request->projectIdentifier) {
            @$query['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->projectMode) {
            @$query['ProjectMode'] = $request->projectMode;
        }

        if (null !== $request->projectName) {
            @$query['ProjectName'] = $request->projectName;
        }

        if (null !== $request->resourceManagerResourceGroupId) {
            @$query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }

        if (null !== $request->tagsShrink) {
            @$query['Tags'] = $request->tagsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateProject',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a DataWorks workspace.
     *
     * @param request - CreateProjectRequest
     *
     * @returns CreateProjectResponse
     *
     * @param CreateProjectRequest $request
     *
     * @return CreateProjectResponse
     */
    public function createProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createProjectWithOptions($request, $runtime);
    }

    /**
     * Adds a user to a DataWorks workspace.
     *
     * @param request - CreateProjectMemberRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateProjectMemberResponse
     *
     * @param CreateProjectMemberRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateProjectMemberResponse
     */
    public function createProjectMemberWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->roleCode) {
            @$query['RoleCode'] = $request->roleCode;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateProjectMember',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateProjectMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds a user to a DataWorks workspace.
     *
     * @param request - CreateProjectMemberRequest
     *
     * @returns CreateProjectMemberResponse
     *
     * @param CreateProjectMemberRequest $request
     *
     * @return CreateProjectMemberResponse
     */
    public function createProjectMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createProjectMemberWithOptions($request, $runtime);
    }

    /**
     * Creates a partition filter expression.
     *
     * @param request - CreateQualityEntityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateQualityEntityResponse
     *
     * @param CreateQualityEntityRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return CreateQualityEntityResponse
     */
    public function createQualityEntityWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->entityLevel) {
            @$body['EntityLevel'] = $request->entityLevel;
        }

        if (null !== $request->envType) {
            @$body['EnvType'] = $request->envType;
        }

        if (null !== $request->matchExpression) {
            @$body['MatchExpression'] = $request->matchExpression;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->tableName) {
            @$body['TableName'] = $request->tableName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateQualityEntity',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateQualityEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a partition filter expression.
     *
     * @param request - CreateQualityEntityRequest
     *
     * @returns CreateQualityEntityResponse
     *
     * @param CreateQualityEntityRequest $request
     *
     * @return CreateQualityEntityResponse
     */
    public function createQualityEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityEntityWithOptions($request, $runtime);
    }

    /**
     * Creates a subscriber for a partition filter expression.
     *
     * @param request - CreateQualityFollowerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateQualityFollowerResponse
     *
     * @param CreateQualityFollowerRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return CreateQualityFollowerResponse
     */
    public function createQualityFollowerWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alarmMode) {
            @$body['AlarmMode'] = $request->alarmMode;
        }

        if (null !== $request->entityId) {
            @$body['EntityId'] = $request->entityId;
        }

        if (null !== $request->follower) {
            @$body['Follower'] = $request->follower;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateQualityFollower',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a subscriber for a partition filter expression.
     *
     * @param request - CreateQualityFollowerRequest
     *
     * @returns CreateQualityFollowerResponse
     *
     * @param CreateQualityFollowerRequest $request
     *
     * @return CreateQualityFollowerResponse
     */
    public function createQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * Associates a node with a partition filter expression.
     *
     * @param request - CreateQualityRelativeNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateQualityRelativeNodeResponse
     *
     * @param CreateQualityRelativeNodeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateQualityRelativeNodeResponse
     */
    public function createQualityRelativeNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->envType) {
            @$body['EnvType'] = $request->envType;
        }

        if (null !== $request->matchExpression) {
            @$body['MatchExpression'] = $request->matchExpression;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->tableName) {
            @$body['TableName'] = $request->tableName;
        }

        if (null !== $request->targetNodeProjectId) {
            @$body['TargetNodeProjectId'] = $request->targetNodeProjectId;
        }

        if (null !== $request->targetNodeProjectName) {
            @$body['TargetNodeProjectName'] = $request->targetNodeProjectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateQualityRelativeNode',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateQualityRelativeNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Associates a node with a partition filter expression.
     *
     * @param request - CreateQualityRelativeNodeRequest
     *
     * @returns CreateQualityRelativeNodeResponse
     *
     * @param CreateQualityRelativeNodeRequest $request
     *
     * @return CreateQualityRelativeNodeResponse
     */
    public function createQualityRelativeNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityRelativeNodeWithOptions($request, $runtime);
    }

    /**
     * Creates a monitoring rule.
     *
     * @param request - CreateQualityRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateQualityRuleResponse
     *
     * @param CreateQualityRuleRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return CreateQualityRuleResponse
     */
    public function createQualityRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->blockType) {
            @$body['BlockType'] = $request->blockType;
        }

        if (null !== $request->checker) {
            @$body['Checker'] = $request->checker;
        }

        if (null !== $request->comment) {
            @$body['Comment'] = $request->comment;
        }

        if (null !== $request->criticalThreshold) {
            @$body['CriticalThreshold'] = $request->criticalThreshold;
        }

        if (null !== $request->entityId) {
            @$body['EntityId'] = $request->entityId;
        }

        if (null !== $request->expectValue) {
            @$body['ExpectValue'] = $request->expectValue;
        }

        if (null !== $request->methodName) {
            @$body['MethodName'] = $request->methodName;
        }

        if (null !== $request->operator) {
            @$body['Operator'] = $request->operator;
        }

        if (null !== $request->predictType) {
            @$body['PredictType'] = $request->predictType;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->property) {
            @$body['Property'] = $request->property;
        }

        if (null !== $request->propertyType) {
            @$body['PropertyType'] = $request->propertyType;
        }

        if (null !== $request->ruleName) {
            @$body['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleType) {
            @$body['RuleType'] = $request->ruleType;
        }

        if (null !== $request->taskSetting) {
            @$body['TaskSetting'] = $request->taskSetting;
        }

        if (null !== $request->templateId) {
            @$body['TemplateId'] = $request->templateId;
        }

        if (null !== $request->trend) {
            @$body['Trend'] = $request->trend;
        }

        if (null !== $request->warningThreshold) {
            @$body['WarningThreshold'] = $request->warningThreshold;
        }

        if (null !== $request->whereCondition) {
            @$body['WhereCondition'] = $request->whereCondition;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateQualityRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a monitoring rule.
     *
     * @param request - CreateQualityRuleRequest
     *
     * @returns CreateQualityRuleResponse
     *
     * @param CreateQualityRuleRequest $request
     *
     * @return CreateQualityRuleResponse
     */
    public function createQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createQualityRuleWithOptions($request, $runtime);
    }

    /**
     * Creates a custom alert rule.
     *
     * @param request - CreateRemindRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateRemindResponse
     *
     * @param CreateRemindRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return CreateRemindResponse
     */
    public function createRemindWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alertInterval) {
            @$body['AlertInterval'] = $request->alertInterval;
        }

        if (null !== $request->alertMethods) {
            @$body['AlertMethods'] = $request->alertMethods;
        }

        if (null !== $request->alertTargets) {
            @$body['AlertTargets'] = $request->alertTargets;
        }

        if (null !== $request->alertUnit) {
            @$body['AlertUnit'] = $request->alertUnit;
        }

        if (null !== $request->baselineIds) {
            @$body['BaselineIds'] = $request->baselineIds;
        }

        if (null !== $request->bizProcessIds) {
            @$body['BizProcessIds'] = $request->bizProcessIds;
        }

        if (null !== $request->detail) {
            @$body['Detail'] = $request->detail;
        }

        if (null !== $request->dndEnd) {
            @$body['DndEnd'] = $request->dndEnd;
        }

        if (null !== $request->maxAlertTimes) {
            @$body['MaxAlertTimes'] = $request->maxAlertTimes;
        }

        if (null !== $request->nodeIds) {
            @$body['NodeIds'] = $request->nodeIds;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->remindName) {
            @$body['RemindName'] = $request->remindName;
        }

        if (null !== $request->remindType) {
            @$body['RemindType'] = $request->remindType;
        }

        if (null !== $request->remindUnit) {
            @$body['RemindUnit'] = $request->remindUnit;
        }

        if (null !== $request->robotUrls) {
            @$body['RobotUrls'] = $request->robotUrls;
        }

        if (null !== $request->webhooks) {
            @$body['Webhooks'] = $request->webhooks;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateRemind',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a custom alert rule.
     *
     * @param request - CreateRemindRequest
     *
     * @returns CreateRemindResponse
     *
     * @param CreateRemindRequest $request
     *
     * @return CreateRemindResponse
     */
    public function createRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createRemindWithOptions($request, $runtime);
    }

    /**
     * Creates or uploads a resource file in DataStudio. The feature that is implemented by calling this operation is the same as the resource creation feature provided in the integrated development environment (IDE).
     *
     * @param request - CreateResourceFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateResourceFileResponse
     *
     * @param CreateResourceFileRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return CreateResourceFileResponse
     */
    public function createResourceFileWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->content) {
            @$body['Content'] = $request->content;
        }

        if (null !== $request->fileDescription) {
            @$body['FileDescription'] = $request->fileDescription;
        }

        if (null !== $request->fileFolderPath) {
            @$body['FileFolderPath'] = $request->fileFolderPath;
        }

        if (null !== $request->fileName) {
            @$body['FileName'] = $request->fileName;
        }

        if (null !== $request->fileType) {
            @$body['FileType'] = $request->fileType;
        }

        if (null !== $request->originResourceName) {
            @$body['OriginResourceName'] = $request->originResourceName;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->registerToCalcEngine) {
            @$body['RegisterToCalcEngine'] = $request->registerToCalcEngine;
        }

        if (null !== $request->resourceFile) {
            @$body['ResourceFile'] = $request->resourceFile;
        }

        if (null !== $request->storageURL) {
            @$body['StorageURL'] = $request->storageURL;
        }

        if (null !== $request->uploadMode) {
            @$body['UploadMode'] = $request->uploadMode;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateResourceFile',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateResourceFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates or uploads a resource file in DataStudio. The feature that is implemented by calling this operation is the same as the resource creation feature provided in the integrated development environment (IDE).
     *
     * @param request - CreateResourceFileRequest
     *
     * @returns CreateResourceFileResponse
     *
     * @param CreateResourceFileRequest $request
     *
     * @return CreateResourceFileResponse
     */
    public function createResourceFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createResourceFileWithOptions($request, $runtime);
    }

    /**
     * @param CreateResourceFileAdvanceRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return CreateResourceFileResponse
     */
    public function createResourceFileAdvance($request, $runtime)
    {
        // Step 0: init client
        $accessKeyId = $this->_credential->getAccessKeyId();
        $accessKeySecret = $this->_credential->getAccessKeySecret();
        $securityToken = $this->_credential->getSecurityToken();
        $credentialType = $this->_credential->getType();
        $openPlatformEndpoint = $this->_openPlatformEndpoint;
        if (null === $openPlatformEndpoint) {
            $openPlatformEndpoint = 'openplatform.aliyuncs.com';
        }

        if (null === $credentialType) {
            $credentialType = 'access_key';
        }

        $authConfig = new Config([
            'accessKeyId' => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'securityToken' => $securityToken,
            'type' => $credentialType,
            'endpoint' => $openPlatformEndpoint,
            'protocol' => $this->_protocol,
            'regionId' => $this->_regionId,
        ]);
        $authClient = new OpenPlatform($authConfig);
        $authRequest = new AuthorizeFileUploadRequest([
            'product' => 'dataworks-public',
            'regionId' => $this->_regionId,
        ]);
        $authResponse = new AuthorizeFileUploadResponse([]);
        $ossConfig = new OSS\Config([
            'accessKeyId' => $accessKeyId,
            'accessKeySecret' => $accessKeySecret,
            'type' => 'access_key',
            'protocol' => $this->_protocol,
            'regionId' => $this->_regionId,
        ]);
        $ossClient = new OSS($ossConfig);
        $fileObj = new FileField([]);
        $ossHeader = new header([]);
        $uploadRequest = new PostObjectRequest([]);
        $ossRuntime = new \AlibabaCloud\Tea\OSSUtils\OSSUtils\RuntimeOptions([]);
        Utils::convert($runtime, $ossRuntime);
        $createResourceFileReq = new CreateResourceFileRequest([]);
        Utils::convert($request, $createResourceFileReq);
        if (null !== $request->resourceFileObject) {
            $authResponse = $authClient->authorizeFileUploadWithOptions($authRequest, $runtime);
            $ossConfig->accessKeyId = $authResponse->body->accessKeyId;
            $ossConfig->endpoint = Utils::getEndpoint($authResponse->body->endpoint, $authResponse->body->useAccelerate, $this->_endpointType);
            $ossClient = new OSS($ossConfig);
            $fileObj = new FileField([
                'filename' => $authResponse->body->objectKey,
                'content' => $request->resourceFileObject,
                'contentType' => '',
            ]);
            $ossHeader = new header([
                'accessKeyId' => $authResponse->body->accessKeyId,
                'policy' => $authResponse->body->encodedPolicy,
                'signature' => $authResponse->body->signature,
                'key' => $authResponse->body->objectKey,
                'file' => $fileObj,
                'successActionStatus' => '201',
            ]);
            $uploadRequest = new PostObjectRequest([
                'bucketName' => $authResponse->body->bucket,
                'header' => $ossHeader,
            ]);
            $ossClient->postObject($uploadRequest, $ossRuntime);
            $createResourceFileReq->resourceFile = 'http://' . $authResponse->body->bucket . '.' . $authResponse->body->endpoint . '/' . $authResponse->body->objectKey . '';
        }

        return $this->createResourceFileWithOptions($createResourceFileReq, $runtime);
    }

    /**
     * Creates a MaxCompute table or view.
     *
     * @param request - CreateTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateTableResponse
     *
     * @param CreateTableRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return CreateTableResponse
     */
    public function createTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appGuid) {
            @$query['AppGuid'] = $request->appGuid;
        }

        if (null !== $request->categoryId) {
            @$query['CategoryId'] = $request->categoryId;
        }

        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->externalTableType) {
            @$query['ExternalTableType'] = $request->externalTableType;
        }

        if (null !== $request->hasPart) {
            @$query['HasPart'] = $request->hasPart;
        }

        if (null !== $request->isView) {
            @$query['IsView'] = $request->isView;
        }

        if (null !== $request->lifeCycle) {
            @$query['LifeCycle'] = $request->lifeCycle;
        }

        if (null !== $request->location) {
            @$query['Location'] = $request->location;
        }

        if (null !== $request->logicalLevelId) {
            @$query['LogicalLevelId'] = $request->logicalLevelId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->physicsLevelId) {
            @$query['PhysicsLevelId'] = $request->physicsLevelId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->schema) {
            @$query['Schema'] = $request->schema;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        if (null !== $request->visibility) {
            @$query['Visibility'] = $request->visibility;
        }

        $body = [];
        if (null !== $request->columns) {
            @$body['Columns'] = $request->columns;
        }

        if (null !== $request->endpoint) {
            @$body['Endpoint'] = $request->endpoint;
        }

        if (null !== $request->envType) {
            @$body['EnvType'] = $request->envType;
        }

        if (null !== $request->themes) {
            @$body['Themes'] = $request->themes;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateTable',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a MaxCompute table or view.
     *
     * @param request - CreateTableRequest
     *
     * @returns CreateTableResponse
     *
     * @param CreateTableRequest $request
     *
     * @return CreateTableResponse
     */
    public function createTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTableWithOptions($request, $runtime);
    }

    /**
     * Creates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - CreateTableLevelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateTableLevelResponse
     *
     * @param CreateTableLevelRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateTableLevelResponse
     */
    public function createTableLevelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->levelType) {
            @$query['LevelType'] = $request->levelType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateTableLevel',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - CreateTableLevelRequest
     *
     * @returns CreateTableLevelResponse
     *
     * @param CreateTableLevelRequest $request
     *
     * @return CreateTableLevelResponse
     */
    public function createTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTableLevelWithOptions($request, $runtime);
    }

    /**
     * Creates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - CreateTableThemeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateTableThemeResponse
     *
     * @param CreateTableThemeRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return CreateTableThemeResponse
     */
    public function createTableThemeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->level) {
            @$query['Level'] = $request->level;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->parentId) {
            @$query['ParentId'] = $request->parentId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'CreateTableTheme',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - CreateTableThemeRequest
     *
     * @returns CreateTableThemeResponse
     *
     * @param CreateTableThemeRequest $request
     *
     * @return CreateTableThemeResponse
     */
    public function createTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createTableThemeWithOptions($request, $runtime);
    }

    /**
     * Creates a file for a function in DataStudio.
     *
     * @param request - CreateUdfFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns CreateUdfFileResponse
     *
     * @param CreateUdfFileRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return CreateUdfFileResponse
     */
    public function createUdfFileWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->className) {
            @$body['ClassName'] = $request->className;
        }

        if (null !== $request->cmdDescription) {
            @$body['CmdDescription'] = $request->cmdDescription;
        }

        if (null !== $request->createFolderIfNotExists) {
            @$body['CreateFolderIfNotExists'] = $request->createFolderIfNotExists;
        }

        if (null !== $request->example) {
            @$body['Example'] = $request->example;
        }

        if (null !== $request->fileFolderPath) {
            @$body['FileFolderPath'] = $request->fileFolderPath;
        }

        if (null !== $request->fileName) {
            @$body['FileName'] = $request->fileName;
        }

        if (null !== $request->functionType) {
            @$body['FunctionType'] = $request->functionType;
        }

        if (null !== $request->parameterDescription) {
            @$body['ParameterDescription'] = $request->parameterDescription;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->resources) {
            @$body['Resources'] = $request->resources;
        }

        if (null !== $request->returnValue) {
            @$body['ReturnValue'] = $request->returnValue;
        }

        if (null !== $request->udfDescription) {
            @$body['UdfDescription'] = $request->udfDescription;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'CreateUdfFile',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return CreateUdfFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a file for a function in DataStudio.
     *
     * @param request - CreateUdfFileRequest
     *
     * @returns CreateUdfFileResponse
     *
     * @param CreateUdfFileRequest $request
     *
     * @return CreateUdfFileResponse
     */
    public function createUdfFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->createUdfFileWithOptions($request, $runtime);
    }

    /**
     * Deletes a baseline based on its ID. You can delete a baseline only if the nodes in the baseline does not have ancestor nodes. You can call the UpdateBaseline operation to delete the relationships between the nodes and their ancestor nodes.
     *
     * @param request - DeleteBaselineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBaselineResponse
     *
     * @param DeleteBaselineRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteBaselineResponse
     */
    public function deleteBaselineWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineId) {
            @$body['BaselineId'] = $request->baselineId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteBaseline',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a baseline based on its ID. You can delete a baseline only if the nodes in the baseline does not have ancestor nodes. You can call the UpdateBaseline operation to delete the relationships between the nodes and their ancestor nodes.
     *
     * @param request - DeleteBaselineRequest
     *
     * @returns DeleteBaselineResponse
     *
     * @param DeleteBaselineRequest $request
     *
     * @return DeleteBaselineResponse
     */
    public function deleteBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBaselineWithOptions($request, $runtime);
    }

    /**
     * @param request - DeleteBusinessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteBusinessResponse
     *
     * @param DeleteBusinessRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return DeleteBusinessResponse
     */
    public function deleteBusinessWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->businessId) {
            @$body['BusinessId'] = $request->businessId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteBusiness',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - DeleteBusinessRequest
     *
     * @returns DeleteBusinessResponse
     *
     * @param DeleteBusinessRequest $request
     *
     * @return DeleteBusinessResponse
     */
    public function deleteBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteBusinessWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Removes a data source.
     *
     * @deprecated OpenAPI DeleteConnection is deprecated
     *
     * @param request - DeleteConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteConnectionResponse
     *
     * @param DeleteConnectionRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteConnectionResponse
     */
    public function deleteConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->connectionId) {
            @$query['ConnectionId'] = $request->connectionId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteConnection',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Removes a data source.
     *
     * @deprecated OpenAPI DeleteConnection is deprecated
     *
     * @param request - DeleteConnectionRequest
     *
     * @returns DeleteConnectionResponse
     *
     * @param DeleteConnectionRequest $request
     *
     * @return DeleteConnectionResponse
     */
    public function deleteConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteConnectionWithOptions($request, $runtime);
    }

    /**
     * Deletes an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks whose MigrationType is set to RealtimeIncremental.
     *
     * @param request - DeleteDIAlarmRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDIAlarmRuleResponse
     *
     * @param DeleteDIAlarmRuleRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteDIAlarmRuleResponse
     */
    public function deleteDIAlarmRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->DIAlarmRuleId) {
            @$body['DIAlarmRuleId'] = $request->DIAlarmRuleId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteDIAlarmRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks whose MigrationType is set to RealtimeIncremental.
     *
     * @param request - DeleteDIAlarmRuleRequest
     *
     * @returns DeleteDIAlarmRuleResponse
     *
     * @param DeleteDIAlarmRuleRequest $request
     *
     * @return DeleteDIAlarmRuleResponse
     */
    public function deleteDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @param request - DeleteDIJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDIJobResponse
     *
     * @param DeleteDIJobRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return DeleteDIJobResponse
     */
    public function deleteDIJobWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->DIJobId) {
            @$body['DIJobId'] = $request->DIJobId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteDIJob',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @param request - DeleteDIJobRequest
     *
     * @returns DeleteDIJobResponse
     *
     * @param DeleteDIJobRequest $request
     *
     * @return DeleteDIJobResponse
     */
    public function deleteDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDIJobWithOptions($request, $runtime);
    }

    /**
     * Deletes a synchronization task. You can call this operation to delete only a real-time synchronization task.
     *
     * @remarks
     * If you want to delete a batch synchronization task, call the DeleteFile operation. For more information, see [Delete a synchronization task](https://help.aliyun.com/document_detail/321443.html).
     *
     * @param request - DeleteDISyncTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDISyncTaskResponse
     *
     * @param DeleteDISyncTaskRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteDISyncTaskResponse
     */
    public function deleteDISyncTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileId) {
            @$query['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDISyncTask',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a synchronization task. You can call this operation to delete only a real-time synchronization task.
     *
     * @remarks
     * If you want to delete a batch synchronization task, call the DeleteFile operation. For more information, see [Delete a synchronization task](https://help.aliyun.com/document_detail/321443.html).
     *
     * @param request - DeleteDISyncTaskRequest
     *
     * @returns DeleteDISyncTaskResponse
     *
     * @param DeleteDISyncTaskRequest $request
     *
     * @return DeleteDISyncTaskResponse
     */
    public function deleteDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * Deletes an API in DataService Studio.
     *
     * @param request - DeleteDataServiceApiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDataServiceApiResponse
     *
     * @param DeleteDataServiceApiRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteDataServiceApiResponse
     */
    public function deleteDataServiceApiWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteDataServiceApi',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an API in DataService Studio.
     *
     * @param request - DeleteDataServiceApiRequest
     *
     * @returns DeleteDataServiceApiResponse
     *
     * @param DeleteDataServiceApiRequest $request
     *
     * @return DeleteDataServiceApiResponse
     */
    public function deleteDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * Revokes the access permissions on an API.
     *
     * @param request - DeleteDataServiceApiAuthorityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDataServiceApiAuthorityResponse
     *
     * @param DeleteDataServiceApiAuthorityRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DeleteDataServiceApiAuthorityResponse
     */
    public function deleteDataServiceApiAuthorityWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->authorizedProjectId) {
            @$body['AuthorizedProjectId'] = $request->authorizedProjectId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteDataServiceApiAuthority',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDataServiceApiAuthorityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes the access permissions on an API.
     *
     * @param request - DeleteDataServiceApiAuthorityRequest
     *
     * @returns DeleteDataServiceApiAuthorityResponse
     *
     * @param DeleteDataServiceApiAuthorityRequest $request
     *
     * @return DeleteDataServiceApiAuthorityResponse
     */
    public function deleteDataServiceApiAuthority($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDataServiceApiAuthorityWithOptions($request, $runtime);
    }

    /**
     * Removes a data source.
     *
     * @param request - DeleteDataSourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteDataSourceResponse
     *
     * @param DeleteDataSourceRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteDataSourceResponse
     */
    public function deleteDataSourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dataSourceId) {
            @$query['DataSourceId'] = $request->dataSourceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteDataSource',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a data source.
     *
     * @param request - DeleteDataSourceRequest
     *
     * @returns DeleteDataSourceResponse
     *
     * @param DeleteDataSourceRequest $request
     *
     * @return DeleteDataSourceResponse
     */
    public function deleteDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteDataSourceWithOptions($request, $runtime);
    }

    /**
     * Deletes a file from DataStudio. If the file has been committed, an asynchronous process is triggered to delete the file in the scheduling system. The value of the DeploymentId parameter returned is used to call the GetDeployment operation to poll the status of the asynchronous process.
     *
     * @param request - DeleteFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteFileResponse
     *
     * @param DeleteFileRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return DeleteFileResponse
     */
    public function deleteFileWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->fileId) {
            @$body['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteFile',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a file from DataStudio. If the file has been committed, an asynchronous process is triggered to delete the file in the scheduling system. The value of the DeploymentId parameter returned is used to call the GetDeployment operation to poll the status of the asynchronous process.
     *
     * @param request - DeleteFileRequest
     *
     * @returns DeleteFileResponse
     *
     * @param DeleteFileRequest $request
     *
     * @return DeleteFileResponse
     */
    public function deleteFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFileWithOptions($request, $runtime);
    }

    /**
     * @param request - DeleteFolderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteFolderResponse
     *
     * @param DeleteFolderRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DeleteFolderResponse
     */
    public function deleteFolderWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->folderId) {
            @$body['FolderId'] = $request->folderId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteFolder',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - DeleteFolderRequest
     *
     * @returns DeleteFolderResponse
     *
     * @param DeleteFolderRequest $request
     *
     * @return DeleteFolderResponse
     */
    public function deleteFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFolderWithOptions($request, $runtime);
    }

    /**
     * Removes a table from a specified category.
     *
     * @param request - DeleteFromMetaCategoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteFromMetaCategoryResponse
     *
     * @param DeleteFromMetaCategoryRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DeleteFromMetaCategoryResponse
     */
    public function deleteFromMetaCategoryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->categoryId) {
            @$query['CategoryId'] = $request->categoryId;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteFromMetaCategory',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteFromMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a table from a specified category.
     *
     * @param request - DeleteFromMetaCategoryRequest
     *
     * @returns DeleteFromMetaCategoryResponse
     *
     * @param DeleteFromMetaCategoryRequest $request
     *
     * @return DeleteFromMetaCategoryResponse
     */
    public function deleteFromMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteFromMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * Delete lineage, supports deleting user-defined lineage relationships.
     *
     * @remarks
     * This API is currently in the trial phase. Users who wish to experience it can apply, and after the administrator adds them to the trial list, they can call this API.
     *
     * @param request - DeleteLineageRelationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteLineageRelationResponse
     *
     * @param DeleteLineageRelationRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteLineageRelationResponse
     */
    public function deleteLineageRelationWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destEntityQualifiedName) {
            @$query['DestEntityQualifiedName'] = $request->destEntityQualifiedName;
        }

        if (null !== $request->relationshipGuid) {
            @$query['RelationshipGuid'] = $request->relationshipGuid;
        }

        if (null !== $request->relationshipType) {
            @$query['RelationshipType'] = $request->relationshipType;
        }

        if (null !== $request->srcEntityQualifiedName) {
            @$query['SrcEntityQualifiedName'] = $request->srcEntityQualifiedName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteLineageRelation',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteLineageRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Delete lineage, supports deleting user-defined lineage relationships.
     *
     * @remarks
     * This API is currently in the trial phase. Users who wish to experience it can apply, and after the administrator adds them to the trial list, they can call this API.
     *
     * @param request - DeleteLineageRelationRequest
     *
     * @returns DeleteLineageRelationResponse
     *
     * @param DeleteLineageRelationRequest $request
     *
     * @return DeleteLineageRelationResponse
     */
    public function deleteLineageRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteLineageRelationWithOptions($request, $runtime);
    }

    /**
     * Deletes a category.
     *
     * @param request - DeleteMetaCategoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteMetaCategoryResponse
     *
     * @param DeleteMetaCategoryRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DeleteMetaCategoryResponse
     */
    public function deleteMetaCategoryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteMetaCategory',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a category.
     *
     * @param request - DeleteMetaCategoryRequest
     *
     * @returns DeleteMetaCategoryResponse
     *
     * @param DeleteMetaCategoryRequest $request
     *
     * @return DeleteMetaCategoryResponse
     */
    public function deleteMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * Deletes a collection.
     *
     * @param request - DeleteMetaCollectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteMetaCollectionResponse
     *
     * @param DeleteMetaCollectionRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return DeleteMetaCollectionResponse
     */
    public function deleteMetaCollectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->qualifiedName) {
            @$query['QualifiedName'] = $request->qualifiedName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteMetaCollection',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMetaCollectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a collection.
     *
     * @param request - DeleteMetaCollectionRequest
     *
     * @returns DeleteMetaCollectionResponse
     *
     * @param DeleteMetaCollectionRequest $request
     *
     * @return DeleteMetaCollectionResponse
     */
    public function deleteMetaCollection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMetaCollectionWithOptions($request, $runtime);
    }

    /**
     * Deletes an entity from a collection.
     *
     * @param request - DeleteMetaCollectionEntityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteMetaCollectionEntityResponse
     *
     * @param DeleteMetaCollectionEntityRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return DeleteMetaCollectionEntityResponse
     */
    public function deleteMetaCollectionEntityWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->collectionQualifiedName) {
            @$query['CollectionQualifiedName'] = $request->collectionQualifiedName;
        }

        if (null !== $request->entityQualifiedName) {
            @$query['EntityQualifiedName'] = $request->entityQualifiedName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteMetaCollectionEntity',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteMetaCollectionEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes an entity from a collection.
     *
     * @param request - DeleteMetaCollectionEntityRequest
     *
     * @returns DeleteMetaCollectionEntityResponse
     *
     * @param DeleteMetaCollectionEntityRequest $request
     *
     * @return DeleteMetaCollectionEntityResponse
     */
    public function deleteMetaCollectionEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteMetaCollectionEntityWithOptions($request, $runtime);
    }

    /**
     * Removes a user from a DataWorks workspace.
     *
     * @param request - DeleteProjectMemberRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteProjectMemberResponse
     *
     * @param DeleteProjectMemberRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteProjectMemberResponse
     */
    public function deleteProjectMemberWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteProjectMember',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteProjectMemberResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a user from a DataWorks workspace.
     *
     * @param request - DeleteProjectMemberRequest
     *
     * @returns DeleteProjectMemberResponse
     *
     * @param DeleteProjectMemberRequest $request
     *
     * @return DeleteProjectMemberResponse
     */
    public function deleteProjectMember($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteProjectMemberWithOptions($request, $runtime);
    }

    /**
     * Deletes a partition filter expression.
     *
     * @param request - DeleteQualityEntityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteQualityEntityResponse
     *
     * @param DeleteQualityEntityRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteQualityEntityResponse
     */
    public function deleteQualityEntityWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->entityId) {
            @$body['EntityId'] = $request->entityId;
        }

        if (null !== $request->envType) {
            @$body['EnvType'] = $request->envType;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteQualityEntity',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteQualityEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a partition filter expression.
     *
     * @param request - DeleteQualityEntityRequest
     *
     * @returns DeleteQualityEntityResponse
     *
     * @param DeleteQualityEntityRequest $request
     *
     * @return DeleteQualityEntityResponse
     */
    public function deleteQualityEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityEntityWithOptions($request, $runtime);
    }

    /**
     * Deletes a subscriber of a partition filter expression.
     *
     * @remarks
     * In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transform, and load (ETL). This way, you can prevent tasks from producing unexpected dirty data that affects the smooth running of tasks and business decision-making. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule that is created based on the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors at the earliest opportunity. For more information, see [Configure monitoring rules](https://help.aliyun.com/document_detail/73690.html).
     *
     * @param request - DeleteQualityFollowerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteQualityFollowerResponse
     *
     * @param DeleteQualityFollowerRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DeleteQualityFollowerResponse
     */
    public function deleteQualityFollowerWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->followerId) {
            @$body['FollowerId'] = $request->followerId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteQualityFollower',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a subscriber of a partition filter expression.
     *
     * @remarks
     * In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transform, and load (ETL). This way, you can prevent tasks from producing unexpected dirty data that affects the smooth running of tasks and business decision-making. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule that is created based on the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors at the earliest opportunity. For more information, see [Configure monitoring rules](https://help.aliyun.com/document_detail/73690.html).
     *
     * @param request - DeleteQualityFollowerRequest
     *
     * @returns DeleteQualityFollowerResponse
     *
     * @param DeleteQualityFollowerRequest $request
     *
     * @return DeleteQualityFollowerResponse
     */
    public function deleteQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * @param request - DeleteQualityRelativeNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteQualityRelativeNodeResponse
     *
     * @param DeleteQualityRelativeNodeRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return DeleteQualityRelativeNodeResponse
     */
    public function deleteQualityRelativeNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->envType) {
            @$body['EnvType'] = $request->envType;
        }

        if (null !== $request->matchExpression) {
            @$body['MatchExpression'] = $request->matchExpression;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->tableName) {
            @$body['TableName'] = $request->tableName;
        }

        if (null !== $request->targetNodeProjectId) {
            @$body['TargetNodeProjectId'] = $request->targetNodeProjectId;
        }

        if (null !== $request->targetNodeProjectName) {
            @$body['TargetNodeProjectName'] = $request->targetNodeProjectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteQualityRelativeNode',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteQualityRelativeNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - DeleteQualityRelativeNodeRequest
     *
     * @returns DeleteQualityRelativeNodeResponse
     *
     * @param DeleteQualityRelativeNodeRequest $request
     *
     * @return DeleteQualityRelativeNodeResponse
     */
    public function deleteQualityRelativeNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityRelativeNodeWithOptions($request, $runtime);
    }

    /**
     * Deletes a monitoring rule.
     *
     * @param request - DeleteQualityRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteQualityRuleResponse
     *
     * @param DeleteQualityRuleRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return DeleteQualityRuleResponse
     */
    public function deleteQualityRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->ruleId) {
            @$body['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteQualityRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a monitoring rule.
     *
     * @param request - DeleteQualityRuleRequest
     *
     * @returns DeleteQualityRuleResponse
     *
     * @param DeleteQualityRuleRequest $request
     *
     * @return DeleteQualityRuleResponse
     */
    public function deleteQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteQualityRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes sensitive field types.
     *
     * @param request - DeleteRecognizeRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRecognizeRuleResponse
     *
     * @param DeleteRecognizeRuleRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DeleteRecognizeRuleResponse
     */
    public function deleteRecognizeRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->sensitiveId) {
            @$body['SensitiveId'] = $request->sensitiveId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteRecognizeRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRecognizeRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes sensitive field types.
     *
     * @param request - DeleteRecognizeRuleRequest
     *
     * @returns DeleteRecognizeRuleResponse
     *
     * @param DeleteRecognizeRuleRequest $request
     *
     * @return DeleteRecognizeRuleResponse
     */
    public function deleteRecognizeRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRecognizeRuleWithOptions($request, $runtime);
    }

    /**
     * Deletes a custom alert rule.
     *
     * @param request - DeleteRemindRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteRemindResponse
     *
     * @param DeleteRemindRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return DeleteRemindResponse
     */
    public function deleteRemindWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->remindId) {
            @$body['RemindId'] = $request->remindId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeleteRemind',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a custom alert rule.
     *
     * @param request - DeleteRemindRequest
     *
     * @returns DeleteRemindResponse
     *
     * @param DeleteRemindRequest $request
     *
     * @return DeleteRemindResponse
     */
    public function deleteRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteRemindWithOptions($request, $runtime);
    }

    /**
     * @param request - DeleteTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteTableResponse
     *
     * @param DeleteTableRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return DeleteTableResponse
     */
    public function deleteTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appGuid) {
            @$query['AppGuid'] = $request->appGuid;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->schema) {
            @$query['Schema'] = $request->schema;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteTable',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - DeleteTableRequest
     *
     * @returns DeleteTableResponse
     *
     * @param DeleteTableRequest $request
     *
     * @return DeleteTableResponse
     */
    public function deleteTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTableWithOptions($request, $runtime);
    }

    /**
     * Deletes a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - DeleteTableLevelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteTableLevelResponse
     *
     * @param DeleteTableLevelRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteTableLevelResponse
     */
    public function deleteTableLevelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->levelId) {
            @$query['LevelId'] = $request->levelId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteTableLevel',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - DeleteTableLevelRequest
     *
     * @returns DeleteTableLevelResponse
     *
     * @param DeleteTableLevelRequest $request
     *
     * @return DeleteTableLevelResponse
     */
    public function deleteTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTableLevelWithOptions($request, $runtime);
    }

    /**
     * Deletes a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - DeleteTableThemeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeleteTableThemeResponse
     *
     * @param DeleteTableThemeRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeleteTableThemeResponse
     */
    public function deleteTableThemeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->themeId) {
            @$query['ThemeId'] = $request->themeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeleteTableTheme',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeleteTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - DeleteTableThemeRequest
     *
     * @returns DeleteTableThemeResponse
     *
     * @param DeleteTableThemeRequest $request
     *
     * @return DeleteTableThemeResponse
     */
    public function deleteTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deleteTableThemeWithOptions($request, $runtime);
    }

    /**
     * Deploys a real-time synchronization task.
     *
     * @param request - DeployDISyncTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeployDISyncTaskResponse
     *
     * @param DeployDISyncTaskRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return DeployDISyncTaskResponse
     */
    public function deployDISyncTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileId) {
            @$query['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DeployDISyncTask',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeployDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deploys a real-time synchronization task.
     *
     * @param request - DeployDISyncTaskRequest
     *
     * @returns DeployDISyncTaskResponse
     *
     * @param DeployDISyncTaskRequest $request
     *
     * @return DeployDISyncTaskResponse
     */
    public function deployDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deployDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * Deploys a file to the production environment.
     *
     * @param request - DeployFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DeployFileResponse
     *
     * @param DeployFileRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return DeployFileResponse
     */
    public function deployFileWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->comment) {
            @$body['Comment'] = $request->comment;
        }

        if (null !== $request->fileId) {
            @$body['FileId'] = $request->fileId;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DeployFile',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DeployFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deploys a file to the production environment.
     *
     * @param request - DeployFileRequest
     *
     * @returns DeployFileResponse
     *
     * @param DeployFileRequest $request
     *
     * @return DeployFileResponse
     */
    public function deployFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->deployFileWithOptions($request, $runtime);
    }

    /**
     * Masks data.
     *
     * @param request - DesensitizeDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DesensitizeDataResponse
     *
     * @param DesensitizeDataRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return DesensitizeDataResponse
     */
    public function desensitizeDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DesensitizeData',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DesensitizeDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Masks data.
     *
     * @param request - DesensitizeDataRequest
     *
     * @returns DesensitizeDataResponse
     *
     * @param DesensitizeDataRequest $request
     *
     * @return DesensitizeDataResponse
     */
    public function desensitizeData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->desensitizeDataWithOptions($request, $runtime);
    }

    /**
     * Adds or modifies a data masking rule.
     *
     * @param tmpReq - DsgDesensPlanAddOrUpdateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgDesensPlanAddOrUpdateResponse
     *
     * @param DsgDesensPlanAddOrUpdateRequest $tmpReq
     * @param RuntimeOptions                  $runtime
     *
     * @return DsgDesensPlanAddOrUpdateResponse
     */
    public function dsgDesensPlanAddOrUpdateWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgDesensPlanAddOrUpdateShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->desensRules) {
            $request->desensRulesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->desensRules, 'DesensRules', 'json');
        }

        $query = [];
        if (null !== $request->desensRulesShrink) {
            @$query['DesensRules'] = $request->desensRulesShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgDesensPlanAddOrUpdate',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgDesensPlanAddOrUpdateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds or modifies a data masking rule.
     *
     * @param request - DsgDesensPlanAddOrUpdateRequest
     *
     * @returns DsgDesensPlanAddOrUpdateResponse
     *
     * @param DsgDesensPlanAddOrUpdateRequest $request
     *
     * @return DsgDesensPlanAddOrUpdateResponse
     */
    public function dsgDesensPlanAddOrUpdate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanAddOrUpdateWithOptions($request, $runtime);
    }

    /**
     * Deletes a data masking rule created in Data Security Guard.
     *
     * @param tmpReq - DsgDesensPlanDeleteRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgDesensPlanDeleteResponse
     *
     * @param DsgDesensPlanDeleteRequest $tmpReq
     * @param RuntimeOptions             $runtime
     *
     * @return DsgDesensPlanDeleteResponse
     */
    public function dsgDesensPlanDeleteWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgDesensPlanDeleteShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->ids) {
            $request->idsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }

        $query = [];
        if (null !== $request->idsShrink) {
            @$query['Ids'] = $request->idsShrink;
        }

        if (null !== $request->sceneCode) {
            @$query['SceneCode'] = $request->sceneCode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgDesensPlanDelete',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgDesensPlanDeleteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a data masking rule created in Data Security Guard.
     *
     * @param request - DsgDesensPlanDeleteRequest
     *
     * @returns DsgDesensPlanDeleteResponse
     *
     * @param DsgDesensPlanDeleteRequest $request
     *
     * @return DsgDesensPlanDeleteResponse
     */
    public function dsgDesensPlanDelete($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanDeleteWithOptions($request, $runtime);
    }

    /**
     * Queries a list of data masking rules.
     *
     * @param request - DsgDesensPlanQueryListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgDesensPlanQueryListResponse
     *
     * @param DsgDesensPlanQueryListRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return DsgDesensPlanQueryListResponse
     */
    public function dsgDesensPlanQueryListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgDesensPlanQueryList',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgDesensPlanQueryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of data masking rules.
     *
     * @param request - DsgDesensPlanQueryListRequest
     *
     * @returns DsgDesensPlanQueryListResponse
     *
     * @param DsgDesensPlanQueryListRequest $request
     *
     * @return DsgDesensPlanQueryListResponse
     */
    public function dsgDesensPlanQueryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanQueryListWithOptions($request, $runtime);
    }

    /**
     * Modifies the status of a data masking rule.
     *
     * @param tmpReq - DsgDesensPlanUpdateStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgDesensPlanUpdateStatusResponse
     *
     * @param DsgDesensPlanUpdateStatusRequest $tmpReq
     * @param RuntimeOptions                   $runtime
     *
     * @return DsgDesensPlanUpdateStatusResponse
     */
    public function dsgDesensPlanUpdateStatusWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgDesensPlanUpdateStatusShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->ids) {
            $request->idsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }

        $query = [];
        if (null !== $request->idsShrink) {
            @$query['Ids'] = $request->idsShrink;
        }

        if (null !== $request->sceneCode) {
            @$query['SceneCode'] = $request->sceneCode;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgDesensPlanUpdateStatus',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgDesensPlanUpdateStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the status of a data masking rule.
     *
     * @param request - DsgDesensPlanUpdateStatusRequest
     *
     * @returns DsgDesensPlanUpdateStatusResponse
     *
     * @param DsgDesensPlanUpdateStatusRequest $request
     *
     * @return DsgDesensPlanUpdateStatusResponse
     */
    public function dsgDesensPlanUpdateStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgDesensPlanUpdateStatusWithOptions($request, $runtime);
    }

    /**
     * Queries a list of compute engines of different types in the current tenant.
     *
     * @param request - DsgPlatformQueryProjectsAndSchemaFromMetaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgPlatformQueryProjectsAndSchemaFromMetaResponse
     *
     * @param DsgPlatformQueryProjectsAndSchemaFromMetaRequest $request
     * @param RuntimeOptions                                   $runtime
     *
     * @return DsgPlatformQueryProjectsAndSchemaFromMetaResponse
     */
    public function dsgPlatformQueryProjectsAndSchemaFromMetaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgPlatformQueryProjectsAndSchemaFromMeta',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgPlatformQueryProjectsAndSchemaFromMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of compute engines of different types in the current tenant.
     *
     * @param request - DsgPlatformQueryProjectsAndSchemaFromMetaRequest
     *
     * @returns DsgPlatformQueryProjectsAndSchemaFromMetaResponse
     *
     * @param DsgPlatformQueryProjectsAndSchemaFromMetaRequest $request
     *
     * @return DsgPlatformQueryProjectsAndSchemaFromMetaResponse
     */
    public function dsgPlatformQueryProjectsAndSchemaFromMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgPlatformQueryProjectsAndSchemaFromMetaWithOptions($request, $runtime);
    }

    /**
     * Queries a list of available sensitive field type templates and the data masking rules supported by the templates. You can refer to the response parameters of this operation to configure a data masking rule.
     *
     * @param request - DsgQueryDefaultTemplatesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgQueryDefaultTemplatesResponse
     *
     * @param DsgQueryDefaultTemplatesRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return DsgQueryDefaultTemplatesResponse
     */
    public function dsgQueryDefaultTemplatesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgQueryDefaultTemplates',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgQueryDefaultTemplatesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of available sensitive field type templates and the data masking rules supported by the templates. You can refer to the response parameters of this operation to configure a data masking rule.
     *
     * @param request - DsgQueryDefaultTemplatesRequest
     *
     * @returns DsgQueryDefaultTemplatesResponse
     *
     * @param DsgQueryDefaultTemplatesRequest $request
     *
     * @return DsgQueryDefaultTemplatesResponse
     */
    public function dsgQueryDefaultTemplates($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgQueryDefaultTemplatesWithOptions($request, $runtime);
    }

    /**
     * Queries the identification results of sensitive data.
     *
     * @remarks
     * The query capability of the API operation is similar to the query feature in Data Security Guard in the DataWorks console. The API operation can be used to query the identification results of sensitive data of a tenant based on the association with the tenant ID.
     * *   You can search for a specific identification result based on filter conditions such as data source type and workspace.
     * *   You can sort the identification results of sensitive data of a tenant based on the values of a field in ascending or descending order.
     * *   This operation supports paged query.
     *
     * @param request - DsgQuerySensResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgQuerySensResultResponse
     *
     * @param DsgQuerySensResultRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return DsgQuerySensResultResponse
     */
    public function dsgQuerySensResultWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->col) {
            @$body['Col'] = $request->col;
        }

        if (null !== $request->dbType) {
            @$body['DbType'] = $request->dbType;
        }

        if (null !== $request->level) {
            @$body['Level'] = $request->level;
        }

        if (null !== $request->nodeName) {
            @$body['NodeName'] = $request->nodeName;
        }

        if (null !== $request->order) {
            @$body['Order'] = $request->order;
        }

        if (null !== $request->orderField) {
            @$body['OrderField'] = $request->orderField;
        }

        if (null !== $request->pageNo) {
            @$body['PageNo'] = $request->pageNo;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->schemaName) {
            @$body['SchemaName'] = $request->schemaName;
        }

        if (null !== $request->sensStatus) {
            @$body['SensStatus'] = $request->sensStatus;
        }

        if (null !== $request->sensitiveId) {
            @$body['SensitiveId'] = $request->sensitiveId;
        }

        if (null !== $request->sensitiveName) {
            @$body['SensitiveName'] = $request->sensitiveName;
        }

        if (null !== $request->table) {
            @$body['Table'] = $request->table;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DsgQuerySensResult',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgQuerySensResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the identification results of sensitive data.
     *
     * @remarks
     * The query capability of the API operation is similar to the query feature in Data Security Guard in the DataWorks console. The API operation can be used to query the identification results of sensitive data of a tenant based on the association with the tenant ID.
     * *   You can search for a specific identification result based on filter conditions such as data source type and workspace.
     * *   You can sort the identification results of sensitive data of a tenant based on the values of a field in ascending or descending order.
     * *   This operation supports paged query.
     *
     * @param request - DsgQuerySensResultRequest
     *
     * @returns DsgQuerySensResultResponse
     *
     * @param DsgQuerySensResultRequest $request
     *
     * @return DsgQuerySensResultResponse
     */
    public function dsgQuerySensResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgQuerySensResultWithOptions($request, $runtime);
    }

    /**
     * Starts a sensitive data identification task in Data Security Guard.
     *
     * @param tmpReq - DsgRunSensIdentifyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgRunSensIdentifyResponse
     *
     * @param DsgRunSensIdentifyRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return DsgRunSensIdentifyResponse
     */
    public function dsgRunSensIdentifyWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgRunSensIdentifyShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->esMetaParams) {
            $request->esMetaParamsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->esMetaParams, 'EsMetaParams', 'json');
        }

        $body = [];
        if (null !== $request->esMetaParamsShrink) {
            @$body['EsMetaParams'] = $request->esMetaParamsShrink;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DsgRunSensIdentify',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgRunSensIdentifyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts a sensitive data identification task in Data Security Guard.
     *
     * @param request - DsgRunSensIdentifyRequest
     *
     * @returns DsgRunSensIdentifyResponse
     *
     * @param DsgRunSensIdentifyRequest $request
     *
     * @return DsgRunSensIdentifyResponse
     */
    public function dsgRunSensIdentify($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgRunSensIdentifyWithOptions($request, $runtime);
    }

    /**
     * Adds or modifies a level-2 data masking scenario.
     *
     * @param tmpReq - DsgSceneAddOrUpdateSceneRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgSceneAddOrUpdateSceneResponse
     *
     * @param DsgSceneAddOrUpdateSceneRequest $tmpReq
     * @param RuntimeOptions                  $runtime
     *
     * @return DsgSceneAddOrUpdateSceneResponse
     */
    public function dsgSceneAddOrUpdateSceneWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgSceneAddOrUpdateSceneShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->scenes) {
            $request->scenesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->scenes, 'scenes', 'json');
        }

        $query = [];
        if (null !== $request->scenesShrink) {
            @$query['scenes'] = $request->scenesShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgSceneAddOrUpdateScene',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgSceneAddOrUpdateSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds or modifies a level-2 data masking scenario.
     *
     * @param request - DsgSceneAddOrUpdateSceneRequest
     *
     * @returns DsgSceneAddOrUpdateSceneResponse
     *
     * @param DsgSceneAddOrUpdateSceneRequest $request
     *
     * @return DsgSceneAddOrUpdateSceneResponse
     */
    public function dsgSceneAddOrUpdateScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgSceneAddOrUpdateSceneWithOptions($request, $runtime);
    }

    /**
     * Queries a list of data masking scenarios.
     *
     * @param request - DsgSceneQuerySceneListByNameRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgSceneQuerySceneListByNameResponse
     *
     * @param DsgSceneQuerySceneListByNameRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return DsgSceneQuerySceneListByNameResponse
     */
    public function dsgSceneQuerySceneListByNameWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgSceneQuerySceneListByName',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgSceneQuerySceneListByNameResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of data masking scenarios.
     *
     * @param request - DsgSceneQuerySceneListByNameRequest
     *
     * @returns DsgSceneQuerySceneListByNameResponse
     *
     * @param DsgSceneQuerySceneListByNameRequest $request
     *
     * @return DsgSceneQuerySceneListByNameResponse
     */
    public function dsgSceneQuerySceneListByName($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgSceneQuerySceneListByNameWithOptions($request, $runtime);
    }

    /**
     * Deletes a level-2 data masking scenario created in Data Security Guard.
     *
     * @param tmpReq - DsgScenedDeleteSceneRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgScenedDeleteSceneResponse
     *
     * @param DsgScenedDeleteSceneRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return DsgScenedDeleteSceneResponse
     */
    public function dsgScenedDeleteSceneWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgScenedDeleteSceneShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->ids) {
            $request->idsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }

        $query = [];
        if (null !== $request->idsShrink) {
            @$query['Ids'] = $request->idsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgScenedDeleteScene',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgScenedDeleteSceneResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a level-2 data masking scenario created in Data Security Guard.
     *
     * @param request - DsgScenedDeleteSceneRequest
     *
     * @returns DsgScenedDeleteSceneResponse
     *
     * @param DsgScenedDeleteSceneRequest $request
     *
     * @return DsgScenedDeleteSceneResponse
     */
    public function dsgScenedDeleteScene($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgScenedDeleteSceneWithOptions($request, $runtime);
    }

    /**
     * Stops a sensitive data identification task.
     *
     * @param request - DsgStopSensIdentifyRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgStopSensIdentifyResponse
     *
     * @param DsgStopSensIdentifyRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return DsgStopSensIdentifyResponse
     */
    public function dsgStopSensIdentifyWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->jobId) {
            @$body['JobId'] = $request->jobId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'DsgStopSensIdentify',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgStopSensIdentifyResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops a sensitive data identification task.
     *
     * @param request - DsgStopSensIdentifyRequest
     *
     * @returns DsgStopSensIdentifyResponse
     *
     * @param DsgStopSensIdentifyRequest $request
     *
     * @return DsgStopSensIdentifyResponse
     */
    public function dsgStopSensIdentify($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgStopSensIdentifyWithOptions($request, $runtime);
    }

    /**
     * Adds or modifies a user group.
     *
     * @param tmpReq - DsgUserGroupAddOrUpdateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgUserGroupAddOrUpdateResponse
     *
     * @param DsgUserGroupAddOrUpdateRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return DsgUserGroupAddOrUpdateResponse
     */
    public function dsgUserGroupAddOrUpdateWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgUserGroupAddOrUpdateShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->userGroups) {
            $request->userGroupsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->userGroups, 'UserGroups', 'json');
        }

        $query = [];
        if (null !== $request->userGroupsShrink) {
            @$query['UserGroups'] = $request->userGroupsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgUserGroupAddOrUpdate',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgUserGroupAddOrUpdateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds or modifies a user group.
     *
     * @param request - DsgUserGroupAddOrUpdateRequest
     *
     * @returns DsgUserGroupAddOrUpdateResponse
     *
     * @param DsgUserGroupAddOrUpdateRequest $request
     *
     * @return DsgUserGroupAddOrUpdateResponse
     */
    public function dsgUserGroupAddOrUpdate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupAddOrUpdateWithOptions($request, $runtime);
    }

    /**
     * Deletes a user group configured in Data Security Guard.
     *
     * @param tmpReq - DsgUserGroupDeleteRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgUserGroupDeleteResponse
     *
     * @param DsgUserGroupDeleteRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return DsgUserGroupDeleteResponse
     */
    public function dsgUserGroupDeleteWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgUserGroupDeleteShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->ids) {
            $request->idsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }

        $query = [];
        if (null !== $request->idsShrink) {
            @$query['Ids'] = $request->idsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgUserGroupDelete',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgUserGroupDeleteResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a user group configured in Data Security Guard.
     *
     * @param request - DsgUserGroupDeleteRequest
     *
     * @returns DsgUserGroupDeleteResponse
     *
     * @param DsgUserGroupDeleteRequest $request
     *
     * @return DsgUserGroupDeleteResponse
     */
    public function dsgUserGroupDelete($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupDeleteWithOptions($request, $runtime);
    }

    /**
     * Queries a list of MaxCompute roles that can be selected by the members of a user group when the user group is created or modified by the tenant in Data Security Guard.
     *
     * @param request - DsgUserGroupGetOdpsRoleGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgUserGroupGetOdpsRoleGroupsResponse
     *
     * @param DsgUserGroupGetOdpsRoleGroupsRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return DsgUserGroupGetOdpsRoleGroupsResponse
     */
    public function dsgUserGroupGetOdpsRoleGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgUserGroupGetOdpsRoleGroups',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgUserGroupGetOdpsRoleGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of MaxCompute roles that can be selected by the members of a user group when the user group is created or modified by the tenant in Data Security Guard.
     *
     * @param request - DsgUserGroupGetOdpsRoleGroupsRequest
     *
     * @returns DsgUserGroupGetOdpsRoleGroupsResponse
     *
     * @param DsgUserGroupGetOdpsRoleGroupsRequest $request
     *
     * @return DsgUserGroupGetOdpsRoleGroupsResponse
     */
    public function dsgUserGroupGetOdpsRoleGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupGetOdpsRoleGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of user groups in Data Security Guard.
     *
     * @param request - DsgUserGroupQueryListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgUserGroupQueryListResponse
     *
     * @param DsgUserGroupQueryListRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DsgUserGroupQueryListResponse
     */
    public function dsgUserGroupQueryListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgUserGroupQueryList',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgUserGroupQueryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of user groups in Data Security Guard.
     *
     * @param request - DsgUserGroupQueryListRequest
     *
     * @returns DsgUserGroupQueryListResponse
     *
     * @param DsgUserGroupQueryListRequest $request
     *
     * @return DsgUserGroupQueryListResponse
     */
    public function dsgUserGroupQueryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupQueryListWithOptions($request, $runtime);
    }

    /**
     * Queries a list of users or roles of the current tenant.
     *
     * @param request - DsgUserGroupQueryUserListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgUserGroupQueryUserListResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return DsgUserGroupQueryUserListResponse
     */
    public function dsgUserGroupQueryUserListWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'DsgUserGroupQueryUserList',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgUserGroupQueryUserListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of users or roles of the current tenant.
     *
     * @returns DsgUserGroupQueryUserListResponse
     *
     * @return DsgUserGroupQueryUserListResponse
     */
    public function dsgUserGroupQueryUserList()
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgUserGroupQueryUserListWithOptions($runtime);
    }

    /**
     * Adds or modifies a data masking whitelist.
     *
     * @param tmpReq - DsgWhiteListAddOrUpdateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgWhiteListAddOrUpdateResponse
     *
     * @param DsgWhiteListAddOrUpdateRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return DsgWhiteListAddOrUpdateResponse
     */
    public function dsgWhiteListAddOrUpdateWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgWhiteListAddOrUpdateShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->whiteLists) {
            $request->whiteListsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->whiteLists, 'WhiteLists', 'json');
        }

        $query = [];
        if (null !== $request->whiteListsShrink) {
            @$query['WhiteLists'] = $request->whiteListsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgWhiteListAddOrUpdate',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgWhiteListAddOrUpdateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Adds or modifies a data masking whitelist.
     *
     * @param request - DsgWhiteListAddOrUpdateRequest
     *
     * @returns DsgWhiteListAddOrUpdateResponse
     *
     * @param DsgWhiteListAddOrUpdateRequest $request
     *
     * @return DsgWhiteListAddOrUpdateResponse
     */
    public function dsgWhiteListAddOrUpdate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgWhiteListAddOrUpdateWithOptions($request, $runtime);
    }

    /**
     * Deletes a data masking whitelist configured in Data Security Guard.
     *
     * @param tmpReq - DsgWhiteListDeleteListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgWhiteListDeleteListResponse
     *
     * @param DsgWhiteListDeleteListRequest $tmpReq
     * @param RuntimeOptions                $runtime
     *
     * @return DsgWhiteListDeleteListResponse
     */
    public function dsgWhiteListDeleteListWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new DsgWhiteListDeleteListShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->ids) {
            $request->idsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->ids, 'Ids', 'json');
        }

        $query = [];
        if (null !== $request->idsShrink) {
            @$query['Ids'] = $request->idsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgWhiteListDeleteList',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgWhiteListDeleteListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Deletes a data masking whitelist configured in Data Security Guard.
     *
     * @param request - DsgWhiteListDeleteListRequest
     *
     * @returns DsgWhiteListDeleteListResponse
     *
     * @param DsgWhiteListDeleteListRequest $request
     *
     * @return DsgWhiteListDeleteListResponse
     */
    public function dsgWhiteListDeleteList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgWhiteListDeleteListWithOptions($request, $runtime);
    }

    /**
     * Queries a data masking whitelist.
     *
     * @param request - DsgWhiteListQueryListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns DsgWhiteListQueryListResponse
     *
     * @param DsgWhiteListQueryListRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return DsgWhiteListQueryListResponse
     */
    public function dsgWhiteListQueryListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'DsgWhiteListQueryList',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return DsgWhiteListQueryListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a data masking whitelist.
     *
     * @param request - DsgWhiteListQueryListRequest
     *
     * @returns DsgWhiteListQueryListResponse
     *
     * @param DsgWhiteListQueryListRequest $request
     *
     * @return DsgWhiteListQueryListResponse
     */
    public function dsgWhiteListQueryList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->dsgWhiteListQueryListWithOptions($request, $runtime);
    }

    /**
     * Edits a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
     *
     * @param request - EditRecognizeRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EditRecognizeRuleResponse
     *
     * @param EditRecognizeRuleRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return EditRecognizeRuleResponse
     */
    public function editRecognizeRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->accountName) {
            @$body['AccountName'] = $request->accountName;
        }

        if (null !== $request->colExclude) {
            @$body['ColExclude'] = $request->colExclude;
        }

        if (null !== $request->colScan) {
            @$body['ColScan'] = $request->colScan;
        }

        if (null !== $request->commentScan) {
            @$body['CommentScan'] = $request->commentScan;
        }

        if (null !== $request->contentScan) {
            @$body['ContentScan'] = $request->contentScan;
        }

        if (null !== $request->hitThreshold) {
            @$body['HitThreshold'] = $request->hitThreshold;
        }

        if (null !== $request->levelName) {
            @$body['LevelName'] = $request->levelName;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->nodeParent) {
            @$body['NodeParent'] = $request->nodeParent;
        }

        if (null !== $request->operationType) {
            @$body['OperationType'] = $request->operationType;
        }

        if (null !== $request->recognizeRules) {
            @$body['RecognizeRules'] = $request->recognizeRules;
        }

        if (null !== $request->recognizeRulesType) {
            @$body['RecognizeRulesType'] = $request->recognizeRulesType;
        }

        if (null !== $request->sensitiveDescription) {
            @$body['SensitiveDescription'] = $request->sensitiveDescription;
        }

        if (null !== $request->sensitiveId) {
            @$body['SensitiveId'] = $request->sensitiveId;
        }

        if (null !== $request->sensitiveName) {
            @$body['SensitiveName'] = $request->sensitiveName;
        }

        if (null !== $request->status) {
            @$body['Status'] = $request->status;
        }

        if (null !== $request->templateId) {
            @$body['TemplateId'] = $request->templateId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        if (null !== $request->level) {
            @$body['level'] = $request->level;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'EditRecognizeRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EditRecognizeRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Edits a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
     *
     * @param request - EditRecognizeRuleRequest
     *
     * @returns EditRecognizeRuleResponse
     *
     * @param EditRecognizeRuleRequest $request
     *
     * @return EditRecognizeRuleResponse
     */
    public function editRecognizeRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->editRecognizeRuleWithOptions($request, $runtime);
    }

    /**
     * @param request - EstablishRelationTableToBusinessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns EstablishRelationTableToBusinessResponse
     *
     * @param EstablishRelationTableToBusinessRequest $request
     * @param RuntimeOptions                          $runtime
     *
     * @return EstablishRelationTableToBusinessResponse
     */
    public function establishRelationTableToBusinessWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->businessId) {
            @$body['BusinessId'] = $request->businessId;
        }

        if (null !== $request->folderId) {
            @$body['FolderId'] = $request->folderId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->tableGuid) {
            @$body['TableGuid'] = $request->tableGuid;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'EstablishRelationTableToBusiness',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return EstablishRelationTableToBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - EstablishRelationTableToBusinessRequest
     *
     * @returns EstablishRelationTableToBusinessResponse
     *
     * @param EstablishRelationTableToBusinessRequest $request
     *
     * @return EstablishRelationTableToBusinessResponse
     */
    public function establishRelationTableToBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->establishRelationTableToBusinessWithOptions($request, $runtime);
    }

    /**
     * Exports a list of data sources.
     *
     * @param request - ExportDataSourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ExportDataSourcesResponse
     *
     * @param ExportDataSourcesRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ExportDataSourcesResponse
     */
    public function exportDataSourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ExportDataSources',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ExportDataSourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Exports a list of data sources.
     *
     * @param request - ExportDataSourcesRequest
     *
     * @returns ExportDataSourcesResponse
     *
     * @param ExportDataSourcesRequest $request
     *
     * @return ExportDataSourcesResponse
     */
    public function exportDataSources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->exportDataSourcesWithOptions($request, $runtime);
    }

    /**
     * Generates an ID for an asynchronous thread that is used to create a synchronization task in Data Integration.
     *
     * @remarks
     * DataWorks allows you to use the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to directly create a batch synchronization task in Data Integration. To create a real-time synchronization task or another type of synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can use the parameters as request parameters of [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) and call the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a real-time synchronization task or another type of synchronization task. DataWorks allows you to create real-time synchronization tasks and other types of synchronization tasks in Data Integration only in asynchronous mode.
     *
     * @param request - GenerateDISyncTaskConfigForCreatingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GenerateDISyncTaskConfigForCreatingResponse
     *
     * @param GenerateDISyncTaskConfigForCreatingRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return GenerateDISyncTaskConfigForCreatingResponse
     */
    public function generateDISyncTaskConfigForCreatingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskParam) {
            @$query['TaskParam'] = $request->taskParam;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GenerateDISyncTaskConfigForCreating',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GenerateDISyncTaskConfigForCreatingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Generates an ID for an asynchronous thread that is used to create a synchronization task in Data Integration.
     *
     * @remarks
     * DataWorks allows you to use the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to directly create a batch synchronization task in Data Integration. To create a real-time synchronization task or another type of synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can use the parameters as request parameters of [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) and call the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a real-time synchronization task or another type of synchronization task. DataWorks allows you to create real-time synchronization tasks and other types of synchronization tasks in Data Integration only in asynchronous mode.
     *
     * @param request - GenerateDISyncTaskConfigForCreatingRequest
     *
     * @returns GenerateDISyncTaskConfigForCreatingResponse
     *
     * @param GenerateDISyncTaskConfigForCreatingRequest $request
     *
     * @return GenerateDISyncTaskConfigForCreatingResponse
     */
    public function generateDISyncTaskConfigForCreating($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateDISyncTaskConfigForCreatingWithOptions($request, $runtime);
    }

    /**
     * Generates the JSON for an asynchronous thread that is used to update a real-time synchronization task in Data Integration.
     *
     * @remarks
     * DataWorks allows you to use only the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To update a real-time synchronization task, you must first call the GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the UpdateDISyncTask operation and use the parameters as request parameters to update a real-time synchronization task in Data Integration. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
     *
     * @param request - GenerateDISyncTaskConfigForUpdatingRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GenerateDISyncTaskConfigForUpdatingResponse
     *
     * @param GenerateDISyncTaskConfigForUpdatingRequest $request
     * @param RuntimeOptions                             $runtime
     *
     * @return GenerateDISyncTaskConfigForUpdatingResponse
     */
    public function generateDISyncTaskConfigForUpdatingWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clientToken) {
            @$query['ClientToken'] = $request->clientToken;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        if (null !== $request->taskParam) {
            @$query['TaskParam'] = $request->taskParam;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GenerateDISyncTaskConfigForUpdating',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GenerateDISyncTaskConfigForUpdatingResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Generates the JSON for an asynchronous thread that is used to update a real-time synchronization task in Data Integration.
     *
     * @remarks
     * DataWorks allows you to use only the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To update a real-time synchronization task, you must first call the GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the UpdateDISyncTask operation and use the parameters as request parameters to update a real-time synchronization task in Data Integration. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
     *
     * @param request - GenerateDISyncTaskConfigForUpdatingRequest
     *
     * @returns GenerateDISyncTaskConfigForUpdatingResponse
     *
     * @param GenerateDISyncTaskConfigForUpdatingRequest $request
     *
     * @return GenerateDISyncTaskConfigForUpdatingResponse
     */
    public function generateDISyncTaskConfigForUpdating($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->generateDISyncTaskConfigForUpdatingWithOptions($request, $runtime);
    }

    /**
     * Queries alert information based on the alert ID that is specified by the AlertId parameter.
     *
     * @param request - GetAlertMessageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetAlertMessageResponse
     *
     * @param GetAlertMessageRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetAlertMessageResponse
     */
    public function getAlertMessageWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alertId) {
            @$body['AlertId'] = $request->alertId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetAlertMessage',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetAlertMessageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries alert information based on the alert ID that is specified by the AlertId parameter.
     *
     * @param request - GetAlertMessageRequest
     *
     * @returns GetAlertMessageResponse
     *
     * @param GetAlertMessageRequest $request
     *
     * @return GetAlertMessageResponse
     */
    public function getAlertMessage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getAlertMessageWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a baseline based on its ID.
     *
     * @param request - GetBaselineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBaselineResponse
     *
     * @param GetBaselineRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return GetBaselineResponse
     */
    public function getBaselineWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineId) {
            @$body['BaselineId'] = $request->baselineId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetBaseline',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a baseline based on its ID.
     *
     * @param request - GetBaselineRequest
     *
     * @returns GetBaselineResponse
     *
     * @param GetBaselineRequest $request
     *
     * @return GetBaselineResponse
     */
    public function getBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of a baseline.
     *
     * @param request - GetBaselineConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBaselineConfigResponse
     *
     * @param GetBaselineConfigRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetBaselineConfigResponse
     */
    public function getBaselineConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineId) {
            @$body['BaselineId'] = $request->baselineId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetBaselineConfig',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBaselineConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of a baseline.
     *
     * @param request - GetBaselineConfigRequest
     *
     * @returns GetBaselineConfigResponse
     *
     * @param GetBaselineConfigRequest $request
     *
     * @return GetBaselineConfigResponse
     */
    public function getBaselineConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineConfigWithOptions($request, $runtime);
    }

    /**
     * The information about the events that are associated with the instance.
     *
     * @param request - GetBaselineKeyPathRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBaselineKeyPathResponse
     *
     * @param GetBaselineKeyPathRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetBaselineKeyPathResponse
     */
    public function getBaselineKeyPathWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineId) {
            @$body['BaselineId'] = $request->baselineId;
        }

        if (null !== $request->bizdate) {
            @$body['Bizdate'] = $request->bizdate;
        }

        if (null !== $request->inGroupId) {
            @$body['InGroupId'] = $request->inGroupId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetBaselineKeyPath',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBaselineKeyPathResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * The information about the events that are associated with the instance.
     *
     * @param request - GetBaselineKeyPathRequest
     *
     * @returns GetBaselineKeyPathResponse
     *
     * @param GetBaselineKeyPathRequest $request
     *
     * @return GetBaselineKeyPathResponse
     */
    public function getBaselineKeyPath($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineKeyPathWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a baseline instance.
     *
     * @param request - GetBaselineStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBaselineStatusResponse
     *
     * @param GetBaselineStatusRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetBaselineStatusResponse
     */
    public function getBaselineStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineId) {
            @$body['BaselineId'] = $request->baselineId;
        }

        if (null !== $request->bizdate) {
            @$body['Bizdate'] = $request->bizdate;
        }

        if (null !== $request->inGroupId) {
            @$body['InGroupId'] = $request->inGroupId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetBaselineStatus',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBaselineStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a baseline instance.
     *
     * @param request - GetBaselineStatusRequest
     *
     * @returns GetBaselineStatusResponse
     *
     * @param GetBaselineStatusRequest $request
     *
     * @return GetBaselineStatusResponse
     */
    public function getBaselineStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBaselineStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a workflow.
     *
     * @param request - GetBusinessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetBusinessResponse
     *
     * @param GetBusinessRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return GetBusinessResponse
     */
    public function getBusinessWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->businessId) {
            @$body['BusinessId'] = $request->businessId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetBusiness',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a workflow.
     *
     * @param request - GetBusinessRequest
     *
     * @returns GetBusinessResponse
     *
     * @param GetBusinessRequest $request
     *
     * @return GetBusinessResponse
     */
    public function getBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getBusinessWithOptions($request, $runtime);
    }

    /**
     * Queries the status of a table creation, update, or deletion task.
     *
     * @param request - GetDDLJobStatusRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDDLJobStatusResponse
     *
     * @param GetDDLJobStatusRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetDDLJobStatusResponse
     */
    public function getDDLJobStatusWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDDLJobStatus',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDDLJobStatusResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of a table creation, update, or deletion task.
     *
     * @param request - GetDDLJobStatusRequest
     *
     * @returns GetDDLJobStatusResponse
     *
     * @param GetDDLJobStatusRequest $request
     *
     * @return GetDDLJobStatusResponse
     */
    public function getDDLJobStatus($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDDLJobStatusWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an alert rule configured for a new-version synchronization task. Only the following types of tasks are supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *
     * @param request - GetDIAlarmRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDIAlarmRuleResponse
     *
     * @param GetDIAlarmRuleRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return GetDIAlarmRuleResponse
     */
    public function getDIAlarmRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->DIAlarmRuleId) {
            @$body['DIAlarmRuleId'] = $request->DIAlarmRuleId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetDIAlarmRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an alert rule configured for a new-version synchronization task. Only the following types of tasks are supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *
     * @param request - GetDIAlarmRuleRequest
     *
     * @returns GetDIAlarmRuleResponse
     *
     * @param GetDIAlarmRuleRequest $request
     *
     * @return GetDIAlarmRuleResponse
     */
    public function getDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a new-version synchronization task created in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres.
     *
     * @param request - GetDIJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDIJobResponse
     *
     * @param GetDIJobRequest $request
     * @param RuntimeOptions  $runtime
     *
     * @return GetDIJobResponse
     */
    public function getDIJobWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->DIJobId) {
            @$body['DIJobId'] = $request->DIJobId;
        }

        if (null !== $request->withDetails) {
            @$body['WithDetails'] = $request->withDetails;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetDIJob',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a new-version synchronization task created in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres.
     *
     * @param request - GetDIJobRequest
     *
     * @returns GetDIJobResponse
     *
     * @param GetDIJobRequest $request
     *
     * @return GetDIJobResponse
     */
    public function getDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDIJobWithOptions($request, $runtime);
    }

    /**
     * Queries the status of a real-time synchronization task or a data synchronization solution.
     *
     * @param request - GetDISyncInstanceInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDISyncInstanceInfoResponse
     *
     * @param GetDISyncInstanceInfoRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetDISyncInstanceInfoResponse
     */
    public function getDISyncInstanceInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileId) {
            @$query['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDISyncInstanceInfo',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDISyncInstanceInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the status of a real-time synchronization task or a data synchronization solution.
     *
     * @param request - GetDISyncInstanceInfoRequest
     *
     * @returns GetDISyncInstanceInfoResponse
     *
     * @param GetDISyncInstanceInfoRequest $request
     *
     * @return GetDISyncInstanceInfoResponse
     */
    public function getDISyncInstanceInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDISyncInstanceInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a real-time synchronization task or a data synchronization solution.
     *
     * @param request - GetDISyncTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDISyncTaskResponse
     *
     * @param GetDISyncTaskRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return GetDISyncTaskResponse
     */
    public function getDISyncTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileId) {
            @$query['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDISyncTask',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a real-time synchronization task or a data synchronization solution.
     *
     * @param request - GetDISyncTaskRequest
     *
     * @returns GetDISyncTaskResponse
     *
     * @param GetDISyncTaskRequest $request
     *
     * @return GetDISyncTaskResponse
     */
    public function getDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a directed acyclic graph (DAG). You can call the GetDag operation to query the information about the DAG for a manually triggered workflow, a manually triggered node, or a data backfill instance. However, you cannot query the information about the DAG for an auto triggered node or an auto triggered workflow.
     *
     * @remarks
     * Supported DAG types:
     * *   MANUAL: DAG for a manually triggered workflow
     * *   SMOKE_TEST: DAG for a smoke testing workflow
     * *   SUPPLY_DATA: DAG for a data backfill instance
     * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
     * Supported DAG states:
     * *   CREATED
     * *   RUNNING
     * *   FAILURE
     * *   SUCCESS
     *
     * @param request - GetDagRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDagResponse
     *
     * @param GetDagRequest  $request
     * @param RuntimeOptions $runtime
     *
     * @return GetDagResponse
     */
    public function getDagWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->dagId) {
            @$body['DagId'] = $request->dagId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetDag',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDagResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a directed acyclic graph (DAG). You can call the GetDag operation to query the information about the DAG for a manually triggered workflow, a manually triggered node, or a data backfill instance. However, you cannot query the information about the DAG for an auto triggered node or an auto triggered workflow.
     *
     * @remarks
     * Supported DAG types:
     * *   MANUAL: DAG for a manually triggered workflow
     * *   SMOKE_TEST: DAG for a smoke testing workflow
     * *   SUPPLY_DATA: DAG for a data backfill instance
     * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
     * Supported DAG states:
     * *   CREATED
     * *   RUNNING
     * *   FAILURE
     * *   SUCCESS
     *
     * @param request - GetDagRequest
     *
     * @returns GetDagResponse
     *
     * @param GetDagRequest $request
     *
     * @return GetDagResponse
     */
    public function getDag($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDagWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a DataService Studio API in the development state.
     *
     * @param request - GetDataServiceApiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDataServiceApiResponse
     *
     * @param GetDataServiceApiRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetDataServiceApiResponse
     */
    public function getDataServiceApiWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetDataServiceApi',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a DataService Studio API in the development state.
     *
     * @param request - GetDataServiceApiRequest
     *
     * @returns GetDataServiceApiResponse
     *
     * @param GetDataServiceApiRequest $request
     *
     * @return GetDataServiceApiResponse
     */
    public function getDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * Queries the test results of an API in DataService Studio.
     *
     * @param request - GetDataServiceApiTestRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDataServiceApiTestResponse
     *
     * @param GetDataServiceApiTestRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetDataServiceApiTestResponse
     */
    public function getDataServiceApiTestWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDataServiceApiTest',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDataServiceApiTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the test results of an API in DataService Studio.
     *
     * @param request - GetDataServiceApiTestRequest
     *
     * @returns GetDataServiceApiTestResponse
     *
     * @param GetDataServiceApiTestRequest $request
     *
     * @return GetDataServiceApiTestResponse
     */
    public function getDataServiceApiTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceApiTestWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an application.
     *
     * @param request - GetDataServiceApplicationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDataServiceApplicationResponse
     *
     * @param GetDataServiceApplicationRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return GetDataServiceApplicationResponse
     */
    public function getDataServiceApplicationWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->applicationId) {
            @$body['ApplicationId'] = $request->applicationId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetDataServiceApplication',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDataServiceApplicationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an application.
     *
     * @param request - GetDataServiceApplicationRequest
     *
     * @returns GetDataServiceApplicationResponse
     *
     * @param GetDataServiceApplicationRequest $request
     *
     * @return GetDataServiceApplicationResponse
     */
    public function getDataServiceApplication($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceApplicationWithOptions($request, $runtime);
    }

    /**
     * Queries a folder.
     *
     * @param request - GetDataServiceFolderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDataServiceFolderResponse
     *
     * @param GetDataServiceFolderRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetDataServiceFolderResponse
     */
    public function getDataServiceFolderWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->folderId) {
            @$body['FolderId'] = $request->folderId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetDataServiceFolder',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDataServiceFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a folder.
     *
     * @param request - GetDataServiceFolderRequest
     *
     * @returns GetDataServiceFolderResponse
     *
     * @param GetDataServiceFolderRequest $request
     *
     * @return GetDataServiceFolderResponse
     */
    public function getDataServiceFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceFolderWithOptions($request, $runtime);
    }

    /**
     * Queries a business process.
     *
     * @param request - GetDataServiceGroupRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDataServiceGroupResponse
     *
     * @param GetDataServiceGroupRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetDataServiceGroupResponse
     */
    public function getDataServiceGroupWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetDataServiceGroup',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDataServiceGroupResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a business process.
     *
     * @param request - GetDataServiceGroupRequest
     *
     * @returns GetDataServiceGroupResponse
     *
     * @param GetDataServiceGroupRequest $request
     *
     * @return GetDataServiceGroupResponse
     */
    public function getDataServiceGroup($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServiceGroupWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a DataService Studio API in the published state.
     *
     * @param request - GetDataServicePublishedApiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDataServicePublishedApiResponse
     *
     * @param GetDataServicePublishedApiRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return GetDataServicePublishedApiResponse
     */
    public function getDataServicePublishedApiWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetDataServicePublishedApi',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDataServicePublishedApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a DataService Studio API in the published state.
     *
     * @param request - GetDataServicePublishedApiRequest
     *
     * @returns GetDataServicePublishedApiResponse
     *
     * @param GetDataServicePublishedApiRequest $request
     *
     * @return GetDataServicePublishedApiResponse
     */
    public function getDataServicePublishedApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataServicePublishedApiWithOptions($request, $runtime);
    }

    /**
     * Queries the metadata of a specified data source.
     *
     * @param request - GetDataSourceMetaRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDataSourceMetaResponse
     *
     * @param GetDataSourceMetaRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetDataSourceMetaResponse
     */
    public function getDataSourceMetaWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->datasourceName) {
            @$query['DatasourceName'] = $request->datasourceName;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetDataSourceMeta',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDataSourceMetaResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the metadata of a specified data source.
     *
     * @param request - GetDataSourceMetaRequest
     *
     * @returns GetDataSourceMetaResponse
     *
     * @param GetDataSourceMetaRequest $request
     *
     * @return GetDataSourceMetaResponse
     */
    public function getDataSourceMeta($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDataSourceMetaWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a deployment package.
     *
     * @param request - GetDeploymentRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetDeploymentResponse
     *
     * @param GetDeploymentRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return GetDeploymentResponse
     */
    public function getDeploymentWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->deploymentId) {
            @$body['DeploymentId'] = $request->deploymentId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetDeployment',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetDeploymentResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a deployment package.
     *
     * @param request - GetDeploymentRequest
     *
     * @returns GetDeploymentResponse
     *
     * @param GetDeploymentRequest $request
     *
     * @return GetDeploymentResponse
     */
    public function getDeployment($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getDeploymentWithOptions($request, $runtime);
    }

    /**
     * Queries the details of an extension.
     *
     * @param request - GetExtensionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetExtensionResponse
     *
     * @param GetExtensionRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return GetExtensionResponse
     */
    public function getExtensionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->extensionCode) {
            @$query['ExtensionCode'] = $request->extensionCode;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetExtension',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetExtensionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of an extension.
     *
     * @param request - GetExtensionRequest
     *
     * @returns GetExtensionResponse
     *
     * @param GetExtensionRequest $request
     *
     * @return GetExtensionResponse
     */
    public function getExtension($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getExtensionWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a file.
     *
     * @param request - GetFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileResponse
     *
     * @param GetFileRequest $request
     * @param RuntimeOptions $runtime
     *
     * @return GetFileResponse
     */
    public function getFileWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->fileId) {
            @$body['FileId'] = $request->fileId;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetFile',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a file.
     *
     * @param request - GetFileRequest
     *
     * @returns GetFileResponse
     *
     * @param GetFileRequest $request
     *
     * @return GetFileResponse
     */
    public function getFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileWithOptions($request, $runtime);
    }

    /**
     * Queries the distribution of node types.
     *
     * @param request - GetFileTypeStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileTypeStatisticResponse
     *
     * @param GetFileTypeStatisticRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetFileTypeStatisticResponse
     */
    public function getFileTypeStatisticWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetFileTypeStatistic',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileTypeStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the distribution of node types.
     *
     * @param request - GetFileTypeStatisticRequest
     *
     * @returns GetFileTypeStatisticResponse
     *
     * @param GetFileTypeStatisticRequest $request
     *
     * @return GetFileTypeStatisticResponse
     */
    public function getFileTypeStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileTypeStatisticWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a file version.
     *
     * @param request - GetFileVersionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFileVersionResponse
     *
     * @param GetFileVersionRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return GetFileVersionResponse
     */
    public function getFileVersionWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->fileId) {
            @$body['FileId'] = $request->fileId;
        }

        if (null !== $request->fileVersion) {
            @$body['FileVersion'] = $request->fileVersion;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetFileVersion',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFileVersionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a file version.
     *
     * @param request - GetFileVersionRequest
     *
     * @returns GetFileVersionResponse
     *
     * @param GetFileVersionRequest $request
     *
     * @return GetFileVersionResponse
     */
    public function getFileVersion($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFileVersionWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a folder.
     *
     * @param request - GetFolderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetFolderResponse
     *
     * @param GetFolderRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return GetFolderResponse
     */
    public function getFolderWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->folderId) {
            @$body['FolderId'] = $request->folderId;
        }

        if (null !== $request->folderPath) {
            @$body['FolderPath'] = $request->folderPath;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetFolder',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a folder.
     *
     * @param request - GetFolderRequest
     *
     * @returns GetFolderResponse
     *
     * @param GetFolderRequest $request
     *
     * @return GetFolderResponse
     */
    public function getFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getFolderWithOptions($request, $runtime);
    }

    /**
     * Queries the data snapshot of an extension point based on the ID of a message in DataWorks OpenEvent when the related extension point event is triggered.
     *
     * @param request - GetIDEEventDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetIDEEventDetailResponse
     *
     * @param GetIDEEventDetailRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetIDEEventDetailResponse
     */
    public function getIDEEventDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->messageId) {
            @$body['MessageId'] = $request->messageId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetIDEEventDetail',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetIDEEventDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the data snapshot of an extension point based on the ID of a message in DataWorks OpenEvent when the related extension point event is triggered.
     *
     * @param request - GetIDEEventDetailRequest
     *
     * @returns GetIDEEventDetailResponse
     *
     * @param GetIDEEventDetailRequest $request
     *
     * @return GetIDEEventDetailResponse
     */
    public function getIDEEventDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getIDEEventDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an instance.
     *
     * @param request - GetInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceResponse
     *
     * @param GetInstanceRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return GetInstanceResponse
     */
    public function getInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an instance.
     *
     * @param request - GetInstanceRequest
     *
     * @returns GetInstanceResponse
     *
     * @param GetInstanceRequest $request
     *
     * @return GetInstanceResponse
     */
    public function getInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the ranking of the running durations of instances.
     *
     * @deprecated OpenAPI GetInstanceConsumeTimeRank is deprecated
     *
     * @param request - GetInstanceConsumeTimeRankRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceConsumeTimeRankResponse
     *
     * @param GetInstanceConsumeTimeRankRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return GetInstanceConsumeTimeRankResponse
     */
    public function getInstanceConsumeTimeRankWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->bizdate) {
            @$body['Bizdate'] = $request->bizdate;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetInstanceConsumeTimeRank',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceConsumeTimeRankResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the ranking of the running durations of instances.
     *
     * @deprecated OpenAPI GetInstanceConsumeTimeRank is deprecated
     *
     * @param request - GetInstanceConsumeTimeRankRequest
     *
     * @returns GetInstanceConsumeTimeRankResponse
     *
     * @param GetInstanceConsumeTimeRankRequest $request
     *
     * @return GetInstanceConsumeTimeRankResponse
     */
    public function getInstanceConsumeTimeRank($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceConsumeTimeRankWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the quantity trend of auto triggered instances.
     *
     * @deprecated OpenAPI GetInstanceCountTrend is deprecated
     *
     * @param request - GetInstanceCountTrendRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceCountTrendResponse
     *
     * @param GetInstanceCountTrendRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetInstanceCountTrendResponse
     */
    public function getInstanceCountTrendWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->beginDate) {
            @$body['BeginDate'] = $request->beginDate;
        }

        if (null !== $request->endDate) {
            @$body['EndDate'] = $request->endDate;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetInstanceCountTrend',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceCountTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the quantity trend of auto triggered instances.
     *
     * @deprecated OpenAPI GetInstanceCountTrend is deprecated
     *
     * @param request - GetInstanceCountTrendRequest
     *
     * @returns GetInstanceCountTrendResponse
     *
     * @param GetInstanceCountTrendRequest $request
     *
     * @return GetInstanceCountTrendResponse
     */
    public function getInstanceCountTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceCountTrendWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the ranking of nodes on which errors occur within the last month.
     *
     * @deprecated OpenAPI GetInstanceErrorRank is deprecated
     *
     * @param request - GetInstanceErrorRankRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceErrorRankResponse
     *
     * @param GetInstanceErrorRankRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetInstanceErrorRankResponse
     */
    public function getInstanceErrorRankWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetInstanceErrorRank',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceErrorRankResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the ranking of nodes on which errors occur within the last month.
     *
     * @deprecated OpenAPI GetInstanceErrorRank is deprecated
     *
     * @param request - GetInstanceErrorRankRequest
     *
     * @returns GetInstanceErrorRankResponse
     *
     * @param GetInstanceErrorRankRequest $request
     *
     * @return GetInstanceErrorRankResponse
     */
    public function getInstanceErrorRank($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceErrorRankWithOptions($request, $runtime);
    }

    /**
     * Queries the logs of an instance.
     *
     * @remarks
     * You may not obtain the instance logs that were generated more than seven days ago.
     *
     * @param request - GetInstanceLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceLogResponse
     *
     * @param GetInstanceLogRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return GetInstanceLogResponse
     */
    public function getInstanceLogWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->instanceHistoryId) {
            @$body['InstanceHistoryId'] = $request->instanceHistoryId;
        }

        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetInstanceLog',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the logs of an instance.
     *
     * @remarks
     * You may not obtain the instance logs that were generated more than seven days ago.
     *
     * @param request - GetInstanceLogRequest
     *
     * @returns GetInstanceLogResponse
     *
     * @param GetInstanceLogRequest $request
     *
     * @return GetInstanceLogResponse
     */
    public function getInstanceLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceLogWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the statistics of instances in different states.
     *
     * @deprecated OpenAPI GetInstanceStatusCount is deprecated
     *
     * @param request - GetInstanceStatusCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceStatusCountResponse
     *
     * @param GetInstanceStatusCountRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetInstanceStatusCountResponse
     */
    public function getInstanceStatusCountWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->bizDate) {
            @$body['BizDate'] = $request->bizDate;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetInstanceStatusCount',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceStatusCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the statistics of instances in different states.
     *
     * @deprecated OpenAPI GetInstanceStatusCount is deprecated
     *
     * @param request - GetInstanceStatusCountRequest
     *
     * @returns GetInstanceStatusCountResponse
     *
     * @param GetInstanceStatusCountRequest $request
     *
     * @return GetInstanceStatusCountResponse
     */
    public function getInstanceStatusCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceStatusCountWithOptions($request, $runtime);
    }

    /**
     * Queries the number of instances that are in each state.
     *
     * @param request - GetInstanceStatusStatisticRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetInstanceStatusStatisticResponse
     *
     * @param GetInstanceStatusStatisticRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return GetInstanceStatusStatisticResponse
     */
    public function getInstanceStatusStatisticWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->bizDate) {
            @$body['BizDate'] = $request->bizDate;
        }

        if (null !== $request->dagType) {
            @$body['DagType'] = $request->dagType;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->schedulerPeriod) {
            @$body['SchedulerPeriod'] = $request->schedulerPeriod;
        }

        if (null !== $request->schedulerType) {
            @$body['SchedulerType'] = $request->schedulerType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetInstanceStatusStatistic',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetInstanceStatusStatisticResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the number of instances that are in each state.
     *
     * @param request - GetInstanceStatusStatisticRequest
     *
     * @returns GetInstanceStatusStatisticResponse
     *
     * @param GetInstanceStatusStatisticRequest $request
     *
     * @return GetInstanceStatusStatisticResponse
     */
    public function getInstanceStatusStatistic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getInstanceStatusStatisticWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the information about instances in a manually triggered workflow.
     *
     * @deprecated OpenAPI GetManualDagInstances is deprecated
     *
     * @param request - GetManualDagInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetManualDagInstancesResponse
     *
     * @param GetManualDagInstancesRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetManualDagInstancesResponse
     */
    public function getManualDagInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->dagId) {
            @$body['DagId'] = $request->dagId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetManualDagInstances',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetManualDagInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the information about instances in a manually triggered workflow.
     *
     * @deprecated OpenAPI GetManualDagInstances is deprecated
     *
     * @param request - GetManualDagInstancesRequest
     *
     * @returns GetManualDagInstancesResponse
     *
     * @param GetManualDagInstancesRequest $request
     *
     * @return GetManualDagInstancesResponse
     */
    public function getManualDagInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getManualDagInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a category tree.
     *
     * @param request - GetMetaCategoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaCategoryResponse
     *
     * @param GetMetaCategoryRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetMetaCategoryResponse
     */
    public function getMetaCategoryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->parentCategoryId) {
            @$query['ParentCategoryId'] = $request->parentCategoryId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaCategory',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a category tree.
     *
     * @param request - GetMetaCategoryRequest
     *
     * @returns GetMetaCategoryResponse
     *
     * @param GetMetaCategoryRequest $request
     *
     * @return GetMetaCategoryResponse
     */
    public function getMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a collection.
     *
     * @param request - GetMetaCollectionDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaCollectionDetailResponse
     *
     * @param GetMetaCollectionDetailRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetMetaCollectionDetailResponse
     */
    public function getMetaCollectionDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->qualifiedName) {
            @$query['QualifiedName'] = $request->qualifiedName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaCollectionDetail',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaCollectionDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a collection.
     *
     * @param request - GetMetaCollectionDetailRequest
     *
     * @returns GetMetaCollectionDetailResponse
     *
     * @param GetMetaCollectionDetailRequest $request
     *
     * @return GetMetaCollectionDetailResponse
     */
    public function getMetaCollectionDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaCollectionDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the lineage of a field in a metatable.
     *
     * @param request - GetMetaColumnLineageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaColumnLineageResponse
     *
     * @param GetMetaColumnLineageRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetMetaColumnLineageResponse
     */
    public function getMetaColumnLineageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->columnGuid) {
            @$query['ColumnGuid'] = $request->columnGuid;
        }

        if (null !== $request->columnName) {
            @$query['ColumnName'] = $request->columnName;
        }

        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->direction) {
            @$query['Direction'] = $request->direction;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaColumnLineage',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaColumnLineageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the lineage of a field in a metatable.
     *
     * @param request - GetMetaColumnLineageRequest
     *
     * @returns GetMetaColumnLineageResponse
     *
     * @param GetMetaColumnLineageRequest $request
     *
     * @return GetMetaColumnLineageResponse
     */
    public function getMetaColumnLineage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaColumnLineageWithOptions($request, $runtime);
    }

    /**
     * Queries the basic metadata information about a compute engine instance.
     *
     * @remarks
     * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
     * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
     *
     * @param request - GetMetaDBInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaDBInfoResponse
     *
     * @param GetMetaDBInfoRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return GetMetaDBInfoResponse
     */
    public function getMetaDBInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaDBInfo',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaDBInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the basic metadata information about a compute engine instance.
     *
     * @remarks
     * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
     * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
     *
     * @param request - GetMetaDBInfoRequest
     *
     * @returns GetMetaDBInfoResponse
     *
     * @param GetMetaDBInfoRequest $request
     *
     * @return GetMetaDBInfoResponse
     */
    public function getMetaDBInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaDBInfoWithOptions($request, $runtime);
    }

    /**
     * Queries metatables in a compute engine instance.
     *
     * @param request - GetMetaDBTableListRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaDBTableListResponse
     *
     * @param GetMetaDBTableListRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetMetaDBTableListResponse
     */
    public function getMetaDBTableListWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appGuid) {
            @$query['AppGuid'] = $request->appGuid;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaDBTableList',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaDBTableListResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries metatables in a compute engine instance.
     *
     * @param request - GetMetaDBTableListRequest
     *
     * @returns GetMetaDBTableListResponse
     *
     * @param GetMetaDBTableListRequest $request
     *
     * @return GetMetaDBTableListResponse
     */
    public function getMetaDBTableList($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaDBTableListWithOptions($request, $runtime);
    }

    /**
     * Queries the basic information about a metatable.
     *
     * @param request - GetMetaTableBasicInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableBasicInfoResponse
     *
     * @param GetMetaTableBasicInfoRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetMetaTableBasicInfoResponse
     */
    public function getMetaTableBasicInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableBasicInfo',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableBasicInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the basic information about a metatable.
     *
     * @param request - GetMetaTableBasicInfoRequest
     *
     * @returns GetMetaTableBasicInfoResponse
     *
     * @param GetMetaTableBasicInfoRequest $request
     *
     * @return GetMetaTableBasicInfoResponse
     */
    public function getMetaTableBasicInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableBasicInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the change logs of a metatable.
     *
     * @remarks
     * > This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - GetMetaTableChangeLogRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableChangeLogResponse
     *
     * @param GetMetaTableChangeLogRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetMetaTableChangeLogResponse
     */
    public function getMetaTableChangeLogWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->changeType) {
            @$body['ChangeType'] = $request->changeType;
        }

        if (null !== $request->endDate) {
            @$body['EndDate'] = $request->endDate;
        }

        if (null !== $request->objectType) {
            @$body['ObjectType'] = $request->objectType;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->startDate) {
            @$body['StartDate'] = $request->startDate;
        }

        if (null !== $request->tableGuid) {
            @$body['TableGuid'] = $request->tableGuid;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableChangeLog',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableChangeLogResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the change logs of a metatable.
     *
     * @remarks
     * > This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - GetMetaTableChangeLogRequest
     *
     * @returns GetMetaTableChangeLogResponse
     *
     * @param GetMetaTableChangeLogRequest $request
     *
     * @return GetMetaTableChangeLogResponse
     */
    public function getMetaTableChangeLog($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableChangeLogWithOptions($request, $runtime);
    }

    /**
     * Queries the field information of a metatable.
     *
     * @param request - GetMetaTableColumnRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableColumnResponse
     *
     * @param GetMetaTableColumnRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetMetaTableColumnResponse
     */
    public function getMetaTableColumnWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableColumn',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableColumnResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the field information of a metatable.
     *
     * @param request - GetMetaTableColumnRequest
     *
     * @returns GetMetaTableColumnResponse
     *
     * @param GetMetaTableColumnRequest $request
     *
     * @return GetMetaTableColumnResponse
     */
    public function getMetaTableColumn($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableColumnWithOptions($request, $runtime);
    }

    /**
     * Queries the complete information about a table, including information about fields in the table.
     *
     * @remarks
     * You can call this operation to query only the information about a table of the E-MapReduce (EMR) compute engine type.
     *
     * @param request - GetMetaTableFullInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableFullInfoResponse
     *
     * @param GetMetaTableFullInfoRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return GetMetaTableFullInfoResponse
     */
    public function getMetaTableFullInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableFullInfo',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableFullInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the complete information about a table, including information about fields in the table.
     *
     * @remarks
     * You can call this operation to query only the information about a table of the E-MapReduce (EMR) compute engine type.
     *
     * @param request - GetMetaTableFullInfoRequest
     *
     * @returns GetMetaTableFullInfoResponse
     *
     * @param GetMetaTableFullInfoRequest $request
     *
     * @return GetMetaTableFullInfoResponse
     */
    public function getMetaTableFullInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableFullInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the instructions on how to use a table.
     *
     * @param request - GetMetaTableIntroWikiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableIntroWikiResponse
     *
     * @param GetMetaTableIntroWikiRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return GetMetaTableIntroWikiResponse
     */
    public function getMetaTableIntroWikiWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        if (null !== $request->wikiVersion) {
            @$query['WikiVersion'] = $request->wikiVersion;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableIntroWiki',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableIntroWikiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the instructions on how to use a table.
     *
     * @param request - GetMetaTableIntroWikiRequest
     *
     * @returns GetMetaTableIntroWikiResponse
     *
     * @param GetMetaTableIntroWikiRequest $request
     *
     * @return GetMetaTableIntroWikiResponse
     */
    public function getMetaTableIntroWiki($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableIntroWikiWithOptions($request, $runtime);
    }

    /**
     * Queries the lineage of a metatable.
     *
     * @param request - GetMetaTableLineageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableLineageResponse
     *
     * @param GetMetaTableLineageRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetMetaTableLineageResponse
     */
    public function getMetaTableLineageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->direction) {
            @$query['Direction'] = $request->direction;
        }

        if (null !== $request->nextPrimaryKey) {
            @$query['NextPrimaryKey'] = $request->nextPrimaryKey;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableLineage',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableLineageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the lineage of a metatable.
     *
     * @param request - GetMetaTableLineageRequest
     *
     * @returns GetMetaTableLineageResponse
     *
     * @param GetMetaTableLineageRequest $request
     *
     * @return GetMetaTableLineageResponse
     */
    public function getMetaTableLineage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableLineageWithOptions($request, $runtime);
    }

    /**
     * Queries metatables in a specified category.
     *
     * @param request - GetMetaTableListByCategoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableListByCategoryResponse
     *
     * @param GetMetaTableListByCategoryRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return GetMetaTableListByCategoryResponse
     */
    public function getMetaTableListByCategoryWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableListByCategory',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableListByCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries metatables in a specified category.
     *
     * @param request - GetMetaTableListByCategoryRequest
     *
     * @returns GetMetaTableListByCategoryResponse
     *
     * @param GetMetaTableListByCategoryRequest $request
     *
     * @return GetMetaTableListByCategoryResponse
     */
    public function getMetaTableListByCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableListByCategoryWithOptions($request, $runtime);
    }

    /**
     * Queries the output information of a metatable.
     *
     * @param request - GetMetaTableOutputRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableOutputResponse
     *
     * @param GetMetaTableOutputRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetMetaTableOutputResponse
     */
    public function getMetaTableOutputWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->endDate) {
            @$query['EndDate'] = $request->endDate;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->startDate) {
            @$query['StartDate'] = $request->startDate;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        if (null !== $request->taskId) {
            @$query['TaskId'] = $request->taskId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableOutput',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the output information of a metatable.
     *
     * @param request - GetMetaTableOutputRequest
     *
     * @returns GetMetaTableOutputResponse
     *
     * @param GetMetaTableOutputRequest $request
     *
     * @return GetMetaTableOutputResponse
     */
    public function getMetaTableOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableOutputWithOptions($request, $runtime);
    }

    /**
     * Obtains a list of partitions in a metatable.
     *
     * @remarks
     * You can call this operation to query only the partitions of a metatable in a MaxCompute or E-MapReduce (EMR) compute engine. If you query partitions of a metatable in an EMR compute engine, only DataLake clusters that use Data Lake Formation (DLF) to manage metadata and Hadoop clusters whose cluster version is earlier than 3.41.0 or 5.7.0 are supported.
     *
     * @param tmpReq - GetMetaTablePartitionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTablePartitionResponse
     *
     * @param GetMetaTablePartitionRequest $tmpReq
     * @param RuntimeOptions               $runtime
     *
     * @return GetMetaTablePartitionResponse
     */
    public function getMetaTablePartitionWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new GetMetaTablePartitionShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->sortCriterion) {
            $request->sortCriterionShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->sortCriterion, 'SortCriterion', 'json');
        }

        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->databaseName) {
            @$query['DatabaseName'] = $request->databaseName;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sortCriterionShrink) {
            @$query['SortCriterion'] = $request->sortCriterionShrink;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTablePartition',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTablePartitionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains a list of partitions in a metatable.
     *
     * @remarks
     * You can call this operation to query only the partitions of a metatable in a MaxCompute or E-MapReduce (EMR) compute engine. If you query partitions of a metatable in an EMR compute engine, only DataLake clusters that use Data Lake Formation (DLF) to manage metadata and Hadoop clusters whose cluster version is earlier than 3.41.0 or 5.7.0 are supported.
     *
     * @param request - GetMetaTablePartitionRequest
     *
     * @returns GetMetaTablePartitionResponse
     *
     * @param GetMetaTablePartitionRequest $request
     *
     * @return GetMetaTablePartitionResponse
     */
    public function getMetaTablePartition($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTablePartitionWithOptions($request, $runtime);
    }

    /**
     * Queries the output tasks of a metatable.
     *
     * @param request - GetMetaTableProducingTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableProducingTasksResponse
     *
     * @param GetMetaTableProducingTasksRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return GetMetaTableProducingTasksResponse
     */
    public function getMetaTableProducingTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->dbName) {
            @$query['DbName'] = $request->dbName;
        }

        if (null !== $request->schemaName) {
            @$query['SchemaName'] = $request->schemaName;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableProducingTasks',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableProducingTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the output tasks of a metatable.
     *
     * @param request - GetMetaTableProducingTasksRequest
     *
     * @returns GetMetaTableProducingTasksResponse
     *
     * @param GetMetaTableProducingTasksRequest $request
     *
     * @return GetMetaTableProducingTasksResponse
     */
    public function getMetaTableProducingTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableProducingTasksWithOptions($request, $runtime);
    }

    /**
     * Queries the information about the themes and levels of a metatable.
     *
     * @param request - GetMetaTableThemeLevelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMetaTableThemeLevelResponse
     *
     * @param GetMetaTableThemeLevelRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return GetMetaTableThemeLevelResponse
     */
    public function getMetaTableThemeLevelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetMetaTableThemeLevel',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMetaTableThemeLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about the themes and levels of a metatable.
     *
     * @param request - GetMetaTableThemeLevelRequest
     *
     * @returns GetMetaTableThemeLevelResponse
     *
     * @param GetMetaTableThemeLevelRequest $request
     *
     * @return GetMetaTableThemeLevelResponse
     */
    public function getMetaTableThemeLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMetaTableThemeLevelWithOptions($request, $runtime);
    }

    /**
     * Queries the progress of a migration task.
     *
     * @param request - GetMigrationProcessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMigrationProcessResponse
     *
     * @param GetMigrationProcessRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetMigrationProcessResponse
     */
    public function getMigrationProcessWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->migrationId) {
            @$body['MigrationId'] = $request->migrationId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetMigrationProcess',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMigrationProcessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the progress of a migration task.
     *
     * @param request - GetMigrationProcessRequest
     *
     * @returns GetMigrationProcessResponse
     *
     * @param GetMigrationProcessRequest $request
     *
     * @return GetMigrationProcessResponse
     */
    public function getMigrationProcess($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMigrationProcessWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a migration task.
     *
     * @param request - GetMigrationSummaryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetMigrationSummaryResponse
     *
     * @param GetMigrationSummaryRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetMigrationSummaryResponse
     */
    public function getMigrationSummaryWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->migrationId) {
            @$body['MigrationId'] = $request->migrationId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetMigrationSummary',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetMigrationSummaryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a migration task.
     *
     * @param request - GetMigrationSummaryRequest
     *
     * @returns GetMigrationSummaryResponse
     *
     * @param GetMigrationSummaryRequest $request
     *
     * @return GetMigrationSummaryResponse
     */
    public function getMigrationSummary($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getMigrationSummaryWithOptions($request, $runtime);
    }

    /**
     * Indicates whether the request is successful.
     *
     * @param request - GetNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetNodeResponse
     *
     * @param GetNodeRequest $request
     * @param RuntimeOptions $runtime
     *
     * @return GetNodeResponse
     */
    public function getNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetNode',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Indicates whether the request is successful.
     *
     * @param request - GetNodeRequest
     *
     * @returns GetNodeResponse
     *
     * @param GetNodeRequest $request
     *
     * @return GetNodeResponse
     */
    public function getNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeWithOptions($request, $runtime);
    }

    /**
     * Queries a list of instances.
     *
     * @param request - GetNodeChildrenRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetNodeChildrenResponse
     *
     * @param GetNodeChildrenRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return GetNodeChildrenResponse
     */
    public function getNodeChildrenWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetNodeChildren',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetNodeChildrenResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of instances.
     *
     * @param request - GetNodeChildrenRequest
     *
     * @returns GetNodeChildrenResponse
     *
     * @param GetNodeChildrenRequest $request
     *
     * @return GetNodeChildrenResponse
     */
    public function getNodeChildren($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeChildrenWithOptions($request, $runtime);
    }

    /**
     * Queries the code of a node.
     *
     * @param request - GetNodeCodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetNodeCodeResponse
     *
     * @param GetNodeCodeRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return GetNodeCodeResponse
     */
    public function getNodeCodeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetNodeCode',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetNodeCodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the code of a node.
     *
     * @param request - GetNodeCodeRequest
     *
     * @returns GetNodeCodeResponse
     *
     * @param GetNodeCodeRequest $request
     *
     * @return GetNodeCodeResponse
     */
    public function getNodeCode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeCodeWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the nodes associated with a baseline.
     *
     * @deprecated OpenAPI GetNodeOnBaseline is deprecated
     *
     * @param request - GetNodeOnBaselineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetNodeOnBaselineResponse
     *
     * @param GetNodeOnBaselineRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetNodeOnBaselineResponse
     */
    public function getNodeOnBaselineWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineId) {
            @$body['BaselineId'] = $request->baselineId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetNodeOnBaseline',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetNodeOnBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the nodes associated with a baseline.
     *
     * @deprecated OpenAPI GetNodeOnBaseline is deprecated
     *
     * @param request - GetNodeOnBaselineRequest
     *
     * @returns GetNodeOnBaselineResponse
     *
     * @param GetNodeOnBaselineRequest $request
     *
     * @return GetNodeOnBaselineResponse
     */
    public function getNodeOnBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeOnBaselineWithOptions($request, $runtime);
    }

    /**
     * Queries a list of ancestor nodes of a node.
     *
     * @param request - GetNodeParentsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetNodeParentsResponse
     *
     * @param GetNodeParentsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return GetNodeParentsResponse
     */
    public function getNodeParentsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetNodeParents',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetNodeParentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of ancestor nodes of a node.
     *
     * @param request - GetNodeParentsRequest
     *
     * @returns GetNodeParentsResponse
     *
     * @param GetNodeParentsRequest $request
     *
     * @return GetNodeParentsResponse
     */
    public function getNodeParents($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeParentsWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the information about node types, including the code and name of a node type.
     *
     * @deprecated OpenAPI GetNodeTypeListInfo is deprecated
     *
     * @param request - GetNodeTypeListInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetNodeTypeListInfoResponse
     *
     * @param GetNodeTypeListInfoRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return GetNodeTypeListInfoResponse
     */
    public function getNodeTypeListInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->keyword) {
            @$body['Keyword'] = $request->keyword;
        }

        if (null !== $request->locale) {
            @$body['Locale'] = $request->locale;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetNodeTypeListInfo',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetNodeTypeListInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the information about node types, including the code and name of a node type.
     *
     * @deprecated OpenAPI GetNodeTypeListInfo is deprecated
     *
     * @param request - GetNodeTypeListInfoRequest
     *
     * @returns GetNodeTypeListInfoResponse
     *
     * @param GetNodeTypeListInfoRequest $request
     *
     * @return GetNodeTypeListInfoResponse
     */
    public function getNodeTypeListInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getNodeTypeListInfoWithOptions($request, $runtime);
    }

    /**
     * Queries the records that are generated on a specified date for access to the high-risk sensitive data in all the DataWorks workspaces of a tenant.
     *
     * @param request - GetOpRiskDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOpRiskDataResponse
     *
     * @param GetOpRiskDataRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return GetOpRiskDataResponse
     */
    public function getOpRiskDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOpRiskData',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOpRiskDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the records that are generated on a specified date for access to the high-risk sensitive data in all the DataWorks workspaces of a tenant.
     *
     * @param request - GetOpRiskDataRequest
     *
     * @returns GetOpRiskDataResponse
     *
     * @param GetOpRiskDataRequest $request
     *
     * @return GetOpRiskDataResponse
     */
    public function getOpRiskData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpRiskDataWithOptions($request, $runtime);
    }

    /**
     * Queries the records that are generated on a specified date for access to sensitive data in all the DataWorks workspaces of a tenant.
     *
     * @param request - GetOpSensitiveDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOpSensitiveDataResponse
     *
     * @param GetOpSensitiveDataRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetOpSensitiveDataResponse
     */
    public function getOpSensitiveDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetOpSensitiveData',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOpSensitiveDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the records that are generated on a specified date for access to sensitive data in all the DataWorks workspaces of a tenant.
     *
     * @param request - GetOpSensitiveDataRequest
     *
     * @returns GetOpSensitiveDataResponse
     *
     * @param GetOpSensitiveDataRequest $request
     *
     * @return GetOpSensitiveDataResponse
     */
    public function getOpSensitiveData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOpSensitiveDataWithOptions($request, $runtime);
    }

    /**
     * Queries the option settings of an extension in a workspace.
     *
     * @param request - GetOptionValueForProjectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetOptionValueForProjectResponse
     *
     * @param GetOptionValueForProjectRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return GetOptionValueForProjectResponse
     */
    public function getOptionValueForProjectWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->extensionCode) {
            @$body['ExtensionCode'] = $request->extensionCode;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetOptionValueForProject',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetOptionValueForProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the option settings of an extension in a workspace.
     *
     * @param request - GetOptionValueForProjectRequest
     *
     * @returns GetOptionValueForProjectResponse
     *
     * @param GetOptionValueForProjectRequest $request
     *
     * @return GetOptionValueForProjectResponse
     */
    public function getOptionValueForProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getOptionValueForProjectWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a permission request order.
     *
     * @param request - GetPermissionApplyOrderDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetPermissionApplyOrderDetailResponse
     *
     * @param GetPermissionApplyOrderDetailRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return GetPermissionApplyOrderDetailResponse
     */
    public function getPermissionApplyOrderDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->flowId) {
            @$query['FlowId'] = $request->flowId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetPermissionApplyOrderDetail',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetPermissionApplyOrderDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a permission request order.
     *
     * @param request - GetPermissionApplyOrderDetailRequest
     *
     * @returns GetPermissionApplyOrderDetailResponse
     *
     * @param GetPermissionApplyOrderDetailRequest $request
     *
     * @return GetPermissionApplyOrderDetailResponse
     */
    public function getPermissionApplyOrderDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getPermissionApplyOrderDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a DataWorks workspace.
     *
     * @param request - GetProjectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetProjectResponse
     *
     * @param GetProjectRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return GetProjectResponse
     */
    public function getProjectWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$query['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetProject',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a DataWorks workspace.
     *
     * @param request - GetProjectRequest
     *
     * @returns GetProjectResponse
     *
     * @param GetProjectRequest $request
     *
     * @return GetProjectResponse
     */
    public function getProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getProjectWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the information about a DataWorks workspace.
     *
     * @deprecated OpenAPI GetProjectDetail is deprecated
     *
     * @param request - GetProjectDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetProjectDetailResponse
     *
     * @param GetProjectDetailRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return GetProjectDetailResponse
     */
    public function getProjectDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetProjectDetail',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetProjectDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the information about a DataWorks workspace.
     *
     * @deprecated OpenAPI GetProjectDetail is deprecated
     *
     * @param request - GetProjectDetailRequest
     *
     * @returns GetProjectDetailResponse
     *
     * @param GetProjectDetailRequest $request
     *
     * @return GetProjectDetailResponse
     */
    public function getProjectDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getProjectDetailWithOptions($request, $runtime);
    }

    /**
     * @param request - GetQualityEntityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetQualityEntityResponse
     *
     * @param GetQualityEntityRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return GetQualityEntityResponse
     */
    public function getQualityEntityWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->envType) {
            @$body['EnvType'] = $request->envType;
        }

        if (null !== $request->matchExpression) {
            @$body['MatchExpression'] = $request->matchExpression;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->tableName) {
            @$body['TableName'] = $request->tableName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetQualityEntity',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetQualityEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * @param request - GetQualityEntityRequest
     *
     * @returns GetQualityEntityResponse
     *
     * @param GetQualityEntityRequest $request
     *
     * @return GetQualityEntityResponse
     */
    public function getQualityEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getQualityEntityWithOptions($request, $runtime);
    }

    /**
     * Queries the subscribers of a partition filter expression.
     *
     * @param request - GetQualityFollowerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetQualityFollowerResponse
     *
     * @param GetQualityFollowerRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return GetQualityFollowerResponse
     */
    public function getQualityFollowerWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->entityId) {
            @$body['EntityId'] = $request->entityId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetQualityFollower',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the subscribers of a partition filter expression.
     *
     * @param request - GetQualityFollowerRequest
     *
     * @returns GetQualityFollowerResponse
     *
     * @param GetQualityFollowerRequest $request
     *
     * @return GetQualityFollowerResponse
     */
    public function getQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a monitoring rule.
     *
     * @param request - GetQualityRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetQualityRuleResponse
     *
     * @param GetQualityRuleRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return GetQualityRuleResponse
     */
    public function getQualityRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->ruleId) {
            @$body['RuleId'] = $request->ruleId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetQualityRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a monitoring rule.
     *
     * @param request - GetQualityRuleRequest
     *
     * @returns GetQualityRuleResponse
     *
     * @param GetQualityRuleRequest $request
     *
     * @return GetQualityRuleResponse
     */
    public function getQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getQualityRuleWithOptions($request, $runtime);
    }

    /**
     * Queries the information about a custom alert rule.
     *
     * @remarks
     * ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetRemind\\&type=RPC\\&version=2020-05-18)
     *
     * @param request - GetRemindRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetRemindResponse
     *
     * @param GetRemindRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return GetRemindResponse
     */
    public function getRemindWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->remindId) {
            @$body['RemindId'] = $request->remindId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetRemind',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about a custom alert rule.
     *
     * @remarks
     * ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetRemind\\&type=RPC\\&version=2020-05-18)
     *
     * @param request - GetRemindRequest
     *
     * @returns GetRemindResponse
     *
     * @param GetRemindRequest $request
     *
     * @return GetRemindResponse
     */
    public function getRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getRemindWithOptions($request, $runtime);
    }

    /**
     * Queries the latest sensitive data in all the DataWorks workspaces of a tenant.
     *
     * @param request - GetSensitiveDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSensitiveDataResponse
     *
     * @param GetSensitiveDataRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return GetSensitiveDataResponse
     */
    public function getSensitiveDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'GetSensitiveData',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSensitiveDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the latest sensitive data in all the DataWorks workspaces of a tenant.
     *
     * @param request - GetSensitiveDataRequest
     *
     * @returns GetSensitiveDataResponse
     *
     * @param GetSensitiveDataRequest $request
     *
     * @return GetSensitiveDataResponse
     */
    public function getSensitiveData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSensitiveDataWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the statistics of instances in different periods of a day.
     *
     * @deprecated OpenAPI GetSuccessInstanceTrend is deprecated
     *
     * @param request - GetSuccessInstanceTrendRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetSuccessInstanceTrendResponse
     *
     * @param GetSuccessInstanceTrendRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return GetSuccessInstanceTrendResponse
     */
    public function getSuccessInstanceTrendWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetSuccessInstanceTrend',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetSuccessInstanceTrendResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the statistics of instances in different periods of a day.
     *
     * @deprecated OpenAPI GetSuccessInstanceTrend is deprecated
     *
     * @param request - GetSuccessInstanceTrendRequest
     *
     * @returns GetSuccessInstanceTrendResponse
     *
     * @param GetSuccessInstanceTrendRequest $request
     *
     * @return GetSuccessInstanceTrendResponse
     */
    public function getSuccessInstanceTrend($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getSuccessInstanceTrendWithOptions($request, $runtime);
    }

    /**
     * Queries the information about an event.
     *
     * @remarks
     *
     * @param request - GetTopicRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetTopicResponse
     *
     * @param GetTopicRequest $request
     * @param RuntimeOptions  $runtime
     *
     * @return GetTopicResponse
     */
    public function getTopicWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->topicId) {
            @$body['TopicId'] = $request->topicId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetTopic',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetTopicResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about an event.
     *
     * @remarks
     *
     * @param request - GetTopicRequest
     *
     * @returns GetTopicResponse
     *
     * @param GetTopicRequest $request
     *
     * @return GetTopicResponse
     */
    public function getTopic($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTopicWithOptions($request, $runtime);
    }

    /**
     * Queries baseline instances affected by an event.
     *
     * @remarks
     * ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetTopicInfluence\\&type=RPC\\&version=2020-05-18)
     *
     * @param request - GetTopicInfluenceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns GetTopicInfluenceResponse
     *
     * @param GetTopicInfluenceRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return GetTopicInfluenceResponse
     */
    public function getTopicInfluenceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->topicId) {
            @$body['TopicId'] = $request->topicId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'GetTopicInfluence',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return GetTopicInfluenceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries baseline instances affected by an event.
     *
     * @remarks
     * ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetTopicInfluence\\&type=RPC\\&version=2020-05-18)
     *
     * @param request - GetTopicInfluenceRequest
     *
     * @returns GetTopicInfluenceResponse
     *
     * @param GetTopicInfluenceRequest $request
     *
     * @return GetTopicInfluenceResponse
     */
    public function getTopicInfluence($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->getTopicInfluenceWithOptions($request, $runtime);
    }

    /**
     * Imports data sources from your on-premises machine to a specific DataWorks workspace.
     *
     * @remarks
     * You can import self-managed data sources or data sources that are exported from other DataWorks workspaces to a specific DataWorks workspace.
     * *   To import a self-managed data source to a DataWorks workspace, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](https://help.aliyun.com/document_detail/181656.html).
     * *   For more information about how to export data sources from DataWorks workspaces to your on-premises machine, see [ExportDataSources](https://help.aliyun.com/document_detail/279570.html).
     *
     * @param request - ImportDataSourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ImportDataSourcesResponse
     *
     * @param ImportDataSourcesRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ImportDataSourcesResponse
     */
    public function importDataSourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dataSources) {
            @$query['DataSources'] = $request->dataSources;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ImportDataSources',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ImportDataSourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Imports data sources from your on-premises machine to a specific DataWorks workspace.
     *
     * @remarks
     * You can import self-managed data sources or data sources that are exported from other DataWorks workspaces to a specific DataWorks workspace.
     * *   To import a self-managed data source to a DataWorks workspace, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](https://help.aliyun.com/document_detail/181656.html).
     * *   For more information about how to export data sources from DataWorks workspaces to your on-premises machine, see [ExportDataSources](https://help.aliyun.com/document_detail/279570.html).
     *
     * @param request - ImportDataSourcesRequest
     *
     * @returns ImportDataSourcesResponse
     *
     * @param ImportDataSourcesRequest $request
     *
     * @return ImportDataSourcesResponse
     */
    public function importDataSources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->importDataSourcesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of alerts.
     *
     * @param request - ListAlertMessagesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListAlertMessagesResponse
     *
     * @param ListAlertMessagesRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListAlertMessagesResponse
     */
    public function listAlertMessagesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alertMethods) {
            @$body['AlertMethods'] = $request->alertMethods;
        }

        if (null !== $request->alertRuleTypes) {
            @$body['AlertRuleTypes'] = $request->alertRuleTypes;
        }

        if (null !== $request->alertUser) {
            @$body['AlertUser'] = $request->alertUser;
        }

        if (null !== $request->baselineId) {
            @$body['BaselineId'] = $request->baselineId;
        }

        if (null !== $request->beginTime) {
            @$body['BeginTime'] = $request->beginTime;
        }

        if (null !== $request->endTime) {
            @$body['EndTime'] = $request->endTime;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remindId) {
            @$body['RemindId'] = $request->remindId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListAlertMessages',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListAlertMessagesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of alerts.
     *
     * @param request - ListAlertMessagesRequest
     *
     * @returns ListAlertMessagesResponse
     *
     * @param ListAlertMessagesRequest $request
     *
     * @return ListAlertMessagesResponse
     */
    public function listAlertMessages($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listAlertMessagesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of baselines.
     *
     * @param request - ListBaselineConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBaselineConfigsResponse
     *
     * @param ListBaselineConfigsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListBaselineConfigsResponse
     */
    public function listBaselineConfigsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineTypes) {
            @$body['BaselineTypes'] = $request->baselineTypes;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->priority) {
            @$body['Priority'] = $request->priority;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->searchText) {
            @$body['SearchText'] = $request->searchText;
        }

        if (null !== $request->useflag) {
            @$body['Useflag'] = $request->useflag;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListBaselineConfigs',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBaselineConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of baselines.
     *
     * @param request - ListBaselineConfigsRequest
     *
     * @returns ListBaselineConfigsResponse
     *
     * @param ListBaselineConfigsRequest $request
     *
     * @return ListBaselineConfigsResponse
     */
    public function listBaselineConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselineConfigsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of baseline instances.
     *
     * @param request - ListBaselineStatusesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBaselineStatusesResponse
     *
     * @param ListBaselineStatusesRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListBaselineStatusesResponse
     */
    public function listBaselineStatusesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineTypes) {
            @$body['BaselineTypes'] = $request->baselineTypes;
        }

        if (null !== $request->bizdate) {
            @$body['Bizdate'] = $request->bizdate;
        }

        if (null !== $request->finishStatus) {
            @$body['FinishStatus'] = $request->finishStatus;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->priority) {
            @$body['Priority'] = $request->priority;
        }

        if (null !== $request->searchText) {
            @$body['SearchText'] = $request->searchText;
        }

        if (null !== $request->status) {
            @$body['Status'] = $request->status;
        }

        if (null !== $request->topicId) {
            @$body['TopicId'] = $request->topicId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListBaselineStatuses',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBaselineStatusesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of baseline instances.
     *
     * @param request - ListBaselineStatusesRequest
     *
     * @returns ListBaselineStatusesResponse
     *
     * @param ListBaselineStatusesRequest $request
     *
     * @return ListBaselineStatusesResponse
     */
    public function listBaselineStatuses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselineStatusesWithOptions($request, $runtime);
    }

    /**
     * Obtains a list of baselines.
     *
     * @param request - ListBaselinesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBaselinesResponse
     *
     * @param ListBaselinesRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ListBaselinesResponse
     */
    public function listBaselinesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineTypes) {
            @$body['BaselineTypes'] = $request->baselineTypes;
        }

        if (null !== $request->enable) {
            @$body['Enable'] = $request->enable;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->priority) {
            @$body['Priority'] = $request->priority;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->searchText) {
            @$body['SearchText'] = $request->searchText;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListBaselines',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBaselinesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains a list of baselines.
     *
     * @param request - ListBaselinesRequest
     *
     * @returns ListBaselinesResponse
     *
     * @param ListBaselinesRequest $request
     *
     * @return ListBaselinesResponse
     */
    public function listBaselines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBaselinesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of workflows.
     *
     * @param request - ListBusinessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListBusinessResponse
     *
     * @param ListBusinessRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ListBusinessResponse
     */
    public function listBusinessWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->keyword) {
            @$body['Keyword'] = $request->keyword;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListBusiness',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of workflows.
     *
     * @param request - ListBusinessRequest
     *
     * @returns ListBusinessResponse
     *
     * @param ListBusinessRequest $request
     *
     * @return ListBusinessResponse
     */
    public function listBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listBusinessWithOptions($request, $runtime);
    }

    /**
     * Queries a list of compute engines that are associated with a DataWorks workspace.
     *
     * @param request - ListCalcEnginesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCalcEnginesResponse
     *
     * @param ListCalcEnginesRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListCalcEnginesResponse
     */
    public function listCalcEnginesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->calcEngineType) {
            @$query['CalcEngineType'] = $request->calcEngineType;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListCalcEngines',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCalcEnginesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of compute engines that are associated with a DataWorks workspace.
     *
     * @param request - ListCalcEnginesRequest
     *
     * @returns ListCalcEnginesResponse
     *
     * @param ListCalcEnginesRequest $request
     *
     * @return ListCalcEnginesResponse
     */
    public function listCalcEngines($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCalcEnginesWithOptions($request, $runtime);
    }

    /**
     * Queries the check results of extension point events.
     *
     * @param request - ListCheckProcessesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListCheckProcessesResponse
     *
     * @param ListCheckProcessesRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListCheckProcessesResponse
     */
    public function listCheckProcessesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->eventCode) {
            @$body['EventCode'] = $request->eventCode;
        }

        if (null !== $request->messageId) {
            @$body['MessageId'] = $request->messageId;
        }

        if (null !== $request->operator) {
            @$body['Operator'] = $request->operator;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->status) {
            @$body['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListCheckProcesses',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListCheckProcessesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the check results of extension point events.
     *
     * @param request - ListCheckProcessesRequest
     *
     * @returns ListCheckProcessesResponse
     *
     * @param ListCheckProcessesRequest $request
     *
     * @return ListCheckProcessesResponse
     */
    public function listCheckProcesses($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listCheckProcessesWithOptions($request, $runtime);
    }

    /**
     * Queries the configurations of submodules in a workspace. You can query information about SPARK parameters.
     *
     * @param request - ListClusterConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListClusterConfigsResponse
     *
     * @param ListClusterConfigsRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListClusterConfigsResponse
     */
    public function listClusterConfigsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListClusterConfigs',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListClusterConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the configurations of submodules in a workspace. You can query information about SPARK parameters.
     *
     * @param request - ListClusterConfigsRequest
     *
     * @returns ListClusterConfigsResponse
     *
     * @param ListClusterConfigsRequest $request
     *
     * @return ListClusterConfigsResponse
     */
    public function listClusterConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClusterConfigsWithOptions($request, $runtime);
    }

    /**
     * Queries clusters that are registered in DataWorks. E-MapReduce (EMR) clusters and Cloudera\\"s Distribution Including Apache Hadoop (CDH) clusters are supported.
     *
     * @param request - ListClustersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListClustersResponse
     *
     * @param ListClustersRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ListClustersResponse
     */
    public function listClustersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListClusters',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListClustersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries clusters that are registered in DataWorks. E-MapReduce (EMR) clusters and Cloudera\\"s Distribution Including Apache Hadoop (CDH) clusters are supported.
     *
     * @param request - ListClustersRequest
     *
     * @returns ListClustersResponse
     *
     * @param ListClustersRequest $request
     *
     * @return ListClustersResponse
     */
    public function listClusters($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listClustersWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries a list of data sources.
     *
     * @deprecated OpenAPI ListConnections is deprecated
     *
     * @param request - ListConnectionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListConnectionsResponse
     *
     * @param ListConnectionsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListConnectionsResponse
     */
    public function listConnectionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListConnections',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListConnectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries a list of data sources.
     *
     * @deprecated OpenAPI ListConnections is deprecated
     *
     * @param request - ListConnectionsRequest
     *
     * @returns ListConnectionsResponse
     *
     * @param ListConnectionsRequest $request
     *
     * @return ListConnectionsResponse
     */
    public function listConnections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listConnectionsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of alert rules configured for a new-version synchronization task. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *
     * @param request - ListDIAlarmRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDIAlarmRulesResponse
     *
     * @param ListDIAlarmRulesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListDIAlarmRulesResponse
     */
    public function listDIAlarmRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->DIJobId) {
            @$body['DIJobId'] = $request->DIJobId;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDIAlarmRules',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDIAlarmRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of alert rules configured for a new-version synchronization task. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks that can be used for real-time data synchronization.
     *
     * @param request - ListDIAlarmRulesRequest
     *
     * @returns ListDIAlarmRulesResponse
     *
     * @param ListDIAlarmRulesRequest $request
     *
     * @return ListDIAlarmRulesResponse
     */
    public function listDIAlarmRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDIAlarmRulesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of new-version synchronization tasks. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can call this operation to obtain only the basic information about the tasks. If you want to obtain the details of a task, call the GetDIJob operation.
     *
     * @param request - ListDIJobsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDIJobsResponse
     *
     * @param ListDIJobsRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ListDIJobsResponse
     */
    public function listDIJobsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->destinationDataSourceType) {
            @$body['DestinationDataSourceType'] = $request->destinationDataSourceType;
        }

        if (null !== $request->jobName) {
            @$body['JobName'] = $request->jobName;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->sourceDataSourceType) {
            @$body['SourceDataSourceType'] = $request->sourceDataSourceType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDIJobs',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDIJobsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of new-version synchronization tasks. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @remarks
     * You can call this operation to obtain only the basic information about the tasks. If you want to obtain the details of a task, call the GetDIJob operation.
     *
     * @param request - ListDIJobsRequest
     *
     * @returns ListDIJobsResponse
     *
     * @param ListDIJobsRequest $request
     *
     * @return ListDIJobsResponse
     */
    public function listDIJobs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDIJobsWithOptions($request, $runtime);
    }

    /**
     * Queries the default global configurations of synchronization solutions in a specified DataWorks workspace.
     *
     * @remarks
     * DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *
     * @param request - ListDIProjectConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDIProjectConfigResponse
     *
     * @param ListDIProjectConfigRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListDIProjectConfigResponse
     */
    public function listDIProjectConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destinationType) {
            @$query['DestinationType'] = $request->destinationType;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->sourceType) {
            @$query['SourceType'] = $request->sourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDIProjectConfig',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDIProjectConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the default global configurations of synchronization solutions in a specified DataWorks workspace.
     *
     * @remarks
     * DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *
     * @param request - ListDIProjectConfigRequest
     *
     * @returns ListDIProjectConfigResponse
     *
     * @param ListDIProjectConfigRequest $request
     *
     * @return ListDIProjectConfigResponse
     */
    public function listDIProjectConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDIProjectConfigWithOptions($request, $runtime);
    }

    /**
     * Queries the details of directed acyclic graphs (DAGs) for a single data backfill instance based on OpSeq.
     *
     * @remarks
     * Supported DAG types:
     * *   MANUAL: DAG for a manually triggered workflow
     * *   SMOKE_TEST: DAG for a smoke testing workflow
     * *   SUPPLY_DATA: DAG for a data backfill instance
     * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
     * Supported DAG states:
     * *   CREATED: The DAG is created.
     * *   RUNNING: The DAG is running.
     * *   FAILURE: The DAG fails to run.
     * *   SUCCESS: The DAG is successfully run.
     *
     * @param request - ListDagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDagsResponse
     *
     * @param ListDagsRequest $request
     * @param RuntimeOptions  $runtime
     *
     * @return ListDagsResponse
     */
    public function listDagsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->opSeq) {
            @$body['OpSeq'] = $request->opSeq;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDags',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of directed acyclic graphs (DAGs) for a single data backfill instance based on OpSeq.
     *
     * @remarks
     * Supported DAG types:
     * *   MANUAL: DAG for a manually triggered workflow
     * *   SMOKE_TEST: DAG for a smoke testing workflow
     * *   SUPPLY_DATA: DAG for a data backfill instance
     * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
     * Supported DAG states:
     * *   CREATED: The DAG is created.
     * *   RUNNING: The DAG is running.
     * *   FAILURE: The DAG fails to run.
     * *   SUCCESS: The DAG is successfully run.
     *
     * @param request - ListDagsRequest
     *
     * @returns ListDagsResponse
     *
     * @param ListDagsRequest $request
     *
     * @return ListDagsResponse
     */
    public function listDags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDagsWithOptions($request, $runtime);
    }

    /**
     * Queries the APIs on which other users are granted the access permissions.
     *
     * @param request - ListDataServiceApiAuthoritiesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDataServiceApiAuthoritiesResponse
     *
     * @param ListDataServiceApiAuthoritiesRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ListDataServiceApiAuthoritiesResponse
     */
    public function listDataServiceApiAuthoritiesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $body = [];
        if (null !== $request->apiNameKeyword) {
            @$body['ApiNameKeyword'] = $request->apiNameKeyword;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDataServiceApiAuthorities',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDataServiceApiAuthoritiesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the APIs on which other users are granted the access permissions.
     *
     * @param request - ListDataServiceApiAuthoritiesRequest
     *
     * @returns ListDataServiceApiAuthoritiesResponse
     *
     * @param ListDataServiceApiAuthoritiesRequest $request
     *
     * @return ListDataServiceApiAuthoritiesResponse
     */
    public function listDataServiceApiAuthorities($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApiAuthoritiesWithOptions($request, $runtime);
    }

    /**
     * Queries the test records of a DataService Studio API. This API operation allows you to query only the test records that are generated within the previous month.
     *
     * @param request - ListDataServiceApiTestRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDataServiceApiTestResponse
     *
     * @param ListDataServiceApiTestRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListDataServiceApiTestResponse
     */
    public function listDataServiceApiTestWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDataServiceApiTest',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDataServiceApiTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the test records of a DataService Studio API. This API operation allows you to query only the test records that are generated within the previous month.
     *
     * @param request - ListDataServiceApiTestRequest
     *
     * @returns ListDataServiceApiTestResponse
     *
     * @param ListDataServiceApiTestRequest $request
     *
     * @return ListDataServiceApiTestResponse
     */
    public function listDataServiceApiTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApiTestWithOptions($request, $runtime);
    }

    /**
     * Queries a list of APIs in the development state.
     *
     * @param request - ListDataServiceApisRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDataServiceApisResponse
     *
     * @param ListDataServiceApisRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListDataServiceApisResponse
     */
    public function listDataServiceApisWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiNameKeyword) {
            @$body['ApiNameKeyword'] = $request->apiNameKeyword;
        }

        if (null !== $request->apiPathKeyword) {
            @$body['ApiPathKeyword'] = $request->apiPathKeyword;
        }

        if (null !== $request->creatorId) {
            @$body['CreatorId'] = $request->creatorId;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDataServiceApis',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDataServiceApisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of APIs in the development state.
     *
     * @param request - ListDataServiceApisRequest
     *
     * @returns ListDataServiceApisResponse
     *
     * @param ListDataServiceApisRequest $request
     *
     * @return ListDataServiceApisResponse
     */
    public function listDataServiceApis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApisWithOptions($request, $runtime);
    }

    /**
     * Queries the basic information of applications.
     *
     * @param request - ListDataServiceApplicationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDataServiceApplicationsResponse
     *
     * @param ListDataServiceApplicationsRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return ListDataServiceApplicationsResponse
     */
    public function listDataServiceApplicationsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectIdList) {
            @$body['ProjectIdList'] = $request->projectIdList;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDataServiceApplications',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDataServiceApplicationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the basic information of applications.
     *
     * @param request - ListDataServiceApplicationsRequest
     *
     * @returns ListDataServiceApplicationsResponse
     *
     * @param ListDataServiceApplicationsRequest $request
     *
     * @return ListDataServiceApplicationsResponse
     */
    public function listDataServiceApplications($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceApplicationsWithOptions($request, $runtime);
    }

    /**
     * Queries the APIs that you are authorized to access.
     *
     * @param request - ListDataServiceAuthorizedApisRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDataServiceAuthorizedApisResponse
     *
     * @param ListDataServiceAuthorizedApisRequest $request
     * @param RuntimeOptions                       $runtime
     *
     * @return ListDataServiceAuthorizedApisResponse
     */
    public function listDataServiceAuthorizedApisWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $body = [];
        if (null !== $request->apiNameKeyword) {
            @$body['ApiNameKeyword'] = $request->apiNameKeyword;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDataServiceAuthorizedApis',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDataServiceAuthorizedApisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the APIs that you are authorized to access.
     *
     * @param request - ListDataServiceAuthorizedApisRequest
     *
     * @returns ListDataServiceAuthorizedApisResponse
     *
     * @param ListDataServiceAuthorizedApisRequest $request
     *
     * @return ListDataServiceAuthorizedApisResponse
     */
    public function listDataServiceAuthorizedApis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceAuthorizedApisWithOptions($request, $runtime);
    }

    /**
     * Queries folders.
     *
     * @param request - ListDataServiceFoldersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDataServiceFoldersResponse
     *
     * @param ListDataServiceFoldersRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListDataServiceFoldersResponse
     */
    public function listDataServiceFoldersWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->folderNameKeyword) {
            @$body['FolderNameKeyword'] = $request->folderNameKeyword;
        }

        if (null !== $request->groupId) {
            @$body['GroupId'] = $request->groupId;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDataServiceFolders',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDataServiceFoldersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries folders.
     *
     * @param request - ListDataServiceFoldersRequest
     *
     * @returns ListDataServiceFoldersResponse
     *
     * @param ListDataServiceFoldersRequest $request
     *
     * @return ListDataServiceFoldersResponse
     */
    public function listDataServiceFolders($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceFoldersWithOptions($request, $runtime);
    }

    /**
     * Queries business processes.
     *
     * @param request - ListDataServiceGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDataServiceGroupsResponse
     *
     * @param ListDataServiceGroupsRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListDataServiceGroupsResponse
     */
    public function listDataServiceGroupsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->groupNameKeyword) {
            @$body['GroupNameKeyword'] = $request->groupNameKeyword;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDataServiceGroups',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDataServiceGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries business processes.
     *
     * @param request - ListDataServiceGroupsRequest
     *
     * @returns ListDataServiceGroupsResponse
     *
     * @param ListDataServiceGroupsRequest $request
     *
     * @return ListDataServiceGroupsResponse
     */
    public function listDataServiceGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServiceGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of APIs in the published state.
     *
     * @param request - ListDataServicePublishedApisRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDataServicePublishedApisResponse
     *
     * @param ListDataServicePublishedApisRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return ListDataServicePublishedApisResponse
     */
    public function listDataServicePublishedApisWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiNameKeyword) {
            @$body['ApiNameKeyword'] = $request->apiNameKeyword;
        }

        if (null !== $request->apiPathKeyword) {
            @$body['ApiPathKeyword'] = $request->apiPathKeyword;
        }

        if (null !== $request->creatorId) {
            @$body['CreatorId'] = $request->creatorId;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDataServicePublishedApis',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDataServicePublishedApisResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of APIs in the published state.
     *
     * @param request - ListDataServicePublishedApisRequest
     *
     * @returns ListDataServicePublishedApisResponse
     *
     * @param ListDataServicePublishedApisRequest $request
     *
     * @return ListDataServicePublishedApisResponse
     */
    public function listDataServicePublishedApis($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataServicePublishedApisWithOptions($request, $runtime);
    }

    /**
     * Queries the data sources added to a DataWorks workspace.
     *
     * @param request - ListDataSourcesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDataSourcesResponse
     *
     * @param ListDataSourcesRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListDataSourcesResponse
     */
    public function listDataSourcesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListDataSources',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDataSourcesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the data sources added to a DataWorks workspace.
     *
     * @param request - ListDataSourcesRequest
     *
     * @returns ListDataSourcesResponse
     *
     * @param ListDataSourcesRequest $request
     *
     * @return ListDataSourcesResponse
     */
    public function listDataSources($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDataSourcesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of deployment packages. This operation is equivalent to viewing a list of deployment packages on the Deployment Packages page of the DataWorks console.
     *
     * @param request - ListDeploymentsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListDeploymentsResponse
     *
     * @param ListDeploymentsRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListDeploymentsResponse
     */
    public function listDeploymentsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->creator) {
            @$body['Creator'] = $request->creator;
        }

        if (null !== $request->endCreateTime) {
            @$body['EndCreateTime'] = $request->endCreateTime;
        }

        if (null !== $request->endExecuteTime) {
            @$body['EndExecuteTime'] = $request->endExecuteTime;
        }

        if (null !== $request->executor) {
            @$body['Executor'] = $request->executor;
        }

        if (null !== $request->keyword) {
            @$body['Keyword'] = $request->keyword;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->status) {
            @$body['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListDeployments',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListDeploymentsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of deployment packages. This operation is equivalent to viewing a list of deployment packages on the Deployment Packages page of the DataWorks console.
     *
     * @param request - ListDeploymentsRequest
     *
     * @returns ListDeploymentsResponse
     *
     * @param ListDeploymentsRequest $request
     *
     * @return ListDeploymentsResponse
     */
    public function listDeployments($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listDeploymentsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of built-in and custom extensions that are enabled in a workspace.
     *
     * @remarks
     * For information about codes of extension point events, see [Development references: Extension point event codes](https://help.aliyun.com/document_detail/463357.html).
     *
     * @param request - ListEnabledExtensionsForProjectRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEnabledExtensionsForProjectResponse
     *
     * @param ListEnabledExtensionsForProjectRequest $request
     * @param RuntimeOptions                         $runtime
     *
     * @return ListEnabledExtensionsForProjectResponse
     */
    public function listEnabledExtensionsForProjectWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->eventCode) {
            @$body['EventCode'] = $request->eventCode;
        }

        if (null !== $request->fileType) {
            @$body['FileType'] = $request->fileType;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListEnabledExtensionsForProject',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEnabledExtensionsForProjectResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of built-in and custom extensions that are enabled in a workspace.
     *
     * @remarks
     * For information about codes of extension point events, see [Development references: Extension point event codes](https://help.aliyun.com/document_detail/463357.html).
     *
     * @param request - ListEnabledExtensionsForProjectRequest
     *
     * @returns ListEnabledExtensionsForProjectResponse
     *
     * @param ListEnabledExtensionsForProjectRequest $request
     *
     * @return ListEnabledExtensionsForProjectResponse
     */
    public function listEnabledExtensionsForProject($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEnabledExtensionsForProjectWithOptions($request, $runtime);
    }

    /**
     * Queries a list of entities by tag. Only entities of the maxcompute-table type are supported.
     *
     * @param tmpReq - ListEntitiesByTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEntitiesByTagsResponse
     *
     * @param ListEntitiesByTagsRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return ListEntitiesByTagsResponse
     */
    public function listEntitiesByTagsWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ListEntitiesByTagsShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->tags) {
            $request->tagsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }

        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEntitiesByTags',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEntitiesByTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of entities by tag. Only entities of the maxcompute-table type are supported.
     *
     * @param request - ListEntitiesByTagsRequest
     *
     * @returns ListEntitiesByTagsResponse
     *
     * @param ListEntitiesByTagsRequest $request
     *
     * @return ListEntitiesByTagsResponse
     */
    public function listEntitiesByTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEntitiesByTagsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of tags of an entity. Only entities of the maxcompute-table type are supported.
     *
     * @param request - ListEntityTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListEntityTagsResponse
     *
     * @param ListEntityTagsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListEntityTagsResponse
     */
    public function listEntityTagsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListEntityTags',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListEntityTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of tags of an entity. Only entities of the maxcompute-table type are supported.
     *
     * @param request - ListEntityTagsRequest
     *
     * @returns ListEntityTagsResponse
     *
     * @param ListEntityTagsRequest $request
     *
     * @return ListEntityTagsResponse
     */
    public function listEntityTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listEntityTagsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of extensions.
     *
     * @param request - ListExtensionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListExtensionsResponse
     *
     * @param ListExtensionsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListExtensionsResponse
     */
    public function listExtensionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListExtensions',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListExtensionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of extensions.
     *
     * @param request - ListExtensionsRequest
     *
     * @returns ListExtensionsResponse
     *
     * @param ListExtensionsRequest $request
     *
     * @return ListExtensionsResponse
     */
    public function listExtensions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listExtensionsWithOptions($request, $runtime);
    }

    /**
     * Queries the information about node types, such as the code and name.
     *
     * @param request - ListFileTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListFileTypeResponse
     *
     * @param ListFileTypeRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return ListFileTypeResponse
     */
    public function listFileTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->keyword) {
            @$body['Keyword'] = $request->keyword;
        }

        if (null !== $request->locale) {
            @$body['Locale'] = $request->locale;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListFileType',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListFileTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about node types, such as the code and name.
     *
     * @param request - ListFileTypeRequest
     *
     * @returns ListFileTypeResponse
     *
     * @param ListFileTypeRequest $request
     *
     * @return ListFileTypeResponse
     */
    public function listFileType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileTypeWithOptions($request, $runtime);
    }

    /**
     * Queries a list of file versions.
     *
     * @param request - ListFileVersionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListFileVersionsResponse
     *
     * @param ListFileVersionsRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListFileVersionsResponse
     */
    public function listFileVersionsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->fileId) {
            @$body['FileId'] = $request->fileId;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListFileVersions',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListFileVersionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of file versions.
     *
     * @param request - ListFileVersionsRequest
     *
     * @returns ListFileVersionsResponse
     *
     * @param ListFileVersionsRequest $request
     *
     * @return ListFileVersionsResponse
     */
    public function listFileVersions($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFileVersionsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of files.
     *
     * @param request - ListFilesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListFilesResponse
     *
     * @param ListFilesRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return ListFilesResponse
     */
    public function listFilesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->exactFileName) {
            @$body['ExactFileName'] = $request->exactFileName;
        }

        if (null !== $request->fileFolderPath) {
            @$body['FileFolderPath'] = $request->fileFolderPath;
        }

        if (null !== $request->fileIdIn) {
            @$body['FileIdIn'] = $request->fileIdIn;
        }

        if (null !== $request->fileTypes) {
            @$body['FileTypes'] = $request->fileTypes;
        }

        if (null !== $request->keyword) {
            @$body['Keyword'] = $request->keyword;
        }

        if (null !== $request->lastEditUser) {
            @$body['LastEditUser'] = $request->lastEditUser;
        }

        if (null !== $request->needAbsoluteFolderPath) {
            @$body['NeedAbsoluteFolderPath'] = $request->needAbsoluteFolderPath;
        }

        if (null !== $request->needContent) {
            @$body['NeedContent'] = $request->needContent;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->useType) {
            @$body['UseType'] = $request->useType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListFiles',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListFilesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of files.
     *
     * @param request - ListFilesRequest
     *
     * @returns ListFilesResponse
     *
     * @param ListFilesRequest $request
     *
     * @return ListFilesResponse
     */
    public function listFiles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFilesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of folders.
     *
     * @param request - ListFoldersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListFoldersResponse
     *
     * @param ListFoldersRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return ListFoldersResponse
     */
    public function listFoldersWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->parentFolderPath) {
            @$body['ParentFolderPath'] = $request->parentFolderPath;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListFolders',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListFoldersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of folders.
     *
     * @param request - ListFoldersRequest
     *
     * @returns ListFoldersResponse
     *
     * @param ListFoldersRequest $request
     *
     * @return ListFoldersResponse
     */
    public function listFolders($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listFoldersWithOptions($request, $runtime);
    }

    /**
     * Queries information about inner nodes. For example, you can call this operation to query the inner nodes of a node group or a do-while node. You cannot call this operation to query the inner nodes of a PAI node.
     *
     * @param request - ListInnerNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInnerNodesResponse
     *
     * @param ListInnerNodesRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListInnerNodesResponse
     */
    public function listInnerNodesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->nodeName) {
            @$body['NodeName'] = $request->nodeName;
        }

        if (null !== $request->outerNodeId) {
            @$body['OuterNodeId'] = $request->outerNodeId;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->programType) {
            @$body['ProgramType'] = $request->programType;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListInnerNodes',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInnerNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about inner nodes. For example, you can call this operation to query the inner nodes of a node group or a do-while node. You cannot call this operation to query the inner nodes of a PAI node.
     *
     * @param request - ListInnerNodesRequest
     *
     * @returns ListInnerNodesResponse
     *
     * @param ListInnerNodesRequest $request
     *
     * @return ListInnerNodesResponse
     */
    public function listInnerNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInnerNodesWithOptions($request, $runtime);
    }

    /**
     * Queries the trend of the number of auto triggered node instances within a specified period of time.
     *
     * @param request - ListInstanceAmountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInstanceAmountResponse
     *
     * @param ListInstanceAmountRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListInstanceAmountResponse
     */
    public function listInstanceAmountWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->beginDate) {
            @$body['BeginDate'] = $request->beginDate;
        }

        if (null !== $request->endDate) {
            @$body['EndDate'] = $request->endDate;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListInstanceAmount',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInstanceAmountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the trend of the number of auto triggered node instances within a specified period of time.
     *
     * @param request - ListInstanceAmountRequest
     *
     * @returns ListInstanceAmountResponse
     *
     * @param ListInstanceAmountRequest $request
     *
     * @return ListInstanceAmountResponse
     */
    public function listInstanceAmount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceAmountWithOptions($request, $runtime);
    }

    /**
     * Queries information about the historical records of all instances. One historical record is generated if an instance is rerun once.
     *
     * @param request - ListInstanceHistoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInstanceHistoryResponse
     *
     * @param ListInstanceHistoryRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListInstanceHistoryResponse
     */
    public function listInstanceHistoryWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListInstanceHistory',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInstanceHistoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about the historical records of all instances. One historical record is generated if an instance is rerun once.
     *
     * @param request - ListInstanceHistoryRequest
     *
     * @returns ListInstanceHistoryResponse
     *
     * @param ListInstanceHistoryRequest $request
     *
     * @return ListInstanceHistoryResponse
     */
    public function listInstanceHistory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstanceHistoryWithOptions($request, $runtime);
    }

    /**
     * Queries a list of instances.
     *
     * @param request - ListInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListInstancesResponse
     *
     * @param ListInstancesRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return ListInstancesResponse
     */
    public function listInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->beginBizdate) {
            @$body['BeginBizdate'] = $request->beginBizdate;
        }

        if (null !== $request->bizName) {
            @$body['BizName'] = $request->bizName;
        }

        if (null !== $request->bizdate) {
            @$body['Bizdate'] = $request->bizdate;
        }

        if (null !== $request->dagId) {
            @$body['DagId'] = $request->dagId;
        }

        if (null !== $request->endBizdate) {
            @$body['EndBizdate'] = $request->endBizdate;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->nodeName) {
            @$body['NodeName'] = $request->nodeName;
        }

        if (null !== $request->orderBy) {
            @$body['OrderBy'] = $request->orderBy;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->programType) {
            @$body['ProgramType'] = $request->programType;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->status) {
            @$body['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListInstances',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of instances.
     *
     * @param request - ListInstancesRequest
     *
     * @returns ListInstancesResponse
     *
     * @param ListInstancesRequest $request
     *
     * @return ListInstancesResponse
     */
    public function listInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries the ancestor or descendant lineage of an entity.
     *
     * @param request - ListLineageRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListLineageResponse
     *
     * @param ListLineageRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return ListLineageResponse
     */
    public function listLineageWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->direction) {
            @$query['Direction'] = $request->direction;
        }

        if (null !== $request->entityQualifiedName) {
            @$query['EntityQualifiedName'] = $request->entityQualifiedName;
        }

        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListLineage',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListLineageResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the ancestor or descendant lineage of an entity.
     *
     * @param request - ListLineageRequest
     *
     * @returns ListLineageResponse
     *
     * @param ListLineageRequest $request
     *
     * @return ListLineageResponse
     */
    public function listLineage($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listLineageWithOptions($request, $runtime);
    }

    /**
     * Queries the information about instances in a manually triggered workflow.
     *
     * @param request - ListManualDagInstancesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListManualDagInstancesResponse
     *
     * @param ListManualDagInstancesRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return ListManualDagInstancesResponse
     */
    public function listManualDagInstancesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->dagId) {
            @$body['DagId'] = $request->dagId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListManualDagInstances',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListManualDagInstancesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the information about instances in a manually triggered workflow.
     *
     * @param request - ListManualDagInstancesRequest
     *
     * @returns ListManualDagInstancesResponse
     *
     * @param ListManualDagInstancesRequest $request
     *
     * @return ListManualDagInstancesResponse
     */
    public function listManualDagInstances($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listManualDagInstancesWithOptions($request, $runtime);
    }

    /**
     * Queries the statistics on the number of phone call-based alerts or text message-based alerts reported within the tenant to which your account belongs during the previous 30 days.
     *
     * @param request - ListMeasureDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMeasureDataResponse
     *
     * @param ListMeasureDataRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return ListMeasureDataResponse
     */
    public function listMeasureDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->componentCode) {
            @$query['ComponentCode'] = $request->componentCode;
        }

        if (null !== $request->domainCode) {
            @$query['DomainCode'] = $request->domainCode;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListMeasureData',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMeasureDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the statistics on the number of phone call-based alerts or text message-based alerts reported within the tenant to which your account belongs during the previous 30 days.
     *
     * @param request - ListMeasureDataRequest
     *
     * @returns ListMeasureDataResponse
     *
     * @param ListMeasureDataRequest $request
     *
     * @return ListMeasureDataResponse
     */
    public function listMeasureData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMeasureDataWithOptions($request, $runtime);
    }

    /**
     * Queries the entities in a collection.
     *
     * @param request - ListMetaCollectionEntitiesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMetaCollectionEntitiesResponse
     *
     * @param ListMetaCollectionEntitiesRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListMetaCollectionEntitiesResponse
     */
    public function listMetaCollectionEntitiesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->collectionQualifiedName) {
            @$query['CollectionQualifiedName'] = $request->collectionQualifiedName;
        }

        if (null !== $request->entityType) {
            @$query['EntityType'] = $request->entityType;
        }

        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListMetaCollectionEntities',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMetaCollectionEntitiesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the entities in a collection.
     *
     * @param request - ListMetaCollectionEntitiesRequest
     *
     * @returns ListMetaCollectionEntitiesResponse
     *
     * @param ListMetaCollectionEntitiesRequest $request
     *
     * @return ListMetaCollectionEntitiesResponse
     */
    public function listMetaCollectionEntities($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMetaCollectionEntitiesWithOptions($request, $runtime);
    }

    /**
     * Queries information about collections. Collections include data albums that are displayed on the Data Map page and categories that are created in the data albums. You can call this API operation to query collections by type.
     *
     * @remarks
     * The type can be ALBUM or ALBUM_CATEGORY. ALBUM indicates data albums. ALBUM_CATEGORY indicates categories.
     *
     * @param request - ListMetaCollectionsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMetaCollectionsResponse
     *
     * @param ListMetaCollectionsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListMetaCollectionsResponse
     */
    public function listMetaCollectionsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->administrator) {
            @$query['Administrator'] = $request->administrator;
        }

        if (null !== $request->collectionType) {
            @$query['CollectionType'] = $request->collectionType;
        }

        if (null !== $request->creator) {
            @$query['Creator'] = $request->creator;
        }

        if (null !== $request->follower) {
            @$query['Follower'] = $request->follower;
        }

        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->orderBy) {
            @$query['OrderBy'] = $request->orderBy;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->parentQualifiedName) {
            @$query['ParentQualifiedName'] = $request->parentQualifiedName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListMetaCollections',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMetaCollectionsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about collections. Collections include data albums that are displayed on the Data Map page and categories that are created in the data albums. You can call this API operation to query collections by type.
     *
     * @remarks
     * The type can be ALBUM or ALBUM_CATEGORY. ALBUM indicates data albums. ALBUM_CATEGORY indicates categories.
     *
     * @param request - ListMetaCollectionsRequest
     *
     * @returns ListMetaCollectionsResponse
     *
     * @param ListMetaCollectionsRequest $request
     *
     * @return ListMetaCollectionsResponse
     */
    public function listMetaCollections($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMetaCollectionsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of metadatabases.
     *
     * @param request - ListMetaDBRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMetaDBResponse
     *
     * @param ListMetaDBRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ListMetaDBResponse
     */
    public function listMetaDBWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListMetaDB',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMetaDBResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of metadatabases.
     *
     * @param request - ListMetaDBRequest
     *
     * @returns ListMetaDBResponse
     *
     * @param ListMetaDBRequest $request
     *
     * @return ListMetaDBResponse
     */
    public function listMetaDB($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMetaDBWithOptions($request, $runtime);
    }

    /**
     * Queries a list of migration tasks.
     *
     * @param request - ListMigrationsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListMigrationsResponse
     *
     * @param ListMigrationsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListMigrationsResponse
     */
    public function listMigrationsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->migrationType) {
            @$body['MigrationType'] = $request->migrationType;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListMigrations',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListMigrationsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of migration tasks.
     *
     * @param request - ListMigrationsRequest
     *
     * @returns ListMigrationsResponse
     *
     * @param ListMigrationsRequest $request
     *
     * @return ListMigrationsResponse
     */
    public function listMigrations($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listMigrationsWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the information about one level of ancestor or descendant nodes of a node.
     *
     * @deprecated OpenAPI ListNodeIO is deprecated
     *
     * @param request - ListNodeIORequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListNodeIOResponse
     *
     * @param ListNodeIORequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ListNodeIOResponse
     */
    public function listNodeIOWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->ioType) {
            @$body['IoType'] = $request->ioType;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListNodeIO',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListNodeIOResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the information about one level of ancestor or descendant nodes of a node.
     *
     * @deprecated OpenAPI ListNodeIO is deprecated
     *
     * @param request - ListNodeIORequest
     *
     * @returns ListNodeIOResponse
     *
     * @param ListNodeIORequest $request
     *
     * @return ListNodeIOResponse
     */
    public function listNodeIO($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodeIOWithOptions($request, $runtime);
    }

    /**
     * Queries the input and output information about a node. Only the ancestor or descendant nodes at the nearest level can be queried each time.
     *
     * @param request - ListNodeInputOrOutputRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListNodeInputOrOutputResponse
     *
     * @param ListNodeInputOrOutputRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return ListNodeInputOrOutputResponse
     */
    public function listNodeInputOrOutputWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->ioType) {
            @$body['IoType'] = $request->ioType;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListNodeInputOrOutput',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListNodeInputOrOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the input and output information about a node. Only the ancestor or descendant nodes at the nearest level can be queried each time.
     *
     * @param request - ListNodeInputOrOutputRequest
     *
     * @returns ListNodeInputOrOutputResponse
     *
     * @param ListNodeInputOrOutputRequest $request
     *
     * @return ListNodeInputOrOutputResponse
     */
    public function listNodeInputOrOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodeInputOrOutputWithOptions($request, $runtime);
    }

    /**
     * The ID of the workspace.
     *
     * @param request - ListNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListNodesResponse
     *
     * @param ListNodesRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return ListNodesResponse
     */
    public function listNodesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->bizName) {
            @$body['BizName'] = $request->bizName;
        }

        if (null !== $request->nodeName) {
            @$body['NodeName'] = $request->nodeName;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->programType) {
            @$body['ProgramType'] = $request->programType;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->schedulerType) {
            @$body['SchedulerType'] = $request->schedulerType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListNodes',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * The ID of the workspace.
     *
     * @param request - ListNodesRequest
     *
     * @returns ListNodesResponse
     *
     * @param ListNodesRequest $request
     *
     * @return ListNodesResponse
     */
    public function listNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodesWithOptions($request, $runtime);
    }

    /**
     * Queries nodes in a baseline.
     *
     * @param request - ListNodesByBaselineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListNodesByBaselineResponse
     *
     * @param ListNodesByBaselineRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListNodesByBaselineResponse
     */
    public function listNodesByBaselineWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->baselineId) {
            @$body['BaselineId'] = $request->baselineId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListNodesByBaseline',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListNodesByBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries nodes in a baseline.
     *
     * @param request - ListNodesByBaselineRequest
     *
     * @returns ListNodesByBaselineResponse
     *
     * @param ListNodesByBaselineRequest $request
     *
     * @return ListNodesByBaselineResponse
     */
    public function listNodesByBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodesByBaselineWithOptions($request, $runtime);
    }

    /**
     * Queries nodes based on the output of the nodes.
     *
     * @param request - ListNodesByOutputRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListNodesByOutputResponse
     *
     * @param ListNodesByOutputRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ListNodesByOutputResponse
     */
    public function listNodesByOutputWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->outputs) {
            @$body['Outputs'] = $request->outputs;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListNodesByOutput',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListNodesByOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries nodes based on the output of the nodes.
     *
     * @param request - ListNodesByOutputRequest
     *
     * @returns ListNodesByOutputResponse
     *
     * @param ListNodesByOutputRequest $request
     *
     * @return ListNodesByOutputResponse
     */
    public function listNodesByOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listNodesByOutputWithOptions($request, $runtime);
    }

    /**
     * Queries a list of permission request orders.
     *
     * @param request - ListPermissionApplyOrdersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListPermissionApplyOrdersResponse
     *
     * @param ListPermissionApplyOrdersRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListPermissionApplyOrdersResponse
     */
    public function listPermissionApplyOrdersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->applyType) {
            @$query['ApplyType'] = $request->applyType;
        }

        if (null !== $request->catalogName) {
            @$query['CatalogName'] = $request->catalogName;
        }

        if (null !== $request->endTime) {
            @$query['EndTime'] = $request->endTime;
        }

        if (null !== $request->engineType) {
            @$query['EngineType'] = $request->engineType;
        }

        if (null !== $request->flowStatus) {
            @$query['FlowStatus'] = $request->flowStatus;
        }

        if (null !== $request->maxComputeProjectName) {
            @$query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }

        if (null !== $request->orderType) {
            @$query['OrderType'] = $request->orderType;
        }

        if (null !== $request->pageNum) {
            @$query['PageNum'] = $request->pageNum;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->queryType) {
            @$query['QueryType'] = $request->queryType;
        }

        if (null !== $request->startTime) {
            @$query['StartTime'] = $request->startTime;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        if (null !== $request->workspaceId) {
            @$query['WorkspaceId'] = $request->workspaceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListPermissionApplyOrders',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListPermissionApplyOrdersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of permission request orders.
     *
     * @param request - ListPermissionApplyOrdersRequest
     *
     * @returns ListPermissionApplyOrdersResponse
     *
     * @param ListPermissionApplyOrdersRequest $request
     *
     * @return ListPermissionApplyOrdersResponse
     */
    public function listPermissionApplyOrders($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listPermissionApplyOrdersWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries the distribution of different types of nodes.
     *
     * @deprecated OpenAPI ListProgramTypeCount is deprecated
     *
     * @param request - ListProgramTypeCountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListProgramTypeCountResponse
     *
     * @param ListProgramTypeCountRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return ListProgramTypeCountResponse
     */
    public function listProgramTypeCountWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListProgramTypeCount',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListProgramTypeCountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries the distribution of different types of nodes.
     *
     * @deprecated OpenAPI ListProgramTypeCount is deprecated
     *
     * @param request - ListProgramTypeCountRequest
     *
     * @returns ListProgramTypeCountResponse
     *
     * @param ListProgramTypeCountRequest $request
     *
     * @return ListProgramTypeCountResponse
     */
    public function listProgramTypeCount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProgramTypeCountWithOptions($request, $runtime);
    }

    /**
     * Queries the IDs of the workspaces on which a specific Alibaba Cloud account or RAM user has permissions in a specific region.
     *
     * @remarks
     * An Alibaba Cloud account can assume a role such as the developer, O\\&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
     *
     * @param request - ListProjectIdsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListProjectIdsResponse
     *
     * @param ListProjectIdsRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListProjectIdsResponse
     */
    public function listProjectIdsWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListProjectIds',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListProjectIdsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the IDs of the workspaces on which a specific Alibaba Cloud account or RAM user has permissions in a specific region.
     *
     * @remarks
     * An Alibaba Cloud account can assume a role such as the developer, O\\&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
     *
     * @param request - ListProjectIdsRequest
     *
     * @returns ListProjectIdsResponse
     *
     * @param ListProjectIdsRequest $request
     *
     * @return ListProjectIdsResponse
     */
    public function listProjectIds($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectIdsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of existing members in a DataWorks workspace.
     *
     * @param request - ListProjectMembersRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListProjectMembersResponse
     *
     * @param ListProjectMembersRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListProjectMembersResponse
     */
    public function listProjectMembersWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListProjectMembers',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListProjectMembersResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of existing members in a DataWorks workspace.
     *
     * @param request - ListProjectMembersRequest
     *
     * @returns ListProjectMembersResponse
     *
     * @param ListProjectMembersRequest $request
     *
     * @return ListProjectMembersResponse
     */
    public function listProjectMembers($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectMembersWithOptions($request, $runtime);
    }

    /**
     * Queries a list of roles in a DataWorks workspace.
     *
     * @remarks
     * ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=ListProjectRoles\\&type=RPC\\&version=2020-05-18)
     *
     * @param request - ListProjectRolesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListProjectRolesResponse
     *
     * @param ListProjectRolesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListProjectRolesResponse
     */
    public function listProjectRolesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListProjectRoles',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListProjectRolesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of roles in a DataWorks workspace.
     *
     * @remarks
     * ## Debugging
     * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=ListProjectRoles\\&type=RPC\\&version=2020-05-18)
     *
     * @param request - ListProjectRolesRequest
     *
     * @returns ListProjectRolesResponse
     *
     * @param ListProjectRolesRequest $request
     *
     * @return ListProjectRolesResponse
     */
    public function listProjectRoles($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectRolesWithOptions($request, $runtime);
    }

    /**
     * Queries a list of DataWorks workspaces of the tenant to which a user belongs.
     *
     * @param tmpReq - ListProjectsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListProjectsResponse
     *
     * @param ListProjectsRequest $tmpReq
     * @param RuntimeOptions      $runtime
     *
     * @return ListProjectsResponse
     */
    public function listProjectsWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ListProjectsShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->tags) {
            $request->tagsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }

        $query = [];
        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->resourceManagerResourceGroupId) {
            @$query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }

        if (null !== $request->tagsShrink) {
            @$query['Tags'] = $request->tagsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListProjects',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListProjectsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of DataWorks workspaces of the tenant to which a user belongs.
     *
     * @param request - ListProjectsRequest
     *
     * @returns ListProjectsResponse
     *
     * @param ListProjectsRequest $request
     *
     * @return ListProjectsResponse
     */
    public function listProjects($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listProjectsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of historical check results based on a partition filter expression.
     *
     * @remarks
     *
     * @param request - ListQualityResultsByEntityRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListQualityResultsByEntityResponse
     *
     * @param ListQualityResultsByEntityRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return ListQualityResultsByEntityResponse
     */
    public function listQualityResultsByEntityWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->endDate) {
            @$body['EndDate'] = $request->endDate;
        }

        if (null !== $request->entityId) {
            @$body['EntityId'] = $request->entityId;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->startDate) {
            @$body['StartDate'] = $request->startDate;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListQualityResultsByEntity',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListQualityResultsByEntityResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of historical check results based on a partition filter expression.
     *
     * @remarks
     *
     * @param request - ListQualityResultsByEntityRequest
     *
     * @returns ListQualityResultsByEntityResponse
     *
     * @param ListQualityResultsByEntityRequest $request
     *
     * @return ListQualityResultsByEntityResponse
     */
    public function listQualityResultsByEntity($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQualityResultsByEntityWithOptions($request, $runtime);
    }

    /**
     * Queries monitoring results after the data quality of a data source or a compute engine is monitored based on monitoring rules.
     *
     * @param request - ListQualityResultsByRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListQualityResultsByRuleResponse
     *
     * @param ListQualityResultsByRuleRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return ListQualityResultsByRuleResponse
     */
    public function listQualityResultsByRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->endDate) {
            @$body['EndDate'] = $request->endDate;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->ruleId) {
            @$body['RuleId'] = $request->ruleId;
        }

        if (null !== $request->startDate) {
            @$body['StartDate'] = $request->startDate;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListQualityResultsByRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListQualityResultsByRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries monitoring results after the data quality of a data source or a compute engine is monitored based on monitoring rules.
     *
     * @param request - ListQualityResultsByRuleRequest
     *
     * @returns ListQualityResultsByRuleResponse
     *
     * @param ListQualityResultsByRuleRequest $request
     *
     * @return ListQualityResultsByRuleResponse
     */
    public function listQualityResultsByRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQualityResultsByRuleWithOptions($request, $runtime);
    }

    /**
     * Queries monitoring rules based on a partition filter expression.
     *
     * @param request - ListQualityRulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListQualityRulesResponse
     *
     * @param ListQualityRulesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return ListQualityRulesResponse
     */
    public function listQualityRulesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->entityId) {
            @$body['EntityId'] = $request->entityId;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListQualityRules',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListQualityRulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries monitoring rules based on a partition filter expression.
     *
     * @param request - ListQualityRulesRequest
     *
     * @returns ListQualityRulesResponse
     *
     * @param ListQualityRulesRequest $request
     *
     * @return ListQualityRulesResponse
     */
    public function listQualityRules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listQualityRulesWithOptions($request, $runtime);
    }

    /**
     * Queries synchronization tasks in Data Integration that use a specific data source.
     *
     * @param request - ListRefDISyncTasksRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListRefDISyncTasksResponse
     *
     * @param ListRefDISyncTasksRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListRefDISyncTasksResponse
     */
    public function listRefDISyncTasksWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->datasourceName) {
            @$query['DatasourceName'] = $request->datasourceName;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->refType) {
            @$query['RefType'] = $request->refType;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListRefDISyncTasks',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListRefDISyncTasksResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries synchronization tasks in Data Integration that use a specific data source.
     *
     * @param request - ListRefDISyncTasksRequest
     *
     * @returns ListRefDISyncTasksResponse
     *
     * @param ListRefDISyncTasksRequest $request
     *
     * @return ListRefDISyncTasksResponse
     */
    public function listRefDISyncTasks($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRefDISyncTasksWithOptions($request, $runtime);
    }

    /**
     * Queries a list of custom alert rules.
     *
     * @param request - ListRemindsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListRemindsResponse
     *
     * @param ListRemindsRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return ListRemindsResponse
     */
    public function listRemindsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alertTarget) {
            @$body['AlertTarget'] = $request->alertTarget;
        }

        if (null !== $request->founder) {
            @$body['Founder'] = $request->founder;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->remindTypes) {
            @$body['RemindTypes'] = $request->remindTypes;
        }

        if (null !== $request->searchText) {
            @$body['SearchText'] = $request->searchText;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListReminds',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListRemindsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of custom alert rules.
     *
     * @param request - ListRemindsRequest
     *
     * @returns ListRemindsResponse
     *
     * @param ListRemindsRequest $request
     *
     * @return ListRemindsResponse
     */
    public function listReminds($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listRemindsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of resource groups of a specific type.
     *
     * @param tmpReq - ListResourceGroupsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListResourceGroupsResponse
     *
     * @param ListResourceGroupsRequest $tmpReq
     * @param RuntimeOptions            $runtime
     *
     * @return ListResourceGroupsResponse
     */
    public function listResourceGroupsWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new ListResourceGroupsShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->tags) {
            $request->tagsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }

        $query = [];
        if (null !== $request->bizExtKey) {
            @$query['BizExtKey'] = $request->bizExtKey;
        }

        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->resourceGroupType) {
            @$query['ResourceGroupType'] = $request->resourceGroupType;
        }

        if (null !== $request->resourceManagerResourceGroupId) {
            @$query['ResourceManagerResourceGroupId'] = $request->resourceManagerResourceGroupId;
        }

        if (null !== $request->tagsShrink) {
            @$query['Tags'] = $request->tagsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListResourceGroups',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListResourceGroupsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of resource groups of a specific type.
     *
     * @param request - ListResourceGroupsRequest
     *
     * @returns ListResourceGroupsResponse
     *
     * @param ListResourceGroupsRequest $request
     *
     * @return ListResourceGroupsResponse
     */
    public function listResourceGroups($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listResourceGroupsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of on-duty engineers in a shift schedule.
     *
     * @param request - ListShiftPersonnelsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListShiftPersonnelsResponse
     *
     * @param ListShiftPersonnelsRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return ListShiftPersonnelsResponse
     */
    public function listShiftPersonnelsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->beginTime) {
            @$body['BeginTime'] = $request->beginTime;
        }

        if (null !== $request->endTime) {
            @$body['EndTime'] = $request->endTime;
        }

        if (null !== $request->shiftPersonUID) {
            @$body['ShiftPersonUID'] = $request->shiftPersonUID;
        }

        if (null !== $request->shiftScheduleIdentifier) {
            @$body['ShiftScheduleIdentifier'] = $request->shiftScheduleIdentifier;
        }

        if (null !== $request->userType) {
            @$body['UserType'] = $request->userType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListShiftPersonnels',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListShiftPersonnelsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of on-duty engineers in a shift schedule.
     *
     * @param request - ListShiftPersonnelsRequest
     *
     * @returns ListShiftPersonnelsResponse
     *
     * @param ListShiftPersonnelsRequest $request
     *
     * @return ListShiftPersonnelsResponse
     */
    public function listShiftPersonnels($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listShiftPersonnelsWithOptions($request, $runtime);
    }

    /**
     * Queries a list of shift schedules in Operation Center.
     *
     * @param request - ListShiftSchedulesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListShiftSchedulesResponse
     *
     * @param ListShiftSchedulesRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return ListShiftSchedulesResponse
     */
    public function listShiftSchedulesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->shiftScheduleName) {
            @$body['ShiftScheduleName'] = $request->shiftScheduleName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListShiftSchedules',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListShiftSchedulesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of shift schedules in Operation Center.
     *
     * @param request - ListShiftSchedulesRequest
     *
     * @returns ListShiftSchedulesResponse
     *
     * @param ListShiftSchedulesRequest $request
     *
     * @return ListShiftSchedulesResponse
     */
    public function listShiftSchedules($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listShiftSchedulesWithOptions($request, $runtime);
    }

    /**
     * Queries the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
     *
     * @param request - ListSuccessInstanceAmountRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListSuccessInstanceAmountResponse
     *
     * @param ListSuccessInstanceAmountRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return ListSuccessInstanceAmountResponse
     */
    public function listSuccessInstanceAmountWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListSuccessInstanceAmount',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListSuccessInstanceAmountResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
     *
     * @param request - ListSuccessInstanceAmountRequest
     *
     * @returns ListSuccessInstanceAmountResponse
     *
     * @param ListSuccessInstanceAmountRequest $request
     *
     * @return ListSuccessInstanceAmountResponse
     */
    public function listSuccessInstanceAmount($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listSuccessInstanceAmountWithOptions($request, $runtime);
    }

    /**
     * Queries a list of table levels. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - ListTableLevelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTableLevelResponse
     *
     * @param ListTableLevelRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListTableLevelResponse
     */
    public function listTableLevelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTableLevel',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of table levels. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - ListTableLevelRequest
     *
     * @returns ListTableLevelResponse
     *
     * @param ListTableLevelRequest $request
     *
     * @return ListTableLevelResponse
     */
    public function listTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTableLevelWithOptions($request, $runtime);
    }

    /**
     * Queries a list of table themes. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - ListTableThemeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTableThemeResponse
     *
     * @param ListTableThemeRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ListTableThemeResponse
     */
    public function listTableThemeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTableTheme',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries a list of table themes. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - ListTableThemeRequest
     *
     * @returns ListTableThemeResponse
     *
     * @param ListTableThemeRequest $request
     *
     * @return ListTableThemeResponse
     */
    public function listTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTableThemeWithOptions($request, $runtime);
    }

    /**
     * Obtains tables of different data source types within a tenant by page.
     *
     * @param request - ListTablesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTablesResponse
     *
     * @param ListTablesRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ListTablesResponse
     */
    public function listTablesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->nextToken) {
            @$query['NextToken'] = $request->nextToken;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ListTables',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTablesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Obtains tables of different data source types within a tenant by page.
     *
     * @param request - ListTablesRequest
     *
     * @returns ListTablesResponse
     *
     * @param ListTablesRequest $request
     *
     * @return ListTablesResponse
     */
    public function listTables($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTablesWithOptions($request, $runtime);
    }

    /**
     * Queries events.
     *
     * @param request - ListTopicsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ListTopicsResponse
     *
     * @param ListTopicsRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return ListTopicsResponse
     */
    public function listTopicsWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->beginTime) {
            @$body['BeginTime'] = $request->beginTime;
        }

        if (null !== $request->endTime) {
            @$body['EndTime'] = $request->endTime;
        }

        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->pageNumber) {
            @$body['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->topicStatuses) {
            @$body['TopicStatuses'] = $request->topicStatuses;
        }

        if (null !== $request->topicTypes) {
            @$body['TopicTypes'] = $request->topicTypes;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ListTopics',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ListTopicsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries events.
     *
     * @param request - ListTopicsRequest
     *
     * @returns ListTopicsResponse
     *
     * @param ListTopicsRequest $request
     *
     * @return ListTopicsResponse
     */
    public function listTopics($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->listTopicsWithOptions($request, $runtime);
    }

    /**
     * Undeploys a node.
     *
     * @param request - OfflineNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns OfflineNodeResponse
     *
     * @param OfflineNodeRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return OfflineNodeResponse
     */
    public function offlineNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'OfflineNode',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return OfflineNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Undeploys a node.
     *
     * @param request - OfflineNodeRequest
     *
     * @returns OfflineNodeResponse
     *
     * @param OfflineNodeRequest $request
     *
     * @return OfflineNodeResponse
     */
    public function offlineNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->offlineNodeWithOptions($request, $runtime);
    }

    /**
     * Publishes an API.
     *
     * @param request - PublishDataServiceApiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns PublishDataServiceApiResponse
     *
     * @param PublishDataServiceApiRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return PublishDataServiceApiResponse
     */
    public function publishDataServiceApiWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'PublishDataServiceApi',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return PublishDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Publishes an API.
     *
     * @param request - PublishDataServiceApiRequest
     *
     * @returns PublishDataServiceApiResponse
     *
     * @param PublishDataServiceApiRequest $request
     *
     * @return PublishDataServiceApiResponse
     */
    public function publishDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->publishDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * Queries the execution results of an asynchronous task.
     *
     * @remarks
     * DataWorks allows you to call only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a batch synchronization task or the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To create or update a real-time synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) or [GenerateDISyncTaskConfigForUpdating](https://help.aliyun.com/document_detail/383464.html) operation to obtain the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask or UpdateDISyncTask operation and use the parameters as request parameters to create or update a real-time synchronization task. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
     *
     * @param request - QueryDISyncTaskConfigProcessResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryDISyncTaskConfigProcessResultResponse
     *
     * @param QueryDISyncTaskConfigProcessResultRequest $request
     * @param RuntimeOptions                            $runtime
     *
     * @return QueryDISyncTaskConfigProcessResultResponse
     */
    public function queryDISyncTaskConfigProcessResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->asyncProcessId) {
            @$query['AsyncProcessId'] = $request->asyncProcessId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'QueryDISyncTaskConfigProcessResult',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryDISyncTaskConfigProcessResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the execution results of an asynchronous task.
     *
     * @remarks
     * DataWorks allows you to call only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a batch synchronization task or the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To create or update a real-time synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) or [GenerateDISyncTaskConfigForUpdating](https://help.aliyun.com/document_detail/383464.html) operation to obtain the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask or UpdateDISyncTask operation and use the parameters as request parameters to create or update a real-time synchronization task. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
     *
     * @param request - QueryDISyncTaskConfigProcessResultRequest
     *
     * @returns QueryDISyncTaskConfigProcessResultResponse
     *
     * @param QueryDISyncTaskConfigProcessResultRequest $request
     *
     * @return QueryDISyncTaskConfigProcessResultResponse
     */
    public function queryDISyncTaskConfigProcessResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryDISyncTaskConfigProcessResultWithOptions($request, $runtime);
    }

    /**
     * Queries the default data category and data sensitivity level template defined by Data Security Guard.
     *
     * @param request - QueryDefaultTemplateRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryDefaultTemplateResponse
     *
     * @param QueryDefaultTemplateRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return QueryDefaultTemplateResponse
     */
    public function queryDefaultTemplateWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QueryDefaultTemplate',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryDefaultTemplateResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the default data category and data sensitivity level template defined by Data Security Guard.
     *
     * @param request - QueryDefaultTemplateRequest
     *
     * @returns QueryDefaultTemplateResponse
     *
     * @param QueryDefaultTemplateRequest $request
     *
     * @return QueryDefaultTemplateResponse
     */
    public function queryDefaultTemplate($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryDefaultTemplateWithOptions($request, $runtime);
    }

    /**
     * Queries information about objects that are created in Data Modeling by using fast modeling language (FML) statements.
     *
     * @remarks
     *   Each time you call this API operation, you must use FML statements to query information about objects that are created in Data Modeling.
     * *   The information about the objects can be queried by page, except for data layers, business processes, and data domains. You can add an offset to the end of an FML statement. The num LIMIT num statement specifies the offset when the information about the objects is queried, and the number of pages to return each time. The offset value must be a multiple of the number of pages.
     * *   A maximum of 1,000 entries can be returned each time you call this API operation.
     *
     * @param request - QueryPublicModelEngineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryPublicModelEngineResponse
     *
     * @param QueryPublicModelEngineRequest $request
     * @param RuntimeOptions                $runtime
     *
     * @return QueryPublicModelEngineResponse
     */
    public function queryPublicModelEngineWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->text) {
            @$body['Text'] = $request->text;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QueryPublicModelEngine',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryPublicModelEngineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries information about objects that are created in Data Modeling by using fast modeling language (FML) statements.
     *
     * @remarks
     *   Each time you call this API operation, you must use FML statements to query information about objects that are created in Data Modeling.
     * *   The information about the objects can be queried by page, except for data layers, business processes, and data domains. You can add an offset to the end of an FML statement. The num LIMIT num statement specifies the offset when the information about the objects is queried, and the number of pages to return each time. The offset value must be a multiple of the number of pages.
     * *   A maximum of 1,000 entries can be returned each time you call this API operation.
     *
     * @param request - QueryPublicModelEngineRequest
     *
     * @returns QueryPublicModelEngineResponse
     *
     * @param QueryPublicModelEngineRequest $request
     *
     * @return QueryPublicModelEngineResponse
     */
    public function queryPublicModelEngine($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryPublicModelEngineWithOptions($request, $runtime);
    }

    /**
     * Queries the type of a sensitive data identification rule.
     *
     * @param request - QueryRecognizeDataByRuleTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryRecognizeDataByRuleTypeResponse
     *
     * @param QueryRecognizeDataByRuleTypeRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return QueryRecognizeDataByRuleTypeResponse
     */
    public function queryRecognizeDataByRuleTypeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->recognizeRulesType) {
            @$body['RecognizeRulesType'] = $request->recognizeRulesType;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QueryRecognizeDataByRuleType',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryRecognizeDataByRuleTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the type of a sensitive data identification rule.
     *
     * @param request - QueryRecognizeDataByRuleTypeRequest
     *
     * @returns QueryRecognizeDataByRuleTypeResponse
     *
     * @param QueryRecognizeDataByRuleTypeRequest $request
     *
     * @return QueryRecognizeDataByRuleTypeResponse
     */
    public function queryRecognizeDataByRuleType($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecognizeDataByRuleTypeWithOptions($request, $runtime);
    }

    /**
     * Queries the details of a specified sensitive field in Data Security Guard.
     *
     * @param request - QueryRecognizeRuleDetailRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryRecognizeRuleDetailResponse
     *
     * @param QueryRecognizeRuleDetailRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return QueryRecognizeRuleDetailResponse
     */
    public function queryRecognizeRuleDetailWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->sensitiveName) {
            @$body['SensitiveName'] = $request->sensitiveName;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QueryRecognizeRuleDetail',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryRecognizeRuleDetailResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the details of a specified sensitive field in Data Security Guard.
     *
     * @param request - QueryRecognizeRuleDetailRequest
     *
     * @returns QueryRecognizeRuleDetailResponse
     *
     * @param QueryRecognizeRuleDetailRequest $request
     *
     * @return QueryRecognizeRuleDetailResponse
     */
    public function queryRecognizeRuleDetail($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecognizeRuleDetailWithOptions($request, $runtime);
    }

    /**
     * Queries the built-in sensitive data identification rule that is used to configure a sensitive field.
     *
     * @param request - QueryRecognizeRulesTypeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QueryRecognizeRulesTypeResponse
     *
     * @param RuntimeOptions $runtime
     *
     * @return QueryRecognizeRulesTypeResponse
     */
    public function queryRecognizeRulesTypeWithOptions($runtime)
    {
        $req = new OpenApiRequest([]);
        $params = new Params([
            'action' => 'QueryRecognizeRulesType',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QueryRecognizeRulesTypeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the built-in sensitive data identification rule that is used to configure a sensitive field.
     *
     * @returns QueryRecognizeRulesTypeResponse
     *
     * @return QueryRecognizeRulesTypeResponse
     */
    public function queryRecognizeRulesType()
    {
        $runtime = new RuntimeOptions([]);

        return $this->queryRecognizeRulesTypeWithOptions($runtime);
    }

    /**
     * Queries data categories.
     *
     * @param request - QuerySensClassificationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QuerySensClassificationResponse
     *
     * @param QuerySensClassificationRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return QuerySensClassificationResponse
     */
    public function querySensClassificationWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->templateId) {
            @$body['TemplateId'] = $request->templateId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QuerySensClassification',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QuerySensClassificationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries data categories.
     *
     * @param request - QuerySensClassificationRequest
     *
     * @returns QuerySensClassificationResponse
     *
     * @param QuerySensClassificationRequest $request
     *
     * @return QuerySensClassificationResponse
     */
    public function querySensClassification($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySensClassificationWithOptions($request, $runtime);
    }

    /**
     * Queries data sensitivity levels in Data Security Guard.
     *
     * @param request - QuerySensLevelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QuerySensLevelResponse
     *
     * @param QuerySensLevelRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return QuerySensLevelResponse
     */
    public function querySensLevelWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->templateId) {
            @$body['TemplateId'] = $request->templateId;
        }

        if (null !== $request->tenantId) {
            @$body['tenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QuerySensLevel',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QuerySensLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries data sensitivity levels in Data Security Guard.
     *
     * @param request - QuerySensLevelRequest
     *
     * @returns QuerySensLevelResponse
     *
     * @param QuerySensLevelRequest $request
     *
     * @return QuerySensLevelResponse
     */
    public function querySensLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySensLevelWithOptions($request, $runtime);
    }

    /**
     * Queries sensitive data identification rules.
     *
     * @param request - QuerySensNodeInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns QuerySensNodeInfoResponse
     *
     * @param QuerySensNodeInfoRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return QuerySensNodeInfoResponse
     */
    public function querySensNodeInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->pageNo) {
            @$body['PageNo'] = $request->pageNo;
        }

        if (null !== $request->pageSize) {
            @$body['PageSize'] = $request->pageSize;
        }

        if (null !== $request->sensitiveName) {
            @$body['SensitiveName'] = $request->sensitiveName;
        }

        if (null !== $request->templateId) {
            @$body['TemplateId'] = $request->templateId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        if (null !== $request->status) {
            @$body['status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'QuerySensNodeInfo',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return QuerySensNodeInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries sensitive data identification rules.
     *
     * @param request - QuerySensNodeInfoRequest
     *
     * @returns QuerySensNodeInfoResponse
     *
     * @param QuerySensNodeInfoRequest $request
     *
     * @return QuerySensNodeInfoResponse
     */
    public function querySensNodeInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->querySensNodeInfoWithOptions($request, $runtime);
    }

    /**
     * Registers the lineage between self-managed entities to DataWorks.
     *
     * @remarks
     * This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
     *
     * @param tmpReq - RegisterLineageRelationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RegisterLineageRelationResponse
     *
     * @param RegisterLineageRelationRequest $tmpReq
     * @param RuntimeOptions                 $runtime
     *
     * @return RegisterLineageRelationResponse
     */
    public function registerLineageRelationWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new RegisterLineageRelationShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->lineageRelationRegisterVO) {
            $request->lineageRelationRegisterVOShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->lineageRelationRegisterVO, 'LineageRelationRegisterVO', 'json');
        }

        $body = [];
        if (null !== $request->lineageRelationRegisterVOShrink) {
            @$body['LineageRelationRegisterVO'] = $request->lineageRelationRegisterVOShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'RegisterLineageRelation',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RegisterLineageRelationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Registers the lineage between self-managed entities to DataWorks.
     *
     * @remarks
     * This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
     *
     * @param request - RegisterLineageRelationRequest
     *
     * @returns RegisterLineageRelationResponse
     *
     * @param RegisterLineageRelationRequest $request
     *
     * @return RegisterLineageRelationResponse
     */
    public function registerLineageRelation($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->registerLineageRelationWithOptions($request, $runtime);
    }

    /**
     * Removes tags from an entity. Only entities of the maxcompute-table type are supported.
     *
     * @param tmpReq - RemoveEntityTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveEntityTagsResponse
     *
     * @param RemoveEntityTagsRequest $tmpReq
     * @param RuntimeOptions          $runtime
     *
     * @return RemoveEntityTagsResponse
     */
    public function removeEntityTagsWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new RemoveEntityTagsShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->tagKeys) {
            $request->tagKeysShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->tagKeys, 'TagKeys', 'json');
        }

        $query = [];
        if (null !== $request->qualifiedName) {
            @$query['QualifiedName'] = $request->qualifiedName;
        }

        $body = [];
        if (null !== $request->tagKeysShrink) {
            @$body['TagKeys'] = $request->tagKeysShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'RemoveEntityTags',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveEntityTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes tags from an entity. Only entities of the maxcompute-table type are supported.
     *
     * @param request - RemoveEntityTagsRequest
     *
     * @returns RemoveEntityTagsResponse
     *
     * @param RemoveEntityTagsRequest $request
     *
     * @return RemoveEntityTagsResponse
     */
    public function removeEntityTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeEntityTagsWithOptions($request, $runtime);
    }

    /**
     * Removes a role from a user in a DataWorks workspace.
     *
     * @param request - RemoveProjectMemberFromRoleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RemoveProjectMemberFromRoleResponse
     *
     * @param RemoveProjectMemberFromRoleRequest $request
     * @param RuntimeOptions                     $runtime
     *
     * @return RemoveProjectMemberFromRoleResponse
     */
    public function removeProjectMemberFromRoleWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->roleCode) {
            @$query['RoleCode'] = $request->roleCode;
        }

        if (null !== $request->userId) {
            @$query['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RemoveProjectMemberFromRole',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RemoveProjectMemberFromRoleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Removes a role from a user in a DataWorks workspace.
     *
     * @param request - RemoveProjectMemberFromRoleRequest
     *
     * @returns RemoveProjectMemberFromRoleResponse
     *
     * @param RemoveProjectMemberFromRoleRequest $request
     *
     * @return RemoveProjectMemberFromRoleResponse
     */
    public function removeProjectMemberFromRole($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->removeProjectMemberFromRoleWithOptions($request, $runtime);
    }

    /**
     * Restarts an instance.
     *
     * @param request - RestartInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RestartInstanceResponse
     *
     * @param RestartInstanceRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return RestartInstanceResponse
     */
    public function restartInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'RestartInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RestartInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Restarts an instance.
     *
     * @param request - RestartInstanceRequest
     *
     * @returns RestartInstanceResponse
     *
     * @param RestartInstanceRequest $request
     *
     * @return RestartInstanceResponse
     */
    public function restartInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->restartInstanceWithOptions($request, $runtime);
    }

    /**
     * Resumes a suspended instance.
     *
     * @param request - ResumeInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ResumeInstanceResponse
     *
     * @param ResumeInstanceRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return ResumeInstanceResponse
     */
    public function resumeInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'ResumeInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ResumeInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Resumes a suspended instance.
     *
     * @param request - ResumeInstanceRequest
     *
     * @returns ResumeInstanceResponse
     *
     * @param ResumeInstanceRequest $request
     *
     * @return ResumeInstanceResponse
     */
    public function resumeInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->resumeInstanceWithOptions($request, $runtime);
    }

    /**
     * Revokes permissions on a table from a user.
     *
     * @param request - RevokeTablePermissionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RevokeTablePermissionResponse
     *
     * @param RevokeTablePermissionRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return RevokeTablePermissionResponse
     */
    public function revokeTablePermissionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->actions) {
            @$query['Actions'] = $request->actions;
        }

        if (null !== $request->maxComputeProjectName) {
            @$query['MaxComputeProjectName'] = $request->maxComputeProjectName;
        }

        if (null !== $request->revokeUserId) {
            @$query['RevokeUserId'] = $request->revokeUserId;
        }

        if (null !== $request->revokeUserName) {
            @$query['RevokeUserName'] = $request->revokeUserName;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        if (null !== $request->workspaceId) {
            @$query['WorkspaceId'] = $request->workspaceId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'RevokeTablePermission',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RevokeTablePermissionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Revokes permissions on a table from a user.
     *
     * @param request - RevokeTablePermissionRequest
     *
     * @returns RevokeTablePermissionResponse
     *
     * @param RevokeTablePermissionRequest $request
     *
     * @return RevokeTablePermissionResponse
     */
    public function revokeTablePermission($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->revokeTablePermissionWithOptions($request, $runtime);
    }

    /**
     * Creates a workflow to backfill data.
     *
     * @remarks
     * For more information about data backfill, see [Backfill data](https://help.aliyun.com/document_detail/137937.html).
     *
     * @param request - RunCycleDagNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RunCycleDagNodesResponse
     *
     * @param RunCycleDagNodesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return RunCycleDagNodesResponse
     */
    public function runCycleDagNodesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alertNoticeType) {
            @$body['AlertNoticeType'] = $request->alertNoticeType;
        }

        if (null !== $request->alertType) {
            @$body['AlertType'] = $request->alertType;
        }

        if (null !== $request->bizBeginTime) {
            @$body['BizBeginTime'] = $request->bizBeginTime;
        }

        if (null !== $request->bizEndTime) {
            @$body['BizEndTime'] = $request->bizEndTime;
        }

        if (null !== $request->concurrentRuns) {
            @$body['ConcurrentRuns'] = $request->concurrentRuns;
        }

        if (null !== $request->endBizDate) {
            @$body['EndBizDate'] = $request->endBizDate;
        }

        if (null !== $request->excludeNodeIds) {
            @$body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }

        if (null !== $request->includeNodeIds) {
            @$body['IncludeNodeIds'] = $request->includeNodeIds;
        }

        if (null !== $request->name) {
            @$body['Name'] = $request->name;
        }

        if (null !== $request->nodeParams) {
            @$body['NodeParams'] = $request->nodeParams;
        }

        if (null !== $request->parallelism) {
            @$body['Parallelism'] = $request->parallelism;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->rootNodeId) {
            @$body['RootNodeId'] = $request->rootNodeId;
        }

        if (null !== $request->startBizDate) {
            @$body['StartBizDate'] = $request->startBizDate;
        }

        if (null !== $request->startFutureInstanceImmediately) {
            @$body['StartFutureInstanceImmediately'] = $request->startFutureInstanceImmediately;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'RunCycleDagNodes',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RunCycleDagNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a workflow to backfill data.
     *
     * @remarks
     * For more information about data backfill, see [Backfill data](https://help.aliyun.com/document_detail/137937.html).
     *
     * @param request - RunCycleDagNodesRequest
     *
     * @returns RunCycleDagNodesResponse
     *
     * @param RunCycleDagNodesRequest $request
     *
     * @return RunCycleDagNodesResponse
     */
    public function runCycleDagNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runCycleDagNodesWithOptions($request, $runtime);
    }

    /**
     * Runs nodes in a manually triggered workflow. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find a manually triggered workflow in Operation Center only after the manually triggered workflow is committed and deployed.
     *
     * @param request - RunManualDagNodesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RunManualDagNodesResponse
     *
     * @param RunManualDagNodesRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return RunManualDagNodesResponse
     */
    public function runManualDagNodesWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->bizDate) {
            @$body['BizDate'] = $request->bizDate;
        }

        if (null !== $request->dagParameters) {
            @$body['DagParameters'] = $request->dagParameters;
        }

        if (null !== $request->endBizDate) {
            @$body['EndBizDate'] = $request->endBizDate;
        }

        if (null !== $request->excludeNodeIds) {
            @$body['ExcludeNodeIds'] = $request->excludeNodeIds;
        }

        if (null !== $request->flowName) {
            @$body['FlowName'] = $request->flowName;
        }

        if (null !== $request->includeNodeIds) {
            @$body['IncludeNodeIds'] = $request->includeNodeIds;
        }

        if (null !== $request->nodeParameters) {
            @$body['NodeParameters'] = $request->nodeParameters;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->startBizDate) {
            @$body['StartBizDate'] = $request->startBizDate;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'RunManualDagNodes',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RunManualDagNodesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Runs nodes in a manually triggered workflow. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find a manually triggered workflow in Operation Center only after the manually triggered workflow is committed and deployed.
     *
     * @param request - RunManualDagNodesRequest
     *
     * @returns RunManualDagNodesResponse
     *
     * @param RunManualDagNodesRequest $request
     *
     * @return RunManualDagNodesResponse
     */
    public function runManualDagNodes($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runManualDagNodesWithOptions($request, $runtime);
    }

    /**
     * Creates a workflow to perform smoke testing.
     *
     * @param request - RunSmokeTestRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RunSmokeTestResponse
     *
     * @param RunSmokeTestRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return RunSmokeTestResponse
     */
    public function runSmokeTestWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->bizdate) {
            @$body['Bizdate'] = $request->bizdate;
        }

        if (null !== $request->name) {
            @$body['Name'] = $request->name;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->nodeParams) {
            @$body['NodeParams'] = $request->nodeParams;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'RunSmokeTest',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RunSmokeTestResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Creates a workflow to perform smoke testing.
     *
     * @param request - RunSmokeTestRequest
     *
     * @returns RunSmokeTestResponse
     *
     * @param RunSmokeTestRequest $request
     *
     * @return RunSmokeTestResponse
     */
    public function runSmokeTest($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runSmokeTestWithOptions($request, $runtime);
    }

    /**
     * Runs a manually triggered node.
     *
     * @param request - RunTriggerNodeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns RunTriggerNodeResponse
     *
     * @param RunTriggerNodeRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return RunTriggerNodeResponse
     */
    public function runTriggerNodeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->appId) {
            @$body['AppId'] = $request->appId;
        }

        if (null !== $request->bizDate) {
            @$body['BizDate'] = $request->bizDate;
        }

        if (null !== $request->cycleTime) {
            @$body['CycleTime'] = $request->cycleTime;
        }

        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'RunTriggerNode',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return RunTriggerNodeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Runs a manually triggered node.
     *
     * @param request - RunTriggerNodeRequest
     *
     * @returns RunTriggerNodeResponse
     *
     * @param RunTriggerNodeRequest $request
     *
     * @return RunTriggerNodeResponse
     */
    public function runTriggerNode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->runTriggerNodeWithOptions($request, $runtime);
    }

    /**
     * Saves the test results of an API.
     *
     * @param request - SaveDataServiceApiTestResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SaveDataServiceApiTestResultResponse
     *
     * @param SaveDataServiceApiTestResultRequest $request
     * @param RuntimeOptions                      $runtime
     *
     * @return SaveDataServiceApiTestResultResponse
     */
    public function saveDataServiceApiTestResultWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->autoGenerate) {
            @$body['AutoGenerate'] = $request->autoGenerate;
        }

        if (null !== $request->failResultSample) {
            @$body['FailResultSample'] = $request->failResultSample;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->resultSample) {
            @$body['ResultSample'] = $request->resultSample;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SaveDataServiceApiTestResult',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SaveDataServiceApiTestResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Saves the test results of an API.
     *
     * @param request - SaveDataServiceApiTestResultRequest
     *
     * @returns SaveDataServiceApiTestResultResponse
     *
     * @param SaveDataServiceApiTestResultRequest $request
     *
     * @return SaveDataServiceApiTestResultResponse
     */
    public function saveDataServiceApiTestResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->saveDataServiceApiTestResultWithOptions($request, $runtime);
    }

    /**
     * Checks whether input data contains sensitive data.
     *
     * @param request - ScanSensitiveDataRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns ScanSensitiveDataResponse
     *
     * @param ScanSensitiveDataRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return ScanSensitiveDataResponse
     */
    public function scanSensitiveDataWithOptions($request, $runtime)
    {
        $request->validate();
        $query = Utils::query($request->toMap());
        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'ScanSensitiveData',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'GET',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return ScanSensitiveDataResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Checks whether input data contains sensitive data.
     *
     * @param request - ScanSensitiveDataRequest
     *
     * @returns ScanSensitiveDataResponse
     *
     * @param ScanSensitiveDataRequest $request
     *
     * @return ScanSensitiveDataResponse
     */
    public function scanSensitiveData($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->scanSensitiveDataWithOptions($request, $runtime);
    }

    /**
     * Queries metatables based on specific conditions.
     *
     * @remarks
     * You can call this operation to query only metatables in a MaxCompute or E-MapReduce (EMR) compute engine.
     *
     * @param request - SearchMetaTablesRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SearchMetaTablesResponse
     *
     * @param SearchMetaTablesRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return SearchMetaTablesResponse
     */
    public function searchMetaTablesWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appGuid) {
            @$query['AppGuid'] = $request->appGuid;
        }

        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->dataSourceType) {
            @$query['DataSourceType'] = $request->dataSourceType;
        }

        if (null !== $request->entityType) {
            @$query['EntityType'] = $request->entityType;
        }

        if (null !== $request->keyword) {
            @$query['Keyword'] = $request->keyword;
        }

        if (null !== $request->pageNumber) {
            @$query['PageNumber'] = $request->pageNumber;
        }

        if (null !== $request->pageSize) {
            @$query['PageSize'] = $request->pageSize;
        }

        if (null !== $request->schema) {
            @$query['Schema'] = $request->schema;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SearchMetaTables',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SearchMetaTablesResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries metatables based on specific conditions.
     *
     * @remarks
     * You can call this operation to query only metatables in a MaxCompute or E-MapReduce (EMR) compute engine.
     *
     * @param request - SearchMetaTablesRequest
     *
     * @returns SearchMetaTablesResponse
     *
     * @param SearchMetaTablesRequest $request
     *
     * @return SearchMetaTablesResponse
     */
    public function searchMetaTables($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->searchMetaTablesWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Queries a node based on the output.
     *
     * @deprecated OpenAPI SearchNodesByOutput is deprecated
     *
     * @param request - SearchNodesByOutputRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SearchNodesByOutputResponse
     *
     * @param SearchNodesByOutputRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return SearchNodesByOutputResponse
     */
    public function searchNodesByOutputWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->outputs) {
            @$body['Outputs'] = $request->outputs;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SearchNodesByOutput',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SearchNodesByOutputResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Queries a node based on the output.
     *
     * @deprecated OpenAPI SearchNodesByOutput is deprecated
     *
     * @param request - SearchNodesByOutputRequest
     *
     * @returns SearchNodesByOutputResponse
     *
     * @param SearchNodesByOutputRequest $request
     *
     * @return SearchNodesByOutputResponse
     */
    public function searchNodesByOutput($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->searchNodesByOutputWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Shares a data source to a specific DataWorks workspace or a specific user.
     *
     * @deprecated OpenAPI SetDataSourceShare is deprecated
     *
     * @param request - SetDataSourceShareRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetDataSourceShareResponse
     *
     * @param SetDataSourceShareRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return SetDataSourceShareResponse
     */
    public function setDataSourceShareWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->datasourceName) {
            @$query['DatasourceName'] = $request->datasourceName;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectPermissions) {
            @$query['ProjectPermissions'] = $request->projectPermissions;
        }

        if (null !== $request->userPermissions) {
            @$query['UserPermissions'] = $request->userPermissions;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'SetDataSourceShare',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetDataSourceShareResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Shares a data source to a specific DataWorks workspace or a specific user.
     *
     * @deprecated OpenAPI SetDataSourceShare is deprecated
     *
     * @param request - SetDataSourceShareRequest
     *
     * @returns SetDataSourceShareResponse
     *
     * @param SetDataSourceShareRequest $request
     *
     * @return SetDataSourceShareResponse
     */
    public function setDataSourceShare($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setDataSourceShareWithOptions($request, $runtime);
    }

    /**
     * Configures tags for an entity. Only entities of the maxcompute-table type are supported.
     *
     * @param tmpReq - SetEntityTagsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetEntityTagsResponse
     *
     * @param SetEntityTagsRequest $tmpReq
     * @param RuntimeOptions       $runtime
     *
     * @return SetEntityTagsResponse
     */
    public function setEntityTagsWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new SetEntityTagsShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->tags) {
            $request->tagsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->tags, 'Tags', 'json');
        }

        $query = [];
        if (null !== $request->qualifiedName) {
            @$query['QualifiedName'] = $request->qualifiedName;
        }

        $body = [];
        if (null !== $request->tagsShrink) {
            @$body['Tags'] = $request->tagsShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SetEntityTags',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetEntityTagsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Configures tags for an entity. Only entities of the maxcompute-table type are supported.
     *
     * @param request - SetEntityTagsRequest
     *
     * @returns SetEntityTagsResponse
     *
     * @param SetEntityTagsRequest $request
     *
     * @return SetEntityTagsResponse
     */
    public function setEntityTags($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setEntityTagsWithOptions($request, $runtime);
    }

    /**
     * Sets the state of a failed instance to successful.
     *
     * @param request - SetSuccessInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SetSuccessInstanceResponse
     *
     * @param SetSuccessInstanceRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return SetSuccessInstanceResponse
     */
    public function setSuccessInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SetSuccessInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SetSuccessInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Sets the state of a failed instance to successful.
     *
     * @param request - SetSuccessInstanceRequest
     *
     * @returns SetSuccessInstanceResponse
     *
     * @param SetSuccessInstanceRequest $request
     *
     * @return SetSuccessInstanceResponse
     */
    public function setSuccessInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->setSuccessInstanceWithOptions($request, $runtime);
    }

    /**
     * Starts a synchronization task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @param tmpReq - StartDIJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartDIJobResponse
     *
     * @param StartDIJobRequest $tmpReq
     * @param RuntimeOptions    $runtime
     *
     * @return StartDIJobResponse
     */
    public function startDIJobWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new StartDIJobShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->realtimeStartSettings) {
            $request->realtimeStartSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->realtimeStartSettings, 'RealtimeStartSettings', 'json');
        }

        $body = [];
        if (null !== $request->DIJobId) {
            @$body['DIJobId'] = $request->DIJobId;
        }

        if (null !== $request->forceToRerun) {
            @$body['ForceToRerun'] = $request->forceToRerun;
        }

        if (null !== $request->realtimeStartSettingsShrink) {
            @$body['RealtimeStartSettings'] = $request->realtimeStartSettingsShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'StartDIJob',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts a synchronization task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
     *
     * @param request - StartDIJobRequest
     *
     * @returns StartDIJobResponse
     *
     * @param StartDIJobRequest $request
     *
     * @return StartDIJobResponse
     */
    public function startDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDIJobWithOptions($request, $runtime);
    }

    /**
     * Starts a real-time synchronization task or a synchronization solution.
     *
     * @param request - StartDISyncInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartDISyncInstanceResponse
     *
     * @param StartDISyncInstanceRequest $request
     * @param RuntimeOptions             $runtime
     *
     * @return StartDISyncInstanceResponse
     */
    public function startDISyncInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileId) {
            @$query['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->startParam) {
            @$query['StartParam'] = $request->startParam;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StartDISyncInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartDISyncInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts a real-time synchronization task or a synchronization solution.
     *
     * @param request - StartDISyncInstanceRequest
     *
     * @returns StartDISyncInstanceResponse
     *
     * @param StartDISyncInstanceRequest $request
     *
     * @return StartDISyncInstanceResponse
     */
    public function startDISyncInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startDISyncInstanceWithOptions($request, $runtime);
    }

    /**
     * Starts a migration task.
     *
     * @param request - StartMigrationRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StartMigrationResponse
     *
     * @param StartMigrationRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return StartMigrationResponse
     */
    public function startMigrationWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->migrationId) {
            @$body['MigrationId'] = $request->migrationId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'StartMigration',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StartMigrationResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Starts a migration task.
     *
     * @param request - StartMigrationRequest
     *
     * @returns StartMigrationResponse
     *
     * @param StartMigrationRequest $request
     *
     * @return StartMigrationResponse
     */
    public function startMigration($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->startMigrationWithOptions($request, $runtime);
    }

    /**
     * Stops a new-version synchronization task. The following type of synchronization task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *
     * @param request - StopDIJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopDIJobResponse
     *
     * @param StopDIJobRequest $request
     * @param RuntimeOptions   $runtime
     *
     * @return StopDIJobResponse
     */
    public function stopDIJobWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->DIJobId) {
            @$body['DIJobId'] = $request->DIJobId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'StopDIJob',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops a new-version synchronization task. The following type of synchronization task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *
     * @param request - StopDIJobRequest
     *
     * @returns StopDIJobResponse
     *
     * @param StopDIJobRequest $request
     *
     * @return StopDIJobResponse
     */
    public function stopDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopDIJobWithOptions($request, $runtime);
    }

    /**
     * Stops a real-time synchronization task.
     *
     * @param request - StopDISyncInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopDISyncInstanceResponse
     *
     * @param StopDISyncInstanceRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return StopDISyncInstanceResponse
     */
    public function stopDISyncInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileId) {
            @$query['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'StopDISyncInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopDISyncInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Stops a real-time synchronization task.
     *
     * @param request - StopDISyncInstanceRequest
     *
     * @returns StopDISyncInstanceResponse
     *
     * @param StopDISyncInstanceRequest $request
     *
     * @return StopDISyncInstanceResponse
     */
    public function stopDISyncInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopDISyncInstanceWithOptions($request, $runtime);
    }

    /**
     * Terminates an instance.
     *
     * @param request - StopInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns StopInstanceResponse
     *
     * @param StopInstanceRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return StopInstanceResponse
     */
    public function stopInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'StopInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return StopInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Terminates an instance.
     *
     * @param request - StopInstanceRequest
     *
     * @returns StopInstanceResponse
     *
     * @param StopInstanceRequest $request
     *
     * @return StopInstanceResponse
     */
    public function stopInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->stopInstanceWithOptions($request, $runtime);
    }

    /**
     * Submits an API in DataService Studio.
     *
     * @param request - SubmitDataServiceApiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SubmitDataServiceApiResponse
     *
     * @param SubmitDataServiceApiRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return SubmitDataServiceApiResponse
     */
    public function submitDataServiceApiWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SubmitDataServiceApi',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SubmitDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Submits an API in DataService Studio.
     *
     * @param request - SubmitDataServiceApiRequest
     *
     * @returns SubmitDataServiceApiResponse
     *
     * @param SubmitDataServiceApiRequest $request
     *
     * @return SubmitDataServiceApiResponse
     */
    public function submitDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * Commits a file to the development environment of the scheduling system to generate a task.
     *
     * @param request - SubmitFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SubmitFileResponse
     *
     * @param SubmitFileRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return SubmitFileResponse
     */
    public function submitFileWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->comment) {
            @$body['Comment'] = $request->comment;
        }

        if (null !== $request->fileId) {
            @$body['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->skipAllDeployFileExtensions) {
            @$body['SkipAllDeployFileExtensions'] = $request->skipAllDeployFileExtensions;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SubmitFile',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SubmitFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Commits a file to the development environment of the scheduling system to generate a task.
     *
     * @param request - SubmitFileRequest
     *
     * @returns SubmitFileResponse
     *
     * @param SubmitFileRequest $request
     *
     * @return SubmitFileResponse
     */
    public function submitFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->submitFileWithOptions($request, $runtime);
    }

    /**
     * Suspends an instance.
     *
     * @param request - SuspendInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns SuspendInstanceResponse
     *
     * @param SuspendInstanceRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return SuspendInstanceResponse
     */
    public function suspendInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->instanceId) {
            @$body['InstanceId'] = $request->instanceId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'SuspendInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return SuspendInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Suspends an instance.
     *
     * @param request - SuspendInstanceRequest
     *
     * @returns SuspendInstanceResponse
     *
     * @param SuspendInstanceRequest $request
     *
     * @return SuspendInstanceResponse
     */
    public function suspendInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->suspendInstanceWithOptions($request, $runtime);
    }

    /**
     * Undeploys a real-time synchronization task.
     *
     * @param request - TerminateDISyncInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TerminateDISyncInstanceResponse
     *
     * @param TerminateDISyncInstanceRequest $request
     * @param RuntimeOptions                 $runtime
     *
     * @return TerminateDISyncInstanceResponse
     */
    public function terminateDISyncInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileId) {
            @$query['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TerminateDISyncInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TerminateDISyncInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Undeploys a real-time synchronization task.
     *
     * @param request - TerminateDISyncInstanceRequest
     *
     * @returns TerminateDISyncInstanceResponse
     *
     * @param TerminateDISyncInstanceRequest $request
     *
     * @return TerminateDISyncInstanceResponse
     */
    public function terminateDISyncInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->terminateDISyncInstanceWithOptions($request, $runtime);
    }

    /**
     * Tests a DataService Studio API in asynchronous mode. You can call the GetDataServiceApiTest operation to query the test result.
     *
     * @param request - TestDataServiceApiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TestDataServiceApiResponse
     *
     * @param TestDataServiceApiRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return TestDataServiceApiResponse
     */
    public function testDataServiceApiWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->apiId) {
            @$query['ApiId'] = $request->apiId;
        }

        $body = [];
        if (null !== $request->bodyContent) {
            @$body['BodyContent'] = $request->bodyContent;
        }

        if (null !== $request->bodyParams) {
            @$body['BodyParams'] = $request->bodyParams;
        }

        if (null !== $request->headParams) {
            @$body['HeadParams'] = $request->headParams;
        }

        if (null !== $request->pathParams) {
            @$body['PathParams'] = $request->pathParams;
        }

        if (null !== $request->queryParam) {
            @$body['QueryParam'] = $request->queryParam;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'TestDataServiceApi',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TestDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Tests a DataService Studio API in asynchronous mode. You can call the GetDataServiceApiTest operation to query the test result.
     *
     * @param request - TestDataServiceApiRequest
     *
     * @returns TestDataServiceApiResponse
     *
     * @param TestDataServiceApiRequest $request
     *
     * @return TestDataServiceApiResponse
     */
    public function testDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->testDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * Tests the network connectivity between a data source and a resource group.
     *
     * @param request - TestNetworkConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TestNetworkConnectionResponse
     *
     * @param TestNetworkConnectionRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return TestNetworkConnectionResponse
     */
    public function testNetworkConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->datasourceName) {
            @$query['DatasourceName'] = $request->datasourceName;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->resourceGroup) {
            @$query['ResourceGroup'] = $request->resourceGroup;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'TestNetworkConnection',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TestNetworkConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Tests the network connectivity between a data source and a resource group.
     *
     * @param request - TestNetworkConnectionRequest
     *
     * @returns TestNetworkConnectionResponse
     *
     * @param TestNetworkConnectionRequest $request
     *
     * @return TestNetworkConnectionResponse
     */
    public function testNetworkConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->testNetworkConnectionWithOptions($request, $runtime);
    }

    /**
     * Queries the ranking of the running durations of instances.
     *
     * @param request - TopTenElapsedTimeInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TopTenElapsedTimeInstanceResponse
     *
     * @param TopTenElapsedTimeInstanceRequest $request
     * @param RuntimeOptions                   $runtime
     *
     * @return TopTenElapsedTimeInstanceResponse
     */
    public function topTenElapsedTimeInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'TopTenElapsedTimeInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TopTenElapsedTimeInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the ranking of the running durations of instances.
     *
     * @param request - TopTenElapsedTimeInstanceRequest
     *
     * @returns TopTenElapsedTimeInstanceResponse
     *
     * @param TopTenElapsedTimeInstanceRequest $request
     *
     * @return TopTenElapsedTimeInstanceResponse
     */
    public function topTenElapsedTimeInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->topTenElapsedTimeInstanceWithOptions($request, $runtime);
    }

    /**
     * Queries the ranking of nodes on which errors occur within the previous month.
     *
     * @param request - TopTenErrorTimesInstanceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns TopTenErrorTimesInstanceResponse
     *
     * @param TopTenErrorTimesInstanceRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return TopTenErrorTimesInstanceResponse
     */
    public function topTenErrorTimesInstanceWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'TopTenErrorTimesInstance',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return TopTenErrorTimesInstanceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Queries the ranking of nodes on which errors occur within the previous month.
     *
     * @param request - TopTenErrorTimesInstanceRequest
     *
     * @returns TopTenErrorTimesInstanceResponse
     *
     * @param TopTenErrorTimesInstanceRequest $request
     *
     * @return TopTenErrorTimesInstanceResponse
     */
    public function topTenErrorTimesInstance($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->topTenErrorTimesInstanceWithOptions($request, $runtime);
    }

    /**
     * Updates a baseline.
     *
     * @param tmpReq - UpdateBaselineRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateBaselineResponse
     *
     * @param UpdateBaselineRequest $tmpReq
     * @param RuntimeOptions        $runtime
     *
     * @return UpdateBaselineResponse
     */
    public function updateBaselineWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateBaselineShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->alertSettings) {
            $request->alertSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->alertSettings, 'AlertSettings', 'json');
        }

        if (null !== $tmpReq->overtimeSettings) {
            $request->overtimeSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->overtimeSettings, 'OvertimeSettings', 'json');
        }

        $body = [];
        if (null !== $request->alertEnabled) {
            @$body['AlertEnabled'] = $request->alertEnabled;
        }

        if (null !== $request->alertMarginThreshold) {
            @$body['AlertMarginThreshold'] = $request->alertMarginThreshold;
        }

        if (null !== $request->alertSettingsShrink) {
            @$body['AlertSettings'] = $request->alertSettingsShrink;
        }

        if (null !== $request->baselineId) {
            @$body['BaselineId'] = $request->baselineId;
        }

        if (null !== $request->baselineName) {
            @$body['BaselineName'] = $request->baselineName;
        }

        if (null !== $request->baselineType) {
            @$body['BaselineType'] = $request->baselineType;
        }

        if (null !== $request->enabled) {
            @$body['Enabled'] = $request->enabled;
        }

        if (null !== $request->nodeIds) {
            @$body['NodeIds'] = $request->nodeIds;
        }

        if (null !== $request->overtimeSettingsShrink) {
            @$body['OvertimeSettings'] = $request->overtimeSettingsShrink;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->priority) {
            @$body['Priority'] = $request->priority;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->removeNodeIds) {
            @$body['RemoveNodeIds'] = $request->removeNodeIds;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateBaseline',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateBaselineResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a baseline.
     *
     * @param request - UpdateBaselineRequest
     *
     * @returns UpdateBaselineResponse
     *
     * @param UpdateBaselineRequest $request
     *
     * @return UpdateBaselineResponse
     */
    public function updateBaseline($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBaselineWithOptions($request, $runtime);
    }

    /**
     * Updates a workflow.
     *
     * @param request - UpdateBusinessRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateBusinessResponse
     *
     * @param UpdateBusinessRequest $request
     * @param RuntimeOptions        $runtime
     *
     * @return UpdateBusinessResponse
     */
    public function updateBusinessWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->businessId) {
            @$body['BusinessId'] = $request->businessId;
        }

        if (null !== $request->businessName) {
            @$body['BusinessName'] = $request->businessName;
        }

        if (null !== $request->description) {
            @$body['Description'] = $request->description;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateBusiness',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateBusinessResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a workflow.
     *
     * @param request - UpdateBusinessRequest
     *
     * @returns UpdateBusinessResponse
     *
     * @param UpdateBusinessRequest $request
     *
     * @return UpdateBusinessResponse
     */
    public function updateBusiness($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateBusinessWithOptions($request, $runtime);
    }

    /**
     * Updates the configurations of submodules in a workspace. You can configure SPARK parameters.
     *
     * @param tmpReq - UpdateClusterConfigsRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateClusterConfigsResponse
     *
     * @param UpdateClusterConfigsRequest $tmpReq
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateClusterConfigsResponse
     */
    public function updateClusterConfigsWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateClusterConfigsShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->configValues) {
            $request->configValuesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->configValues, 'ConfigValues', 'json');
        }

        $query = [];
        if (null !== $request->clusterId) {
            @$query['ClusterId'] = $request->clusterId;
        }

        if (null !== $request->configType) {
            @$query['ConfigType'] = $request->configType;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $body = [];
        if (null !== $request->configValuesShrink) {
            @$body['ConfigValues'] = $request->configValuesShrink;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateClusterConfigs',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateClusterConfigsResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the configurations of submodules in a workspace. You can configure SPARK parameters.
     *
     * @param request - UpdateClusterConfigsRequest
     *
     * @returns UpdateClusterConfigsResponse
     *
     * @param UpdateClusterConfigsRequest $request
     *
     * @return UpdateClusterConfigsResponse
     */
    public function updateClusterConfigs($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateClusterConfigsWithOptions($request, $runtime);
    }

    // Deprecated
    /**
     * Updates a data source.
     *
     * @deprecated OpenAPI UpdateConnection is deprecated
     *
     * @param request - UpdateConnectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateConnectionResponse
     *
     * @param UpdateConnectionRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return UpdateConnectionResponse
     */
    public function updateConnectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->connectionId) {
            @$query['ConnectionId'] = $request->connectionId;
        }

        if (null !== $request->content) {
            @$query['Content'] = $request->content;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateConnection',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'PUT',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateConnectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    // Deprecated
    /**
     * Updates a data source.
     *
     * @deprecated OpenAPI UpdateConnection is deprecated
     *
     * @param request - UpdateConnectionRequest
     *
     * @returns UpdateConnectionResponse
     *
     * @param UpdateConnectionRequest $request
     *
     * @return UpdateConnectionResponse
     */
    public function updateConnection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateConnectionWithOptions($request, $runtime);
    }

    /**
     * Updates an alert rule for a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks that can be used for real-time data synchronization. You must update all fields in the alert rule.
     *
     * @param tmpReq - UpdateDIAlarmRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateDIAlarmRuleResponse
     *
     * @param UpdateDIAlarmRuleRequest $tmpReq
     * @param RuntimeOptions           $runtime
     *
     * @return UpdateDIAlarmRuleResponse
     */
    public function updateDIAlarmRuleWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateDIAlarmRuleShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->notificationSettings) {
            $request->notificationSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->notificationSettings, 'NotificationSettings', 'json');
        }

        if (null !== $tmpReq->triggerConditions) {
            $request->triggerConditionsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->triggerConditions, 'TriggerConditions', 'json');
        }

        $body = [];
        if (null !== $request->DIAlarmRuleId) {
            @$body['DIAlarmRuleId'] = $request->DIAlarmRuleId;
        }

        if (null !== $request->description) {
            @$body['Description'] = $request->description;
        }

        if (null !== $request->enabled) {
            @$body['Enabled'] = $request->enabled;
        }

        if (null !== $request->metricType) {
            @$body['MetricType'] = $request->metricType;
        }

        if (null !== $request->notificationSettingsShrink) {
            @$body['NotificationSettings'] = $request->notificationSettingsShrink;
        }

        if (null !== $request->triggerConditionsShrink) {
            @$body['TriggerConditions'] = $request->triggerConditionsShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateDIAlarmRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateDIAlarmRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates an alert rule for a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *
     * @remarks
     * You can configure alert rules only for tasks that can be used for real-time data synchronization. You must update all fields in the alert rule.
     *
     * @param request - UpdateDIAlarmRuleRequest
     *
     * @returns UpdateDIAlarmRuleResponse
     *
     * @param UpdateDIAlarmRuleRequest $request
     *
     * @return UpdateDIAlarmRuleResponse
     */
    public function updateDIAlarmRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDIAlarmRuleWithOptions($request, $runtime);
    }

    /**
     * Updates a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *
     * @param tmpReq - UpdateDIJobRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateDIJobResponse
     *
     * @param UpdateDIJobRequest $tmpReq
     * @param RuntimeOptions     $runtime
     *
     * @return UpdateDIJobResponse
     */
    public function updateDIJobWithOptions($tmpReq, $runtime)
    {
        $tmpReq->validate();
        $request = new UpdateDIJobShrinkRequest([]);
        Utils::convert($tmpReq, $request);
        if (null !== $tmpReq->jobSettings) {
            $request->jobSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->jobSettings, 'JobSettings', 'json');
        }

        if (null !== $tmpReq->resourceSettings) {
            $request->resourceSettingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->resourceSettings, 'ResourceSettings', 'json');
        }

        if (null !== $tmpReq->tableMappings) {
            $request->tableMappingsShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->tableMappings, 'TableMappings', 'json');
        }

        if (null !== $tmpReq->transformationRules) {
            $request->transformationRulesShrink = Utils::arrayToStringWithSpecifiedStyle($tmpReq->transformationRules, 'TransformationRules', 'json');
        }

        $body = [];
        if (null !== $request->DIJobId) {
            @$body['DIJobId'] = $request->DIJobId;
        }

        if (null !== $request->description) {
            @$body['Description'] = $request->description;
        }

        if (null !== $request->jobSettingsShrink) {
            @$body['JobSettings'] = $request->jobSettingsShrink;
        }

        if (null !== $request->resourceSettingsShrink) {
            @$body['ResourceSettings'] = $request->resourceSettingsShrink;
        }

        if (null !== $request->tableMappingsShrink) {
            @$body['TableMappings'] = $request->tableMappingsShrink;
        }

        if (null !== $request->transformationRulesShrink) {
            @$body['TransformationRules'] = $request->transformationRulesShrink;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateDIJob',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateDIJobResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
     *
     * @param request - UpdateDIJobRequest
     *
     * @returns UpdateDIJobResponse
     *
     * @param UpdateDIJobRequest $request
     *
     * @return UpdateDIJobResponse
     */
    public function updateDIJob($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDIJobWithOptions($request, $runtime);
    }

    /**
     * Modifies the default global configuration of synchronization solutions in a DataWorks workspace.
     *
     * @remarks
     * DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *
     * @param request - UpdateDIProjectConfigRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateDIProjectConfigResponse
     *
     * @param UpdateDIProjectConfigRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdateDIProjectConfigResponse
     */
    public function updateDIProjectConfigWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->destinationType) {
            @$query['DestinationType'] = $request->destinationType;
        }

        if (null !== $request->projectConfig) {
            @$query['ProjectConfig'] = $request->projectConfig;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->sourceType) {
            @$query['SourceType'] = $request->sourceType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateDIProjectConfig',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateDIProjectConfigResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the default global configuration of synchronization solutions in a DataWorks workspace.
     *
     * @remarks
     * DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
     *
     * @param request - UpdateDIProjectConfigRequest
     *
     * @returns UpdateDIProjectConfigResponse
     *
     * @param UpdateDIProjectConfigRequest $request
     *
     * @return UpdateDIProjectConfigResponse
     */
    public function updateDIProjectConfig($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDIProjectConfigWithOptions($request, $runtime);
    }

    /**
     * Updates a data synchronization task.
     *
     * @param request - UpdateDISyncTaskRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateDISyncTaskResponse
     *
     * @param UpdateDISyncTaskRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return UpdateDISyncTaskResponse
     */
    public function updateDISyncTaskWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->fileId) {
            @$query['FileId'] = $request->fileId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->taskContent) {
            @$query['TaskContent'] = $request->taskContent;
        }

        if (null !== $request->taskParam) {
            @$query['TaskParam'] = $request->taskParam;
        }

        if (null !== $request->taskType) {
            @$query['TaskType'] = $request->taskType;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateDISyncTask',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateDISyncTaskResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a data synchronization task.
     *
     * @param request - UpdateDISyncTaskRequest
     *
     * @returns UpdateDISyncTaskResponse
     *
     * @param UpdateDISyncTaskRequest $request
     *
     * @return UpdateDISyncTaskResponse
     */
    public function updateDISyncTask($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDISyncTaskWithOptions($request, $runtime);
    }

    /**
     * Updates the information about an API in the development state in DataService Studio.
     *
     * @param request - UpdateDataServiceApiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateDataServiceApiResponse
     *
     * @param UpdateDataServiceApiRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateDataServiceApiResponse
     */
    public function updateDataServiceApiWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->apiDescription) {
            @$body['ApiDescription'] = $request->apiDescription;
        }

        if (null !== $request->apiId) {
            @$body['ApiId'] = $request->apiId;
        }

        if (null !== $request->apiPath) {
            @$body['ApiPath'] = $request->apiPath;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->protocols) {
            @$body['Protocols'] = $request->protocols;
        }

        if (null !== $request->registrationDetails) {
            @$body['RegistrationDetails'] = $request->registrationDetails;
        }

        if (null !== $request->requestMethod) {
            @$body['RequestMethod'] = $request->requestMethod;
        }

        if (null !== $request->resourceGroupId) {
            @$body['ResourceGroupId'] = $request->resourceGroupId;
        }

        if (null !== $request->responseContentType) {
            @$body['ResponseContentType'] = $request->responseContentType;
        }

        if (null !== $request->scriptDetails) {
            @$body['ScriptDetails'] = $request->scriptDetails;
        }

        if (null !== $request->tenantId) {
            @$body['TenantId'] = $request->tenantId;
        }

        if (null !== $request->timeout) {
            @$body['Timeout'] = $request->timeout;
        }

        if (null !== $request->visibleRange) {
            @$body['VisibleRange'] = $request->visibleRange;
        }

        if (null !== $request->wizardDetails) {
            @$body['WizardDetails'] = $request->wizardDetails;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateDataServiceApi',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateDataServiceApiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the information about an API in the development state in DataService Studio.
     *
     * @param request - UpdateDataServiceApiRequest
     *
     * @returns UpdateDataServiceApiResponse
     *
     * @param UpdateDataServiceApiRequest $request
     *
     * @return UpdateDataServiceApiResponse
     */
    public function updateDataServiceApi($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDataServiceApiWithOptions($request, $runtime);
    }

    /**
     * Updates a data source.
     *
     * @param request - UpdateDataSourceRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateDataSourceResponse
     *
     * @param UpdateDataSourceRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return UpdateDataSourceResponse
     */
    public function updateDataSourceWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->content) {
            @$query['Content'] = $request->content;
        }

        if (null !== $request->dataSourceId) {
            @$query['DataSourceId'] = $request->dataSourceId;
        }

        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->status) {
            @$query['Status'] = $request->status;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateDataSource',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'PUT',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateDataSourceResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a data source.
     *
     * @param request - UpdateDataSourceRequest
     *
     * @returns UpdateDataSourceResponse
     *
     * @param UpdateDataSourceRequest $request
     *
     * @return UpdateDataSourceResponse
     */
    public function updateDataSource($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateDataSourceWithOptions($request, $runtime);
    }

    /**
     * Updates a file.
     *
     * @remarks
     * When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
     *
     * @param request - UpdateFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateFileResponse
     *
     * @param UpdateFileRequest $request
     * @param RuntimeOptions    $runtime
     *
     * @return UpdateFileResponse
     */
    public function updateFileWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->advancedSettings) {
            @$body['AdvancedSettings'] = $request->advancedSettings;
        }

        if (null !== $request->applyScheduleImmediately) {
            @$body['ApplyScheduleImmediately'] = $request->applyScheduleImmediately;
        }

        if (null !== $request->autoParsing) {
            @$body['AutoParsing'] = $request->autoParsing;
        }

        if (null !== $request->autoRerunIntervalMillis) {
            @$body['AutoRerunIntervalMillis'] = $request->autoRerunIntervalMillis;
        }

        if (null !== $request->autoRerunTimes) {
            @$body['AutoRerunTimes'] = $request->autoRerunTimes;
        }

        if (null !== $request->connectionName) {
            @$body['ConnectionName'] = $request->connectionName;
        }

        if (null !== $request->content) {
            @$body['Content'] = $request->content;
        }

        if (null !== $request->cronExpress) {
            @$body['CronExpress'] = $request->cronExpress;
        }

        if (null !== $request->cycleType) {
            @$body['CycleType'] = $request->cycleType;
        }

        if (null !== $request->dependentNodeIdList) {
            @$body['DependentNodeIdList'] = $request->dependentNodeIdList;
        }

        if (null !== $request->dependentType) {
            @$body['DependentType'] = $request->dependentType;
        }

        if (null !== $request->endEffectDate) {
            @$body['EndEffectDate'] = $request->endEffectDate;
        }

        if (null !== $request->fileDescription) {
            @$body['FileDescription'] = $request->fileDescription;
        }

        if (null !== $request->fileFolderPath) {
            @$body['FileFolderPath'] = $request->fileFolderPath;
        }

        if (null !== $request->fileId) {
            @$body['FileId'] = $request->fileId;
        }

        if (null !== $request->fileName) {
            @$body['FileName'] = $request->fileName;
        }

        if (null !== $request->ignoreParentSkipRunningProperty) {
            @$body['IgnoreParentSkipRunningProperty'] = $request->ignoreParentSkipRunningProperty;
        }

        if (null !== $request->imageId) {
            @$body['ImageId'] = $request->imageId;
        }

        if (null !== $request->inputList) {
            @$body['InputList'] = $request->inputList;
        }

        if (null !== $request->inputParameters) {
            @$body['InputParameters'] = $request->inputParameters;
        }

        if (null !== $request->outputList) {
            @$body['OutputList'] = $request->outputList;
        }

        if (null !== $request->outputParameters) {
            @$body['OutputParameters'] = $request->outputParameters;
        }

        if (null !== $request->owner) {
            @$body['Owner'] = $request->owner;
        }

        if (null !== $request->paraValue) {
            @$body['ParaValue'] = $request->paraValue;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->rerunMode) {
            @$body['RerunMode'] = $request->rerunMode;
        }

        if (null !== $request->resourceGroupIdentifier) {
            @$body['ResourceGroupIdentifier'] = $request->resourceGroupIdentifier;
        }

        if (null !== $request->schedulerType) {
            @$body['SchedulerType'] = $request->schedulerType;
        }

        if (null !== $request->startEffectDate) {
            @$body['StartEffectDate'] = $request->startEffectDate;
        }

        if (null !== $request->startImmediately) {
            @$body['StartImmediately'] = $request->startImmediately;
        }

        if (null !== $request->stop) {
            @$body['Stop'] = $request->stop;
        }

        if (null !== $request->timeout) {
            @$body['Timeout'] = $request->timeout;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateFile',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a file.
     *
     * @remarks
     * When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
     *
     * @param request - UpdateFileRequest
     *
     * @returns UpdateFileResponse
     *
     * @param UpdateFileRequest $request
     *
     * @return UpdateFileResponse
     */
    public function updateFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFileWithOptions($request, $runtime);
    }

    /**
     * Updates a folder.
     *
     * @param request - UpdateFolderRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateFolderResponse
     *
     * @param UpdateFolderRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return UpdateFolderResponse
     */
    public function updateFolderWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->folderId) {
            @$body['FolderId'] = $request->folderId;
        }

        if (null !== $request->folderName) {
            @$body['FolderName'] = $request->folderName;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateFolder',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateFolderResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a folder.
     *
     * @param request - UpdateFolderRequest
     *
     * @returns UpdateFolderResponse
     *
     * @param UpdateFolderRequest $request
     *
     * @return UpdateFolderResponse
     */
    public function updateFolder($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateFolderWithOptions($request, $runtime);
    }

    /**
     * Returns the check result of an extension point event to DataStudio after the extension point event is triggered during data development and checked by an extension.
     *
     * @param request - UpdateIDEEventResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateIDEEventResultResponse
     *
     * @param UpdateIDEEventResultRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateIDEEventResultResponse
     */
    public function updateIDEEventResultWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->checkResult) {
            @$body['CheckResult'] = $request->checkResult;
        }

        if (null !== $request->checkResultTip) {
            @$body['CheckResultTip'] = $request->checkResultTip;
        }

        if (null !== $request->extensionCode) {
            @$body['ExtensionCode'] = $request->extensionCode;
        }

        if (null !== $request->messageId) {
            @$body['MessageId'] = $request->messageId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateIDEEventResult',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateIDEEventResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Returns the check result of an extension point event to DataStudio after the extension point event is triggered during data development and checked by an extension.
     *
     * @param request - UpdateIDEEventResultRequest
     *
     * @returns UpdateIDEEventResultResponse
     *
     * @param UpdateIDEEventResultRequest $request
     *
     * @return UpdateIDEEventResultResponse
     */
    public function updateIDEEventResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateIDEEventResultWithOptions($request, $runtime);
    }

    /**
     * Updates a category.
     *
     * @param request - UpdateMetaCategoryRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateMetaCategoryResponse
     *
     * @param UpdateMetaCategoryRequest $request
     * @param RuntimeOptions            $runtime
     *
     * @return UpdateMetaCategoryResponse
     */
    public function updateMetaCategoryWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->categoryId) {
            @$body['CategoryId'] = $request->categoryId;
        }

        if (null !== $request->comment) {
            @$body['Comment'] = $request->comment;
        }

        if (null !== $request->name) {
            @$body['Name'] = $request->name;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateMetaCategory',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMetaCategoryResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a category.
     *
     * @param request - UpdateMetaCategoryRequest
     *
     * @returns UpdateMetaCategoryResponse
     *
     * @param UpdateMetaCategoryRequest $request
     *
     * @return UpdateMetaCategoryResponse
     */
    public function updateMetaCategory($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaCategoryWithOptions($request, $runtime);
    }

    /**
     * Updates the name and comment of a collection.
     *
     * @remarks
     * Only the name and comment of a collection can be updated.
     *
     * @param request - UpdateMetaCollectionRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateMetaCollectionResponse
     *
     * @param UpdateMetaCollectionRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateMetaCollectionResponse
     */
    public function updateMetaCollectionWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->qualifiedName) {
            @$query['QualifiedName'] = $request->qualifiedName;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateMetaCollection',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMetaCollectionResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the name and comment of a collection.
     *
     * @remarks
     * Only the name and comment of a collection can be updated.
     *
     * @param request - UpdateMetaCollectionRequest
     *
     * @returns UpdateMetaCollectionResponse
     *
     * @param UpdateMetaCollectionRequest $request
     *
     * @return UpdateMetaCollectionResponse
     */
    public function updateMetaCollection($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaCollectionWithOptions($request, $runtime);
    }

    /**
     * Updates the metadata information about a table. Only MaxCompute tables are supported.
     *
     * @param request - UpdateMetaTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateMetaTableResponse
     *
     * @param UpdateMetaTableRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return UpdateMetaTableResponse
     */
    public function updateMetaTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->caption) {
            @$query['Caption'] = $request->caption;
        }

        if (null !== $request->categoryId) {
            @$query['CategoryId'] = $request->categoryId;
        }

        if (null !== $request->envType) {
            @$query['EnvType'] = $request->envType;
        }

        if (null !== $request->newOwnerId) {
            @$query['NewOwnerId'] = $request->newOwnerId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->schema) {
            @$query['Schema'] = $request->schema;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        if (null !== $request->visibility) {
            @$query['Visibility'] = $request->visibility;
        }

        $body = [];
        if (null !== $request->addedLabels) {
            @$body['AddedLabels'] = $request->addedLabels;
        }

        if (null !== $request->removedLabels) {
            @$body['RemovedLabels'] = $request->removedLabels;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateMetaTable',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMetaTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the metadata information about a table. Only MaxCompute tables are supported.
     *
     * @param request - UpdateMetaTableRequest
     *
     * @returns UpdateMetaTableResponse
     *
     * @param UpdateMetaTableRequest $request
     *
     * @return UpdateMetaTableResponse
     */
    public function updateMetaTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaTableWithOptions($request, $runtime);
    }

    /**
     * Updates the instructions on how to use a table. If no instruction on how to use the table is available, the instructions that are configured by calling this operation are added.
     *
     * @param request - UpdateMetaTableIntroWikiRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateMetaTableIntroWikiResponse
     *
     * @param UpdateMetaTableIntroWikiRequest $request
     * @param RuntimeOptions                  $runtime
     *
     * @return UpdateMetaTableIntroWikiResponse
     */
    public function updateMetaTableIntroWikiWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        $body = [];
        if (null !== $request->content) {
            @$body['Content'] = $request->content;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateMetaTableIntroWiki',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateMetaTableIntroWikiResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the instructions on how to use a table. If no instruction on how to use the table is available, the instructions that are configured by calling this operation are added.
     *
     * @param request - UpdateMetaTableIntroWikiRequest
     *
     * @returns UpdateMetaTableIntroWikiResponse
     *
     * @param UpdateMetaTableIntroWikiRequest $request
     *
     * @return UpdateMetaTableIntroWikiResponse
     */
    public function updateMetaTableIntroWiki($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateMetaTableIntroWikiWithOptions($request, $runtime);
    }

    /**
     * Changes the owner of a node.
     *
     * @param request - UpdateNodeOwnerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateNodeOwnerResponse
     *
     * @param UpdateNodeOwnerRequest $request
     * @param RuntimeOptions         $runtime
     *
     * @return UpdateNodeOwnerResponse
     */
    public function updateNodeOwnerWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->userId) {
            @$body['UserId'] = $request->userId;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateNodeOwner',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateNodeOwnerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Changes the owner of a node.
     *
     * @param request - UpdateNodeOwnerRequest
     *
     * @returns UpdateNodeOwnerResponse
     *
     * @param UpdateNodeOwnerRequest $request
     *
     * @return UpdateNodeOwnerResponse
     */
    public function updateNodeOwner($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNodeOwnerWithOptions($request, $runtime);
    }

    /**
     * Freezes or unfreezes a node.
     *
     * @param request - UpdateNodeRunModeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateNodeRunModeResponse
     *
     * @param UpdateNodeRunModeRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return UpdateNodeRunModeResponse
     */
    public function updateNodeRunModeWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->nodeId) {
            @$body['NodeId'] = $request->nodeId;
        }

        if (null !== $request->projectEnv) {
            @$body['ProjectEnv'] = $request->projectEnv;
        }

        if (null !== $request->schedulerType) {
            @$body['SchedulerType'] = $request->schedulerType;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateNodeRunMode',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateNodeRunModeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Freezes or unfreezes a node.
     *
     * @param request - UpdateNodeRunModeRequest
     *
     * @returns UpdateNodeRunModeResponse
     *
     * @param UpdateNodeRunModeRequest $request
     *
     * @return UpdateNodeRunModeResponse
     */
    public function updateNodeRunMode($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateNodeRunModeWithOptions($request, $runtime);
    }

    /**
     * Updates a subscription relationship.
     *
     * @param request - UpdateQualityFollowerRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateQualityFollowerResponse
     *
     * @param UpdateQualityFollowerRequest $request
     * @param RuntimeOptions               $runtime
     *
     * @return UpdateQualityFollowerResponse
     */
    public function updateQualityFollowerWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alarmMode) {
            @$body['AlarmMode'] = $request->alarmMode;
        }

        if (null !== $request->follower) {
            @$body['Follower'] = $request->follower;
        }

        if (null !== $request->followerId) {
            @$body['FollowerId'] = $request->followerId;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateQualityFollower',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateQualityFollowerResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a subscription relationship.
     *
     * @param request - UpdateQualityFollowerRequest
     *
     * @returns UpdateQualityFollowerResponse
     *
     * @param UpdateQualityFollowerRequest $request
     *
     * @return UpdateQualityFollowerResponse
     */
    public function updateQualityFollower($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateQualityFollowerWithOptions($request, $runtime);
    }

    /**
     * Updates a monitoring rule.
     *
     * @param request - UpdateQualityRuleRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateQualityRuleResponse
     *
     * @param UpdateQualityRuleRequest $request
     * @param RuntimeOptions           $runtime
     *
     * @return UpdateQualityRuleResponse
     */
    public function updateQualityRuleWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->blockType) {
            @$body['BlockType'] = $request->blockType;
        }

        if (null !== $request->checker) {
            @$body['Checker'] = $request->checker;
        }

        if (null !== $request->comment) {
            @$body['Comment'] = $request->comment;
        }

        if (null !== $request->criticalThreshold) {
            @$body['CriticalThreshold'] = $request->criticalThreshold;
        }

        if (null !== $request->entityId) {
            @$body['EntityId'] = $request->entityId;
        }

        if (null !== $request->expectValue) {
            @$body['ExpectValue'] = $request->expectValue;
        }

        if (null !== $request->id) {
            @$body['Id'] = $request->id;
        }

        if (null !== $request->methodName) {
            @$body['MethodName'] = $request->methodName;
        }

        if (null !== $request->openSwitch) {
            @$body['OpenSwitch'] = $request->openSwitch;
        }

        if (null !== $request->operator) {
            @$body['Operator'] = $request->operator;
        }

        if (null !== $request->predictType) {
            @$body['PredictType'] = $request->predictType;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectName) {
            @$body['ProjectName'] = $request->projectName;
        }

        if (null !== $request->property) {
            @$body['Property'] = $request->property;
        }

        if (null !== $request->propertyType) {
            @$body['PropertyType'] = $request->propertyType;
        }

        if (null !== $request->ruleName) {
            @$body['RuleName'] = $request->ruleName;
        }

        if (null !== $request->ruleType) {
            @$body['RuleType'] = $request->ruleType;
        }

        if (null !== $request->taskSetting) {
            @$body['TaskSetting'] = $request->taskSetting;
        }

        if (null !== $request->templateId) {
            @$body['TemplateId'] = $request->templateId;
        }

        if (null !== $request->trend) {
            @$body['Trend'] = $request->trend;
        }

        if (null !== $request->warningThreshold) {
            @$body['WarningThreshold'] = $request->warningThreshold;
        }

        if (null !== $request->whereCondition) {
            @$body['WhereCondition'] = $request->whereCondition;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateQualityRule',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateQualityRuleResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a monitoring rule.
     *
     * @param request - UpdateQualityRuleRequest
     *
     * @returns UpdateQualityRuleResponse
     *
     * @param UpdateQualityRuleRequest $request
     *
     * @return UpdateQualityRuleResponse
     */
    public function updateQualityRule($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateQualityRuleWithOptions($request, $runtime);
    }

    /**
     * Modifies a custom alert rule.
     *
     * @param request - UpdateRemindRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateRemindResponse
     *
     * @param UpdateRemindRequest $request
     * @param RuntimeOptions      $runtime
     *
     * @return UpdateRemindResponse
     */
    public function updateRemindWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->alertInterval) {
            @$body['AlertInterval'] = $request->alertInterval;
        }

        if (null !== $request->alertMethods) {
            @$body['AlertMethods'] = $request->alertMethods;
        }

        if (null !== $request->alertTargets) {
            @$body['AlertTargets'] = $request->alertTargets;
        }

        if (null !== $request->alertUnit) {
            @$body['AlertUnit'] = $request->alertUnit;
        }

        if (null !== $request->baselineIds) {
            @$body['BaselineIds'] = $request->baselineIds;
        }

        if (null !== $request->bizProcessIds) {
            @$body['BizProcessIds'] = $request->bizProcessIds;
        }

        if (null !== $request->detail) {
            @$body['Detail'] = $request->detail;
        }

        if (null !== $request->dndEnd) {
            @$body['DndEnd'] = $request->dndEnd;
        }

        if (null !== $request->maxAlertTimes) {
            @$body['MaxAlertTimes'] = $request->maxAlertTimes;
        }

        if (null !== $request->nodeIds) {
            @$body['NodeIds'] = $request->nodeIds;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->remindId) {
            @$body['RemindId'] = $request->remindId;
        }

        if (null !== $request->remindName) {
            @$body['RemindName'] = $request->remindName;
        }

        if (null !== $request->remindType) {
            @$body['RemindType'] = $request->remindType;
        }

        if (null !== $request->remindUnit) {
            @$body['RemindUnit'] = $request->remindUnit;
        }

        if (null !== $request->robotUrls) {
            @$body['RobotUrls'] = $request->robotUrls;
        }

        if (null !== $request->useFlag) {
            @$body['UseFlag'] = $request->useFlag;
        }

        if (null !== $request->webhooks) {
            @$body['Webhooks'] = $request->webhooks;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateRemind',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateRemindResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies a custom alert rule.
     *
     * @param request - UpdateRemindRequest
     *
     * @returns UpdateRemindResponse
     *
     * @param UpdateRemindRequest $request
     *
     * @return UpdateRemindResponse
     */
    public function updateRemind($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateRemindWithOptions($request, $runtime);
    }

    /**
     * Updates a MaxCompute table.
     *
     * @param request - UpdateTableRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateTableResponse
     *
     * @param UpdateTableRequest $request
     * @param RuntimeOptions     $runtime
     *
     * @return UpdateTableResponse
     */
    public function updateTableWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->appGuid) {
            @$query['AppGuid'] = $request->appGuid;
        }

        if (null !== $request->categoryId) {
            @$query['CategoryId'] = $request->categoryId;
        }

        if (null !== $request->comment) {
            @$query['Comment'] = $request->comment;
        }

        if (null !== $request->createIfNotExists) {
            @$query['CreateIfNotExists'] = $request->createIfNotExists;
        }

        if (null !== $request->externalTableType) {
            @$query['ExternalTableType'] = $request->externalTableType;
        }

        if (null !== $request->hasPart) {
            @$query['HasPart'] = $request->hasPart;
        }

        if (null !== $request->isView) {
            @$query['IsView'] = $request->isView;
        }

        if (null !== $request->lifeCycle) {
            @$query['LifeCycle'] = $request->lifeCycle;
        }

        if (null !== $request->location) {
            @$query['Location'] = $request->location;
        }

        if (null !== $request->logicalLevelId) {
            @$query['LogicalLevelId'] = $request->logicalLevelId;
        }

        if (null !== $request->ownerId) {
            @$query['OwnerId'] = $request->ownerId;
        }

        if (null !== $request->physicsLevelId) {
            @$query['PhysicsLevelId'] = $request->physicsLevelId;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->schema) {
            @$query['Schema'] = $request->schema;
        }

        if (null !== $request->tableName) {
            @$query['TableName'] = $request->tableName;
        }

        if (null !== $request->visibility) {
            @$query['Visibility'] = $request->visibility;
        }

        $body = [];
        if (null !== $request->columns) {
            @$body['Columns'] = $request->columns;
        }

        if (null !== $request->endpoint) {
            @$body['Endpoint'] = $request->endpoint;
        }

        if (null !== $request->envType) {
            @$body['EnvType'] = $request->envType;
        }

        if (null !== $request->themes) {
            @$body['Themes'] = $request->themes;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateTable',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateTableResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a MaxCompute table.
     *
     * @param request - UpdateTableRequest
     *
     * @returns UpdateTableResponse
     *
     * @param UpdateTableRequest $request
     *
     * @return UpdateTableResponse
     */
    public function updateTable($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableWithOptions($request, $runtime);
    }

    /**
     * Updates the fields in a MaxCompute table.
     *
     * @param request - UpdateTableAddColumnRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateTableAddColumnResponse
     *
     * @param UpdateTableAddColumnRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateTableAddColumnResponse
     */
    public function updateTableAddColumnWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        $body = [];
        if (null !== $request->column) {
            @$body['Column'] = $request->column;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateTableAddColumn',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateTableAddColumnResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the fields in a MaxCompute table.
     *
     * @param request - UpdateTableAddColumnRequest
     *
     * @returns UpdateTableAddColumnResponse
     *
     * @param UpdateTableAddColumnRequest $request
     *
     * @return UpdateTableAddColumnResponse
     */
    public function updateTableAddColumn($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableAddColumnWithOptions($request, $runtime);
    }

    /**
     * Updates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - UpdateTableLevelRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateTableLevelResponse
     *
     * @param UpdateTableLevelRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return UpdateTableLevelResponse
     */
    public function updateTableLevelWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->description) {
            @$query['Description'] = $request->description;
        }

        if (null !== $request->levelId) {
            @$query['LevelId'] = $request->levelId;
        }

        if (null !== $request->levelType) {
            @$query['LevelType'] = $request->levelType;
        }

        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateTableLevel',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateTableLevelResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - UpdateTableLevelRequest
     *
     * @returns UpdateTableLevelResponse
     *
     * @param UpdateTableLevelRequest $request
     *
     * @return UpdateTableLevelResponse
     */
    public function updateTableLevel($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableLevelWithOptions($request, $runtime);
    }

    /**
     * Modifies the information about a table, such as the table folder, level, and category.
     *
     * @param request - UpdateTableModelInfoRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateTableModelInfoResponse
     *
     * @param UpdateTableModelInfoRequest $request
     * @param RuntimeOptions              $runtime
     *
     * @return UpdateTableModelInfoResponse
     */
    public function updateTableModelInfoWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->firstLevelThemeId) {
            @$query['FirstLevelThemeId'] = $request->firstLevelThemeId;
        }

        if (null !== $request->levelId) {
            @$query['LevelId'] = $request->levelId;
        }

        if (null !== $request->levelType) {
            @$query['LevelType'] = $request->levelType;
        }

        if (null !== $request->secondLevelThemeId) {
            @$query['SecondLevelThemeId'] = $request->secondLevelThemeId;
        }

        if (null !== $request->tableGuid) {
            @$query['TableGuid'] = $request->tableGuid;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateTableModelInfo',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateTableModelInfoResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Modifies the information about a table, such as the table folder, level, and category.
     *
     * @param request - UpdateTableModelInfoRequest
     *
     * @returns UpdateTableModelInfoResponse
     *
     * @param UpdateTableModelInfoRequest $request
     *
     * @return UpdateTableModelInfoResponse
     */
    public function updateTableModelInfo($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableModelInfoWithOptions($request, $runtime);
    }

    /**
     * Updates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - UpdateTableThemeRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateTableThemeResponse
     *
     * @param UpdateTableThemeRequest $request
     * @param RuntimeOptions          $runtime
     *
     * @return UpdateTableThemeResponse
     */
    public function updateTableThemeWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->name) {
            @$query['Name'] = $request->name;
        }

        if (null !== $request->projectId) {
            @$query['ProjectId'] = $request->projectId;
        }

        if (null !== $request->themeId) {
            @$query['ThemeId'] = $request->themeId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateTableTheme',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateTableThemeResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
     *
     * @param request - UpdateTableThemeRequest
     *
     * @returns UpdateTableThemeResponse
     *
     * @param UpdateTableThemeRequest $request
     *
     * @return UpdateTableThemeResponse
     */
    public function updateTableTheme($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateTableThemeWithOptions($request, $runtime);
    }

    /**
     * Updates the file information about a function.
     *
     * @param request - UpdateUdfFileRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateUdfFileResponse
     *
     * @param UpdateUdfFileRequest $request
     * @param RuntimeOptions       $runtime
     *
     * @return UpdateUdfFileResponse
     */
    public function updateUdfFileWithOptions($request, $runtime)
    {
        $request->validate();
        $body = [];
        if (null !== $request->className) {
            @$body['ClassName'] = $request->className;
        }

        if (null !== $request->cmdDescription) {
            @$body['CmdDescription'] = $request->cmdDescription;
        }

        if (null !== $request->example) {
            @$body['Example'] = $request->example;
        }

        if (null !== $request->fileFolderPath) {
            @$body['FileFolderPath'] = $request->fileFolderPath;
        }

        if (null !== $request->fileId) {
            @$body['FileId'] = $request->fileId;
        }

        if (null !== $request->functionType) {
            @$body['FunctionType'] = $request->functionType;
        }

        if (null !== $request->parameterDescription) {
            @$body['ParameterDescription'] = $request->parameterDescription;
        }

        if (null !== $request->projectId) {
            @$body['ProjectId'] = $request->projectId;
        }

        if (null !== $request->projectIdentifier) {
            @$body['ProjectIdentifier'] = $request->projectIdentifier;
        }

        if (null !== $request->resources) {
            @$body['Resources'] = $request->resources;
        }

        if (null !== $request->returnValue) {
            @$body['ReturnValue'] = $request->returnValue;
        }

        if (null !== $request->udfDescription) {
            @$body['UdfDescription'] = $request->udfDescription;
        }

        $req = new OpenApiRequest([
            'body' => Utils::parseToMap($body),
        ]);
        $params = new Params([
            'action' => 'UpdateUdfFile',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateUdfFileResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Updates the file information about a function.
     *
     * @param request - UpdateUdfFileRequest
     *
     * @returns UpdateUdfFileResponse
     *
     * @param UpdateUdfFileRequest $request
     *
     * @return UpdateUdfFileResponse
     */
    public function updateUdfFile($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateUdfFileWithOptions($request, $runtime);
    }

    /**
     * Returns the processing result sent by an extension after a process in Operation Center is blocked by the extension.
     *
     * @param request - UpdateWorkbenchEventResultRequest
     * @param runtime - runtime options for this request RuntimeOptions
     *
     * @returns UpdateWorkbenchEventResultResponse
     *
     * @param UpdateWorkbenchEventResultRequest $request
     * @param RuntimeOptions                    $runtime
     *
     * @return UpdateWorkbenchEventResultResponse
     */
    public function updateWorkbenchEventResultWithOptions($request, $runtime)
    {
        $request->validate();
        $query = [];
        if (null !== $request->checkResult) {
            @$query['CheckResult'] = $request->checkResult;
        }

        if (null !== $request->checkResultTip) {
            @$query['CheckResultTip'] = $request->checkResultTip;
        }

        if (null !== $request->extensionCode) {
            @$query['ExtensionCode'] = $request->extensionCode;
        }

        if (null !== $request->messageId) {
            @$query['MessageId'] = $request->messageId;
        }

        $req = new OpenApiRequest([
            'query' => Utils::query($query),
        ]);
        $params = new Params([
            'action' => 'UpdateWorkbenchEventResult',
            'version' => '2020-05-18',
            'protocol' => 'HTTPS',
            'pathname' => '/',
            'method' => 'POST',
            'authType' => 'AK',
            'style' => 'RPC',
            'reqBodyType' => 'formData',
            'bodyType' => 'json',
        ]);

        return UpdateWorkbenchEventResultResponse::fromMap($this->callApi($params, $req, $runtime));
    }

    /**
     * Returns the processing result sent by an extension after a process in Operation Center is blocked by the extension.
     *
     * @param request - UpdateWorkbenchEventResultRequest
     *
     * @returns UpdateWorkbenchEventResultResponse
     *
     * @param UpdateWorkbenchEventResultRequest $request
     *
     * @return UpdateWorkbenchEventResultResponse
     */
    public function updateWorkbenchEventResult($request)
    {
        $runtime = new RuntimeOptions([]);

        return $this->updateWorkbenchEventResultWithOptions($request, $runtime);
    }
}
